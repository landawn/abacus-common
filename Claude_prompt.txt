

-- ==========================================================

Use multiple agents to review all classes under folder: ./src/main/java/ line by line carefully to find bugs and fix them.



-- ==========================================================

Step 1 - Use multiple agents to apply below template to all sample/example in javadoc in all classes in folder: ./src/main/java/ 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Sample codes
     * }</pre>
	 
Step 2 - Replace below sample/example template in Javadoc
     * <pre>
     * Sample codes
     * </pre>
with:
     * <pre>{@code
     * Sample codes
     * }</pre>

Step 3 - Replace below sample/example template in Javadoc
     * <pre>
     * <code>
     * Sample codes
     * </code>
     * </pre>
with:
     * <pre>{@code
     * Sample codes
     * }</pre>

Step 4 - Replace below sample/example template in Javadoc
     * <pre>
     * Sample codes
     * </pre>
with:
     * <pre>{@code
     * Sample codes
     * }</pre>

Step 5 - Replace all other sample/example templates in Javadoc with template:
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Sample codes
     * }</pre>


-- ==========================================================

Follow the steps below strictly and execute them in order.

Step 1 - Use multiple agents to verify each sample/example in all javadoc in all classes under folder: ./src/main/java/ by implementation and make sure all the samples/examples pass tests.

Step 2 - Use multiple agents to review the Javadoc comments for all public methods in the classes under ./src/main/java/. Ensure that similar methods have consistent and harmonized documentation, including clear and uniform descriptions of method behavior, parameters, and exceptions.

Step 3 - Use multiple agents to generate comprehensive Javadoc for all public methods, including public static methods but skip the methods annotated with @Override, in all classes in folder: ./src/main/java/. The Javadoc should be detailed and precise, thoroughly explaining the method’s purpose, behavior, parameters, return value, and exceptions. Where applicable, include a concise usage example (a couple of lines). The example block should always be placed before any @param, @return, or other annotation tags. If Javadoc already exists, review it against the actual implementation and update it for accuracy and clarity. Finally, merge the new or revised Javadoc directly into source file, replacing any existing documentation. DON'T skip any class. Use below template for usage example in Javadoc:
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Sample codes
     * }</pre>



-- ==========================================================

Follow the steps below strictly and execute them in order.

Step 1 — Use multiple agents to generate comprehensive unit tests for all public methods in every class under: ./src/main/java/ and for all public methods inherited from parent classes.

Requirements:

	1.1. Do not skip any public method. Every public method must have at least one corresponding unit test.
	1.2. The test class package must be identical to that of the source class.
	1.3. All test classes and test methods must be declared public.
	1.4. Each test class must extend the base class TestBase.
	1.5. The test class name must follow this pattern: *2025Test.java (append 2025Test to the source class name).
	1.6. Use JUnit 5 (org.junit.jupiter.api.Assertions). Do not use org.junit.Assert.
	1.7. Use Pair.left() and Pair.right() methods instead of direct field access (Pair.left, Pair.right).
	1.8. If a file such as *2025Test.java already exists, append new test methods to it rather than overwriting the file.
	1.9. Add @Tag("2025") for each test class if the tag doesn't exist.
	1.10. Ensure that the tests provide thorough code path coverage based on the actual implementation logic.

Step 2 — Review all unit tests in every *2025Test.java file to verify that: Each public method (including inherited ones) has at least one test. Add missing tests where necessary.

Step 3 — Fix Compilation Errors. Compile all *2025Test.java classes and fix any compilation errors.

Step 4 — Re-verify Coverage. After fixing compilation issues, re-review all *2025Test.java files to ensure: Every public method in the source classes is tested at least once. Add any missing tests.

Step 5 — Final Compilation Check Recompile all *2025Test.java files and resolve any remaining compilation errors.

-- ==========================================================
