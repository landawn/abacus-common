/*
 * Copyright (c) 2015, Haiyang Li.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.landawn.abacus.util;

import static com.landawn.abacus.util.WD._BACKSLASH;
import static com.landawn.abacus.util.WD._QUOTATION_D;
import static com.landawn.abacus.util.WD._QUOTATION_S;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;
import java.util.Collection;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.RandomAccess;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.lang.model.SourceVersion;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.MayReturnNull;
import com.landawn.abacus.logging.Logger;
import com.landawn.abacus.logging.LoggerFactory;
import com.landawn.abacus.util.u.Optional;
import com.landawn.abacus.util.u.OptionalChar;
import com.landawn.abacus.util.stream.IntStream;
import com.landawn.abacus.util.stream.Stream;

/**
 * A comprehensive utility class for string operations and manipulations.
 * 
 * <p>This class provides a wide range of static methods for common string operations including:
 * <ul>
 *   <li><b>Null-safe operations:</b> Methods that gracefully handle {@code null} inputs without throwing exceptions</li>
 *   <li><b>Validation:</b> Check if strings are empty, blank, valid email addresses, URLs, or Java identifiers</li>
 *   <li><b>Transformation:</b> Convert case, reverse, abbreviate, pad, trim, and normalize strings</li>
 *   <li><b>Search and Replace:</b> Find substrings, count occurrences, replace text with various options</li>
 *   <li><b>Comparison:</b> Compare strings with options for case sensitivity and locale</li>
 *   <li><b>Parsing:</b> Convert strings to numeric types, booleans, and other data types</li>
 *   <li><b>Encoding/Decoding:</b> Base64, URL encoding, Unicode operations</li>
 *   <li><b>String Building:</b> Efficient concatenation and joining operations</li>
 *   <li><b>Pattern Matching:</b> Work with regular expressions and wildcards</li>
 * </ul>
 * 
 * <h3>Design Philosophy</h3>
 * <ul>
 *   <li>Methods are designed to be null-safe where reasonable, returning sensible defaults instead of throwing exceptions</li>
 *   <li>Empty strings are preferred over {@code null} as return values</li>
 *   <li>Methods follow consistent naming patterns for discoverability</li>
 *   <li>Performance optimizations are applied for common operations</li>
 * </ul>
 * 
 * <h3>Exception Handling</h3>
 * <p>This class is designed to avoid throwing unnecessary exceptions. For example:
 * <ul>
 *   <li>Reversing a {@code null} or empty string returns the input unchanged</li>
 *   <li>Checking if a {@code null} string is empty returns {@code true}</li>
 *   <li>Exceptions are only thrown when the method contract is violated (e.g., negative array size)</li>
 * </ul>
 * 
 * <h3>Thread Safety</h3>
 * <p>All methods in this class are thread-safe as they operate on immutable strings and don't maintain state.
 * 
 * <h3>Attribution</h3>
 * <p>This class includes code adapted from Apache Commons Lang, Google Guava, and other open source projects
 * under the Apache License 2.0. The methods may have been modified to fit the design of this library.
 *
 * @see Joiner
 * @see Splitter
 * @see com.landawn.abacus.util.N
 * @see com.landawn.abacus.util.Array
 * @see com.landawn.abacus.util.Iterables
 * @see com.landawn.abacus.util.Iterators
 * @see com.landawn.abacus.util.Maps
 * @see com.landawn.abacus.util.URLEncodedUtil
 * @see com.landawn.abacus.util.AppendableWriter
 * @see com.landawn.abacus.util.StringWriter
 * @see com.landawn.abacus.util.RegExUtil
 * @see com.landawn.abacus.util.IEEE754rUtil
 */
@SuppressWarnings({ "java:S1694", "UnnecessaryUnicodeEscape" })
public abstract sealed class Strings permits Strings.StringUtil {

    private static final Logger LOGGER = LoggerFactory.getLogger(Strings.class);

    /**
     * String with value {@code "null"}.
     */
    @Beta
    public static final String NULL = "null";

    /**
     *
     * Char array with value {@code "['n', 'u', 'l', 'l']"}.
     */
    static final char[] NULL_CHAR_ARRAY = NULL.toCharArray();

    /**
     * The empty String {@code ""}.
     */
    public static final String EMPTY = "";

    //    /**
    //     * The empty String {@code ""}.
    //     * @deprecated Use {@link #EMPTY_STRING} instead
    //     */
    //    @Deprecated
    //    public static final String EMPTY = EMPTY_STRING;

    /**
     * A String for a space character: {@code " "}.
     *
     */
    public static final String SPACE = WD.SPACE;

    /**
     * A String for linefeed LF ("\n").
     *
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences
     *      for Character and String Literals</a>
     */
    public static final String LF = "\n";

    /**
     * A String for carriage return CR ("\r").
     *
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences
     *      for Character and String Literals</a>
     */
    public static final String CR = "\r";

    /**
     * Carriage return followed by line feed. This is the line ending used on Windows.
     */
    public static final String CR_LF = "\r\n";

    @Beta
    public static final char CHAR_ZERO = (char) 0;
    @Beta
    public static final char CHAR_SPACE = WD._SPACE;
    @Beta
    public static final char CHAR_LF = LF.charAt(0);
    @Beta
    public static final char CHAR_CR = CR.charAt(0);

    /**
     * Field COMMA_SPACE (value is {@code ", "})
     */
    public static final String COMMA_SPACE = WD.COMMA_SPACE;

    /**
     * Value is {@code ", "}
     */
    public static final String ELEMENT_SEPARATOR = COMMA_SPACE;

    static final char[] ELEMENT_SEPARATOR_CHAR_ARRAY = ELEMENT_SEPARATOR.toCharArray();

    static final String TRUE = Boolean.TRUE.toString().intern();

    static final char[] TRUE_CHAR_ARRAY = TRUE.toCharArray();

    static final String FALSE = Boolean.FALSE.toString().intern();

    static final char[] FALSE_CHAR_ARRAY = FALSE.toCharArray();

    static final String BACKSLASH_ASTERISK = "*";

    static final String STR_FOR_EMPTY_ARRAY = "[]";

    // java.lang.ExceptionInInitializerError: Exception java.lang.NoClassDefFoundError: Could not initialize class com.landawn.abacus.util.WD [in thread "main"]
    //    static final Set<String> CASE_INSENSITIVE_KEYWORDS = Set.of(" ", ", ", ";", ":", ":", ":", "=", "|", "&", "@", "$", "*", "+", "-", "_", "#", "!", "<", ">",
    //            "~", "^", "%", "\"", "'", "`", "{", "}", "[", "]", "(", ")", "?", "/", "\\", ".", ",", ";", ":", "!", "@", "#", "$", "%", "^", "&", "*");

    //    static final Set<String> CASE_INSENSITIVE_KEYWORDS;
    //
    //    static {
    //        final String[] strs = java.util.stream.Stream.of(WD.class.getDeclaredFields())
    //                .filter(it -> Modifier.isPublic(it.getModifiers()) && Modifier.isStatic(it.getModifiers()) && Modifier.isFinal(it.getModifiers())
    //                        && it.getType() == String.class)
    //                .map(it -> {
    //                    try {
    //                        return (String) it.get(null);
    //                    } catch (IllegalArgumentException | IllegalAccessException e) {
    //                        throw new RuntimeException(e);
    //                    }
    //                })
    //                .filter(it -> it.length() <= 3 && it.toUpperCase().equals(it.toLowerCase()))
    //                .toArray(String[]::new);
    //
    //        CASE_INSENSITIVE_KEYWORDS = Set.of(strs);
    //
    //        N.println(CASE_INSENSITIVE_KEYWORDS);
    //    }

    /**
     * A regex pattern for recognizing blocks of whitespace characters.
     * The apparent convolutedness of the pattern serves the purpose of ignoring
     * "blocks" consisting of only a single space: the pattern is used only to
     * normalize whitespace, condensing "blocks" down to a single space, thus
     * matching the same would likely cause a great many noop replacements.
     */
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("(?: |\\u00A0|\\s|[\\s&&[^ ]])\\s*");//NOSONAR

    private static final Splitter lineSplitter = Splitter.forLines();
    private static final Splitter trimLineSplitter = Splitter.forLines().trimResults();
    private static final Splitter omitEmptyLinesLineSplitter = Splitter.forLines().omitEmptyStrings();
    private static final Splitter trimAndOmitEmptyLinesLineSplitter = Splitter.forLines().trimResults().omitEmptyStrings();

    //    private static final Map<Object, Splitter> splitterPool = new HashMap<>();
    //
    //    private static final Map<Object, Splitter> trimSplitterPool = new HashMap<>();
    //
    //    private static final Map<Object, Splitter> preserveSplitterPool = new HashMap<>();
    //
    //    private static final Map<Object, Splitter> trimPreserveSplitterPool = new HashMap<>();
    //
    //    static {
    //        final List<String> delimiters = Array.asList(" ", "  ", "   ", "\t", "\n", "\r", ",", ", ", ";", "; ", ":", ": ", " : ", "-", " - ", "_", " _ ", "#",
    //                "##", " # ", "=", "==", " = ", "|", " | ", "||", " || ", "&", "&&", "@", "@@", "$", "$$", "*", "**", "+", "++");
    //
    //        for (final String delimiter : delimiters) {
    //            splitterPool.put(delimiter, Splitter.with(delimiter).omitEmptyStrings());
    //            trimSplitterPool.put(delimiter, Splitter.with(delimiter).omitEmptyStrings().trimResults());
    //            preserveSplitterPool.put(delimiter, Splitter.with(delimiter));
    //            trimPreserveSplitterPool.put(delimiter, Splitter.with(delimiter).trimResults());
    //
    //            if (delimiter.length() == 1) {
    //                final char delimiterChar = delimiter.charAt(0);
    //
    //                splitterPool.put(delimiterChar, Splitter.with(delimiterChar).omitEmptyStrings());
    //                trimSplitterPool.put(delimiterChar, Splitter.with(delimiterChar).omitEmptyStrings().trimResults());
    //                preserveSplitterPool.put(delimiterChar, Splitter.with(delimiterChar));
    //                trimPreserveSplitterPool.put(delimiterChar, Splitter.with(delimiterChar).trimResults());
    //            }
    //        }
    //    }

    private static final Encoder BASE64_ENCODER = java.util.Base64.getEncoder();

    private static final Decoder BASE64_DECODER = java.util.Base64.getDecoder();

    private static final Encoder BASE64_URL_ENCODER = java.util.Base64.getUrlEncoder().withoutPadding();

    private static final Decoder BASE64_URL_DECODER = java.util.Base64.getUrlDecoder();

    private Strings() {
        // Utility class.
    }

    /**
     * Generates a new universally unique identifier (UUID) string.
     *
     * <p>This method creates a standard UUID using {@link UUID#randomUUID()} and returns it
     * as a string in the canonical format with hyphens (8-4-4-4-12 format).</p>
     *
     * <p>The UUID is generated using a cryptographically strong pseudo random number generator.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String uuid = uuid();                          // returns something like "550e8400-e29b-41d4-a716-446655440000"
     * 
     * // Common use cases
     * String id = uuid();                            // returns "123e4567-e89b-12d3-a456-426614174000"
     * String uniqueKey = "KEY_" + uuid();            // returns "KEY_123e4567-e89b-12d3-a456-426614174000"
     * }</pre>
     *
     * @return A new UUID string in the standard format (8-4-4-4-12).
     * @see #guid()
     * @see UUID#randomUUID()
     */
    public static String uuid() {
        return UUID.randomUUID().toString();
    }

    /**
     * Generates a new globally unique identifier (GUID) string without hyphens.
     *
     * <p>This method creates a UUID using {@link UUID#randomUUID()} and removes all hyphen characters
     * to produce a continuous string of 32 hexadecimal characters.</p>
     *
     * <p>The returned string is suitable for use cases where a unique identifier is needed without
     * the standard UUID hyphen separators.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String guid = guid();                          // returns something like "550e8400e29b41d4a716446655440000"
     * 
     * // Common use cases
     * String sessionId = "SESSION_" + guid();        // returns "SESSION_550e8400e29b41d4a716446655440000"
     * String fileName = "temp_" + guid() + ".txt";   // returns "temp_550e8400e29b41d4a716446655440000.txt"
     * }</pre>
     *
     * @return A new UUID string without hyphens, consisting of 32 hexadecimal characters.
     * @see #uuid()
     * @see UUID#randomUUID()
     */
    public static String guid() {
        return uuid().replace("-", "");
    }

    /**
     * Converts the provided character array into a String.
     *
     * <p>This method provides a null-safe way to convert a character array to a String.
     * If the input array is {@code null}, the method returns {@code null} rather than
     * throwing a NullPointerException.</p>
     *
     * <p>Example:
     * <pre>{@code
     * char[] chars = {'h', 'e', 'l', 'l', 'o'};
     * valueOf(chars);                                // returns "hello"
     * valueOf(new char[] {'a', 'b', 'c'});          // returns "abc"
     * valueOf(new char[0]);                          // returns ""
     * valueOf(null);                                 // returns null
     * }</pre>
     *
     * @param value The character array to be converted. It can be {@code null}.
     * @return A String representation of the character array. Returns {@code null} if <i>value</i> is {@code null}.
     * @see String#valueOf(char[])
     * @see N#toString(Object)
     */
    public static String valueOf(final char[] value) {
        return value == null ? null : String.valueOf(value);
    }

    /**
      * Checks if the given CharSequence is a valid Java identifier.
      *
      * <p>A valid Java identifier must start with a letter, a currency character ($), or a connecting character such as underscore (_).
      * Identifiers cannot start with a number, and they cannot be a Java keyword or boolean literal (true or false).
      * Subsequent characters may include letters, digits, currency characters, or connecting characters.</p>
      *
      * <p>The method returns {@code false} for null or empty input.</p>
      *
      * <p>Example:
      * <pre>{@code
      * // Valid Java identifiers
      * isValidJavaIdentifier("myVariable");           // returns true
      * isValidJavaIdentifier("_privateField");        // returns true
      * isValidJavaIdentifier("$money");               // returns true
      * isValidJavaIdentifier("MAX_VALUE");            // returns true
      * isValidJavaIdentifier("userId123");            // returns true
      * 
      * // Invalid Java identifiers
      * isValidJavaIdentifier(null);                   // returns false
      * isValidJavaIdentifier("");                     // returns false
      * isValidJavaIdentifier("   ");                  // returns false
      * isValidJavaIdentifier("123abc");               // returns false (starts with digit)
      * }</pre>
      *
      * @param cs The CharSequence to be checked. It can be {@code null} or empty.
      * @return {@code true} if the CharSequence is a valid Java identifier, {@code false} otherwise.
      * @see Character#isJavaIdentifierStart(char)
      * @see Character#isJavaIdentifierPart(char)
      * @see <a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-3.html#jls-3.8">Java Language Specification - Identifiers</a>
      */
    public static boolean isValidJavaIdentifier(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.JAVA_IDENTIFIER_MATCHER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a Java keyword.
     *
     * <p>This method verifies whether the provided CharSequence matches any of the reserved
     * keywords in the Java programming language. Java keywords include reserved words like
     * {@code class}, {@code public}, {@code if}, {@code else}, etc.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Java keywords
     * isKeyword("class");                            // returns true
     * isKeyword("public");                           // returns true
     * isKeyword("if");                               // returns true
     * isKeyword("return");                           // returns true
     * 
     * // Not Java keywords
     * isKeyword("Class");                            // returns false (case sensitive)
     * isKeyword("myVariable");                       // returns false
     * isKeyword(null);                               // returns false
     * isKeyword("");                                 // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence is a Java keyword, {@code false} otherwise.
     */
    public static boolean isKeyword(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return SourceVersion.isKeyword(cs);
    }

    /**
     * Checks if the given CharSequence is a valid email address.
     *
     * <p>This method uses a regular expression (RFC 5322) to validate the email address. It checks for the general form of an email address
     * which is "local-part@domain". The local-part can contain alphanumeric characters and special characters like !, #, $, %, &, ', *, +, -, /, =, ?, ^, _, `, {, |, } and ~.
     * The domain part contains at least one dot (.) and can contain alphanumeric characters as well as hyphens (-).</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid email addresses
     * isValidEmailAddress("user@example.com");       // returns true
     * isValidEmailAddress("john.doe@company.org");   // returns true
     * isValidEmailAddress("admin+tag@domain.co.uk"); // returns true
     * 
     * // Invalid email addresses
     * isValidEmailAddress("invalid.email");          // returns false (no @ symbol)
     * isValidEmailAddress("@example.com");           // returns false (no local part)
     * isValidEmailAddress("user@");                  // returns false (no domain)
     * isValidEmailAddress(null);                     // returns false
     * isValidEmailAddress("");                       // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence is a valid email address, {@code false} otherwise.
     * @see #findFirstEmailAddress(CharSequence)
     * @see #findAllEmailAddresses(CharSequence)
     */
    public static boolean isValidEmailAddress(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.EMAIL_ADDRESS_RFC_5322_FINDER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a valid URL.
     *
     * <p>This method uses a regular expression to validate the URL. It checks for the general form of a URL
     * which includes protocol, domain, port, path, query parameters, and fragment identifier.
     * The URL can start with various protocols including http, https, ftp, file, etc.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid URLs
     * isValidUrl("http://www.example.com");          // returns true
     * isValidUrl("https://example.com:8080/path");   // returns true
     * isValidUrl("ftp://files.example.com/doc.pdf"); // returns true
     * isValidUrl("file:///C:/Users/doc.txt");        // returns true
     * 
     * // Invalid URLs
     * isValidUrl("not a url");                       // returns false
     * isValidUrl("www.example.com");                 // returns false (no protocol)
     * isValidUrl(null);                              // returns false
     * isValidUrl("");                                // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence is a valid URL, {@code false} otherwise.
     */
    public static boolean isValidUrl(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.URL_FINDER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a valid HTTP URL.
     *
     * <p>This method uses a regular expression to validate the URL. It checks for the general form of a URL
     * which includes protocol, domain, port, path, query parameters, and fragment identifier.
     * The URL must start with http:// or https://.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid HTTP URLs
     * isValidHttpUrl("http://www.example.com");      // returns true
     * isValidHttpUrl("https://example.com/path");    // returns true
     * isValidHttpUrl("https://api.example.com:8443");// returns true
     * 
     * // Invalid HTTP URLs
     * isValidHttpUrl("ftp://files.example.com");     // returns false (not HTTP)
     * isValidHttpUrl("www.example.com");             // returns false (no protocol)
     * isValidHttpUrl("file:///C:/doc.txt");          // returns false (not HTTP)
     * isValidHttpUrl(null);                          // returns false
     * isValidHttpUrl("");                            // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence is a valid HTTP URL, {@code false} otherwise.
     */
    public static boolean isValidHttpUrl(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.HTTP_URL_FINDER.matcher(cs).matches();
    }

    /**
     * Checks if the specified {@code CharSequence} is {@code null} or empty.
     *
     * <p>A CharSequence is considered empty if it has zero length. This method provides
     * a null-safe way to check for empty strings.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isEmpty(null);                                 // returns true
     * isEmpty("");                                   // returns true
     * isEmpty("   ");                                // returns false (contains spaces)
     * isEmpty("abc");                                // returns false
     * isEmpty(new StringBuilder());                  // returns true
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if the CharSequence is {@code null} or has zero length, {@code false} otherwise.
     */
    public static boolean isEmpty(final CharSequence cs) {
        return (cs == null) || (cs.isEmpty());
    }

    /**
     * Checks if the given CharSequence is {@code null} or contains only whitespace characters.
     *
     * <p>A CharSequence is considered blank if it is null, empty, or contains only whitespace
     * characters as defined by {@link Character#isWhitespace(char)}. This includes spaces,
     * tabs, newlines, and other Unicode whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isBlank(null);                                 // returns true
     * isBlank("");                                   // returns true
     * isBlank("   ");                                // returns true
     * isBlank("\t\n\r");                            // returns true
     * isBlank("  abc  ");                           // returns false
     * isBlank("abc");                                // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence is {@code null} or contains only whitespace characters, {@code false} otherwise.
     */
    public static boolean isBlank(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        if (cs instanceof String) {
            return ((String) cs).isBlank();
        }

        for (int i = 0, len = cs.length(); i < len; i++) {
            if (!Character.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence is not {@code null} and not empty.
     *
     * <p>This method is the opposite of {@link #isEmpty(CharSequence)}. It returns {@code true}
     * when the CharSequence is not null and has at least one character.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isNotEmpty("abc");                             // returns true
     * isNotEmpty("   ");                             // returns true (contains spaces)
     * isNotEmpty(new StringBuilder("test"));         // returns true
     * isNotEmpty("");                                // returns false
     * isNotEmpty(null);                              // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if the CharSequence is not {@code null} and not empty, {@code false} otherwise.
     */
    public static boolean isNotEmpty(final CharSequence cs) {
        return (cs != null) && (!cs.isEmpty());
    }

    /**
     * Checks if the given CharSequence is not {@code null} and contains non-whitespace characters.
     *
     * <p>This method is the opposite of {@link #isBlank(CharSequence)}. It returns {@code true}
     * when the CharSequence is not null and contains at least one non-whitespace character.</p>
     *
     * <p>This method is marked as @Beta, indicating it may be subject to change in future versions.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isNotBlank("abc");                             // returns true
     * isNotBlank("  abc  ");                         // returns true
     * isNotBlank("   ");                             // returns false (only whitespace)
     * isNotBlank("");                                // returns false
     * isNotBlank(null);                              // returns false
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if the CharSequence is not {@code null} and contains non-whitespace characters, {@code false} otherwise.
     */
    @Beta
    public static boolean isNotBlank(final CharSequence cs) {
        return !isBlank(cs);
    }

    /**
     * Checks if both of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when both CharSequences are either null or empty.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllEmpty(null, null);                        // returns true
     * isAllEmpty("", "");                            // returns true
     * isAllEmpty(null, "");                          // returns true
     * isAllEmpty("", null);                          // returns true
     * isAllEmpty("abc", "");                         // returns false
     * isAllEmpty("", "xyz");                         // returns false
     * isAllEmpty("abc", "xyz");                      // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if both CharSequences are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAllEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when all three CharSequences are either null or empty.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllEmpty(null, null, null);                  // returns true
     * isAllEmpty("", "", "");                        // returns true
     * isAllEmpty(null, "", null);                    // returns true
     * isAllEmpty("abc", "", "");                     // returns false
     * isAllEmpty("", "xyz", "");                     // returns false
     * isAllEmpty("", "", "123");                     // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @param c The third CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if all CharSequences are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAllEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * <p>Checks if all the CharSequences are empty ("") or {@code null}.</p>
     *
     * <p>This method returns {@code true} only when all provided CharSequences are either null or empty.
     * If the input array itself is null or empty, the method returns {@code true}.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <pre>
     * Strings.isAllEmpty(null)             = true
     * Strings.isAllEmpty(null, "")         = true
     * Strings.isAllEmpty(new String[] {})  = true
     * Strings.isAllEmpty(null, "foo")      = false
     * Strings.isAllEmpty("", "bar")        = false
     * Strings.isAllEmpty("bob", "")        = false
     * Strings.isAllEmpty("  bob  ", null)  = false
     * Strings.isAllEmpty(" ", "bar")       = false
     * Strings.isAllEmpty("foo", "bar")     = false
     * </pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or null
     * @see Strings#isAllEmpty(CharSequence...)
     */
    public static boolean isAllEmpty(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the provided CharSequences in the Iterable are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when all CharSequences in the Iterable are either null or empty.
     * If the Iterable itself is null or empty, the method returns {@code true}.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList(null, "", null);
     * isAllEmpty(list1);                             // returns true
     * 
     * List<String> list2 = Arrays.asList("", "abc", "");
     * isAllEmpty(list2);                             // returns false
     * 
     * isAllEmpty(null);                              // returns true
     * isAllEmpty(new ArrayList<>());                 // returns true
     * }</pre>
     *
     * @param css The Iterable of CharSequences to be checked. It can be {@code null}.
     * @return {@code true} if all CharSequences in the Iterable are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAllEmpty(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if both of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when both CharSequences are either null, empty, or contain only whitespace.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllBlank(null, null);                        // returns true
     * isAllBlank("", "");                            // returns true
     * isAllBlank("   ", "\t\n");                     // returns true
     * isAllBlank(null, "   ");                       // returns true
     * isAllBlank("abc", "   ");                      // returns false
     * isAllBlank("   ", "xyz");                      // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if both CharSequences are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAllBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) && isBlank(b);
    }

    /**
     * Checks if all the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when all three CharSequences are either null, empty, or contain only whitespace.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllBlank(null, null, null);                  // returns true
     * isAllBlank("", "", "");                        // returns true
     * isAllBlank("   ", "\t", "\n");                 // returns true
     * isAllBlank("abc", "   ", "");                  // returns false
     * isAllBlank("", "xyz", "   ");                  // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @param c The third CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if all CharSequences are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAllBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) && isBlank(b) && isBlank(c);
    }

    /**
     * <p>Checks if all the CharSequences are empty (""), {@code null} or whitespace only.</p>
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>This method returns {@code true} only when all provided CharSequences are either null, empty, or contain only whitespace.
     * If the input array itself is null or empty, the method returns {@code true}.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <pre>
     * Strings.isAllBlank(null)             = true
     * Strings.isAllBlank(null, "foo")      = false
     * Strings.isAllBlank(null, null)       = true
     * Strings.isAllBlank("", "bar")        = false
     * Strings.isAllBlank("bob", "")        = false
     * Strings.isAllBlank("  bob  ", null)  = false
     * Strings.isAllBlank(" ", "bar")       = false
     * Strings.isAllBlank("foo", "bar")     = false
     * Strings.isAllBlank(new String[] {})  = true
     * </pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or {@code null} or whitespace only
     * @see Strings#isAllBlank(CharSequence...)
     */
    public static boolean isAllBlank(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the provided CharSequences in the Iterable are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when all CharSequences in the Iterable are either null, empty, or contain only whitespace.
     * If the Iterable itself is null or empty, the method returns {@code true}.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList(null, "", "   ");
     * isAllBlank(list1);                             // returns true
     * 
     * List<String> list2 = Arrays.asList("   ", "abc", "");
     * isAllBlank(list2);                             // returns false
     * 
     * isAllBlank(null);                              // returns true
     * isAllBlank(new ArrayList<>());                 // returns true
     * }</pre>
     *
     * @param css The Iterable of CharSequences to be checked. It can be {@code null}.
     * @return {@code true} if all CharSequences in the Iterable are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAllBlank(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if any of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the two CharSequences is either null or empty.
     * It returns {@code false} only when both CharSequences are not empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAnyEmpty(null, null);                        // returns true
     * isAnyEmpty("", "");                            // returns true
     * isAnyEmpty("abc", "");                         // returns true
     * isAnyEmpty("", "xyz");                         // returns true
     * isAnyEmpty(null, "xyz");                       // returns true
     * isAnyEmpty("abc", "xyz");                      // returns false
     * isAnyEmpty("   ", "xyz");                      // returns false (spaces are not empty)
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if any of the CharSequences are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAnyEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) || isEmpty(b);
    }

    /**
     * Checks if any of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the three CharSequences is either null or empty.
     * It returns {@code false} only when all CharSequences are not empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAnyEmpty(null, null, null);                  // returns true
     * isAnyEmpty("abc", "", "xyz");                  // returns true
     * isAnyEmpty("", "def", "xyz");                  // returns true
     * isAnyEmpty("abc", "def", null);                // returns true
     * isAnyEmpty("abc", "def", "xyz");               // returns false
     * isAnyEmpty("   ", "def", "xyz");               // returns false (spaces are not empty)
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @param c The third CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if any of the CharSequences are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAnyEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) || isEmpty(b) || isEmpty(c);
    }

    /**
     * <p>Checks if any of the CharSequences are empty ("") or {@code null}.</p>
     *
     * <p>This method returns {@code true} if at least one of the provided CharSequences is either null or empty.
     * If the input array itself is null or has zero length, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the array are not empty.</p>
     *
     * <pre>
     * Strings.isAnyEmpty((String) null)    = true
     * Strings.isAnyEmpty((String[]) null)  = false
     * Strings.isAnyEmpty(null, "foo")      = true
     * Strings.isAnyEmpty("", "bar")        = true
     * Strings.isAnyEmpty("bob", "")        = true
     * Strings.isAnyEmpty("  bob  ", null)  = true
     * Strings.isAnyEmpty(" ", "bar")       = false
     * Strings.isAnyEmpty("foo", "bar")     = false
     * Strings.isAnyEmpty(new String[]{})   = false
     * Strings.isAnyEmpty(new String[]{""}) = true
     * </pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or null
     * @see Strings#isAnyEmpty(CharSequence...)
     */
    public static boolean isAnyEmpty(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isEmpty(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences in the Iterable are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one CharSequence in the Iterable is either null or empty.
     * If the Iterable itself is null or empty, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the Iterable are not empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList("abc", "", "xyz");
     * isAnyEmpty(list1);                             // returns true
     * 
     * List<String> list2 = Arrays.asList("abc", "def", "xyz");
     * isAnyEmpty(list2);                             // returns false
     * 
     * isAnyEmpty(null);                              // returns false
     * isAnyEmpty(new ArrayList<>());                 // returns false
     * }</pre>
     *
     * @param css The Iterable of CharSequences to be checked. It can be {@code null}.
     * @return {@code true} if any CharSequences in the Iterable are {@code null} or empty, {@code false} otherwise.
     */
    public static boolean isAnyEmpty(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isEmpty(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the two CharSequences is either null, empty, or contains only whitespace.
     * It returns {@code false} only when both CharSequences contain non-whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAnyBlank(null, null);                        // returns true
     * isAnyBlank("", "");                            // returns true
     * isAnyBlank("   ", "xyz");                      // returns true
     * isAnyBlank("abc", "\t\n");                     // returns true
     * isAnyBlank(null, "xyz");                       // returns true
     * isAnyBlank("abc", "xyz");                      // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if any of the CharSequences are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAnyBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) || isBlank(b);
    }

    /**
     * Checks if any of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the three CharSequences is either null, empty, or contains only whitespace.
     * It returns {@code false} only when all CharSequences contain non-whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAnyBlank(null, null, null);                  // returns true
     * isAnyBlank("abc", "   ", "xyz");               // returns true
     * isAnyBlank("", "def", "xyz");                  // returns true
     * isAnyBlank("abc", "def", null);                // returns true
     * isAnyBlank("abc", "def", "xyz");               // returns false
     * }</pre>
     *
     * @param a The first CharSequence to be checked. It can be {@code null}.
     * @param b The second CharSequence to be checked. It can be {@code null}.
     * @param c The third CharSequence to be checked. It can be {@code null}.
     * @return {@code true} if any of the CharSequences are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAnyBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) || isBlank(b) || isBlank(c);
    }

    /**
     * <p>Checks if any of the CharSequences are empty ("") or {@code null} or whitespace only.</p>
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>This method returns {@code true} if at least one of the provided CharSequences is either null, empty, or contains only whitespace.
     * If the input array itself is null or has zero length, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the array contain non-whitespace characters.</p>
     *
     * <pre>
     * Strings.isAnyBlank((String) null)    = true
     * Strings.isAnyBlank((String[]) null)  = false
     * Strings.isAnyBlank(null, "foo")      = true
     * Strings.isAnyBlank(null, null)       = true
     * Strings.isAnyBlank("", "bar")        = true
     * Strings.isAnyBlank("bob", "")        = true
     * Strings.isAnyBlank("  bob  ", null)  = true
     * Strings.isAnyBlank(" ", "bar")       = true
     * Strings.isAnyBlank(new String[] {})  = false
     * Strings.isAnyBlank(new String[]{""}) = true
     * Strings.isAnyBlank("foo", "bar")     = false
     * </pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or {@code null} or whitespace only
     * @see Strings#isAnyBlank(CharSequence...)
     */
    public static boolean isAnyBlank(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences in the Iterable are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one CharSequence in the Iterable is either null, empty, or contains only whitespace.
     * If the Iterable itself is null or empty, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the Iterable contain non-whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList("abc", "   ", "xyz");
     * isAnyBlank(list1);                             // returns true
     * 
     * List<String> list2 = Arrays.asList("abc", "def", "xyz");
     * isAnyBlank(list2);                             // returns false
     * 
     * isAnyBlank(null);                              // returns false
     * isAnyBlank(new ArrayList<>());                 // returns false
     * }</pre>
     *
     * @param css The Iterable of CharSequences to be checked. It can be {@code null}.
     * @return {@code true} if any CharSequences in the Iterable are {@code null} or blank, {@code false} otherwise.
     */
    public static boolean isAnyBlank(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the input string is wrapped with the specified prefix and suffix string.
     *
     * <p>This method verifies whether the string starts and ends with the same specified string.
     * The prefixSuffix parameter serves as both the prefix and suffix.
     * The check is case-sensitive.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isWrappedWith("'hello'", "'");                 // returns true
     * isWrappedWith("\"text\"", "\"");               // returns true
     * isWrappedWith("--comment--", "--");            // returns true
     * isWrappedWith("hello", "'");                   // returns false
     * isWrappedWith("'hello\"", "'");                // returns false
     * isWrappedWith(null, "'");                      // returns false
     * }</pre>
     *
     * @param str The input string to be checked.
     * @param prefixSuffix The string that should be the prefix and suffix of the input string.
     * @return {@code true} if the input string starts and ends with the prefixSuffix string, {@code false} otherwise.
     * @throws IllegalArgumentException if prefixSuffix is empty.
     */
    public static boolean isWrappedWith(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return str != null && str.length() >= prefixSuffix.length() * 2 && str.startsWith(prefixSuffix) && str.endsWith(prefixSuffix);
    }

    /**
     * Checks if the input string is wrapped with the specified prefix and suffix string.
     *
     * <p>This method verifies whether the string starts with the specified prefix and ends with the specified suffix.
     * The check is case-sensitive.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isWrappedWith("<html>content</html>", "<html>", "</html>");   // returns true
     * isWrappedWith("{data}", "{", "}");                            // returns true
     * isWrappedWith("[array]", "[", "]");                           // returns true
     * isWrappedWith("hello", "<", ">");                             // returns false
     * isWrappedWith("<hello", "<", ">");                            // returns false
     * isWrappedWith(null, "<", ">");                                // returns false
     * }</pre>
     *
     * @param str The input string to be checked.
     * @param prefix The string that should be the prefix of the input string.
     * @param suffix The string that should be the suffix of the input string.
     * @return {@code true} if the input string starts with the prefix and ends with the suffix, {@code false} otherwise.
     * @throws IllegalArgumentException if prefix or suffix is empty.
     */
    public static boolean isWrappedWith(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        return str != null && str.length() >= prefix.length() + suffix.length() && str.startsWith(prefix) && str.endsWith(suffix);
    }

    /**
     * Returns the specified default value if the given {@code charSequence} is {@code null}, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method provides a null-safe way to ensure a CharSequence is never null.
     * The default value must not be null.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfNull("hello", "default");             // returns "hello"
     * defaultIfNull(null, "default");                // returns "default"
     * defaultIfNull("", "default");                  // returns ""
     * defaultIfNull("   ", "default");               // returns "   "
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for {@code null}
     * @param defaultForNull the default value to return if {@code str} is {@code null}
     * @return {@code str} if it is not {@code null}, otherwise {@code defaultForNull}
     * @throws IllegalArgumentException if the specified default value is {@code null}.
     * @see #defaultIfEmpty(CharSequence, CharSequence)
     * @see #defaultIfBlank(CharSequence, CharSequence)
     * @see N#defaultIfNull(Object, Object)
     */
    public static <T extends CharSequence> T defaultIfNull(final T str, final T defaultForNull) throws IllegalArgumentException {
        N.checkArgNotNull(defaultForNull, cs.defaultValue);

        return str == null ? defaultForNull : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is {@code null}, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method provides a null-safe way to ensure a CharSequence is never null, with lazy evaluation of the default value.
     * The supplier is only invoked if the input CharSequence is null.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfNull("hello", () -> "default");       // returns "hello"
     * defaultIfNull(null, () -> "default");          // returns "default"
     * defaultIfNull("", () -> "default");            // returns ""
     * defaultIfNull(null, () -> generateDefault());  // calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for {@code null}
     * @param supplierForDefault the supplier that provides the default value if {@code str} is {@code null}
     * @return {@code str} if it is not {@code null}, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is {@code null} when the specified {@code charSequence} is {@code null}.
     * @see #defaultIfEmpty(CharSequence, Supplier)
     * @see #defaultIfBlank(CharSequence, Supplier)
     * @see N#defaultIfNull(Object, Supplier)
     */
    public static <T extends CharSequence> T defaultIfNull(final T str, final Supplier<? extends T> supplierForDefault) throws IllegalArgumentException {
        if (str == null) {
            return N.checkArgNotNull(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence empty if it is null or has zero length.
     * The default value must not be empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfEmpty("hello", "default");            // returns "hello"
     * defaultIfEmpty("", "default");                 // returns "default"
     * defaultIfEmpty(null, "default");               // returns "default"
     * defaultIfEmpty("   ", "default");              // returns "   " (spaces are not empty)
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for emptiness
     * @param defaultForEmpty the default value to return if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise {@code defaultForEmpty}
     * @throws IllegalArgumentException if the specified default charSequence value is empty.
     * @see #defaultIfNull(CharSequence, CharSequence)
     * @see #defaultIfBlank(CharSequence, CharSequence)
     * @see #firstNonEmpty(String, String)
     * @see N#defaultIfEmpty(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultForEmpty) throws IllegalArgumentException {
        N.checkArgNotEmpty(defaultForEmpty, cs.defaultValue);

        return isEmpty(str) ? defaultForEmpty : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence empty if it is null or has zero length.
     * The supplier is only invoked if the input CharSequence is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfEmpty("hello", () -> "default");      // returns "hello"
     * defaultIfEmpty("", () -> "default");           // returns "default"
     * defaultIfEmpty(null, () -> "default");         // returns "default"
     * defaultIfEmpty("", () -> generateDefault());   // calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for emptiness
     * @param supplierForDefault the supplier that provides the default value if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is empty when the specified {@code charSequence} is empty.
     * @see #defaultIfNull(CharSequence, Supplier)
     * @see #defaultIfBlank(CharSequence, Supplier)
     * @see #firstNonEmpty(String, String)
     * @see N#defaultIfEmpty(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isEmpty(str)) {
            return N.checkArgNotEmpty(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence blank if it is null, empty, or contains only whitespace characters.
     * The default value must not be blank.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfBlank("hello", "default");            // returns "hello"
     * defaultIfBlank("   ", "default");              // returns "default"
     * defaultIfBlank("", "default");                 // returns "default"
     * defaultIfBlank(null, "default");               // returns "default"
     * defaultIfBlank("  abc  ", "default");          // returns "  abc  "
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for blankness
     * @param defaultForBlank the default value to return if {@code str} is blank
     * @return {@code str} if it is not blank, otherwise {@code defaultForBlank}
     * @throws IllegalArgumentException if the specified default charSequence value is blank.
     * @see #defaultIfNull(CharSequence, CharSequence)
     * @see #defaultIfEmpty(CharSequence, CharSequence)
     * @see #firstNonBlank(String, String)
     * @see N#defaultIfBlank(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultForBlank) throws IllegalArgumentException {
        N.checkArgNotBlank(defaultForBlank, cs.defaultValue);

        return isBlank(str) ? defaultForBlank : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence blank if it is null, empty, or contains only whitespace characters.
     * The supplier is only invoked if the input CharSequence is blank.</p>
     *
     * <p>Example:
     * <pre>{@code
     * defaultIfBlank("hello", () -> "default");      // returns "hello"
     * defaultIfBlank("   ", () -> "default");        // returns "default"
     * defaultIfBlank(null, () -> "default");         // returns "default"
     * defaultIfBlank("   ", () -> generateDefault());// calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for blankness
     * @param supplierForDefault the supplier that provides the default value if {@code str} is blank
     * @return {@code str} if it is not blank, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is blank when the specified {@code charSequence} is blank.
     * @see #defaultIfNull(CharSequence, Supplier)
     * @see #defaultIfEmpty(CharSequence, Supplier)
     * @see #firstNonBlank(String, String)
     * @see N#defaultIfBlank(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isBlank(str)) {
            return N.checkArgNotBlank(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the first non-empty String from the given two Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not empty.
     * A string is considered empty if it is null or has zero length.
     * If both strings are empty, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstNonEmpty("hello", "world");               // returns "hello"
     * firstNonEmpty("", "world");                    // returns "world"
     * firstNonEmpty(null, "world");                  // returns "world"
     * firstNonEmpty("", "");                         // returns ""
     * firstNonEmpty(null, null);                     // returns ""
     * }</pre>
     *
     * @param a The first String to be checked. It can be {@code null} or empty.
     * @param b The second String to be checked. It can be {@code null} or empty.
     * @return The first non-empty String from the given two String. If both are empty, returns an empty string {@code ""}.
     * @see N#firstNonEmpty(CharSequence, CharSequence)
     */
    public static String firstNonEmpty(final String a, final String b) {
        return isEmpty(a) ? (isEmpty(b) ? EMPTY : b) : a;
    }

    /**
     * Returns the first non-empty String from the given three Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not empty.
     * A string is considered empty if it is null or has zero length.
     * If all strings are empty, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstNonEmpty("hello", "world", "!");          // returns "hello"
     * firstNonEmpty("", "world", "!");               // returns "world"
     * firstNonEmpty("", "", "!");                    // returns "!"
     * firstNonEmpty(null, null, "!");                // returns "!"
     * firstNonEmpty("", "", "");                     // returns ""
     * firstNonEmpty(null, null, null);               // returns ""
     * }</pre>
     *
     * @param a The first String to be checked. It can be {@code null} or empty.
     * @param b The second String to be checked. It can be {@code null} or empty.
     * @param c The third String to be checked. It can be {@code null} or empty.
     * @return The first non-empty String from the given three Strings. If all are empty, returns an empty string {@code ""}.
     * @see N#firstNonEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static String firstNonEmpty(final String a, final String b, final String c) {
        return isEmpty(a) ? (isEmpty(b) ? (isEmpty(c) ? EMPTY : c) : b) : a;
    }

    /**
     * <p>Returns the first value in the array which is not empty.</p>
     *
     * <p>If all values are empty or the array is {@code null} or empty then an empty string {@code ""} is returned.</p>
     *
     * <p>A string is considered empty if it is null or has zero length.</p>
     *
     * <pre>
     * Strings.firstNonEmpty(null, null, null)   = ""
     * Strings.firstNonEmpty(null, null, "")     = ""
     * Strings.firstNonEmpty(null, "", " ")      = " "
     * Strings.firstNonEmpty("abc")              = "abc"
     * Strings.firstNonEmpty(null, "xyz")        = "xyz"
     * Strings.firstNonEmpty("", "xyz")          = "xyz"
     * Strings.firstNonEmpty(null, "xyz", "abc") = "xyz"
     * Strings.firstNonEmpty()                   = ""
     * </pre>
     *
     * @param css the values to test, may be {@code null} or empty
     * @return the first value from {@code css} which is not empty, or an empty string {@code ""} if there is no non-empty value.
     * @see N#firstNonEmpty(CharSequence...)
     */
    public static String firstNonEmpty(final String... css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotEmpty(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-empty String from the given Iterable of Strings.
     *
     * <p>This method iterates through the strings and returns the first one that is not empty.
     * A string is considered empty if it is null or has zero length.
     * If all strings are empty or the Iterable is null or empty, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList("", null, "hello");
     * firstNonEmpty(list1);                          // returns "hello"
     * 
     * List<String> list2 = Arrays.asList("", null, "");
     * firstNonEmpty(list2);                          // returns ""
     * 
     * firstNonEmpty(null);                           // returns ""
     * firstNonEmpty(new ArrayList<>());              // returns ""
     * }</pre>
     *
     * @param css The Iterable of Strings to be checked. It can be {@code null}.
     * @return The first non-empty String from the given Iterable. If all Strings are empty or the Iterable is {@code null}, returns an empty string {@code ""}.
     * @see N#firstNonEmpty(Iterable)
     */
    public static String firstNonEmpty(final Iterable<String> css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotEmpty(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-blank String from the given two Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * If both strings are blank, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstNonBlank("hello", "world");               // returns "hello"
     * firstNonBlank("   ", "world");                 // returns "world"
     * firstNonBlank(null, "world");                  // returns "world"
     * firstNonBlank("   ", "   ");                   // returns ""
     * firstNonBlank(null, null);                     // returns ""
     * }</pre>
     *
     * @param a The first String to be checked. It can be {@code null} or empty.
     * @param b The second String to be checked. It can be {@code null} or empty.
     * @return The first non-blank String from the given two Strings. If both are blank, returns an empty string {@code ""}.
     * @see N#firstNonBlank(CharSequence, CharSequence)
     */
    public static String firstNonBlank(final String a, final String b) {
        return isBlank(a) ? (isBlank(b) ? EMPTY : b) : a;
    }

    /**
     * Returns the first non-blank String from the given three Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * If all strings are blank, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstNonBlank("hello", "world", "!");          // returns "hello"
     * firstNonBlank("   ", "world", "!");            // returns "world"
     * firstNonBlank("   ", "   ", "!");              // returns "!"
     * firstNonBlank(null, null, "!");                // returns "!"
     * firstNonBlank("   ", "   ", "   ");            // returns ""
     * firstNonBlank(null, null, null);               // returns ""
     * }</pre>
     *
     * @param a The first String to be checked. It can be {@code null} or empty.
     * @param b The second String to be checked. It can be {@code null} or empty.
     * @param c The third String to be checked. It can be {@code null} or empty.
     * @return The first non-blank String from the given three Strings. If all are blank, returns an empty string {@code ""}.
     * @see N#firstNonBlank(CharSequence, CharSequence, CharSequence)
     */
    public static String firstNonBlank(final String a, final String b, final String c) {
        return isBlank(a) ? (isBlank(b) ? (isBlank(c) ? EMPTY : c) : b) : a;
    }

    /**
     * Returns the first non-blank String from the given Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * If all strings are blank or the array is null or empty, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstNonBlank(null, "   ", "hello");           // returns "hello"
     * firstNonBlank("", "\t", "world");              // returns "world"
     * firstNonBlank("   ", "   ", "   ");            // returns ""
     * firstNonBlank(null, null, null);               // returns ""
     * firstNonBlank();                               // returns ""
     * firstNonBlank((String[]) null);                // returns ""
     * }</pre>
     *
     * @param css The Strings to be checked. They can be {@code null} or empty.
     * @return The first non-blank String from the given Strings. If all are blank, returns an empty string {@code ""}.
     * @see N#firstNonBlank(CharSequence...)
     */
    public static String firstNonBlank(final String... css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotBlank(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-blank String from the given Iterable of Strings, or an empty string {@code ""} if all Strings are blank or the Iterable is {@code null}.
     *
     * <p>This method iterates through the strings and returns the first one that is not blank.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * If all strings are blank or the Iterable is null or empty, an empty string ("") is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list1 = Arrays.asList("   ", null, "hello");
     * firstNonBlank(list1);                          // returns "hello"
     * 
     * List<String> list2 = Arrays.asList("   ", null, "\t");
     * firstNonBlank(list2);                          // returns ""
     * 
     * firstNonBlank(null);                           // returns ""
     * firstNonBlank(new ArrayList<>());              // returns ""
     * }</pre>
     *
     * @param css The Iterable of Strings to be checked. It can be {@code null}.
     * @return The first non-blank String from the given Iterable. If all Strings are blank or the Iterable is {@code null}, returns an empty string {@code ""}.
     * @see N#firstNonBlank(Iterable)
     */
    public static String firstNonBlank(final Iterable<String> css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotBlank(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Converts the specified String to an empty String {@code ""} if it's {@code null}, otherwise returns the original string.
     *
     * <p>This method provides a null-safe way to ensure a string is never null, converting null values to empty strings.</p>
     *
     * <p>Example:
     * <pre>{@code
     * nullToEmpty(null);                             // returns ""
     * nullToEmpty("");                               // returns ""
     * nullToEmpty("   ");                            // returns "   "
     * nullToEmpty("hello");                          // returns "hello"
     * }</pre>
     *
     * @param str The input string to be checked. It can be {@code null}.
     * @return An empty string if the input string is {@code null}, otherwise the original string.
     * @see N#nullToEmpty(String)
     */
    public static String nullToEmpty(final String str) {
        return str == null ? EMPTY : str;
    }

    /**
     * Converts each {@code null} String element in the specified String array to an empty String {@code ""}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all null elements with empty strings.
     * Non-null elements remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {null, "hello", null, "world"};
     * nullToEmpty(arr);                              // arr becomes {"", "hello", "", "world"}
     * 
     * String[] arr2 = {"a", "b", "c"};
     * nullToEmpty(arr2);                             // arr2 remains {"a", "b", "c"}
     * 
     * nullToEmpty(null);                             // does nothing
     * nullToEmpty(new String[0]);                    // does nothing
     * }</pre>
     *
     * @param strs The input string array to be checked. Each {@code null} element in the array will be converted to an empty string. It can be {@code null} or empty.
     * @see N#nullToEmpty(String[])
     * @see N#nullToEmptyForEach(String[])
     */
    public static void nullToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strs[i] == null ? EMPTY : strs[i];
        }
    }

    /**
     * Converts the specified String to {@code null} if it's empty, otherwise returns the original string.
     *
     * <p>This method considers a string empty if it has zero length. Strings containing only whitespace
     * are not considered empty and will not be converted to null.</p>
     *
     * <p>Example:
     * <pre>{@code
     * emptyToNull("");                               // returns null
     * emptyToNull(null);                             // returns null
     * emptyToNull("   ");                            // returns "   " (spaces are not empty)
     * emptyToNull("hello");                          // returns "hello"
     * }</pre>
     *
     * @param str The input string to be checked. It can be {@code null} or empty.
     * @return {@code null} if the input string is empty, otherwise the original string.
     */
    public static <T extends CharSequence> T emptyToNull(final T str) {
        return str == null || str.isEmpty() ? null : str;
    }

    /**
     * Converts each empty String element in the specified String array to {@code null}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all empty string elements with null.
     * Non-empty elements and null elements remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"", "hello", "", "world"};
     * emptyToNull(arr);                              // arr becomes {null, "hello", null, "world"}
     * 
     * String[] arr2 = {"a", "   ", "c"};
     * emptyToNull(arr2);                             // arr2 remains {"a", "   ", "c"} (spaces are not empty)
     * 
     * emptyToNull(null);                             // does nothing
     * emptyToNull(new String[0]);                    // does nothing
     * }</pre>
     *
     * @param strs The input string array to be checked. Each empty element in the array will be converted to {@code null}. It can be {@code null} or empty.
     */
    public static <T extends CharSequence> void emptyToNull(final T[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strs[i] == null || strs[i].isEmpty() ? null : strs[i];
        }
    }

    /**
     * Converts the specified String to an empty String {@code ""} if it's blank, otherwise returns the original string.
     *
     * <p>This method considers a string blank if it is null, empty, or contains only whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * blankToEmpty(null);                            // returns ""
     * blankToEmpty("");                              // returns ""
     * blankToEmpty("   ");                           // returns ""
     * blankToEmpty("\t\n");                          // returns ""
     * blankToEmpty("hello");                         // returns "hello"
     * blankToEmpty("  hello  ");                     // returns "  hello  "
     * }</pre>
     *
     * @param str The input string to be checked. It can be {@code null} or empty.
     * @return An empty string if the input string is blank, otherwise the original string.
     */
    public static String blankToEmpty(final String str) {
        return isBlank(str) ? EMPTY : str;
    }

    /**
     * Converts each blank String element in the specified String array to an empty String {@code ""}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all blank string elements with empty strings.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * Non-blank elements remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {null, "   ", "hello", "\t"};
     * blankToEmpty(arr);                             // arr becomes {"", "", "hello", ""}
     * 
     * String[] arr2 = {"a", "  b  ", "c"};
     * blankToEmpty(arr2);                            // arr2 remains {"a", "  b  ", "c"}
     * 
     * blankToEmpty(null);                            // does nothing
     * blankToEmpty(new String[0]);                   // does nothing
     * }</pre>
     *
     * @param strs The input string array to be checked. Each blank element in the array will be converted to an empty string. It can be {@code null} or empty.
     */
    public static void blankToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = isBlank(strs[i]) ? EMPTY : strs[i];
        }
    }

    /**
     * Converts the specified String to {@code null} if it's blank, otherwise returns the original string.
     *
     * <p>This method considers a string blank if it is null, empty, or contains only whitespace characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * blankToNull("");                               // returns null
     * blankToNull("   ");                            // returns null
     * blankToNull("\t\n");                           // returns null
     * blankToNull(null);                             // returns null
     * blankToNull("hello");                          // returns "hello"
     * blankToNull("  hello  ");                      // returns "  hello  "
     * }</pre>
     *
     * @param str The input string to be checked. It can be {@code null} or empty.
     * @return {@code null} if the input string is blank, otherwise the original string.
     */
    public static <T extends CharSequence> T blankToNull(final T str) {
        return isBlank(str) ? null : str;
    }

    /**
     * Converts each blank String element in the specified String array to {@code null}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all blank string elements with null.
     * A string is considered blank if it is null, empty, or contains only whitespace characters.
     * Non-blank elements remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"   ", "hello", "\t", "world"};
     * blankToNull(arr);                              // arr becomes {null, "hello", null, "world"}
     * 
     * String[] arr2 = {"a", "  b  ", "c"};
     * blankToNull(arr2);                             // arr2 remains {"a", "  b  ", "c"}
     * 
     * blankToNull(null);                             // does nothing
     * blankToNull(new String[0]);                    // does nothing
     * }</pre>
     *
     * @param strs The input string array to be checked. Each blank element in the array will be converted to {@code null}. It can be {@code null} or empty.
     */
    public static <T extends CharSequence> void blankToNull(final T[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = isBlank(strs[i]) ? null : strs[i];
        }
    }

    /**
     * <p>Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "...is the time for..."</p>
     *
     * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
     * a "left edge" offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * ellipses, but it will appear somewhere in the result.
     *
     * <p>In no case will it return a String of length greater than
     * {@code maxWidth}.</p>
     *
     * <pre>
     * Strings.abbreviate(null, 0, 4)                  = null
     * Strings.abbreviate("", 0, 4)                  = ""
     * Strings.abbreviate("abcdefghijklmno", -1, 10) = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 0, 10)  = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 1, 10)  = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 4, 10)  = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 5, 10)  = "...fghi..."
     * Strings.abbreviate("abcdefghijklmno", 6, 10)  = "...ghij..."
     * Strings.abbreviate("abcdefghijklmno", 8, 10)  = "...ijklmno"
     * Strings.abbreviate("abcdefghijklmno", 10, 10) = "...ijklmno"
     * Strings.abbreviate("abcdefghijklmno", 12, 10) = "...ijklmno"
     * Strings.abbreviate("abcdefghij", 0, 3)        = IllegalArgumentException
     * Strings.abbreviate("abcdefghij", 5, 6)        = IllegalArgumentException
     * </pre>
     *
     * @param str the String to check, which may be null
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException if the width is too small
     * @deprecated
     */
    @Deprecated
    static String abbreviate(final String str, final int offset, final int maxWidth) {
        return abbreviate(str, "...", offset, maxWidth);
    }

    // Abbreviating
    //-----------------------------------------------------------------------

    /**
     * <p>Abbreviates a String using a given replacement marker. This will turn
     * "Now is the time for all good men" into "...is the time for..." if "..." was defined
     * as the replacement marker.</p>
     *
     * <p>Works like {@code abbreviate(String, String, int)}, but allows you to specify
     * a "left edge" offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * replacement marker, but it will appear somewhere in the result.
     *
     * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>
     *
     * <pre>
     * Strings.abbreviate(null, "...", 0, 4)                  = null
     * Strings.abbreviate("", "...", 0, 4)                  = ""
     * Strings.abbreviate("abcdefghijklmno", {@code null}, *, *)    = "abcdefghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "---", -1, 10) = "abcdefg---"
     * Strings.abbreviate("abcdefghijklmno", ",", 0, 10)    = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", ",", 1, 10)    = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", ",", 2, 10)    = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", "::", 4, 10)   = "::efghij::"
     * Strings.abbreviate("abcdefghijklmno", "...", 6, 10)  = "...ghij..."
     * Strings.abbreviate("abcdefghijklmno", "*", 9, 10)    = "*ghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "'", 10, 10)   = "'ghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "!", 12, 10)   = "!ghijklmno"
     * Strings.abbreviate("abcdefghij", "abra", 0, 4)       = IllegalArgumentException
     * Strings.abbreviate("abcdefghij", "...", 5, 6)        = IllegalArgumentException
     * </pre>
     *
     * @param str the String to check, which may be null
     * @param abbrevMarker the String used as replacement marker
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     * @deprecated
     */
    @Deprecated
    static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
        final int abbrevMarkerLength = N.len(abbrevMarker);
        final int minAbbrevWidth = abbrevMarkerLength + 1;
        final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;

        if (maxWidth < minAbbrevWidth) {
            throw new IllegalArgumentException(String.format("Minimum abbreviation width is %d", minAbbrevWidth));
        }

        if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
            return Strings.substring(str, 0, maxWidth);
        } else if (isAnyEmpty(str, abbrevMarker)) {
            return str;
        }

        final int strLen = str.length();

        if (strLen <= maxWidth) {
            return str;
        }

        if (offset > strLen) {
            offset = strLen;
        }

        if (strLen - offset < maxWidth - abbrevMarkerLength) {
            offset = strLen - (maxWidth - abbrevMarkerLength);
        }

        if (offset <= abbrevMarkerLength + 1) {
            return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;
        }

        if (maxWidth < minAbbrevWidthOffset) {
            throw new IllegalArgumentException(String.format("Minimum abbreviation width with offset is %d", minAbbrevWidthOffset));
        }

        if (offset + maxWidth - abbrevMarkerLength < strLen) {
            return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);
        }

        return abbrevMarker + str.substring(strLen - (maxWidth - abbrevMarkerLength));
    }

    /**
     * <p>Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "Now is the time for..."</p>
     *
     * <p>Specifically:</p>
     * <ul>
     *   <li>If the number of characters in {@code str} is less than or equal to
     *       {@code maxWidth}, return {@code str}.</li>
     *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + "...")}.</li>
     *   <li>If {@code maxWidth} is less than {@code 4}, throw an
     *       {@code IllegalArgumentException}.</li>
     *   <li>In no case will it return a String of length greater than
     *       {@code maxWidth}.</li>
     * </ul>
     *
     * <pre>
     * Strings.abbreviate(null, 4)        = null
     * Strings.abbreviate("", 4)        = ""
     * Strings.abbreviate("abcdefg", 6) = "abc..."
     * Strings.abbreviate("abcdefg", 7) = "abcdefg"
     * Strings.abbreviate("abcdefg", 8) = "abcdefg"
     * Strings.abbreviate("abcdefg", 4) = "a..."
     * Strings.abbreviate("abcdefg", 3) = IllegalArgumentException
     * </pre>
     *
     * @param str the String to check, which may be null
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     */
    public static String abbreviate(final String str, final int maxWidth) {
        return abbreviate(str, "...", 0, maxWidth);
    }

    /**
     * <p>Abbreviates a String using another given String as replacement marker. This will turn
     * "Now is the time for all good men" into "Now is the time for..." if "..." was defined
     * as the replacement marker.</p>
     *
     * <p>Specifically:</p>
     * <ul>
     *   <li>If the number of characters in {@code str} is less than or equal to
     *       {@code maxWidth}, return {@code str}.</li>
     *   <li>Else abbreviate it to {@code (substring(str, 0, max-abbrevMarker.length) + abbrevMarker)}.</li>
     *   <li>If {@code maxWidth} is less than {@code abbrevMarker.length + 1}, throw an
     *       {@code IllegalArgumentException}.</li>
     *   <li>In no case will it return a String of length greater than
     *       {@code maxWidth}.</li>
     * </ul>
     *
     * <pre>
     * Strings.abbreviate(null, "...", 4)        = null
     * Strings.abbreviate("", "...", 4)        = ""
     * Strings.abbreviate("abcdefg", null, *)  = "abcdefg"
     * Strings.abbreviate("abcdefg", ".", 5)   = "abcd."
     * Strings.abbreviate("abcdefg", ".", 7)   = "abcdefg"
     * Strings.abbreviate("abcdefg", ".", 8)   = "abcdefg"
     * Strings.abbreviate("abcdefg", "..", 4)  = "ab.."
     * Strings.abbreviate("abcdefg", "..", 3)  = "a.."
     * Strings.abbreviate("abcdefg", "..", 2)  = IllegalArgumentException
     * Strings.abbreviate("abcdefg", "...", 3) = IllegalArgumentException
     * </pre>
     *
     * @param str the String to check, which may be null
     * @param abbrevMarker the String used as replacement marker
     * @param maxWidth maximum length of result String, must be at least {@code abbrevMarker.length + 1}
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     */
    public static String abbreviate(final String str, final String abbrevMarker, final int maxWidth) {
        return abbreviate(str, abbrevMarker, 0, maxWidth);
    }

    /**
     * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
     * replacement String.</p>
     *
     * <p>This abbreviation only occurs if the following criteria is met:</p>
     * <ul>
     * <li>Neither the String for abbreviation nor the replacement String are {@code null} or empty </li>
     * <li>The length to truncate to is less than the length of the supplied String</li>
     * <li>The length to truncate to is greater than 0</li>
     * <li>The abbreviated String will have enough room for the length supplied replacement String
     * and the first and last characters of the supplied String for abbreviation</li>
     * </ul>
     * <p>Otherwise, the returned String will be the same as the supplied String for abbreviation.
     * </p>
     *
     * <pre>
     * Strings.abbreviateMiddle(null, null, 0)      = null
     * Strings.abbreviateMiddle("abc", null, 0)      = "abc"
     * Strings.abbreviateMiddle("abc", ".", 0)      = "abc"
     * Strings.abbreviateMiddle("abc", ".", 3)      = "abc"
     * Strings.abbreviateMiddle("abcdef", ".", 4)     = "ab.f"
     * </pre>
     *
     * @param str the String to abbreviate, which may be null
     * @param middle the String to replace the middle characters with, which may be null
     * @param length the length to abbreviate {@code str} to.
     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
     */
    public static String abbreviateMiddle(final String str, final String middle, final int length) {
        if (isAnyEmpty(str, middle) || length >= str.length() || length < middle.length() + 2) {
            return str;
        }

        final int targetSting = length - middle.length();
        final int startOffset = targetSting / 2 + targetSting % 2;
        final int endOffset = str.length() - targetSting / 2;

        return str.substring(0, startOffset) + middle + str.substring(endOffset);
    }

    /**
     * <p>Centers a String in a larger String of size {@code size}
     * using the space character (' ').</p>
     *
     * <p>If the size is less than the String length, the original String is returned.
     * This method is equivalent to {@code center(str, size, " ")}.</p>
     *
     * <p>Example:
     * <pre>
     * Strings.center(null, 4)     = "    "
     * Strings.center("", 4)     = "    "
     * Strings.center("ab", 4)   = " ab "
     * Strings.center("abcd", 2) = "abcd"
     * Strings.center("a", 4)    = " a  "
     * </pre>
     *
     * @param str the String to center, which may be null
     * @param size the int size of new String
     * @return centered String
     */
    public static String center(final String str, final int size) {
        return center(str, size, ' ');
    }

    /**
     * <p>Centers a String in a larger String of size {@code size}.
     * Uses a supplied character as the value to pad the String with.</p>
     *
     * <p>If the size is less than the String length, the String is returned.
     * Padding is distributed evenly on both sides. If the padding cannot be evenly distributed,
     * the extra padding character is added to the right side.</p>
     *
     * <pre>
     * Strings.center(null, 4, ' ')     = "    "
     * Strings.center("", 4, ' ')     = "    "
     * Strings.center("ab", 4, ' ')   = " ab "
     * Strings.center("abcd", 2, ' ') = "abcd"
     * Strings.center("a", 4, ' ')    = " a  "
     * Strings.center("a", 4, 'y')    = "yayy"
     * </pre>
     *
     * @param str the String to center, which may be null
     * @param size the int size of new String.
     * @param padChar the character to pad the new String with
     * @return centered String
     * @throws IllegalArgumentException if size is negative
     */
    public static String center(String str, final int size, final char padChar) throws IllegalArgumentException {
        N.checkArgNotNegative(size, cs.size);

        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= size) {
            return str;
        }

        final int strLen = str.length();
        final int pads = size - strLen;

        str = padStart(str, strLen + pads / 2, padChar);
        return padEnd(str, size, padChar);
    }

    /**
     * <p>Centers a String in a larger String of size {@code minLength}.
     * Uses a supplied String as the value to pad the String with.</p>
     *
     * <p>If the size is less than the String length, the String is returned.
     * Padding is distributed evenly on both sides. If the padding cannot be evenly distributed,
     * the extra padding is added to the right side.</p>
     *
     * <pre>
     * Strings.center(null, 4, " ")     = "    "
     * Strings.center("", 4, " ")     = "    "
     * Strings.center("ab", 4, " ")   = " ab "
     * Strings.center("abcd", 2, " ") = "abcd"
     * Strings.center("a", 4, " ")    = " a  "
     * Strings.center("a", 4, "yz")   = "yzayz"
     * Strings.center("abc", 7, "")   = "  abc  "
     * </pre>
     *
     * @param str the String to center, which may be null
     * @param minLength the minimum size of new String.
     * @param padStr the String to pad the new String with, must not be {@code null} or empty
     * @return centered String
     * @throws IllegalArgumentException if minLength is negative
     */
    public static String center(String str, final int minLength, String padStr) throws IllegalArgumentException {
        N.checkArgNotNegative(minLength, cs.minLength);
        // N.checkArgNotEmpty(padStr, "padStr");

        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        if (isEmpty(padStr)) {
            padStr = " ";
        }

        final int strLen = str.length();
        final int pads = minLength - strLen;

        str = padStart(str, strLen + pads / 2, padStr);
        return padEnd(str, minLength, padStr);
    }

    /**
     * Pads the given string from the start (left) with spaces until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>Example:
     * <pre>{@code
     * padStart("abc", 5);                            // returns "  abc"
     * padStart("abc", 3);                            // returns "abc"
     * padStart("abc", 1);                            // returns "abc"
     * padStart("", 3);                               // returns "   "
     * padStart(null, 3);                             // returns "   "
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null} or empty.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @return A new string that is a copy of the original string padded with leading spaces so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(final String str, final int minLength) {
        return padStart(str, minLength, WD._SPACE);
    }

    /**
     * Pads the given string from the start (left) with the specified character until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>Example:
     * <pre>{@code
     * padStart("abc", 5, '*');                       // returns "**abc"
     * padStart("abc", 3, '*');                       // returns "abc"
     * padStart("abc", 6, '0');                       // returns "000abc"
     * padStart("", 3, 'x');                          // returns "xxx"
     * padStart(null, 3, '-');                        // returns "---"
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null}, in which case it will be treated as an empty string.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @param padChar The character to be used for padding.
     * @return A new string that is a copy of the original string padded with the padChar so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(String str, final int minLength, final char padChar) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        final String padStr = Strings.repeat(padChar, minLength - str.length());

        return concat(padStr, str);
    }

    /**
     * Pads the given string from the start (left) with the specified string until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>If the padding string is longer than the remaining space, only the necessary portion of the padding string is used.</p>
     *
     * <p>Example:
     * <pre>{@code
     * padStart("abc", 7, "xy");                      // returns "xyxyabc"
     * padStart("abc", 6, "123");                     // returns "123abc"
     * padStart("abc", 8, "xy");                      // returns "xyxyxabc"
     * padStart("", 4, "ab");                         // returns "abab"
     * padStart(null, 3, "0");                        // returns "000"
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null}, in which case it will be treated as an empty string.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @param padStr The string to be used for padding.
     * @return A new string that is a copy of the original string padded with the padStr so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(String str, final int minLength, final String padStr) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        @SuppressWarnings("DuplicateExpressions")
        final int delta = ((minLength - str.length()) % padStr.length() == 0) ? ((minLength - str.length()) / padStr.length())
                : ((minLength - str.length()) / padStr.length() + 1);
        switch (delta) {
            case 1:
                return padStr + str;

            case 2:
                return padStr + padStr + str;

            case 3:
                return padStr + padStr + padStr + str;

            default: {
                final StringBuilder sb = Objectory.createStringBuilder(str.length() + (padStr.length() * delta));

                try {
                    //noinspection StringRepeatCanBeUsed
                    for (int i = 0; i < delta; i++) {
                        sb.append(padStr);
                    }

                    sb.append(str);

                    return sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }
            }
        }
    }

    /**
     * Pads the given string from the end (right) with spaces until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>Example:
     * <pre>{@code
     * padEnd("abc", 5);                              // returns "abc  "
     * padEnd("abc", 3);                              // returns "abc"
     * padEnd("abc", 1);                              // returns "abc"
     * padEnd("", 3);                                 // returns "   "
     * padEnd(null, 3);                               // returns "   "
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null}, in which case it will be treated as an empty string.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @return A new string that is a copy of the original string padded with trailing spaces so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padEnd(final String str, final int minLength) {
        return padEnd(str, minLength, WD._SPACE);
    }

    /**
     * Pads the given string from the end (right) with the specified character until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>Example:
     * <pre>{@code
     * padEnd("abc", 5, '*');                         // returns "abc**"
     * padEnd("abc", 3, '*');                         // returns "abc"
     * padEnd("abc", 6, '0');                         // returns "abc000"
     * padEnd("", 3, 'x');                            // returns "xxx"
     * padEnd(null, 3, '-');                          // returns "---"
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null}, in which case it will be treated as an empty string.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @param padChar The character to be used for padding.
     * @return A new string that is a copy of the original string padded with the padChar so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padEnd(String str, final int minLength, final char padChar) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        final String padStr = Strings.repeat(padChar, minLength - str.length());

        return concat(str, padStr);
    }

    /**
     * Pads the given string from the end (right) with the specified string until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>If the padding string is longer than the remaining space, only the necessary portion of the padding string is used.</p>
     *
     * <p>Example:
     * <pre>{@code
     * padEnd("abc", 7, "xy");                        // returns "abcxyxy"
     * padEnd("abc", 6, "123");                       // returns "abc123"
     * padEnd("abc", 8, "xy");                        // returns "abcxyxyx"
     * padEnd("", 4, "ab");                           // returns "abab"
     * padEnd(null, 3, "0");                          // returns "000"
     * }</pre>
     *
     * @param str The string to be padded. It can be {@code null}, in which case it will be treated as an empty string.
     * @param minLength The minimum length the string should have after padding. Must be non-negative.
     * @param padStr The string to be used for padding.
     * @return A new string that is a copy of the original string padded with the padStr so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padEnd(String str, final int minLength, final String padStr) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        @SuppressWarnings("DuplicateExpressions")
        final int delta = ((minLength - str.length()) % padStr.length() == 0) ? ((minLength - str.length()) / padStr.length())
                : ((minLength - str.length()) / padStr.length() + 1);

        switch (delta) {
            case 1:
                return str + padStr;

            case 2:
                return str + padStr + padStr;

            case 3:
                return str + padStr + padStr + padStr;

            default: {
                final StringBuilder sb = Objectory.createStringBuilder(str.length() + (padStr.length() * delta));

                try {
                    sb.append(str);

                    //noinspection StringRepeatCanBeUsed
                    for (int i = 0; i < delta; i++) {
                        sb.append(padStr);
                    }

                    return sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }
            }
        }
    }

    /**
     * Repeats the given character a specified number of times and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified character repeated n times.</p>
     *
     * <p>Example:
     * <pre>{@code
     * repeat('a', 0);                                // returns ""
     * repeat('a', 3);                                // returns "aaa"
     * repeat('*', 5);                                // returns "*****"
     * repeat(' ', 4);                                // returns "    "
     * }</pre>
     *
     * @param ch The character to be repeated.
     * @param n The number of times the character should be repeated. Must be non-negative.
     * @return A string consisting of the given character repeated n times.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(final char ch, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY;
        } else if (n == 1) {
            return N.stringOf(ch);
        }

        return N.stringOf(ch).repeat(n);
    }

    /**
     * Repeats the given character a specified number of times, separated by a specified delimiter, and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified character repeated n times,
     * with each occurrence separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * repeat('a', 0, ',');                           // returns ""
     * repeat('a', 1, ',');                           // returns "a"
     * repeat('a', 3, ',');                           // returns "a,a,a"
     * repeat('*', 4, '-');                           // returns "*-*-*-*"
     * }</pre>
     *
     * @param ch The character to be repeated.
     * @param n The number of times the character should be repeated. Must be non-negative.
     * @param delimiter The character used to separate the repeated characters.
     * @return A string consisting of the given character repeated n times, separated by the delimiter.
     * @throws IllegalArgumentException if n is negative.
     * @see #repeat(char, int, char)
     * @see #repeat(String, int, String)
     */
    public static String repeat(final char ch, final int n, final char delimiter) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        return repeat(N.stringOf(ch), n, N.stringOf(delimiter));
    }

    /**
     * Repeats the given string a specified number of times and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified string repeated n times.
     * If the input string is null or empty, or n is 0, appropriate results are returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * repeat("ab", 0);                               // returns ""
     * repeat("ab", 1);                               // returns "ab"
     * repeat("ab", 3);                               // returns "ababab"
     * repeat("Hello", 2);                            // returns "HelloHello"
     * repeat(null, 3);                               // returns ""
     * repeat("", 3);                                 // returns ""
     * }</pre>
     *
     * @param str The string to be repeated. It can be {@code null} or empty.
     * @param n The number of times the string should be repeated. Must be non-negative.
     * @return A string consisting of the given string repeated n times.
     * @throws IllegalArgumentException if n is negative.
     * @see #repeat(char, int, char)
     * @see #repeat(String, int, String)
     */
    public static String repeat(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (N.isEmpty(str) || n == 0) {
            return EMPTY;
        } else if (n == 1) {
            return str;
        }

        return str.repeat(n);
    }

    /**
     * Repeats the given string a specified number of times, separated by a specified delimiter, and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified string repeated n times,
     * with each occurrence separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * repeat("ab", 0, ",");                          // returns ""
     * repeat("ab", 1, ",");                          // returns "ab"
     * repeat("ab", 3, ",");                          // returns "ab,ab,ab"
     * repeat("Hello", 2, " ");                       // returns "Hello Hello"
     * repeat("X", 4, "-");                           // returns "X-X-X-X"
     * }</pre>
     *
     * @param str The string to be repeated. It can be {@code null} or empty.
     * @param n The number of times the string should be repeated. Must be non-negative.
     * @param delimiter The string used to separate the repeated strings.
     * @return A string consisting of the given string repeated n times, separated by the delimiter.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(final String str, final int n, final String delimiter) throws IllegalArgumentException {
        if (N.isEmpty(delimiter)) {
            return repeat(str, n);
        }

        return repeat(str, n, delimiter, EMPTY, EMPTY);
    }

    /**
     * Repeats the given string a specified number of times, separated by a specified delimiter, and returns the resulting string.
     * The resulting string is also prefixed and suffixed with the provided strings.
     *
     * <p>This method creates a string consisting of the prefix, followed by the specified string repeated n times
     * (with each occurrence separated by the delimiter), and ending with the suffix.</p>
     *
     * <p>Example:
     * <pre>{@code
     * repeat("ab", 0, ",", "[", "]");                // returns "[]"
     * repeat("ab", 1, ",", "[", "]");                // returns "[ab]"
     * repeat("ab", 3, ",", "[", "]");                // returns "[ab,ab,ab]"
     * repeat("X", 4, "-", "Start:", ":End");         // returns "Start:X-X-X-X:End"
     * }</pre>
     *
     * @param str The string to be repeated. It can be {@code null} or empty.
     * @param n The number of times the string should be repeated. Must be non-negative.
     * @param delimiter The string used to separate the repeated strings.
     * @param prefix The string to be added at the start of the resulting string.
     * @param suffix The string to be added at the end of the resulting string.
     * @return A string consisting of the prefix, the given string repeated n times separated by the delimiter, and the suffix.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(String str, final int n, String delimiter, String prefix, String suffix) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        str = str == null ? EMPTY : str;
        delimiter = delimiter == null ? EMPTY : delimiter;
        prefix = prefix == null ? EMPTY : prefix;
        suffix = suffix == null ? EMPTY : suffix;

        if (n == 0 || (isEmpty(str) && isEmpty(delimiter))) {
            return concat(prefix + suffix);
        } else if (n == 1) {
            return concat(prefix, str, suffix);
        }

        return join(Array.repeat(str, n), delimiter, prefix, suffix);
    }

    /**
     * Returns the byte array returned by {@code String.getBytes()}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a byte array using the platform's default charset.</p>
     *
     * <p>Example:
     * <pre>{@code
     * getBytes("hello");                             // returns byte array of "hello"
     * getBytes("");                                  // returns empty byte array
     * getBytes(null);                                // returns null
     * }</pre>
     *
     * @param string The input string to be converted. It can be {@code null}.
     * @return A byte array representation of the input string using the default charset, or {@code null} if the input string is {@code null}.
     */
    @MayReturnNull
    public static byte[] getBytes(final String string) {
        return string == null ? null : string.getBytes();
    }

    /**
     * Returns the byte array returned by {@code String#getBytes(Charset)}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a byte array using the specified charset.</p>
     *
     * <p>Example:
     * <pre>{@code
     * getBytes("hello", StandardCharsets.UTF_8);     // returns UTF-8 encoded bytes
     * getBytes("hello", StandardCharsets.US_ASCII);  // returns ASCII encoded bytes
     * getBytes("", StandardCharsets.UTF_8);          // returns empty byte array
     * getBytes(null, StandardCharsets.UTF_8);        // returns null
     * }</pre>
     *
     * @param string The input string to be converted. It can be {@code null}.
     * @param charset The charset to be used for encoding.
     * @return the encoded bytes
     */
    @MayReturnNull
    public static byte[] getBytes(final String string, final Charset charset) {
        return string == null ? null : string.getBytes(charset);
    }

    /**
     * Returns the byte array returned by {@code String#getBytes(Charsets.UTF_8)}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a UTF-8 encoded byte array.</p>
     *
     * <p>Example:
     * <pre>{@code
     * getBytesUtf8("hello");                         // returns UTF-8 encoded bytes
     * getBytesUtf8("");                           // returns UTF-8 encoded bytes
     * getBytesUtf8("");                              // returns empty byte array
     * getBytesUtf8(null);                            // returns null
     * }</pre>
     *
     * @param string The input string to be converted. It can be {@code null}.
     * @return A byte array representation of the input string using UTF-8 encoding, or {@code null} if the input string is {@code null}.
     */
    @MayReturnNull
    public static byte[] getBytesUtf8(final String string) {
        return getBytes(string, Charsets.UTF_8);
    }

    /**
     * Returns the char array of the specified CharSequence, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a CharSequence to a char array.
     * It handles String instances efficiently by using the native toCharArray() method.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toCharArray("hello");                          // returns ['h','e','l','l','o']
     * toCharArray("");                               // returns []
     * toCharArray(null);                             // returns null
     * toCharArray(new StringBuilder("abc"));         // returns ['a','b','c']
     * }</pre>
     *
     * @param source The input CharSequence to be converted. It can be {@code null}.
     * @return A char array representation of the input CharSequence. Returns {@code null} if the input CharSequence is {@code null}.
     */
    @MayReturnNull
    public static char[] toCharArray(final CharSequence source) {
        if (source == null) {
            return null; // NOSONAR
        } else if (source.isEmpty()) {
            return N.EMPTY_CHAR_ARRAY;
        } else if (source instanceof String) {
            return ((String) source).toCharArray();
        }

        final int len = N.len(source);

        final char[] array = new char[len];

        for (int i = 0; i < len; i++) {
            array[i] = source.charAt(i);
        }

        return array;
    }

    /**
     * <p>Converts a {@code CharSequence} into an array of code points.</p>
     *
     * <p>Valid pairs of surrogate code units will be converted into a single supplementary
     * code point. Isolated surrogate code units (i.e., a high surrogate not followed by a low surrogate or
     * a low surrogate not preceded by a high surrogate) will be returned as-is.</p>
     *
     * <p>Example:
     * <pre>
     * Strings.toCodePoints(null)   =  null
     * Strings.toCodePoints("")     =  []  // empty array
     * Strings.toCodePoints("ABC")  =  [65, 66, 67]
     * Strings.toCodePoints("")    =  [128077]  // emoji as single code point
     * </pre>
     *
     * @param str the character sequence to convert
     * @return An array of code points representing the input CharSequence, or {@code null} if the input is {@code null}.
     */
    @MayReturnNull
    public static int[] toCodePoints(final CharSequence str) {
        if (str == null) {
            return null; // NOSONAR
        } else if (str.isEmpty()) {
            return N.EMPTY_INT_ARRAY;
        }

        final String s = str.toString();

        return s.codePoints().toArray();
    }

    /**
     * Converts a character to lowercase.
     *
     * <p>This method converts the specified character to its lowercase equivalent
     * according to the Unicode standard.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toLowerCase('A');                              // returns 'a'
     * toLowerCase('Z');                              // returns 'z'
     * toLowerCase('a');                              // returns 'a'
     * toLowerCase('1');                              // returns '1'
     * toLowerCase('');                              // returns ''
     * }</pre>
     *
     * @param ch The character to convert to lowercase.
     * @return The lowercase equivalent of the character.
     * @see Character#toLowerCase(char)
     */
    public static char toLowerCase(final char ch) {
        return Character.toLowerCase(ch);
    }

    /**
     * <p>
     * Converts a String to lower case as per {@link String#toLowerCase()}.
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>
     * <strong>Note:</strong> As described in the documentation for
     * {@link String#toLowerCase()}, the result of this method is affected by
     * the current locale. For platform-independent case transformations, the
     * method {@link #toLowerCase(String, Locale)} should be used with a specific
     * locale (e.g., {@link Locale#ENGLISH}).
     * </p>
     *
     * <pre>
     * Strings.toLowerCase(null)  = null
     * Strings.toLowerCase("")    = ""
     * Strings.toLowerCase("aBc") = "abc"
     * </pre>
     *
     * @param str
     *            the String to lower case, which may be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String toLowerCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toLowerCase();
    }

    /**
     * <p>
     * Converts a String to lower case as per {@link String#toLowerCase(Locale)}
     * .
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>This method allows locale-specific case transformations, which is important
     * for certain languages where case conversion rules differ from the default.</p>
     *
     * <pre>
     * Strings.toLowerCase(null, Locale.ENGLISH)  = null
     * Strings.toLowerCase("", Locale.ENGLISH)    = ""
     * Strings.toLowerCase("aBc", Locale.ENGLISH) = "abc"
     * </pre>
     *
     * @param str
     *            the String to lower case, which may be null
     * @param locale
     *            the locale that defines the case transformation rules, must
     *            not be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String toLowerCase(final String str, final Locale locale) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toLowerCase(locale);
    }

    /**
     * Converts the given string to lower case with underscores.
     * If the input string is {@code null} or empty, it returns the input string.
     *
     * <p>This method converts uppercase letters to lowercase and inserts underscores
     * before uppercase letters that are preceded by lowercase letters or followed by lowercase letters.
     * This is useful for converting camelCase or PascalCase strings to snake_case.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toLowerCaseWithUnderscore("helloWorld");       // returns "hello_world"
     * toLowerCaseWithUnderscore("HelloWorld");       // returns "hello_world"
     * toLowerCaseWithUnderscore("helloWorldAPI");    // returns "hello_world_api"
     * toLowerCaseWithUnderscore("IOError");          // returns "io_error"
     * toLowerCaseWithUnderscore(null);               // returns null
     * toLowerCaseWithUnderscore("");                 // returns ""
     * }</pre>
     *
     * @param str the input string to be converted
     * @return the converted string in lower case with underscores
     */
    public static String toLowerCaseWithUnderscore(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);
        char ch = 0;

        try {
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (Character.isUpperCase(ch)) {
                    if (i > 0 && (Character.isLowerCase(str.charAt(i - 1)) || (i < len - 1 && Character.isLowerCase(str.charAt(i + 1))))) {
                        if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {//NOSONAR
                            sb.append(WD._UNDERSCORE);
                        }
                    }

                    sb.append(Character.toLowerCase(ch));
                } else {
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Converts a character to uppercase.
     *
     * <p>This method converts the specified character to its uppercase equivalent
     * according to the Unicode standard.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toUpperCase('a');                              // returns 'A'
     * toUpperCase('z');                              // returns 'Z'
     * toUpperCase('A');                              // returns 'A'
     * toUpperCase('1');                              // returns '1'
     * toUpperCase('');                              // returns ''
     * }</pre>
     *
     * @param ch The character to convert to uppercase.
     * @return The uppercase equivalent of the character.
     * @see Character#toUpperCase(char)
     */
    public static char toUpperCase(final char ch) {
        return Character.toUpperCase(ch);
    }

    /**
     * <p>
     * Converts a String to upper case as per {@link String#toUpperCase()}.
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>
     * <strong>Note:</strong> As described in the documentation for
     * {@link String#toUpperCase()}, the result of this method is affected by
     * the current locale. For platform-independent case transformations, the
     * method {@link #toUpperCase(String, Locale)} should be used with a specific
     * locale (e.g., {@link Locale#ENGLISH}).
     * </p>
     *
     * <pre>
     * Strings.toUpperCase(null)  = null
     * Strings.toUpperCase("")    = ""
     * Strings.toUpperCase("aBc") = "ABC"
     * </pre>
     *
     * @param str the String to upper case, which may be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String toUpperCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toUpperCase();
    }

    /**
     * <p>
     * Converts a String to upper case as per {@link String#toUpperCase(Locale)}
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>This method allows locale-specific case transformations, which is important
     * for certain languages where case conversion rules differ from the default.</p>
     *
     * <pre>
     * Strings.toUpperCase(null, Locale.ENGLISH)  = null
     * Strings.toUpperCase("", Locale.ENGLISH)    = ""
     * Strings.toUpperCase("aBc", Locale.ENGLISH) = "ABC"
     * </pre>
     *
     * @param str
     *            the String to upper case, which may be null
     * @param locale
     *            the locale that defines the case transformation rules, must
     *            not be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String toUpperCase(final String str, final Locale locale) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toUpperCase(locale);
    }
    // Case conversion
    // -----------------------------------------------------------------------

    /**
     * Converts the given string to upper case with underscores.
     *
     * <p>This method converts the input string to uppercase and inserts underscores before uppercase letters 
     * that are preceded by lowercase letters or followed by lowercase letters. This is useful for converting 
     * camelCase or PascalCase strings to UPPER_CASE_WITH_UNDERSCORES format.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toUpperCaseWithUnderscore(null);           // returns null
     * toUpperCaseWithUnderscore("");             // returns ""
     * toUpperCaseWithUnderscore("helloWorld");   // returns "HELLO_WORLD"
     * toUpperCaseWithUnderscore("HelloWorld");   // returns "HELLO_WORLD"
     * toUpperCaseWithUnderscore("helloWorldAPI"); // returns "HELLO_WORLD_API"
     * toUpperCaseWithUnderscore("XMLParser");     // returns "XML_PARSER"
     * toUpperCaseWithUnderscore("IOError");       // returns "IO_ERROR"
     * }</pre>
     *
     * @param str the input string to be converted. It can be {@code null} or empty.
     * @return the converted string in upper case with underscores, or the original string if it is {@code null} or empty.
     */
    public static String toUpperCaseWithUnderscore(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);
        char ch = 0;

        try {
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (Character.isUpperCase(ch)) {
                    if (i > 0 && (Character.isLowerCase(str.charAt(i - 1)) || (i < len - 1 && Character.isLowerCase(str.charAt(i + 1))))) {
                        if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {//NOSONAR
                            sb.append(WD._UNDERSCORE);
                        }
                    }

                    sb.append(ch);
                } else {
                    //    if (i > 0 && ((isAsciiNumeric(ch) && !isAsciiNumeric(str.charAt(i - 1))) || (isAsciiNumeric(str.charAt(i - 1)) && !isAsciiNumeric(ch)))) {
                    //        if (sb.length() > 0 && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {
                    //            sb.append(WD._UNDERSCORE);
                    //        }
                    //    }

                    sb.append(Character.toUpperCase(ch));
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Converts the specified string to camel case.
     *
     * <p>This method converts a string with underscores or hyphens to camel case format. 
     * The first word starts with a lowercase letter, and each subsequent word starts with an uppercase letter.
     * All other letters are lowercase. The delimiters (underscores or hyphens) are removed.</p>
     *
     * <p>If the input string contains no delimiters but has uppercase letters, it intelligently converts 
     * from PascalCase or UPPER_CASE to camelCase.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toCamelCase(null);                 // returns null
     * toCamelCase("");                   // returns ""
     * toCamelCase("first_name");         // returns "firstName"
     * toCamelCase("FIRST_NAME");         // returns "firstName"
     * toCamelCase("first-name");         // returns "firstName"
     * toCamelCase("FirstName");          // returns "firstName"
     * toCamelCase("FIRSTNAME");          // returns "firstname"
     * toCamelCase("firstName");          // returns "firstName"
     * }</pre>
     *
     * @param str The input string to be converted. It can be {@code null} or empty.
     * @return A camel case representation of the input string. Returns the original string if it's {@code null} or empty.
     */
    public static String toCamelCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        String[] substrs = null;
        int idx = str.indexOf('_');

        if (idx < 0) {
            idx = str.indexOf('-');
        }

        if (idx >= 0) {
            substrs = RegExUtil.split(str, RegExUtil.CAMEL_CASE_SEPARATOR);
        }

        return toCamelCase(str, idx, substrs);
    }

    /**
     * Converts the specified string to camel case using a custom split character.
     *
     * <p>This method converts a string with a specified delimiter character to camel case format. 
     * The first word starts with a lowercase letter, and each subsequent word starts with an uppercase letter.
     * All other letters are lowercase. The delimiter characters are removed.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toCamelCase(null, '.');            // returns null
     * toCamelCase("", '.');              // returns ""
     * toCamelCase("first.name", '.');    // returns "firstName"
     * toCamelCase("FIRST.NAME", '.');    // returns "firstName"
     * toCamelCase("first#name", '#');    // returns "firstName"
     * toCamelCase("firstName", '.');     // returns "firstName"
     * }</pre>
     *
     * @param str The input string to be converted. It can be {@code null} or empty.
     * @param splitChar The character used to split the input string.
     * @return A camel case representation of the input string. Returns the original string if it's {@code null} or empty.
     */
    public static String toCamelCase(final String str, final char splitChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        String[] substrs = null;
        final int idx = str.indexOf(splitChar);

        if (idx >= 0) {
            substrs = Strings.split(str, splitChar);
        }

        return toCamelCase(str, idx, substrs);
    }

    private static String toCamelCase(final String str, final int firstSplitorIndex, final String[] substrs) {
        if (firstSplitorIndex >= 0) {
            final StringBuilder sb = Objectory.createStringBuilder(str.length());

            try {
                boolean first = true;

                for (final String substr : substrs) {
                    if (isNotEmpty(substr)) {
                        sb.append(substr.toLowerCase());

                        if (!first) {
                            sb.setCharAt(sb.length() - substr.length(), Character.toUpperCase(substr.charAt(0)));
                        } else {
                            first = false;
                        }
                    }
                }

                return sb.toString();
            } finally {
                Objectory.recycle(sb);
            }
        } else {
            for (int i = 0, len = str.length(); i < len; i++) {
                if (Character.isLowerCase(str.charAt(i))) {
                    if (i == 1) {
                        return str.substring(0, 1).toLowerCase() + str.substring(1);
                    } else if (i > 1) {
                        return str.substring(0, i - 1).toLowerCase() + str.substring(i - 1);
                    }

                    break;
                } else if ((i + 1) == str.length()) {
                    return str.toLowerCase();
                }
            }

            return str;
        }
    }

    /**
     * Converts the specified string to Pascal case.
     *
     * <p>This method converts a string with underscores to Pascal case format (also known as UpperCamelCase). 
     * Each word starts with an uppercase letter, and all other letters are lowercase. 
     * The underscores are removed.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toPascalCase(null);                // returns null
     * toPascalCase("");                  // returns ""
     * toPascalCase("first_name");        // returns "FirstName"
     * toPascalCase("FIRST_NAME");        // returns "FirstName"
     * toPascalCase("firstName");         // returns "FirstName"
     * toPascalCase("FirstName");         // returns "FirstName"
     * toPascalCase("first");             // returns "First"
     * }</pre>
     *
     * @param str The input string to be converted. It can be {@code null} or empty.
     * @return A Pascal case representation of the input string. Returns the original string if it's {@code null} or empty.
     */
    public static String toPascalCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        String[] substrs = null;
        int idx = str.indexOf('_');

        if (idx < 0) {
            idx = str.indexOf('-');
        }

        if (idx >= 0) {
            substrs = RegExUtil.split(str, RegExUtil.CAMEL_CASE_SEPARATOR);
        }

        return toPascalCase(str, idx, substrs);
    }

    /**
     * Converts the specified string to Pascal case using a custom split character.
     *
     * <p>This method converts a string with a specified delimiter character to Pascal case format (also known as UpperCamelCase). 
     * Each word starts with an uppercase letter, and all other letters are lowercase. 
     * The delimiter characters are removed.</p>
     *
     * <p>If the string contains no delimiter characters, only the first character is converted to uppercase.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * toPascalCase(null, '.');           // returns null
     * toPascalCase("", '.');             // returns ""
     * toPascalCase("first.name", '.');   // returns "FirstName"
     * toPascalCase("FIRST.NAME", '.');   // returns "FirstName"
     * toPascalCase("first-name", '-');   // returns "FirstName"
     * toPascalCase("firstName", '.');    // returns "FirstName"
     * toPascalCase("firstname", '.');    // returns "Firstname"
     * }</pre>
     *
     * @param str The input string to be converted. It can be {@code null} or empty.
     * @param splitChar The character used to split the input string.
     * @return A Pascal case representation of the input string. Returns the original string if it's {@code null} or empty.
     */
    public static String toPascalCase(final String str, final char splitChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        String[] substrs = null;
        final int idx = str.indexOf(splitChar);

        if (idx >= 0) {
            substrs = Strings.split(str, splitChar);
        }

        return toPascalCase(str, idx, substrs);
    }

    private static String toPascalCase(final String str, final int firstSplitorIndex, final String[] substrs) {
        if (firstSplitorIndex >= 0) {
            final StringBuilder sb = Objectory.createStringBuilder(str.length());

            try {
                for (final String substr : substrs) {
                    if (isNotEmpty(substr)) {
                        sb.append(substr.toLowerCase());

                        sb.setCharAt(sb.length() - substr.length(), Character.toUpperCase(substr.charAt(0)));
                    }
                }

                return sb.toString();
            } finally {
                Objectory.recycle(sb);
            }
        } else {
            return Character.isLowerCase(str.charAt(0)) ? str.substring(0, 1).toUpperCase() + str.substring(1) : str;
        }
    }

    /**
     * Swaps the case of a character changing upper and title case to lower case, and lower case to upper case.
     *
     * <p>This method converts uppercase and title case characters to lowercase, and lowercase characters to uppercase.
     * Characters that are neither uppercase, title case, nor lowercase remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * swapCase('A');    // returns 'a'
     * swapCase('a');    // returns 'A'
     * swapCase('1');    // returns '1'
     * swapCase(' ');    // returns ' '
     * }</pre>
     *
     * @param ch The input character to be case-swapped.
     * @return The case-swapped representation of the input character.
     */
    public static char swapCase(final char ch) {
        return Character.isUpperCase(ch) || Character.isTitleCase(ch) ? Character.toLowerCase(ch)
                : (Character.isLowerCase(ch) ? Character.toUpperCase(ch) : ch);
    }

    /**
     * Swaps the case of a String changing upper and title case to lower case, and lower case to upper case.
     *
     * <p>This method processes each character in the string, converting uppercase and title case characters to lowercase, 
     * and lowercase characters to uppercase. Characters that are neither uppercase, title case, nor lowercase remain unchanged.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}.</p>
     *
     * <p>Note: This method performs character-by-character case swapping, not word-based swapping. 
     * For word-based algorithms, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * swapCase(null);                    // returns null
     * swapCase("");                      // returns ""
     * swapCase("The dog has a BONE");    // returns "tHE DOG HAS A bone"
     * swapCase("Hello World");           // returns "hELLO wORLD"
     * swapCase("ABC123xyz");             // returns "abc123XYZ"
     * }</pre>
     *
     * @param str the String to swap case, which may be null
     * @return the case-swapped String, {@code null} if the input is {@code null}
     */
    public static String swapCase(final String str) {
        if (isEmpty(str)) {
            return str;
        }

        final int strLen = str.length();
        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        int oldCodepoint, newCodePoint;

        for (int i = 0; i < strLen; i += Character.charCount(newCodePoint)) {
            oldCodepoint = str.codePointAt(i);

            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {
                newCodePoint = Character.toLowerCase(oldCodepoint);
            } else if (Character.isLowerCase(oldCodepoint)) {
                newCodePoint = Character.toUpperCase(oldCodepoint);
            } else {
                newCodePoint = oldCodepoint;
            }

            newCodePoints[outOffset++] = newCodePoint;
        }

        return new String(newCodePoints, 0, outOffset);
    }

    // Copied from Apache commons Lang under Apache License v2.

    /**
     * Converts the first character of the given string to lower case.
     *
     * <p>This method converts only the first character to lowercase while leaving the rest of the string unchanged.
     * It properly handles Unicode characters including supplementary characters.</p>
     *
     * <p>The method returns the original string if it is {@code null}, empty, or already starts with a lowercase character.</p>
     *
     * <p>Example:
     * <pre>{@code
     * uncapitalize(null);        // returns null
     * uncapitalize("");          // returns ""
     * uncapitalize("Cat");       // returns "cat"
     * uncapitalize("CAT");       // returns "cAT"
     * uncapitalize("cat");       // returns "cat"
     * uncapitalize("C");         // returns "c"
     * }</pre>
     *
     * @param str The string to be uncapitalized. It can be {@code null} or empty.
     * @return A string with its first character converted to lower case, or the original string if it's {@code null}, empty, or already starts with a lowercase character.
     */
    public static String uncapitalize(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int firstCodePoint = str.codePointAt(0);
        final int newCodePoint = Character.toLowerCase(firstCodePoint);

        if (firstCodePoint == newCodePoint) {
            // already uncapitalize
            return str;
        }

        final int strLen = str.length();

        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        newCodePoints[outOffset++] = newCodePoint; // copy the first code point

        for (int inOffset = Character.charCount(firstCodePoint); inOffset < strLen;) {
            final int codePoint = str.codePointAt(inOffset);
            newCodePoints[outOffset++] = codePoint; // copy the remaining ones
            inOffset += Character.charCount(codePoint);
        }

        return new String(newCodePoints, 0, outOffset);
    }

    // Copied from Apache commons Lang under Apache License v2.

    /**
     * Converts the first character of the given string to upper case.
     *
     * <p>This method converts only the first character to uppercase (title case) while leaving the rest of the string unchanged.
     * It properly handles Unicode characters including supplementary characters.</p>
     *
     * <p>The method returns the original string if it is {@code null}, empty, or already starts with an uppercase character.</p>
     *
     * <p>Example:
     * <pre>{@code
     * capitalize(null);          // returns null
     * capitalize("");            // returns ""
     * capitalize("cat");         // returns "Cat"
     * capitalize("cAT");         // returns "CAT"
     * capitalize("Cat");         // returns "Cat"
     * capitalize("c");           // returns "C"
     * capitalize("'cat'");       // returns "'cat'"
     * }</pre>
     *
     * @param str The string to be capitalized. It can be {@code null} or empty.
     * @return A string with its first character converted to upper case, or the original string if it's {@code null}, empty, or already starts with an uppercase character.
     */
    public static String capitalize(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int firstCodepoint = str.codePointAt(0);
        final int newCodePoint = Character.toTitleCase(firstCodepoint);

        if (firstCodepoint == newCodePoint) {
            // already capitalized
            return str;
        }

        final int strLen = str.length();
        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        newCodePoints[outOffset++] = newCodePoint; // copy the first code point

        for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen;) {
            final int codePoint = str.codePointAt(inOffset);
            newCodePoints[outOffset++] = codePoint; // copy the remaining ones
            inOffset += Character.charCount(codePoint);
        }

        return new String(newCodePoints, 0, outOffset);
    }

    /**
     * Capitalizes all the words in the specified string split by space (' ').
     *
     * <p>This method splits the input string by spaces and capitalizes the first letter of each word.
     * The rest of each word is left unchanged. Empty tokens between consecutive spaces are preserved.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * capitalizeFully(null);                     // returns null
     * capitalizeFully("");                       // returns ""
     * capitalizeFully("hello world");            // returns "Hello World"
     * capitalizeFully("HELLO WORLD");            // returns "HELLO WORLD"
     * capitalizeFully("hello  world");           // returns "Hello  World"
     * capitalizeFully("hELLO wORLD");            // returns "HELLO WORLD"
     * }</pre>
     *
     * @param str The string to be processed. It can be {@code null} or empty.
     * @return The processed string with all words capitalized, or the original string if it's {@code null} or empty.
     */
    public static String capitalizeFully(final String str) {
        return capitalizeFully(str, " ");
    }

    /**
     * Capitalizes all the words in the specified string split by the provided delimiter.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word.
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * capitalizeFully(null, "-");                // returns null
     * capitalizeFully("", "-");                  // returns ""
     * capitalizeFully("hello-world", "-");       // returns "Hello-World"
     * capitalizeFully("HELLO_WORLD", "_");       // returns "HELLO_WORLD"
     * capitalizeFully("hello.world.java", ".");  // returns "Hello.World.Java"
     * }</pre>
     *
     * @param str The string to be processed. It can be {@code null} or empty.
     * @param delimiter The delimiter used to split the string into words. It must not be empty.
     * @return The processed string with all words capitalized, or the original string if it's {@code null} or empty.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String capitalizeFully(final String str, final String delimiter) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter); // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);

        for (int i = 0; i < words.length; i++) {
            words[i] = capitalize(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Capitalizes all the words in the given string, split by the provided delimiter, excluding the specified words except the first word.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word,
     * except for words that appear in the excludedWords array (unless they are the first word).
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The first word is always capitalized regardless of whether it appears in the excluded words list.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * capitalizeFully("the quick brown fox", " ", "the", "of");     // returns "The Quick Brown Fox"
     * capitalizeFully("the end of story", " ", "the", "of");        // returns "The End of Story"
     * capitalizeFully("of mice and men", " ", "of", "and");         // returns "Of Mice and Men"
     * }</pre>
     *
     * @param str The string to be processed. If it's {@code null} or empty, the method will return the input string.
     * @param delimiter The delimiter used to split the string into words. It must not be empty.
     * @param excludedWords An array of words to be excluded from capitalization. If it's {@code null} or empty, all words will be capitalized.
     * @return The processed string with all non-excluded words capitalized.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     */
    public static String capitalizeFully(final String str, final String delimiter, final String... excludedWords) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter); // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return capitalizeFully(str, delimiter);
        }

        return capitalizeFully(str, delimiter, N.toSet(excludedWords));
    }

    /**
     * Capitalizes all the words in the given string, split by the provided delimiter, excluding the words in the excludedWords collection except the first word.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word,
     * except for words that appear in the excludedWords collection (unless they are the first word).
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The first word is always capitalized regardless of whether it appears in the excluded words collection.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Set<String> excluded = Set.of("the", "of", "and");
     * capitalizeFully("the lord of the rings", " ", excluded);      // returns "The Lord of the Rings"
     * capitalizeFully("and then there were none", " ", excluded);   // returns "And Then There Were None"
     * }</pre>
     *
     * @param str The string to be processed. If it's {@code null} or empty, the method will return the input string.
     * @param delimiter The delimiter used to split the string into words. It must not be empty.
     * @param excludedWords A collection of words to be excluded from capitalization. If it's {@code null} or empty, all words will be capitalized.
     * @return The processed string with all non-excluded words capitalized.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String capitalizeFully(final String str, final String delimiter, final Collection<String> excludedWords) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter); // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return capitalizeFully(str, delimiter);
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);
        final Collection<String> excludedWordSet = excludedWords instanceof Set || (excludedWords.size() <= 3 && words.length <= 3) ? excludedWords
                : N.newHashSet(excludedWords);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = i != 0 && excludedWordSet.contains(words[i]) ? words[i] : capitalize(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Converts all the words in the given string using the provided converter function.
     *
     * <p>This method splits the input string by spaces and applies the converter function to each word.
     * Empty tokens between consecutive spaces are preserved. The words are then joined back together with spaces.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * convertWords("hello world", String::toUpperCase);          // returns "HELLO WORLD"
     * convertWords("hello world", s -> s + "!");                 // returns "hello! world!"
     * convertWords("hello  world", String::toUpperCase);         // returns "HELLO  WORLD"
     * }</pre>
     *
     * @param str The string to be processed. If it's {@code null} or empty, the method will return the input string.
     * @param converter The function used to convert each word. This function should accept a string and return a string.
     * @return The processed string with all words converted using the provided converter function.
     */
    public static String convertWords(final String str, final Function<? super String, String> converter) {
        return convertWords(str, " ", converter);
    }

    /**
     * Converts all the words from the specified string, split by the provided delimiter, using the provided converter function.
     *
     * <p>This method splits the input string by the specified delimiter and applies the converter function to each word.
     * Empty tokens between consecutive delimiters are preserved. The words are then joined back together with the delimiter.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * convertWords("hello-world", "-", String::toUpperCase);     // returns "HELLO-WORLD"
     * convertWords("hello.world.java", ".", s -> "[" + s + "]"); // returns "[hello].[world].[java]"
     * convertWords("hello--world", "-", String::toUpperCase);    // returns "HELLO--WORLD"
     * }</pre>
     *
     * @param str The string to be processed. If it's {@code null} or empty, the method will return the input string.
     * @param delimiter The delimiter used to split the string into words. It must not be empty.
     * @param converter The function used to convert each word.
     * @return The processed string with all words converted using the provided converter function.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     */
    public static String convertWords(final String str, final String delimiter, final Function<? super String, String> converter)
            throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter); // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = converter.apply(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Converts all the words from the specified string, split by the provided delimiter, using the provided converter function.
     * Words that are present in the excludedWords collection are not converted.
     *
     * <p>This method splits the input string by the specified delimiter and applies the converter function to each word,
     * except for words that appear in the excludedWords collection. Empty tokens between consecutive delimiters are preserved.
     * The words are then joined back together with the delimiter.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Set<String> excluded = Set.of("and", "or");
     * convertWords("jack and jill", " ", excluded, String::toUpperCase);  // returns "JACK and JILL"
     * convertWords("true or false", " ", excluded, s -> "*" + s + "*");   // returns "*true* or *false*"
     * }</pre>
     *
     * @param str The string to be processed. If it's {@code null} or empty, the method will return the input string.
     * @param delimiter The delimiter used to split the string into words. It must not be empty.
     * @param excludedWords A collection of words to be excluded from conversion. If it's {@code null} or empty, all words will be converted.
     * @param converter The function used to convert each word. If a word is in the excludedWords collection, it will not be converted.
     * @return The processed string with all non-excluded words converted using the provided converter function.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     */
    public static String convertWords(final String str, final String delimiter, final Collection<String> excludedWords,
            final Function<? super String, String> converter) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter); // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return convertWords(str, delimiter, converter);
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);
        final Collection<String> excludedWordSet = excludedWords instanceof Set || (excludedWords.size() <= 3 && words.length <= 3) ? excludedWords
                : N.newHashSet(excludedWords);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = excludedWordSet.contains(words[i]) ? words[i] : converter.apply(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Replaces single quotes (') and double quotes (") with escaped versions (\' and \") if they are not already escaped.
     *
     * <p>This method scans through the string and adds a backslash before any unescaped single or double quote character.
     * If a quote is already preceded by a backslash, it will not be escaped again.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * quoteEscaped(null);                    // returns null
     * quoteEscaped("");                      // returns ""
     * quoteEscaped("Hello World");           // returns "Hello World"
     * quoteEscaped("She said \"Hi\"");       // returns "She said \"Hi\""
     * quoteEscaped("It's a test");           // returns "It\'s a test"
     * quoteEscaped("Already \\'escaped\\'"); // returns "Already \\'escaped\\'"
     * }</pre>
     *
     * @param str The string to be processed. It can be {@code null} or empty.
     * @return The string with all unescaped single and double quotes escaped, or the original string if it's {@code null} or empty.
     */
    public static String quoteEscaped(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);

        try {
            char ch = 0;
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if ((ch == _BACKSLASH) && (i < (len - 1))) {
                    sb.append(ch);
                    sb.append(str.charAt(++i));
                } else {
                    if ((ch == _QUOTATION_S) || (ch == _QUOTATION_D)) {
                        sb.append(_BACKSLASH);
                    }
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Escapes the specified quotation character in the given string if it is not already escaped.
     *
     * <p>This method scans through the string and adds a backslash before any unescaped occurrence of the specified quote character.
     * If the quote character is already preceded by a backslash, it will not be escaped again.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * quoteEscaped(null, '"');               // returns null
     * quoteEscaped("", '"');                 // returns ""
     * quoteEscaped("She said \"Hi\"", '"'); // returns "She said \"Hi\""
     * quoteEscaped("It's a test", '\'');     // returns "It\'s a test"
     * quoteEscaped("No quotes here", '"');   // returns "No quotes here"
     * quoteEscaped("Already \\\"escaped\\\"", '"'); // returns "Already \\\"escaped\\\""
     * }</pre>
     *
     * @param str the input string to be processed, may be {@code null} or empty
     * @param quoteChar the quotation character to be escaped, should be either {@code "} or {@code '}
     * @return the processed string with the specified quotation character escaped, or the original string if it is {@code null} or empty
     */
    public static String quoteEscaped(final String str, final char quoteChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);

        try {
            char ch = 0;
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if ((ch == _BACKSLASH) && (i < (len - 1))) {
                    sb.append(ch);
                    sb.append(str.charAt(++i));
                } else {
                    if (ch == quoteChar) {
                        sb.append(_BACKSLASH);
                    }
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    // --------------------------------------------------------------------------

    /**
     * Converts the char to the unicode format '\u0020'.
     *
     * <p>This method converts a character to its Unicode escape sequence representation.
     * The format is the Java source code format: a backslash followed by 'u' and exactly four hexadecimal digits.</p>
     *
     * <p>Example:
     * <pre>{@code
     * unicodeEscaped(' ');     // returns "\u0020"
     * unicodeEscaped('A');     // returns "\u0041"
     * unicodeEscaped('');     // returns "\u20ac"
     * unicodeEscaped('\n');    // returns "\u000a"
     * }</pre>
     *
     * @param ch the character to convert
     * @return the Unicode escape sequence representation of the character
     */
    public static String unicodeEscaped(final char ch) {
        if (ch < 0x10) {
            return "\\u000" + Integer.toHexString(ch);
        } else if (ch < 0x100) {
            return "\\u00" + Integer.toHexString(ch);
        } else if (ch < 0x1000) {
            return "\\u0" + Integer.toHexString(ch);
        }

        return "\\u" + Integer.toHexString(ch);
    }

    /**
     * Normalizes whitespace in a string by trimming leading and trailing whitespace and replacing sequences of whitespace characters with a single space.
     *
     * <p>This method is similar to the XPath normalize-space function. It first trims the string using {@link #trim(String)} 
     * to remove leading and trailing whitespace, then replaces any sequence of whitespace characters (including space, tab, 
     * newline, carriage return, form feed, and vertical tab) with a single space character.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}, and an empty string if the input is empty or contains only whitespace.</p>
     *
     * <p>Example:
     * <pre>{@code
     * normalizeSpace(null);                     // returns null
     * normalizeSpace("");                       // returns ""
     * normalizeSpace("  ");                     // returns ""
     * normalizeSpace("abc");                    // returns "abc"
     * normalizeSpace("  abc  ");                // returns "abc"
     * normalizeSpace("  abc    def  ");         // returns "abc def"
     * normalizeSpace("abc\n\tdef");             // returns "abc def"
     * normalizeSpace("  multiple   spaces  ");  // returns "multiple spaces"
     * }</pre>
     *
     * @param str the source String to normalize whitespaces from, which may be null
     * @return the normalized String, {@code null} if the input is {@code null}
     * @see Pattern
     * @see #trim(String)
     * @see <a href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize-space</a>
     */
    public static String normalizeSpace(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return WHITESPACE_PATTERN.matcher(str.trim()).replaceAll(WD.SPACE);
    }

    /**
     * Replaces all occurrences of a String within another String.
     *
     * <p>This method searches for all occurrences of the target string and replaces them with the replacement string.
     * A {@code null} reference passed to this method is a no-op.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceAll(null, *, *);           // returns null
     * replaceAll("", *, *);             // returns ""
     * replaceAll("any", null, *);       // returns "any"
     * replaceAll("any", *, null);       // returns "any"
     * replaceAll("any", "", *);         // returns "any"
     * replaceAll("aba", "a", null);     // returns "b"
     * replaceAll("aba", "a", "");       // returns "b"
     * replaceAll("aba", "a", "z");      // returns "zbz"
     * replaceAll("abaaaba", "aa", "z"); // returns "abzaba"
     * }</pre>
     *
     * @param str text to search and replace in, which may be null
     * @param target the String to search for, which may be null
     * @param replacement the String to replace it with, which may be null
     * @return the text with all occurrences of the target string replaced, {@code null} if the input is {@code null}
     */
    public static String replaceAll(final String str, final String target, final String replacement) {
        return replaceAll(str, 0, target, replacement);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the target string starting from the given index and replaces them with the replacement string.
     * Occurrences before the specified index are not replaced.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceAll("abacadae", 0, "a", "z");    // returns "zbzczde"
     * replaceAll("abacadae", 3, "a", "z");    // returns "abzczde"
     * replaceAll("abacadae", 5, "a", "z");    // returns "abacadze"
     * replaceAll("hello world", 0, "o", "0"); // returns "hell0 w0rld"
     * replaceAll("hello world", 6, "o", "0"); // returns "hello w0rld"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with all occurrences of the target string replaced with the replacement string, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceAll(final String str, final int fromIndex, final String target, final String replacement) {
        return replace(str, fromIndex, target, replacement, -1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method searches for the first occurrence of the target string and replaces it with the replacement string.
     * Subsequent occurrences are not replaced.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceFirst(null, *, *);            // returns null
     * replaceFirst("", *, *);              // returns ""
     * replaceFirst("any", null, *);        // returns "any"
     * replaceFirst("any", *, null);        // returns "ny"
     * replaceFirst("any", "", *);          // returns "any"
     * replaceFirst("aba", "a", null);      // returns "ba"
     * replaceFirst("aba", "a", "");        // returns "ba"
     * replaceFirst("aba", "a", "z");       // returns "zba"
     * replaceFirst("abaaaba", "aa", "z");  // returns "abzaba"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return the text with the first occurrence of the target string replaced, {@code null} if the input is {@code null}
     */
    public static String replaceFirst(final String str, final String target, final String replacement) {
        return replaceFirst(str, 0, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method searches for the first occurrence of the target string starting from the given index and replaces it with the replacement string.
     * Occurrences before the specified index are not replaced.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceFirst("abacadae", 0, "a", "z");    // returns "zbacadae"
     * replaceFirst("abacadae", 3, "a", "z");    // returns "abzcadae"
     * replaceFirst("abacadae", 5, "a", "z");    // returns "abacadze"
     * replaceFirst("hello world", 0, "o", "0"); // returns "hell0 world"
     * replaceFirst("hello world", 6, "o", "0"); // returns "hello w0rld"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the first occurrence of the target string replaced with the replacement string, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceFirst(final String str, final int fromIndex, final String target, final String replacement) {
        return replace(str, fromIndex, target, replacement, 1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method is equivalent to {@link #replaceFirst(String, String, String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceOnce(null, *, *);            // returns null
     * replaceOnce("", *, *);              // returns ""
     * replaceOnce("any", null, *);        // returns "any"
     * replaceOnce("any", *, null);        // returns "any"
     * replaceOnce("any", "", *);          // returns "any"
     * replaceOnce("aba", "a", null);      // returns "ba"
     * replaceOnce("aba", "a", "");        // returns "ba"
     * replaceOnce("aba", "a", "z");       // returns "zba"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null}.
     * @param target The string to be replaced. It can be {@code null}.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the first occurrence of the target string replaced with the replacement string.
     *         If the input string or target string is {@code null}, the method returns the original string.
     * @deprecated Use {@link #replaceFirst(String, String, String)} instead
     */
    @Deprecated
    public static String replaceOnce(final String str, final String target, final String replacement) {
        return replaceFirst(str, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method is equivalent to {@link #replaceFirst(String, int, String, String)}.</p>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the first occurrence of the target string replaced with the replacement string, starting from the specified index.
     * @deprecated Use {@link #replaceFirst(String, int, String, String)} instead
     */
    @Deprecated
    public static String replaceOnce(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceFirst(str, fromIndex, target, replacement);
    }

    /**
     * Replaces the last occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method searches for the last occurrence of the target string and replaces it with the replacement string.
     * All other occurrences remain unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceLast(null, *, *);            // returns null
     * replaceLast("", *, *);              // returns ""
     * replaceLast("any", null, *);        // returns "any"
     * replaceLast("any", a, null);        // returns "ny"
     * replaceLast("any", "", *);          // returns "any"
     * replaceLast("aba", "a", null);      // returns "ab"
     * replaceLast("aba", "a", "");        // returns "ab"
     * replaceLast("aba", "a", "z");       // returns "abz"
     * replaceLast("abaaaba", "aa", "z");  // returns "abaazba"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement the String to replace with, which may be null
     * @return A new string with the last occurrence of the target string replaced with the replacement string.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceLast(final String str, final String target, final String replacement) {
        return replaceLast(str, N.len(str), target, replacement);
    }

    /**
     * Replaces the last occurrence of a target string in the input string with a replacement string, searching backward from a specified index.
     *
     * <p>This method searches backward from the specified index for the last occurrence of the target string and replaces it with the replacement string.
     * The search starts from the given index and proceeds toward the beginning of the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceLast("abacadae", 8, "a", "z");    // returns "abacadze"
     * replaceLast("abacadae", 5, "a", "z");    // returns "abzcadae"
     * replaceLast("abacadae", 2, "a", "z");    // returns "zbacadae"
     * replaceLast("hello world", 11, "o", "0"); // returns "hello w0rld"
     * replaceLast("hello world", 5, "o", "0");  // returns "hell0 world"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param startIndexFromBack The index to start the search from, searching backward.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the last occurrence of the target string replaced with the replacement string, starting from the specified index backward.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceLast(final String str, final int startIndexFromBack, final String target, final String replacement) {
        if (isEmpty(str) || isEmpty(target) || startIndexFromBack < 0) {
            return str;
        }

        final int lastIndex = lastIndexOf(str, target, startIndexFromBack);

        if (lastIndex < 0) {
            return str;
        }

        return Strings.replaceRange(str, lastIndex, lastIndex + N.len(target), replacement);
    }

    /**
     * Replaces occurrences of a target string in the input string with a replacement string, starting from a specified index and up to a maximum number of replacements.
     *
     * <p>This method provides fine-grained control over string replacement operations. You can specify where to start searching,
     * what to replace, what to replace it with, and how many replacements to make.</p>
     *
     * <p>A {@code null} reference passed to this method is a no-op.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replace(null, *, *, *, *);              // returns null
     * replace("", *, *, *, *);                // returns ""
     * replace("any", *, null, *, *);          // returns "any"
     * replace("any", *, "", *, *);            // returns "any"
     * replace("any", *, *, *, 0);             // returns "any"
     * replace("abaa", 0, "a", null, -1);      // returns "b"
     * replace("abaa", 0, "a", "", -1);        // returns "b"
     * replace("abaa", 0, "a", "z", 0);        // returns "abaa"
     * replace("abaa", 0, "a", "z", 1);        // returns "zbaa"
     * replace("abaa", 0, "a", "z", 2);        // returns "zbza"
     * replace("abaa", 0, "a", "z", -1);       // returns "zbzz"
     * replace("abaa", 1, "a", "z", -1);       // returns "abzz"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null}.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null}.
     * @param replacement The string to replace the target string. It cannot be {@code null}.
     * @param max The maximum number of replacements. If it's -1, all occurrences will be replaced.
     * @return A new string with occurrences of the target string replaced with the replacement string, starting from the specified index and up to the maximum number of replacements.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replace(final String str, final int fromIndex, final String target, final String replacement, final int max) {
        return replace(str, fromIndex, target, replacement, max, false);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for all occurrences of the target string and replaces them with the replacement string.
     * The case of the original text is preserved except for the replaced portions.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceAllIgnoreCase(null, *, *);              // returns null
     * replaceAllIgnoreCase("", *, *);                // returns ""
     * replaceAllIgnoreCase("any", null, *);          // returns "any"
     * replaceAllIgnoreCase("any", *, null);          // returns "any"
     * replaceAllIgnoreCase("any", "", *);            // returns "any"
     * replaceAllIgnoreCase("aba", "A", null);        // returns "b"
     * replaceAllIgnoreCase("aba", "A", "");          // returns "b"
     * replaceAllIgnoreCase("aba", "A", "z");         // returns "zbz"
     * replaceAllIgnoreCase("ABa", "a", "z");         // returns "zBz"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with all occurrences of the target string replaced with the replacement string, ignoring case considerations.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceAllIgnoreCase(final String str, final String target, final String replacement) {
        return replaceAllIgnoreCase(str, 0, target, replacement);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index.
     *
     * <p>This method performs a case-insensitive search for all occurrences of the target string starting from the given index 
     * and replaces them with the replacement string. The case of the original text is preserved except for the replaced portions.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceAllIgnoreCase("aBaCaDaE", 0, "A", "z");    // returns "zBzCzDzE"
     * replaceAllIgnoreCase("aBaCaDaE", 3, "A", "z");    // returns "aBzCzDzE"
     * replaceAllIgnoreCase("aBaCaDaE", 5, "A", "z");    // returns "aBaCzDzE"
     * replaceAllIgnoreCase("HELLO world", 0, "o", "0"); // returns "HELL0 w0rld"
     * replaceAllIgnoreCase("HELLO world", 6, "o", "0"); // returns "HELLO w0rld"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with all occurrences of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceAllIgnoreCase(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceIgnoreCase(str, fromIndex, target, replacement, -1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, ignoring case considerations.
     *
     * <p>This method searches for the first occurrence of the target string in the input string without considering case differences,
     * and replaces it with the specified replacement string. The search starts from the beginning of the input string.</p>
     *
     * <p>The method returns the original string if the target is not found or if the input/target is null or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceFirstIgnoreCase("Hello World", "hello", "Hi");     // returns "Hi World"
     * replaceFirstIgnoreCase("JAVA java Java", "java", "C++");  // returns "C++ java Java"
     * replaceFirstIgnoreCase("Programming", "GRAM", "");        // returns "Proming"
     * replaceFirstIgnoreCase("Test", "xyz", "abc");             // returns "Test"
     * replaceFirstIgnoreCase(null, "test", "new");              // returns null
     * replaceFirstIgnoreCase("Test", null, "new");              // returns "Test"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the first occurrence of the target string replaced with the replacement string, ignoring case considerations.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceFirstIgnoreCase(final String str, final String target, final String replacement) {
        return replaceFirstIgnoreCase(str, 0, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index.
     *
     * <p>This method searches for the first occurrence of the target string in the input string starting from the specified index,
     * without considering case differences, and replaces it with the specified replacement string.</p>
     *
     * <p>The method returns the original string if the target is not found after the specified index or if the input/target is null or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceFirstIgnoreCase("Hello HELLO hello", 0, "hello", "Hi");    // returns "Hi HELLO hello"
     * replaceFirstIgnoreCase("Hello HELLO hello", 6, "hello", "Hi");    // returns "Hello Hi hello"
     * replaceFirstIgnoreCase("Hello HELLO hello", 12, "hello", "Hi");   // returns "Hello HELLO Hi"
     * replaceFirstIgnoreCase("Test String", 5, "test", "Best");         // returns "Test String"
     * replaceFirstIgnoreCase("Test", 10, "test", "Best");               // returns "Test"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @return A new string with the first occurrence of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceFirstIgnoreCase(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceIgnoreCase(str, fromIndex, target, replacement, 1);
    }

    /**
     * Replaces occurrences of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index and up to a maximum number of replacements.
     *
     * <p>This method searches for occurrences of the target string in the input string starting from the specified index,
     * without considering case differences, and replaces them with the specified replacement string up to the maximum number specified.</p>
     *
     * <p>If max is -1, all occurrences will be replaced. If max is 0, no replacements will be made.
     * If the replacement is null, it will be treated as an empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceIgnoreCase("Java JAVA java", 0, "java", "C++", -1);    // returns "C++ C++ C++"
     * replaceIgnoreCase("Java JAVA java", 0, "java", "C++", 2);     // returns "C++ C++ java"
     * replaceIgnoreCase("Java JAVA java", 5, "java", "C++", -1);    // returns "Java C++ C++"
     * replaceIgnoreCase("Test String", 0, "xyz", "abc", -1);        // returns "Test String"
     * replaceIgnoreCase("Test", 0, "test", null, 1);                // returns ""
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the search for the target string. It should be a non-negative integer.
     * @param target The string to be replaced. It can be {@code null} or empty.
     * @param replacement The string to replace the target string. It can be {@code null}.
     * @param max The maximum number of replacements. If it's -1, all occurrences will be replaced.
     * @return A new string with occurrences of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index and up to the maximum number of replacements.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceIgnoreCase(final String str, final int fromIndex, final String target, final String replacement, final int max) {
        return replace(str, fromIndex, target, replacement, max, true);
    }

    private static String replace(final String str, final int fromIndex, final String target, String replacement, int max, final boolean ignoreCase) {
        N.checkPositionIndex(fromIndex, N.len(str));

        // TODO
        //    if (replacement == null) {
        //        throw new IllegalArgumentException("Replacement can't be null");
        //    }

        if (isEmpty(str) || isEmpty(target) || max == 0) {
            return str;
        }

        if (replacement == null) {
            replacement = "";
        }

        final String searchText = ignoreCase ? str.toLowerCase() : str;
        final String searchTarget = ignoreCase ? target.toLowerCase() : target;

        int end = searchText.indexOf(searchTarget, fromIndex);

        if (end == N.INDEX_NOT_FOUND) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + (N.len(replacement) - N.len(target)) * (N.min(16, max)));
        final int substrLength = target.length();
        sb.append(str, 0, fromIndex);
        int start = fromIndex;

        try {
            while (end != N.INDEX_NOT_FOUND) {
                sb.append(str, start, end).append(replacement);
                start = end + substrLength;

                if (--max == 0) {
                    break;
                }

                end = searchText.indexOf(searchTarget, start);
            }

            sb.append(str, start, str.length());

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Replaces the substring specified by the start and end indices with the specified replacement string.
     *
     * <p>This method replaces the characters in the input string from the start index (inclusive) to the end index (exclusive)
     * with the specified replacement string. The original string is not modified.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceRange("Hello World", 6, 11, "Java");     // returns "Hello Java"
     * replaceRange("Programming", 0, 7, "Test");      // returns "Testming"
     * replaceRange("ABCDEF", 2, 4, "XYZ");            // returns "ABXYZEF"
     * replaceRange("Test", 1, 3, "");                 // returns "Tt"
     * }</pre>
     *
     * @param str The input string where the replacement should occur. It cannot be {@code null}.
     * @param fromIndex The start index of the substring to be replaced. It should be a non-negative integer and less than the length of the input string.
     * @param toIndex The end index of the substring to be replaced. It should be a non-negative integer, greater than the start index and less than or equal to the length of the input string.
     * @param replacement The string to replace the substring. It cannot be {@code null}.
     * @return A new string with the specified substring replaced with the replacement string.
     * @throws IndexOutOfBoundsException If the start or end index is out of the string bounds.
     * @deprecated Use {@link #replaceRange(String, int, int, String)} instead of this method.
     * @see #replaceRange(String, int, int, String)
     */
    @Deprecated
    public static String replace(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        return replaceRange(str, fromIndex, toIndex, replacement);
    }

    /**
     * Replaces the substring between two specified delimiters in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the start delimiter and then finds the first occurrence of the end delimiter
     * after the start delimiter. The substring between these delimiters (excluding the delimiters themselves) is replaced
     * with the replacement string.</p>
     *
     * <p>The delimiters themselves are not included in the replaced substring and remain in the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceBetween("Hello [World]!", "[", "]", "Java");       // returns "Hello [Java]!"
     * replaceBetween("Start<old>End", "<", ">", "new");         // returns "Start<new>End"
     * replaceBetween("A{B{C}D}E", "{", "}", "X");               // returns "A{X}D}E"
     * replaceBetween("No delimiters", "[", "]", "test");        // returns "No delimiters"
     * replaceBetween("Only[Start", "[", "]", "test");           // returns "Only[Start"
     * replaceBetween(null, "[", "]", "test");                   // returns null
     * }</pre>
     *
     * @param str The string to be processed.
     * @param delimiterOfExclusiveBeginIndex The delimiter after which the replacement should start.
     * @param delimiterOfExclusiveEndIndex The delimiter before which the replacement should end.
     * @param replacement The string to replace the substring between the delimiters. If it's {@code null}, the substring between the delimiters will be removed.
     * @return The processed string with the substring between the delimiters replaced with the replacement string.
     *         If the input string is {@code null} or either of the delimiters is {@code null}, the original string is returned.
     * @see #substringBetween(String, String, String)
     */
    public static String replaceBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final String replacement) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null) {
            return str;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return str;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return str;
        }

        return replace(str, startIndex, endIndex, replacement);
    }

    /**
     * Replaces the substring after a specified delimiter in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the delimiter and replaces everything after it
     * (excluding the delimiter itself) with the replacement string. The delimiter remains in the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceAfter("Hello, World!", ",", " Java!");      // returns "Hello, Java!"
     * replaceAfter("prefix:suffix", ":", "new");         // returns "prefix:new"
     * replaceAfter("NoDelimiter", ":", "test");          // returns "NoDelimiter"
     * replaceAfter("EndsWith:", ":", "");                // returns "EndsWith:"
     * replaceAfter("Multiple:colons:here", ":", "X");    // returns "Multiple:X"
     * replaceAfter(null, ":", "test");                   // returns null
     * }</pre>
     *
     * @param str The string to be processed.
     * @param delimiterOfExclusiveBeginIndex The delimiter after which the replacement should start.
     * @param replacement The string to replace the substring after the delimiter. If it's {@code null}, the substring after the delimiter will be removed.
     * @return The processed string with the substring after the delimiter replaced with the replacement string.
     *         If the input string is {@code null} or the delimiter is {@code null}, the original string is returned.
     */
    public static String replaceAfter(final String str, final String delimiterOfExclusiveBeginIndex, final String replacement) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return str;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return str;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        return replace(str, startIndex, str.length(), replacement);
    }

    /**
     * Replaces the substring before a specified delimiter in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the delimiter and replaces everything before it
     * (excluding the delimiter itself) with the replacement string. The delimiter remains in the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * replaceBefore("Hello, World!", ",", "Hi");         // returns "Hi, World!"
     * replaceBefore("prefix:suffix", ":", "new");        // returns "new:suffix"
     * replaceBefore("NoDelimiter", ":", "test");         // returns "NoDelimiter"
     * replaceBefore(":StartsWith", ":", "");             // returns ":StartsWith"
     * replaceBefore("Multiple:colons:here", ":", "X");   // returns "X:colons:here"
     * replaceBefore(null, ":", "test");                  // returns null
     * }</pre>
     *
     * @param str The string to be processed.
     * @param delimiterOfExclusiveEndIndex The delimiter before which the replacement should end.
     * @param replacement The string to replace the substring before the delimiter. If it's {@code null}, the substring before the delimiter will be removed.
     * @return The processed string with the substring before the delimiter replaced with the replacement string.
     *         If the input string is {@code null} or the delimiter is {@code null}, the original string is returned.
     */
    public static String replaceBefore(final String str, final String delimiterOfExclusiveEndIndex, final String replacement) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return str;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return str;
        }

        return replace(str, 0, endIndex, replacement);
    }

    // Remove
    // -----------------------------------------------------------------------

    /**
     * Removes a substring only if it is at the beginning of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeStart(null, "*");                  // returns null
     * removeStart("", "*");                    // returns ""
     * removeStart("abc", null);                // returns "abc"
     * removeStart("www.domain.com", "www.");   // returns "domain.com"
     * removeStart("domain.com", "www.");       // returns "domain.com"
     * removeStart("www.domain.com", "domain"); // returns "www.domain.com"
     * removeStart("abc", "");                  // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeStr the String to search for and remove, which may be null
     * @return the substring with the string removed if found, {@code null} if null String input
     */
    public static String removeStart(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (str.startsWith(removeStr)) {
            return str.substring(removeStr.length());
        }

        return str;
    }

    /**
     * Case-insensitive removal of a substring if it is at the beginning of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeStartIgnoreCase(null, "*");                   // returns null
     * removeStartIgnoreCase("", "*");                     // returns ""
     * removeStartIgnoreCase("abc", null);                 // returns "abc"
     * removeStartIgnoreCase("www.domain.com", "www.");    // returns "domain.com"
     * removeStartIgnoreCase("www.domain.com", "WWW.");    // returns "domain.com"
     * removeStartIgnoreCase("domain.com", "www.");        // returns "domain.com"
     * removeStartIgnoreCase("www.domain.com", "domain");  // returns "www.domain.com"
     * removeStartIgnoreCase("abc", "");                   // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeStr the String to search for (case insensitive) and remove, may be null
     * @return the specified String if it's {@code null} or empty, or removal String is {@code null} or empty.
     */
    public static String removeStartIgnoreCase(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (startsWithIgnoreCase(str, removeStr)) {
            return str.substring(removeStr.length());
        }

        return str;
    }

    /**
     * Removes a substring only if it is at the end of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeEnd(null, "*");                   // returns null
     * removeEnd("", "*");                     // returns ""
     * removeEnd("abc", null);                 // returns "abc"
     * removeEnd("www.domain.com", ".com.");   // returns "www.domain.com"
     * removeEnd("www.domain.com", ".com");    // returns "www.domain"
     * removeEnd("www.domain.com", "domain");  // returns "www.domain.com"
     * removeEnd("abc", "");                   // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeStr the String to search for and remove, which may be null
     * @return the specified String if it's {@code null} or empty, or removal String is {@code null} or empty.
     */
    public static String removeEnd(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (str.endsWith(removeStr)) {
            return str.substring(0, str.length() - removeStr.length());
        }

        return str;
    }

    /**
     * Case-insensitive removal of a substring if it is at the end of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeEndIgnoreCase(null, "*");                    // returns null
     * removeEndIgnoreCase("", "*");                      // returns ""
     * removeEndIgnoreCase("abc", null);                  // returns "abc"
     * removeEndIgnoreCase("www.domain.com", ".com.");    // returns "www.domain.com"
     * removeEndIgnoreCase("www.domain.com", ".com");     // returns "www.domain"
     * removeEndIgnoreCase("www.domain.com", "domain");   // returns "www.domain.com"
     * removeEndIgnoreCase("abc", "");                    // returns "abc"
     * removeEndIgnoreCase("www.domain.com", ".COM");     // returns "www.domain"
     * removeEndIgnoreCase("www.domain.COM", ".com");     // returns "www.domain"
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeStr the String to search for (case insensitive) and remove, may be null
     * @return the specified String if it's {@code null} or empty, or removal String is {@code null} or empty.
     */
    public static String removeEndIgnoreCase(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (endsWithIgnoreCase(str, removeStr)) {
            return str.substring(0, str.length() - removeStr.length());
        }

        return str;
    }

    /**
     * Removes all occurrences of a character from within the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeAll(null, '*');        // returns null
     * removeAll("", '*');          // returns ""
     * removeAll("queued", 'u');    // returns "qeed"
     * removeAll("queued", 'z');    // returns "queued"
     * removeAll("aaa", 'a');       // returns ""
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeChar the char to search for and remove, which may be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String removeAll(final String str, final char removeChar) {
        return removeAll(str, 0, removeChar);
    }

    /**
     * Removes all occurrences of a specified character from the input string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the specified character starting from the given index
     * and removes them from the string. Characters before the specified index are preserved.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeAll("abcabc", 0, 'a');    // returns "bcbc"
     * removeAll("abcabc", 3, 'a');    // returns "abcbc"
     * removeAll("abcabc", 3, 'b');    // returns "abcac"
     * removeAll("hello", 0, 'l');     // returns "heo"
     * removeAll("test", 10, 't');     // returns "test" (index out of bounds)
     * removeAll(null, 0, 'a');        // returns null
     * }</pre>
     *
     * @param str The input string where the removal should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the removal. It should be a non-negative integer.
     * @param removeChar The character to be removed.
     * @return A new string with all occurrences of the specified character removed, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the character is not found, the input string is returned unchanged.
     */
    public static String removeAll(final String str, final int fromIndex, final char removeChar) {
        // N.checkIndex(fromIndex, N.len(str));

        if (str == null || str.isEmpty()) {
            return str;
        }

        final int index = str.indexOf(removeChar, fromIndex);
        if (index == N.INDEX_NOT_FOUND) {
            return str;
        } else {
            final char[] cbuf = new char[str.length()];

            if (index > 0) {
                str.getChars(0, index, cbuf, 0);
            }

            int count = index;
            char ch = 0;

            for (int i = index + 1, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (ch != removeChar) {
                    cbuf[count++] = ch;
                }
            }

            return count == cbuf.length ? str : new String(cbuf, 0, count);
        }
    }

    /**
     * Removes all occurrences of a substring from within the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} remove string will return the source string. An empty ("") remove string will return the source string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeAll(null, "*");         // returns null
     * removeAll("", "*");           // returns ""
     * removeAll("abc", null);       // returns "abc"
     * removeAll("abc", "");         // returns "abc"
     * removeAll("queued", "ue");    // returns "qd"
     * removeAll("queued", "zz");    // returns "queued"
     * removeAll("abcabc", "abc");   // returns ""
     * }</pre>
     *
     * @param str the source String to search, which may be null
     * @param removeStr the String to search for and remove, which may be null
     * @return the specified String if it's {@code null} or empty.
     */
    public static String removeAll(final String str, final String removeStr) {
        return removeAll(str, 0, removeStr);
    }

    /**
     * Removes all occurrences of a specified string from the input string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the specified string starting from the given index
     * and removes them from the input string. The part of the string before the specified index is preserved.</p>
     *
     * <p>Example:
     * <pre>{@code
     * removeAll("abcabcabc", 0, "abc");    // returns ""
     * removeAll("abcabcabc", 3, "abc");    // returns "abc"
     * removeAll("abcabcabc", 6, "abc");    // returns "abcabc"
     * removeAll("hello world", 0, "o");    // returns "hell wrld"
     * removeAll("test", 10, "es");         // returns "test" (index out of bounds)
     * removeAll(null, 0, "abc");           // returns null
     * }</pre>
     *
     * @param str The input string where the removal should occur. It can be {@code null} or empty.
     * @param fromIndex The index from which to start the removal. It should be a non-negative integer.
     * @param removeStr The string to be removed. It can be {@code null} or empty.
     * @return A new string with all occurrences of the specified string removed, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the string to be removed is not found, the input string is returned unchanged.
     */
    public static String removeAll(final String str, final int fromIndex, final String removeStr) {
        //  N.checkIndex(fromIndex, N.len(str));

        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        return replace(str, fromIndex, removeStr, EMPTY, -1);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter character.
     *
     * <p>This method splits the string at each occurrence of the delimiter character. Empty strings between
     * consecutive delimiters are omitted from the result. Leading and trailing delimiters are also ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split("a,b,c", ',');         // returns ["a", "b", "c"]
     * split("a,,b,c", ',');        // returns ["a", "b", "c"]
     * split(",a,b,c,", ',');       // returns ["a", "b", "c"]
     * split("abc", ',');           // returns ["abc"]
     * split("", ',');              // returns []
     * split(null, ',');            // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The character used as the delimiter for splitting the string.
     * @return An array of substrings derived from the input string, split based on the delimiter character.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final char delimiter) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    final Splitter splitter = splitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings() : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter character.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter character. Empty strings between
     * consecutive delimiters are omitted from the result. Leading and trailing delimiters are also ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split(" a , b , c ", ',', true);    // returns ["a", "b", "c"]
     * split(" a , b , c ", ',', false);   // returns [" a ", " b ", " c "]
     * split("a,,b", ',', true);           // returns ["a", "b"]
     * split("", ',', true);               // returns []
     * split(null, ',', true);             // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The character used as the delimiter for splitting the string.
     * @param trim A boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return An array of substrings derived from the input string, split based on the delimiter character and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final char delimiter, final boolean trim) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    if (trim) {
        //        final Splitter splitter = trimSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings().trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return split(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     *
     * <p>This method splits the string at each occurrence of the delimiter string. Empty strings between
     * consecutive delimiters are omitted from the result. If delimiter is {@code null}, the string is split on whitespace.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split("a::b::c", "::");        // returns ["a", "b", "c"]
     * split("a::::b::c", "::");      // returns ["a", "b", "c"]
     * split("::a::b::c::", "::");    // returns ["a", "b", "c"]
     * split("abc", "::");            // returns ["abc"]
     * split("a b  c", null);         // returns ["a", "b", "c"]
     * split("", "::");               // returns []
     * split(null, "::");             // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @return An array of substrings derived from the input string, split based on the delimiter string.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final String delimiter) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    final Splitter splitter = splitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings() : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter string. Empty strings between
     * consecutive delimiters are omitted from the result. If delimiter is {@code null}, the string is split on whitespace.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split(" a :: b :: c ", "::", true);    // returns ["a", "b", "c"]
     * split(" a :: b :: c ", "::", false);   // returns [" a ", " b ", " c "]
     * split("a::::b", "::", true);           // returns ["a", "b"]
     * split(" a  b  c ", null, true);        // returns ["a", "b", "c"]
     * split("", "::", true);                 // returns []
     * split(null, "::", true);               // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param trim A boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return An array of substrings derived from the input string, split based on the delimiter string and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final String delimiter, final boolean trim) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    if (trim) {
        //        final Splitter splitter = trimSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings().trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return split(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * The split operation will stop after reaching the specified maximum limit of substrings.
     *
     * <p>This method splits the string at each occurrence of the delimiter string up to the maximum limit.
     * If the string contains more delimiters than max-1, the last substring will contain all remaining text including delimiters.
     * Empty strings between consecutive delimiters are omitted from the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split("a:b:c:d:e", ":", 3);    // returns ["a", "b", "c:d:e"]
     * split("a:b:c:d:e", ":", 5);    // returns ["a", "b", "c", "d", "e"]
     * split("a:b:c:d:e", ":", 10);   // returns ["a", "b", "c", "d", "e"]
     * split("a:b:c", ":", 1);        // returns ["a:b:c"]
     * split("", ":", 3);             // returns []
     * split(null, ":", 3);           // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max The maximum number of substrings to be included in the resulting array.
     *            If the string contains more delimiters, the last substring will contain all remaining text.
     * @return An array of substrings derived from the input string, split based on the delimiter string.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] split(final String str, final String delimiter, final int max) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        if (max == 1) {
            return new String[] { str };
        }

        //    return Splitter.with(delimiter).omitEmptyStrings().limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * The split operation will stop after reaching the specified maximum limit of substrings.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter string up to the maximum limit.
     * If the string contains more delimiters than max-1, the last substring will contain all remaining text including delimiters.
     * Empty strings between consecutive delimiters are omitted from the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * split(" a : b : c : d ", ":", 3, true);    // returns ["a", "b", "c : d"]
     * split(" a : b : c : d ", ":", 3, false);   // returns [" a ", " b ", " c : d "]
     * split("a:b:c", ":", 1, true);              // returns ["a:b:c"]
     * split("a:b:c", ":", 1, false);             // returns ["a:b:c"]
     * split("", ":", 3, true);                   // returns []
     * split(null, ":", 3, true);                 // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max The maximum number of substrings to be included in the resulting array.
     *            If the string contains more delimiters, the last substring will contain all remaining text.
     * @param trim A boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return An array of substrings derived from the input string, split based on the delimiter string, limited by the max parameter and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] split(final String str, final String delimiter, final int max, final boolean trim) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        if (max == 1) {
            return new String[] { trim ? str.trim() : str };
        }

        //    return Splitter.with(delimiter).omitEmptyStrings().trim(trim).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, trim, false);
    }

    /**
     * Splits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * This is an alternative to using StringTokenizer.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens(null, '*');              // returns []
     * splitPreserveAllTokens("", '*');                // returns [""]
     * splitPreserveAllTokens("a.b.c", '.');           // returns ["a", "b", "c"]
     * splitPreserveAllTokens("a..b.c", '.');          // returns ["a", "", "b", "c"]
     * splitPreserveAllTokens("a:b:c", '.');           // returns ["a:b:c"]
     * splitPreserveAllTokens("a b c", ' ');           // returns ["a", "b", "c"]
     * splitPreserveAllTokens("a b c ", ' ');          // returns ["a", "b", "c", ""]
     * splitPreserveAllTokens(" a b c", ' ');          // returns ["", "a", "b", "c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the character used as the delimiter
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final char delimiter) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    final Splitter splitter = preserveSplitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter) : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, true);
    }

    /**
     * Splits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens(" a . b . c ", '.', true);     // returns ["a", "b", "c"]
     * splitPreserveAllTokens(" a . b . c ", '.', false);    // returns [" a ", " b ", " c "]
     * splitPreserveAllTokens("a..b", '.', true);            // returns ["a", "", "b"]
     * splitPreserveAllTokens(" .. ", '.', true);            // returns ["", "", ""]
     * splitPreserveAllTokens("", '.', true);                // returns [""]
     * splitPreserveAllTokens(null, '.', true);              // returns []
     * }</pre>
     *
     * @param str the String to parse, may be {@code null}
     * @param delimiter the character used as the delimiter
     * @param trim If {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final char delimiter, final boolean trim) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    if (trim) {
        //        final Splitter splitter = trimPreserveSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return splitPreserveAllTokens(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, true);
    }

    /**
     * Splits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens(null, "*");            // returns []
     * splitPreserveAllTokens("", "*");              // returns [""]
     * splitPreserveAllTokens("abc def", null);      // returns ["abc", "def"]
     * splitPreserveAllTokens("abc def", " ");       // returns ["abc", "def"]
     * splitPreserveAllTokens("abc  def", " ");      // returns ["abc", "", "def"]
     * splitPreserveAllTokens("ab:cd:ef", ":");      // returns ["ab", "cd", "ef"]
     * splitPreserveAllTokens("ab:cd:ef:", ":");     // returns ["ab", "cd", "ef", ""]
     * splitPreserveAllTokens(":cd:ef", ":");        // returns ["", "cd", "ef"]
     * splitPreserveAllTokens("a::b::c", "::")       // returns ["a", "b", "c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    final Splitter splitter = preserveSplitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter) : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, true);
    }

    /**
     * Splits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * A {@code null} separatorChars splits on whitespace. If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens(" a : b : c ", ":", true);     // returns ["a", "b", "c"]
     * splitPreserveAllTokens(" a : b : c ", ":", false);    // returns [" a ", " b ", " c "]
     * splitPreserveAllTokens("a::b", ":", true);            // returns ["a", "", "b"]
     * splitPreserveAllTokens(" :: ", ":", true);            // returns ["", "", ""]
     * splitPreserveAllTokens("", ":", true);                // returns [""]
     * splitPreserveAllTokens(null, ":", true);              // returns []
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param trim If {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final boolean trim) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    if (trim) {
        //        final Splitter splitter = trimPreserveSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return splitPreserveAllTokens(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, true);
    }

    /**
     * Splits the provided text into an array with a maximum length, separators specified, preserving all tokens.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If more than {@code max} delimited substrings are found, the last returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters).</p>
     *
     * <p>A {@code null} input String returns {@code null}. A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens("a:b:c:d", ":", 3);      // returns ["a", "b", "c:d"]
     * splitPreserveAllTokens("a:b:::d", ":", 3);      // returns ["a", "b", "::d"]
     * splitPreserveAllTokens("a:b:c:d", ":", 5);      // returns ["a", "b", "c", "d"]
     * splitPreserveAllTokens(":a:b:c", ":", 4);       // returns ["", "a", "b", "c"]
     * splitPreserveAllTokens("a:b:c:", ":", 4);       // returns ["a", "b", "c", ""]
     * splitPreserveAllTokens("a:b:c", ":", 1);        // returns ["a:b:c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max The maximum number of substrings to be included in the resulting array.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final int max) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        if (max == 1) {
            return new String[] { str };
        }

        // return Splitter.with(delimiter).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, false, true);
    }

    /**
     * Splits the provided text into an array with a maximum length, separators specified, preserving all tokens.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If more than {@code max} delimited substrings are found, the last returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters). If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>A {@code null} input String returns {@code null}. A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitPreserveAllTokens(" a : b : c : d ", ":", 3, true);    // returns ["a", "b", "c : d"]
     * splitPreserveAllTokens(" a : b : c : d ", ":", 3, false);   // returns [" a ", " b ", " c : d "]
     * splitPreserveAllTokens("a::b:c", ":", 4, true);             // returns ["a", "", "b", "c"]
     * splitPreserveAllTokens(" : : ", ":", 3, true);              // returns ["", "", ""]
     * splitPreserveAllTokens("a:b:c", ":", 1, true);              // returns ["a:b:c"]
     * splitPreserveAllTokens("a:b:c", ":", 1, false);             // returns ["a:b:c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter The string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max The maximum number of substrings to be included in the resulting array.
     * @param trim If {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final int max, final boolean trim) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        if (max == 1) {
            return new String[] { trim ? str.trim() : str };
        }

        // return Splitter.with(delimiter).trim(trim).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, trim, true);
    }

    // Copied from Apache Commons Lang 3.17.0 under Apache License 2.0
    private static String[] splitWorker(final String str, final char delimiter, final int max, final boolean trim, final boolean preserveAllTokens)
            throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return preserveAllTokens ? new String[] { EMPTY } : N.EMPTY_STRING_ARRAY;
        }

        final int len = str.length();
        final List<String> substrs = new ArrayList<>();

        int sizePlus1 = 1;
        int i = 0;
        int start = 0;
        boolean match = false;
        boolean lastMatch = false;

        while (i < len) {
            if (str.charAt(i) == delimiter) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    substrs.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }

        if (match || preserveAllTokens && lastMatch) {
            substrs.add(str.substring(start, i));
        }

        final String[] ret = substrs.toArray(N.EMPTY_STRING_ARRAY);

        if (trim) {
            trim(ret);
        }

        return ret;
    }

    // Copied from Apache Commons Lang 3.17.0 under Apache License 2.0
    private static String[] splitWorker(final String str, final String delimiter, final int max, final boolean trim, final boolean preserveAllTokens)
            throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return preserveAllTokens ? new String[] { EMPTY } : N.EMPTY_STRING_ARRAY;
        } else if (max == 1) {
            final String[] result = { str };

            if (trim) {
                trim(result);
            }

            return result;
        }

        final int delimiterLength = N.len(delimiter);

        if (delimiterLength == 1) {
            return splitWorker(str, delimiter.charAt(0), max, trim, preserveAllTokens);
        }

        final int len = str.length();
        final List<String> substrs = new ArrayList<>();

        int i = 0;

        if (delimiterLength == 0) {
            int start = 0;
            boolean match = false;
            boolean lastMatch = false;
            int sizePlus1 = 1;
            // Null separator means use whitespace
            while (i < len) {
                if (Character.isWhitespace(str.charAt(i))) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        substrs.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }

            if (match || (preserveAllTokens && lastMatch)) {
                substrs.add(str.substring(start, i));
            }
        } else {
            // standard case
            int idx = -1;

            while (i <= len - delimiterLength) {
                if ((idx = str.indexOf(delimiter, i)) < 0) {
                    break;
                }

                if (idx > i) {
                    substrs.add(str.substring(i, idx));
                } else if (preserveAllTokens) {
                    substrs.add(EMPTY);
                }

                if (substrs.size() == max - 1) {
                    if (preserveAllTokens || idx + delimiterLength < len) {
                        substrs.add(str.substring(idx + delimiterLength));
                    }

                    i = len; // end the loop
                    idx = -1; // reset idx to avoid adding another substring

                    break;
                }

                i = idx + delimiterLength;
            }

            if (idx < 0 || i < len) {
                if (i < len) {
                    substrs.add(str.substring(i, len));
                } else if (preserveAllTokens) {
                    substrs.add(EMPTY);
                }
            }
        }

        final String[] ret = substrs.toArray(N.EMPTY_STRING_ARRAY);

        if (trim) {
            trim(ret);
        }

        return ret;
    }

    /**
     * Splits the given string into an array of substrings, each of which is a line of text from the original string.
     *
     * <p>The string is split at line terminators, which can be the carriage return character ('\r'), 
     * the newline character ('\n'), or the carriage return followed immediately by the newline character ('\r\n').
     * Empty lines are preserved in the result.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitToLines("Line1\nLine2\nLine3");     // returns ["Line1", "Line2", "Line3"]
     * splitToLines("Line1\r\nLine2\r\nLine3"); // returns ["Line1", "Line2", "Line3"]
     * splitToLines("Line1\rLine2\rLine3");     // returns ["Line1", "Line2", "Line3"]
     * splitToLines("\n\n");                    // returns ["", "", ""]
     * splitToLines("");                        // returns [""]
     * splitToLines(null);                      // returns []
     * }</pre>
     *
     * @param str The string to be split. If it's {@code null}, the method will return an empty String array.
     * @return An array of substrings derived from the input string, each of which is a line of text.
     *         If the input string is {@code null}, return an empty String array. If the input string is empty, return an String array with one empty String inside.
     */
    public static String[] splitToLines(final String str) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { Strings.EMPTY };
        }

        return lineSplitter.splitToArray(str);
    }

    /**
     * Splits the given string into an array of substrings, each of which is a line of text from the original string.
     *
     * <p>The string is split at line terminators, which can be the carriage return character ('\r'), 
     * the newline character ('\n'), or the carriage return followed immediately by the newline character ('\r\n').
     * If the trim parameter is {@code true}, leading and trailing whitespace is removed from each line of text.
     * If the omitEmptyLines parameter is {@code true}, empty lines (after trimming, if the trim parameter is true) are not included in the resulting array.</p>
     *
     * <p>Example:
     * <pre>{@code
     * splitToLines(" Line1 \n Line2 \n Line3 ", true, false);    // returns ["Line1", "Line2", "Line3"]
     * splitToLines(" Line1 \n \n Line3 ", true, true);           // returns ["Line1", "Line3"]
     * splitToLines("Line1\n\nLine3", false, true);               // returns ["Line1", "Line3"]
     * splitToLines("\n\n", false, false);                        // returns ["", "", ""]
     * splitToLines("\n\n", true, true);                          // returns []
     * splitToLines("", true, true);                              // returns []
     * splitToLines(null, true, true);                            // returns []
     * }</pre>
     *
     * @param str The string to be split.
     * @param trim A boolean that determines whether to trim leading and trailing whitespace from each line of text.
     * @param omitEmptyLines A boolean that determines whether to omit empty lines from the resulting array.
     * @return An array of substrings derived from the input string, each of which is a line of text, optionally trimmed and with empty lines optionally omitted.
     *         If the input string is {@code null} or {@code str.length() == 0 && omitEmptyLines}, return an empty String array. If the input string is empty, return an String array with one empty String inside.
     */
    public static String[] splitToLines(final String str, final boolean trim, final boolean omitEmptyLines) {
        if (str == null || (str.isEmpty() && omitEmptyLines)) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { Strings.EMPTY };
        }

        if (trim) {
            if (omitEmptyLines) {
                return trimAndOmitEmptyLinesLineSplitter.splitToArray(str);
            } else {
                return trimLineSplitter.splitToArray(str);
            }
        } else if (omitEmptyLines) {
            return omitEmptyLinesLineSplitter.splitToArray(str);
        } else {
            return lineSplitter.splitToArray(str);
        }
    }

    // -----------------------------------------------------------------------

    /**
     * Removes space characters (char &lt;= 32) from both ends of this String, handling {@code null} by returning {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #strip(String)}.</p>
     *
     * <p>To trim your choice of characters, use the {@link #strip(String, String)} methods.</p>
     *
     * <p>Example:
     * <pre>{@code
     * trim(null);           // returns null
     * trim("");             // returns ""
     * trim("     ");        // returns ""
     * trim("abc");          // returns "abc"
     * trim("    abc    ");  // returns "abc"
     * trim(" \t\r\n ");     // returns ""
     * }</pre>
     *
     * @param str the String to be trimmed, which may be null
     * @return the trimmed string, {@code null} if null String input
     */
    public static String trim(final String str) {
        return isEmpty(str) || (!Character.isWhitespace(str.charAt(0)) && !Character.isWhitespace(str.charAt(str.length() - 1))) ? str : str.trim();
    }

    /**
     * Trims leading and trailing space characters from each string in the provided array.
     *
     * <p>This method uses {@link String#trim()} to remove space characters (char &lt;= 32) from both ends of each string.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", " def ", "ghi"};
     * trim(arr);  // arr becomes ["abc", "def", "ghi"]
     * 
     * String[] arr2 = {null, "  test  ", ""};
     * trim(arr2); // arr2 becomes [null, "test", ""]
     * }</pre>
     *
     * @param strs The array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trim(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trim(strs[i]);
        }
    }

    /**
     * Removes space characters (char &lt;= 32) from both ends of this String returning {@code null} if the String is empty ("") after the trim or if it is {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #stripToNull(String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * trimToNull(null);           // returns null
     * trimToNull("");             // returns null
     * trimToNull("     ");        // returns null
     * trimToNull("abc");          // returns "abc"
     * trimToNull("    abc    ");  // returns "abc"
     * trimToNull(" \t\r\n ");     // returns null
     * }</pre>
     *
     * @param str the String to be trimmed, which may be null
     * @return the trimmed String, {@code null} if only spaces, empty or null String input
     */
    public static String trimToNull(String str) {
        str = trim(str);

        return isEmpty(str) ? null : str;
    }

    /**
     * Trims leading and trailing whitespace from each string in the provided array and sets the string to {@code null} if it is empty after trimming.
     *
     * <p>This method uses {@link String#trim()} to remove whitespace. If a string becomes empty after trimming, it is set to {@code null}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", "   ", "def", ""};
     * trimToNull(arr);  // arr becomes ["abc", null, "def", null]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * trimToNull(arr2); // arr2 becomes [null, "test", null]
     * }</pre>
     *
     * @param strs The array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trimToNull(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trimToNull(strs[i]);
        }
    }

    /**
     * Removes control characters (char &lt;= 32) from both ends of this String returning an empty String ("") if the String is empty ("") after the trim or if it is {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #stripToEmpty(String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * trimToEmpty(null);           // returns ""
     * trimToEmpty("");             // returns ""
     * trimToEmpty("     ");        // returns ""
     * trimToEmpty("abc");          // returns "abc"
     * trimToEmpty("    abc    ");  // returns "abc"
     * trimToEmpty(" \t\r\n ");     // returns ""
     * }</pre>
     *
     * @param str the String to be trimmed, which may be null
     * @return the trimmed String, or an empty String if {@code null} input
     */
    public static String trimToEmpty(final String str) {
        return isEmpty(str) ? EMPTY : str.trim();
    }

    /**
     * Trims leading and trailing whitespace from each string in the provided array.
     *
     * <p>If a string becomes {@code null} after trimming, it is set to empty string.
     * This method uses {@link String#trim()} to remove whitespace.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", null, "def", "   "};
     * trimToEmpty(arr);  // arr becomes ["abc", "", "def", ""]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * trimToEmpty(arr2); // arr2 becomes ["", "test", ""]
     * }</pre>
     *
     * @param strs The array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trimToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trimToEmpty(strs[i]);
        }
    }

    // Stripping
    // -----------------------------------------------------------------------

    /**
     * Strips whitespace from the start and end of a String.
     *
     * <p>This is similar to {@link #trim(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>A {@code null} input String returns {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * strip(null);      // returns null
     * strip("");        // returns ""
     * strip("   ");     // returns ""
     * strip("abc");     // returns "abc"
     * strip("  abc");   // returns "abc"
     * strip("abc  ");   // returns "abc"
     * strip(" abc ");   // returns "abc"
     * strip(" ab c ");  // returns "ab c"
     * }</pre>
     *
     * @param str the String to remove whitespace from, which may be null
     * @return the stripped String, {@code null} if null String input
     */
    public static String strip(final String str) {
        return strip(str, null);
    }

    /**
     * Strips whitespace from the start and end of each string in the provided array.
     *
     * <p>This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", " def ", "ghi"};
     * strip(arr);  // arr becomes ["abc", "def", "ghi"]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * strip(arr2); // arr2 becomes [null, "test", ""]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void strip(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strip(strs[i]);
        }
    }

    /**
     * Strips whitespace from the start and end of a String returning {@code null} if the String is empty ("") after the strip.
     *
     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripToNull(null);      // returns null
     * stripToNull("");        // returns null
     * stripToNull("   ");     // returns null
     * stripToNull("abc");     // returns "abc"
     * stripToNull("  abc");   // returns "abc"
     * stripToNull("abc  ");   // returns "abc"
     * stripToNull(" abc ");   // returns "abc"
     * stripToNull(" ab c ");  // returns "ab c"
     * }</pre>
     *
     * @param str the String to be stripped, which may be null
     * @return the stripped String, {@code null} if whitespace, empty or null String input
     */
    public static String stripToNull(String str) {
        str = strip(str, null);

        return isEmpty(str) ? null : str;
    }

    /**
     * Strips whitespace from the start and end of each string in the provided array and sets the string to {@code null} if it is empty after stripping.
     *
     * <p>This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", "   ", "def", ""};
     * stripToNull(arr);  // arr becomes ["abc", null, "def", null]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * stripToNull(arr2); // arr2 becomes [null, "test", null]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripToNull(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripToNull(strs[i]);
        }
    }

    /**
     * Strips whitespace from the start and end of a String returning an empty String if {@code null} input.
     *
     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripToEmpty(null);      // returns ""
     * stripToEmpty("");        // returns ""
     * stripToEmpty("   ");     // returns ""
     * stripToEmpty("abc");     // returns "abc"
     * stripToEmpty("  abc");   // returns "abc"
     * stripToEmpty("abc  ");   // returns "abc"
     * stripToEmpty(" abc ");   // returns "abc"
     * stripToEmpty(" ab c ");  // returns "ab c"
     * }</pre>
     *
     * @param str the String to be stripped, which may be null
     * @return the trimmed String, or an empty String if {@code null} input
     */
    public static String stripToEmpty(final String str) {
        return isEmpty(str) ? EMPTY : strip(str, null);
    }

    /**
     * Strips leading and trailing whitespace from each string in the provided array.
     *
     * <p>If a string becomes {@code null} after stripping, it is set to an empty string.
     * This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"  abc  ", null, "def", "   "};
     * stripToEmpty(arr);  // arr becomes ["abc", "", "def", ""]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * stripToEmpty(arr2); // arr2 becomes ["", "test", ""]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripToEmpty(strs[i]);
        }
    }

    /**
     * Strips any of a set of characters from the start and end of a String.
     *
     * <p>This is similar to {@link String#trim()} but allows the characters to be stripped to be controlled.</p>
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * Alternatively use {@link #strip(String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * strip(null, "*");           // returns null
     * strip("", "*");             // returns ""
     * strip("abc", null);         // returns "abc"
     * strip("  abc", null);       // returns "abc"
     * strip("abc  ", null);       // returns "abc"
     * strip(" abc ", null);       // returns "abc"
     * strip("  abcyx", "xyz");    // returns "  abc"
     * strip("yxabcxyz", "xyz");   // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, which may be null
     * @param stripChars the characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String strip(final String str, final String stripChars) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return stripEnd(stripStart(str, stripChars), stripChars);
    }

    /**
     * Strips the specified characters from the start and end of each string in the provided array.
     *
     * <p>This method uses {@link #strip(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"xxabcyy", "xydefyx", "xyz"};
     * strip(arr, "xyz");  // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"  test  ", null, " \tabc\n "};
     * strip(arr2, null);  // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars The set of characters to be stripped from the strings. If {@code null}, the method behaves as {@link #strip(String)}.
     */
    public static void strip(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strip(strs[i], stripChars);
        }
    }

    /**
     * Strips whitespace from the start of a String.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.
     * A {@code null} input String returns {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripStart(null);        // returns null
     * stripStart("");          // returns ""
     * stripStart("abc");       // returns "abc"
     * stripStart("  abc");     // returns "abc"
     * stripStart("abc  ");     // returns "abc  "
     * stripStart(" abc ");     // returns "abc "
     * }</pre>
     *
     * @param str the String to remove whitespace from, which may be null
     * @return the stripped String, {@code null} if null String input
     */
    public static String stripStart(final String str) {
        return stripStart(str, null);
    }

    /**
     * Strips any of a set of characters from the start of a String.
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripStart(null, "*");           // returns null
     * stripStart("", "*");             // returns ""
     * stripStart("abc", "");           // returns "abc"
     * stripStart("abc", null);         // returns "abc"
     * stripStart("  abc", null);       // returns "abc"
     * stripStart("abc  ", null);       // returns "abc  "
     * stripStart(" abc ", null);       // returns "abc "
     * stripStart("yxabc  ", "xyz");    // returns "abc  "
     * stripStart("xyzabc", "xyz");     // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, which may be null
     * @param stripChars the characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String stripStart(final String str, final String stripChars) {
        if (isEmpty(str) || (stripChars != null && stripChars.isEmpty())) {
            return str;
        }

        final int strLen = str.length();
        int start = 0;
        if (stripChars == null) {
            while (start != strLen && Character.isWhitespace(str.charAt(start))) {
                start++;
            }
        } else {
            while (start != strLen && stripChars.indexOf(str.charAt(start)) != N.INDEX_NOT_FOUND) {
                start++;
            }
        }

        return start == 0 ? str : str.substring(start);
    }

    /**
     * Strips the specified characters from the start of each string in the provided array.
     *
     * <p>This method uses {@link #stripStart(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"xxabc", "xydef", "xyz"};
     * stripStart(arr, "xyz");  // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"  test", null, " \tabc"};
     * stripStart(arr2, null);  // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars The set of characters to be stripped from the start of the strings. If {@code null}, the method behaves as {@link #stripStart(String, String)}.
     * @see #stripStart(String, String)
     */
    public static void stripStart(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripStart(strs[i], stripChars);
        }
    }

    /**
     * Strips whitespace from the end of a String.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.
     * A {@code null} input String returns {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripEnd(null);          // returns null
     * stripEnd("");            // returns ""
     * stripEnd("abc");         // returns "abc"
     * stripEnd("  abc");       // returns "  abc"
     * stripEnd("abc  ");       // returns "abc"
     * stripEnd(" abc ");       // returns " abc"
     * }</pre>
     *
     * @param str the String to remove whitespace from, which may be null
     * @return the stripped String, {@code null} if null String input
     */
    public static String stripEnd(final String str) {
        return stripEnd(str, null);
    }

    /**
     * Strips any of a set of characters from the end of a String.
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripEnd(null, "*");           // returns null
     * stripEnd("", "*");             // returns ""
     * stripEnd("abc", "");           // returns "abc"
     * stripEnd("abc", null);         // returns "abc"
     * stripEnd("  abc", null);       // returns "  abc"
     * stripEnd("abc  ", null);       // returns "abc"
     * stripEnd(" abc ", null);       // returns " abc"
     * stripEnd("  abcyx", "xyz");    // returns "  abc"
     * stripEnd("120.00", ".0");      // returns "12"
     * stripEnd("abcxyz", "xyz");     // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, which may be null
     * @param stripChars the set of characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String stripEnd(final String str, final String stripChars) {
        if (isEmpty(str) || (stripChars != null && stripChars.isEmpty())) {
            return str;
        }

        int end = str.length();

        if (stripChars == null) {
            while (end > 0 && Character.isWhitespace(str.charAt(end - 1))) {
                end--;
            }
        } else {
            while (end > 0 && stripChars.indexOf(str.charAt(end - 1)) != N.INDEX_NOT_FOUND) {
                end--;
            }
        }

        return end == str.length() ? str : str.substring(0, end);
    }

    /**
     * Strips the specified characters from the end of each string in the provided array.
     *
     * <p>This method uses {@link #stripEnd(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"abcxx", "defxy", "xyz"};
     * stripEnd(arr, "xyz");  // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"test  ", null, "abc \t"};
     * stripEnd(arr2, null);  // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars The set of characters to be stripped from the end of the strings. If {@code null}, the method behaves as {@link #stripEnd(String, String)}.
     * @see #stripEnd(String, String)
     */
    public static void stripEnd(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripEnd(strs[i], stripChars);
        }
    }

    /**
     * Removes diacritics (~= accents) from a string. The case will not be altered.
     *
     * <p>For instance, '' will be replaced by 'a'.
     * Note that ligatures will be left as is.</p>
     *
     * <p>This method uses Java's Normalizer to decompose accented characters and then removes the combining diacritical marks.
     * Some special characters like  and  are handled separately.</p>
     *
     * <p>Example:
     * <pre>{@code
     * stripAccents(null);                  // returns null
     * stripAccents("");                    // returns ""
     * stripAccents("control");             // returns "control"
     * stripAccents("clair");              // returns "eclair"
     * stripAccents(" la carte");          // returns "a la carte"
     * stripAccents("d");                // returns "Lodz"
     * }</pre>
     *
     * @param str the String to strip accents from, which may be null
     * @return the stripped String, {@code null} if null String input
     */
    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented
    // characters by their unaccented equivalent (and uncommitted bug fix:
    // https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).
    @MayReturnNull
    public static String stripAccents(final String str) {
        if (str == null) {
            return null;
        }
        final StringBuilder decomposed = new StringBuilder(Normalizer.normalize(str, Normalizer.Form.NFD));
        convertRemainingAccentCharacters(decomposed);
        // Note that this doesn't correctly remove ligatures...
        return STRIP_ACCENTS_PATTERN.matcher(decomposed).replaceAll(EMPTY);
    }

    /**
     * Pattern used in {@link #stripAccents(String)}.
     */
    private static final Pattern STRIP_ACCENTS_PATTERN = Pattern.compile("\\p{InCombiningDiacriticalMarks}+"); //$NON-NLS-1$

    private static void convertRemainingAccentCharacters(final StringBuilder decomposed) {
        char ch = 0;

        for (int i = 0; i < decomposed.length(); i++) {
            ch = decomposed.charAt(i);

            if (ch == '\u0141') {
                decomposed.setCharAt(i, 'L');
            } else if (ch == '\u0142') {
                decomposed.setCharAt(i, 'l');
            }
        }
    }

    /**
     * Strips accents from each string in the provided array.
     *
     * <p>This method uses {@link #stripAccents(String)} to remove accents from each string.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"clair", "caf", "nave"};
     * stripAccents(arr);  // arr becomes ["eclair", "cafe", "naive"]
     * 
     * String[] arr2 = {null, "d", "rsum"};
     * stripAccents(arr2); // arr2 becomes [null, "Lodz", "resume"]
     * }</pre>
     *
     * @param strs The array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripAccents(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripAccents(strs[i]);
        }
    }
    // Chomping
    // -----------------------------------------------------------------------

    /**
     * Removes one newline from end of a String if it's there, otherwise leave it alone.
     * 
     * <p>A newline is defined as "\n", "\r", or "\r\n". This method removes exactly one occurrence
     * of any of these sequences from the end of the string. If the string ends with multiple newlines,
     * only the last one is removed.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * chomp(null)          = null
     * chomp("")            = ""
     * chomp("abc \r")      = "abc "
     * chomp("abc\n")       = "abc"
     * chomp("abc\r\n")     = "abc"
     * chomp("abc\r\n\r\n") = "abc\r\n"
     * chomp("abc\n\r")     = "abc\n"
     * chomp("abc\n\rabc")  = "abc\n\rabc"
     * chomp("\r")          = ""
     * chomp("\n")          = ""
     * chomp("\r\n")        = ""
     * }</pre>
     *
     * @param str the String to chomp a newline from, which may be null
     * @return String without newline at the end, {@code null} if {@code null} String input
     */
    public static String chomp(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        if (str.length() == 1) {
            final char ch = str.charAt(0);

            if (ch == CHAR_CR || ch == CHAR_LF) {
                return EMPTY;
            }

            return str;
        }

        int lastIdx = str.length() - 1;
        final char last = str.charAt(lastIdx);

        if (last == CHAR_LF) {
            if (lastIdx > 0 && str.charAt(lastIdx - 1) == CHAR_CR) {
                lastIdx--;
            }
        } else if (last != CHAR_CR) {
            lastIdx++;
        }

        return lastIdx == str.length() ? str : str.substring(0, lastIdx);
    }

    /**
     * Removes one newline from end of each string in the provided array if it's there, otherwise leaves it alone.
     * 
     * <p>A newline is defined as "\n", "\r", or "\r\n". This method processes each string in the array
     * independently, removing exactly one occurrence of any of these sequences from the end of each string.
     * The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] strs = {"abc\n", "def\r", "ghi"};
     * chomp(strs);
     * // strs is now {"abc", "def", "ghi"}
     * }</pre>
     *
     * @param strs The array of strings to be chomped. Each string in the array will be updated in-place.
     */
    public static void chomp(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = chomp(strs[i]);
        }
    }

    // Chopping
    // -----------------------------------------------------------------------

    /**
     * Remove the last character from a String.
     *
     * <p>If the String ends in "\r\n", then both characters are removed. Otherwise, only the last
     * character is removed. This differs from {@link #chomp(String)} which only removes newline sequences.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}, and an empty string if the input
     * has only one character or is already empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * chop(null)          = null
     * chop("")            = ""
     * chop("abc \r")      = "abc "
     * chop("abc\n")       = "abc"
     * chop("abc\r\n")     = "abc"
     * chop("abc")         = "ab"
     * chop("abc\nabc")    = "abc\nab"
     * chop("a")           = ""
     * chop("\r")          = ""
     * chop("\n")          = ""
     * chop("\r\n")        = ""
     * }</pre>
     *
     * @param str the String to chop last character from, which may be null
     * @return String without last character, {@code null} if {@code null} String input
     */
    public static String chop(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int strLen = str.length();

        if (strLen < 2) {
            return EMPTY;
        }

        final int lastIdx = strLen - 1;

        if (str.charAt(lastIdx) == CHAR_LF && str.charAt(lastIdx - 1) == CHAR_CR) {
            return str.substring(0, lastIdx - 1);
        } else {
            return str.substring(0, lastIdx);
        }
    }

    /**
     * Removes the last character from each string in the provided array.
     *
     * <p>If a string in the array ends in "\r\n", both characters are removed. Otherwise, only the last
     * character is removed. The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] strs = {"abc", "def\r\n", "g"};
     * chop(strs);
     * // strs is now {"ab", "def", ""}
     * }</pre>
     *
     * @param strs The array of strings to be chopped. Each string in the array will be updated in-place.
     */
    public static void chop(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = chop(strs[i]);
        }
    }

    /**
     * Truncates a String to a specified maximum width.
     *
     * <p>This method will return the original string if it is shorter than or equal to the specified
     * maximum width. If the string is longer, it will be truncated to exactly the maximum width.
     * The method handles {@code null} input by returning {@code null}.</p>
     *
     * <p>If {@code maxWidth} is less than 0, an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * truncate(null, 0)       = null
     * truncate(null, 2)       = null
     * truncate("", 4)         = ""
     * truncate("abcdefg", 4)  = "abcd"
     * truncate("abcdefg", 6)  = "abcdef"
     * truncate("abcdefg", 7)  = "abcdefg"
     * truncate("abcdefg", 8)  = "abcdefg"
     * truncate("abcdefg", -1) = throws an IllegalArgumentException
     * }</pre>
     *
     * @param str the String to truncate, which may be null
     * @param maxWidth maximum length of result String, must be positive
     * @return truncated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException If {@code maxWidth} is less than 0
     */
    public static String truncate(final String str, final int maxWidth) {
        return truncate(str, 0, maxWidth);
    }

    /**
     * Truncates a String to a specified maximum width starting from a given offset.
     *
     * <p>This method allows you to specify a "left edge" offset from where the truncation should begin.
     * The resulting string will contain at most {@code maxWidth} characters starting from the offset position.
     * If the string is shorter than {@code offset + maxWidth}, the entire substring from offset is returned.</p>
     *
     * <p>If {@code offset} or {@code maxWidth} is less than 0, an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * truncate(null, 0, 0) = null
     * truncate(null, 2, 4) = null
     * truncate("", 0, 10) = ""
     * truncate("", 2, 10) = ""
     * truncate("abcdefghij", 0, 3) = "abc"
     * truncate("abcdefghij", 5, 6) = "fghij"
     * truncate("raspberry peach", 10, 15) = "peach"
     * truncate("abcdefghijklmno", 0, 10) = "abcdefghij"
     * truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentException
     * truncate("abcdefghij", 3, -1) = throws an IllegalArgumentException
     * }</pre>
     *
     * @param str the String to truncate, which may be null
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be positive
     * @return truncated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException If {@code offset} or {@code maxWidth} is less than 0
     */
    @MayReturnNull
    public static String truncate(final String str, final int offset, final int maxWidth) throws IllegalArgumentException {
        N.checkArgNotNegative(offset, cs.offset);
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (str == null) {
            return null;
        } else if (str.length() <= offset || maxWidth == 0) {
            return EMPTY;
        } else if (str.length() - offset <= maxWidth) {
            return offset == 0 ? str : str.substring(offset);
        } else {
            return str.substring(offset, offset + maxWidth);
        }
    }

    /**
     * Truncates each string in the provided array to the specified maximum width.
     *
     * <p>If a string in the array has a length less than or equal to the maxWidth, it remains unchanged.
     * If a string in the array has a length greater than the maxWidth, it is truncated to the maxWidth.
     * The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] strs = {"hello", "world123", "hi"};
     * truncate(strs, 5);
     * // strs is now {"hello", "world", "hi"}
     * }</pre>
     *
     * @param strs The array of strings to be truncated. Each string in the array will be updated in-place.
     * @param maxWidth The maximum length for each string. Must be non-negative.
     * @throws IllegalArgumentException If maxWidth is less than 0.
     */
    public static void truncate(final String[] strs, final int maxWidth) {
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = truncate(strs[i], maxWidth);
        }
    }

    /**
     * Truncates each string in the provided array to the specified maximum width starting from the given offset.
     *
     * <p>This method processes each string in the array independently. For each string, if it has a length
     * less than or equal to the offset, it becomes an empty string. Otherwise, it is truncated to contain
     * at most {@code maxWidth} characters starting from the offset position. The strings in the array are
     * updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] strs = {"hello", "world123", "hi"};
     * truncate(strs, 2, 3);
     * // strs is now {"llo", "rld", ""}
     * }</pre>
     *
     * @param strs The array of strings to be truncated. Each string in the array will be updated in-place.
     * @param offset The starting index from where the string needs to be truncated.
     * @param maxWidth The maximum length for each string starting from the offset. Must be non-negative.
     * @throws IllegalArgumentException If maxWidth or offset is less than 0.
     */
    public static void truncate(final String[] strs, final int offset, final int maxWidth) {
        N.checkArgNotNegative(offset, cs.offset);
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = truncate(strs[i], offset, maxWidth);
        }
    }

    // Delete
    // -----------------------------------------------------------------------

    /**
     * Deletes all white spaces from a String as defined by {@link Character#isWhitespace(char)}.
     *
     * <p>This method removes all characters for which {@link Character#isWhitespace(char)} returns {@code true}.
     * This includes spaces, tabs, newlines, and other Unicode whitespace characters. The method returns
     * {@code null} if the input is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * deleteWhitespace(null)         = null
     * deleteWhitespace("")           = ""
     * deleteWhitespace("abc")        = "abc"
     * deleteWhitespace("   ab  c  ") = "abc"
     * deleteWhitespace("a\tb\nc")    = "abc"
     * deleteWhitespace("a b\tc\r\n") = "abc"
     * }</pre>
     *
     * @param str the String to delete whitespace from, which may be null
     * @return the String without whitespaces, {@code null} if {@code null} String input
     */
    public static String deleteWhitespace(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int len = str.length();
        final char[] cbuf = new char[len];
        int count = 0;
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = str.charAt(i);

            if (!Character.isWhitespace(ch)) {
                cbuf[count++] = ch;
            }
        }

        return count == cbuf.length ? str : new String(cbuf, 0, count);
    }

    /**
     * Deletes all white spaces from each string in the provided array.
     *
     * <p>White spaces are determined by {@link Character#isWhitespace(char)}. This includes spaces,
     * tabs, newlines, and other Unicode whitespace characters. Each string in the array is processed
     * independently and updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] strs = {"  hello  ", "world\t123", " h i "};
     * deleteWhitespace(strs);
     * // strs is now {"hello", "world123", "hi"}
     * }</pre>
     *
     * @param strs The array of strings to be processed. Each string in the array will be updated in-place.
     */
    public static void deleteWhitespace(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = deleteWhitespace(strs[i]);
        }
    }

    /**
     * Appends the specified suffix to the input string if it is not already present at the end of the string.
     *
     * <p>This method checks if the string already ends with the specified suffix. If it does, the original
     * string is returned unchanged. If not, the suffix is appended to the string. If the input string is
     * {@code null} or empty, the suffix is returned as is.</p>
     *
     * <p>The suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * appendIfMissing(null, ".txt")     = ".txt"
     * appendIfMissing("", ".txt")       = ".txt"
     * appendIfMissing("file", ".txt")   = "file.txt"
     * appendIfMissing("file.txt", ".txt") = "file.txt"
     * appendIfMissing("file.doc", ".txt") = "file.doc.txt"
     * appendIfMissing("file", "")       = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to which the suffix should be appended. May be {@code null} or empty.
     * @param suffix The suffix to append to the string. Must not be empty.
     * @return The input string with the suffix appended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the suffix is empty.
     */
    public static String appendIfMissing(final String str, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return suffix;
        } else if (str.endsWith(suffix)) {
            return str;
        } else {
            return str + suffix;
        }
    }

    /**
     * Appends the specified suffix to the input string if it is not already present at the end of the string,
     * ignoring case considerations.
     *
     * <p>This method performs a case-insensitive check to determine if the string already ends with the
     * specified suffix. If it does, the original string is returned unchanged. If not, the suffix is
     * appended to the string. If the input string is {@code null} or empty, the suffix is returned as is.</p>
     *
     * <p>The suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * appendIfMissingIgnoreCase(null, ".TXT")     = ".TXT"
     * appendIfMissingIgnoreCase("", ".TXT")       = ".TXT"
     * appendIfMissingIgnoreCase("file", ".TXT")   = "file.TXT"
     * appendIfMissingIgnoreCase("file.txt", ".TXT") = "file.txt"
     * appendIfMissingIgnoreCase("file.TXT", ".txt") = "file.TXT"
     * appendIfMissingIgnoreCase("file", "")       = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to which the suffix should be appended. May be {@code null} or empty.
     * @param suffix The suffix to append to the string. Must not be empty.
     * @return The input string with the suffix appended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the suffix is empty.
     */
    public static String appendIfMissingIgnoreCase(final String str, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return suffix;
        } else if (Strings.endsWithIgnoreCase(str, suffix)) {
            return str;
        } else {
            return str + suffix;
        }
    }

    /**
     * Prepends the specified prefix to the input string if it is not already present at the start of the string.
     *
     * <p>This method checks if the string already starts with the specified prefix. If it does, the original
     * string is returned unchanged. If not, the prefix is prepended to the string. If the input string is
     * {@code null} or empty, the prefix is returned as is.</p>
     *
     * <p>The prefix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * prependIfMissing(null, "http://")     = "http://"
     * prependIfMissing("", "http://")       = "http://"
     * prependIfMissing("example.com", "http://") = "http://example.com"
     * prependIfMissing("http://example.com", "http://") = "http://example.com"
     * prependIfMissing("ftp://example.com", "http://") = "http://ftp://example.com"
     * prependIfMissing("example.com", "")   = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to which the prefix should be prepended. May be {@code null} or empty.
     * @param prefix The prefix to prepend to the string. Must not be empty.
     * @return The input string with the prefix prepended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefix is empty.
     */
    public static String prependIfMissing(final String str, final String prefix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);

        if (str == null || str.isEmpty()) {
            return prefix;
        } else if (str.startsWith(prefix)) {
            return str;
        } else {
            return concat(prefix, str);
        }
    }

    /**
     * Prepends the specified prefix to the input string if it is not already present at the start of the string,
     * ignoring case considerations.
     *
     * <p>This method performs a case-insensitive check to determine if the string already starts with the
     * specified prefix. If it does, the original string is returned unchanged. If not, the prefix is
     * prepended to the string. If the input string is {@code null} or empty, the prefix is returned as is.</p>
     *
     * <p>The prefix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * prependIfMissingIgnoreCase(null, "HTTP://")     = "HTTP://"
     * prependIfMissingIgnoreCase("", "HTTP://")       = "HTTP://"
     * prependIfMissingIgnoreCase("example.com", "HTTP://") = "HTTP://example.com"
     * prependIfMissingIgnoreCase("http://example.com", "HTTP://") = "http://example.com"
     * prependIfMissingIgnoreCase("HTTP://example.com", "http://") = "HTTP://example.com"
     * prependIfMissingIgnoreCase("example.com", "")   = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to which the prefix should be prepended. May be {@code null} or empty.
     * @param prefix The prefix to prepend to the string. Must not be empty.
     * @return The input string with the prefix prepended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefix is empty.
     */
    public static String prependIfMissingIgnoreCase(final String str, final String prefix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);

        if (str == null || str.isEmpty()) {
            return prefix;
        } else if (Strings.startsWithIgnoreCase(str, prefix)) {
            return str;
        } else {
            return concat(prefix, str);
        }
    }

    /**
     * Wraps the input string with the specified prefix and suffix if they are not already present.
     *
     * <p>This method uses the same string as both prefix and suffix. The method follows these rules:</p>
     * <ul>
     * <li>If the input string is {@code null} or empty, the prefix and suffix are concatenated and returned.</li>
     * <li>If the input string already starts with the prefix and ends with the suffix, the original string is returned.</li>
     * <li>If the input string already starts with the prefix but not ends with the suffix, then {@code str + prefixSuffix} is returned.</li>
     * <li>If the input string ends with the suffix but not starts with the prefix, then {@code prefixSuffix + str} is returned.</li>
     * <li>Otherwise, the prefix and suffix are added to the start and end of the string respectively.</li>
     * </ul>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * wrapIfMissing(null, "\"")    = "\"\""
     * wrapIfMissing("", "\"")      = "\"\""
     * wrapIfMissing("abc", "\"")   = "\"abc\""
     * wrapIfMissing("\"abc", "\"") = "\"abc\""
     * wrapIfMissing("abc\"", "\"") = "\"abc\""
     * wrapIfMissing("\"abc\"", "\"") = "\"abc\""
     * wrapIfMissing("abc", "")     = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to be wrapped. May be {@code null} or empty.
     * @param prefixSuffix The string to be used as both the prefix and suffix for wrapping. Must not be empty.
     * @return The input string wrapped with the prefixSuffix at both ends if they were not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefixSuffix is empty.
     */
    public static String wrapIfMissing(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return wrapIfMissing(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Wraps the input string with the specified prefix and suffix if they are not already present.
     *
     * <p>The method follows these rules:</p>
     * <ul>
     * <li>If the input string is {@code null} or empty, the prefix and suffix are concatenated and returned.</li>
     * <li>If the input string already starts with the prefix and ends with the suffix, the original string is returned.</li>
     * <li>If the input string already starts with the prefix but not ends with the suffix, then {@code str + suffix} is returned.</li>
     * <li>If the input string ends with the suffix but not starts with the prefix, then {@code prefix + str} is returned.</li>
     * <li>Otherwise, the prefix and suffix are added to the start and end of the string respectively.</li>
     * </ul>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * wrapIfMissing(null, "[", "]") = "[]"
     * wrapIfMissing("", "[", "]") = "[]"
     * wrapIfMissing("[", "[", "]") = "[]"
     * wrapIfMissing("]", "[", "]") = "[]"
     * wrapIfMissing("abc", "[", "]") = "[abc]"
     * wrapIfMissing("[abc", "[", "]") = "[abc]"
     * wrapIfMissing("abc]", "[", "]") = "[abc]"
     * wrapIfMissing("[abc]", "[", "]") = "[abc]"
     * wrapIfMissing("a", "aa", "aa") = "aaaaa"
     * wrapIfMissing("aa", "aa", "aa") = "aaaa"
     * wrapIfMissing("aaa", "aa", "aa") = "aaaaa"
     * wrapIfMissing("aaaa", "aa", "aa") = "aaaa"
     * }</pre>
     *
     * @param str The string to be wrapped. May be {@code null} or empty.
     * @param prefix The string to be used as the prefix for wrapping. Must not be empty.
     * @param suffix The string to be used as the suffix for wrapping. Must not be empty.
     * @return The input string wrapped with the prefix and suffix at both ends if they were not already present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefix or suffix is empty.
     */
    public static String wrapIfMissing(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (isEmpty(str)) {
            return concat(prefix, suffix);
        } else if (str.startsWith(prefix)) {
            return (str.length() - prefix.length() >= suffix.length() && str.endsWith(suffix)) ? str : concat(str + suffix);
        } else if (str.endsWith(suffix)) {
            return concat(prefix, str);
        } else {
            return concat(prefix, str, suffix);
        }
    }

    /**
     * Wraps the input string with the specified prefix and suffix.
     *
     * <p>This method unconditionally adds the prefix and suffix to the string, regardless of whether
     * they are already present. If the input string is {@code null}, it will be treated as an empty string.
     * This method uses the same string as both prefix and suffix.</p>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * wrap(null, "\"")    = "\"\""
     * wrap("", "\"")      = "\"\""
     * wrap("abc", "\"")   = "\"abc\""
     * wrap("\"abc", "\"") = "\"\"abc\""
     * wrap("abc\"", "\"") = "\"abc\"\""
     * wrap("\"abc\"", "\"") = "\"\"abc\"\""
     * wrap("abc", "")     = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to be wrapped. May be {@code null}.
     * @param prefixSuffix The string to be used as both the prefix and suffix for wrapping. Must not be empty.
     * @return The input string wrapped with the prefixSuffix at both ends.
     * @throws IllegalArgumentException If the prefixSuffix is empty.
     */
    public static String wrap(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return wrap(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Wraps the input string with the specified prefix and suffix.
     *
     * <p>This method unconditionally adds the prefix and suffix to the string, regardless of whether
     * they are already present. If the input string is {@code null}, it will be treated as an empty string.</p>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * wrap(null, "[", "]") = "[]"
     * wrap("", "[", "]") = "[]"
     * wrap("[", "[", "]") = "[[]"
     * wrap("]", "[", "]") = "[]]"
     * wrap("abc", "[", "]") = "[abc]"
     * wrap("[abc]", "[", "]") = "[[abc]]"
     * wrap("a", "aa", "aa") = "aaaaa"
     * wrap("aa", "aa", "aa") = "aaaaaa"
     * wrap("aaa", "aa", "aa") = "aaaaaaa"
     * }</pre>
     *
     * @param str The string to be wrapped. May be {@code null}.
     * @param prefix The string to be used as the prefix for wrapping. Must not be empty.
     * @param suffix The string to be used as the suffix for wrapping. Must not be empty.
     * @return The input string wrapped with the prefix and suffix at both ends.
     * @throws IllegalArgumentException If the prefix or suffix is empty.
     */
    public static String wrap(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (isEmpty(str)) {
            return concat(prefix, suffix);
        } else {
            return concat(prefix, str, suffix);
        }
    }

    /**
     * Unwraps the input string if it is wrapped by the specified prefixSuffix at both ends.
     *
     * <p>This method removes the prefixSuffix from both the start and end of the string if and only if
     * the string starts and ends with the prefixSuffix. If the input string is {@code null} or empty,
     * the original string is returned. If the input string is not wrapped by the prefixSuffix, the
     * original string is returned unchanged.</p>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * unwrap(null, "\"")     = null
     * unwrap("", "\"")       = ""
     * unwrap("abc", "\"")    = "abc"
     * unwrap("\"abc", "\"")  = "\"abc"
     * unwrap("abc\"", "\"")  = "abc\""
     * unwrap("\"abc\"", "\"") = "abc"
     * unwrap("\"\"abc\"\"", "\"") = "\"abc\""
     * unwrap("abc", "")      = throws IllegalArgumentException
     * }</pre>
     *
     * @param str The string to be unwrapped. May be {@code null} or empty.
     * @param prefixSuffix The string used as both the prefix and suffix for unwrapping. Must not be empty.
     * @return The input string with the prefixSuffix removed from both ends if they were present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefixSuffix is empty.
     */
    public static String unwrap(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return unwrap(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Unwraps the input string if it is wrapped by the specified prefix and suffix.
     *
     * <p>This method removes the prefix from the start and the suffix from the end of the string if and
     * only if the string starts with the prefix and ends with the suffix. If the input string is {@code null}
     * or empty, the original string is returned. If the input string is not wrapped by the prefix and suffix,
     * the original string is returned unchanged.</p>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p>Example:
     * <pre>{@code
     * unwrap(null, "[", "]") = null
     * unwrap("", "[", "]") = ""
     * unwrap("[", "[", "]") = "["
     * unwrap("]", "[", "]") = "]"
     * unwrap("[abc]", "[", "]") = "abc"
     * unwrap("[[abc]]", "[", "]") = "[abc]"
     * unwrap("[abc", "[", "]") = "[abc"
     * unwrap("abc]", "[", "]") = "abc]"
     * unwrap("aaaaa", "aa", "aa") = "a"
     * unwrap("aa", "aa", "aa") = "aa"
     * unwrap("aaa", "aa", "aa") = "aaa"
     * unwrap("aaaa", "aa", "aa") = ""
     * }</pre>
     *
     * @param str The string to be unwrapped. May be {@code null} or empty.
     * @param prefix The string used as the prefix for unwrapping. Must not be empty.
     * @param suffix The string used as the suffix for unwrapping. Must not be empty.
     * @return The input string with the prefix and suffix removed from both ends if they were present; otherwise, the original string.
     * @throws IllegalArgumentException If the prefix or suffix is empty.
     */
    public static String unwrap(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return str;
        } else if (str.length() - prefix.length() >= suffix.length() && str.startsWith(prefix) && str.endsWith(suffix)) {
            return str.substring(prefix.length(), str.length() - suffix.length());
        } else {
            return str;
        }
    }

    /**
     * Checks if the specified character is a lowercase character.
     *
     * <p>This method delegates to {@link Character#isLowerCase(char)} to determine if the character
     * is a lowercase letter according to Unicode standards.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isLowerCase('a') = true
     * isLowerCase('A') = false
     * isLowerCase('1') = false
     * isLowerCase('') = true
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is lowercase, {@code false} otherwise
     * @see Character#isLowerCase(char)
     */
    public static boolean isLowerCase(final char ch) {
        return Character.isLowerCase(ch);
    }

    /**
     * Checks if the specified character is an ASCII lowercase character.
     *
     * <p>This method checks if the character is in the range 'a' to 'z' (ASCII values 97 to 122).
     * Unlike {@link #isLowerCase(char)}, this method only considers ASCII lowercase letters and
     * does not include lowercase letters from other Unicode ranges.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiLowerCase('a') = true
     * isAsciiLowerCase('z') = true
     * isAsciiLowerCase('A') = false
     * isAsciiLowerCase('1') = false
     * isAsciiLowerCase('') = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is an ASCII lowercase letter, {@code false} otherwise
     */
    public static boolean isAsciiLowerCase(final char ch) {
        return (ch >= 'a') && (ch <= 'z');
    }

    /**
     * Checks if the specified character is an uppercase character.
     *
     * <p>This method delegates to {@link Character#isUpperCase(char)} to determine if the character
     * is an uppercase letter according to Unicode standards.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isUpperCase('A') = true
     * isUpperCase('a') = false
     * isUpperCase('1') = false
     * isUpperCase('') = true
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is uppercase, {@code false} otherwise
     * @see Character#isUpperCase(char)
     */
    public static boolean isUpperCase(final char ch) {
        return Character.isUpperCase(ch);
    }

    /**
     * Checks if the specified character is an ASCII uppercase character.
     *
     * <p>This method checks if the character is in the range 'A' to 'Z' (ASCII values 65 to 90).
     * Unlike {@link #isUpperCase(char)}, this method only considers ASCII uppercase letters and
     * does not include uppercase letters from other Unicode ranges.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiUpperCase('A') = true
     * isAsciiUpperCase('Z') = true
     * isAsciiUpperCase('a') = false
     * isAsciiUpperCase('1') = false
     * isAsciiUpperCase('') = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is an ASCII uppercase letter, {@code false} otherwise
     */
    public static boolean isAsciiUpperCase(final char ch) {
        return (ch >= 'A') && (ch <= 'Z');
    }

    /**
     * Checks if all characters in the given CharSequence are lowercase.
     *
     * <p>This method returns {@code true} if all characters in the CharSequence are lowercase letters
     * according to {@link Character#isLowerCase(char)}. An empty CharSequence or {@code null} returns
     * {@code true}. Note that non-letter characters will cause this method to return {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllLowerCase(null)   = true
     * isAllLowerCase("")     = true
     * isAllLowerCase("abc")  = true
     * isAllLowerCase("abC")  = false
     * isAllLowerCase("ab c") = false (space is not a lowercase letter)
     * isAllLowerCase("ab1")  = false (digit is not a lowercase letter)
     * }</pre>
     *
     * @param cs the CharSequence to check, which may be null
     * @return {@code true} if all characters are lowercase or the CharSequence is empty; {@code false} otherwise
     */
    public static boolean isAllLowerCase(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLowerCase(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all characters in the given CharSequence are uppercase.
     *
     * <p>This method returns {@code true} if all characters in the CharSequence are uppercase letters
     * according to {@link Character#isUpperCase(char)}. An empty CharSequence or {@code null} returns
     * {@code true}. Note that non-letter characters will cause this method to return {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAllUpperCase(null)   = true
     * isAllUpperCase("")     = true
     * isAllUpperCase("ABC")  = true
     * isAllUpperCase("ABc")  = false
     * isAllUpperCase("AB C") = false (space is not an uppercase letter)
     * isAllUpperCase("AB1")  = false (digit is not an uppercase letter)
     * }</pre>
     *
     * @param cs the CharSequence to check, which may be null
     * @return {@code true} if all characters are uppercase or the CharSequence is empty; {@code false} otherwise
     */
    public static boolean isAllUpperCase(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isUpperCase(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains mixed case characters.
     *
     * <p>A CharSequence is considered mixed case if it contains both uppercase and lowercase characters.
     * If the CharSequence is empty, {@code null}, or contains only a single character, it is not considered
     * mixed case and the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isMixedCase(null)    = false
     * isMixedCase("")      = false
     * isMixedCase("a")     = false
     * isMixedCase("A")     = false
     * isMixedCase("abc")   = false
     * isMixedCase("ABC")   = false
     * isMixedCase("aBc")   = true
     * isMixedCase("Hello") = true
     * isMixedCase("123")   = false (no letters)
     * isMixedCase("a1B2")  = true
     * }</pre>
     *
     * @param cs The CharSequence to check. It may be {@code null}.
     * @return {@code true} if the CharSequence is mixed case, {@code false} otherwise.
     */
    public static boolean isMixedCase(final CharSequence cs) {
        if (isEmpty(cs) || cs.length() == 1) {
            return false;
        }

        boolean containsUppercase = false;
        boolean containsLowercase = false;
        final int len = cs.length();

        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (Character.isUpperCase(ch)) {
                containsUppercase = true;
            } else if (Character.isLowerCase(ch)) {
                containsLowercase = true;
            }

            if (containsUppercase && containsLowercase) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified character is a digit.
     *
     * <p>This method delegates to {@link Character#isDigit(char)} to determine if the character
     * is a digit (0-9) according to Unicode standards. This includes not only ASCII digits but
     * also digits from other Unicode scripts.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isDigit('0') = true
     * isDigit('9') = true
     * isDigit('a') = false
     * isDigit('A') = false
     * isDigit('') = true (Arabic-Indic digit zero)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a digit, {@code false} otherwise
     * @see Character#isDigit(char)
     */
    public static boolean isDigit(final char ch) {
        return Character.isDigit(ch);
    }

    /**
     * Checks if the specified character is a letter.
     *
     * <p>This method delegates to {@link Character#isLetter(char)} to determine if the character
     * is a letter according to Unicode standards. This includes letters from all Unicode scripts,
     * not just ASCII letters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isLetter('a') = true
     * isLetter('A') = true
     * isLetter('') = true
     * isLetter('') = true
     * isLetter('1') = false
     * isLetter(' ') = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a letter, {@code false} otherwise
     * @see Character#isLetter(char)
     */
    public static boolean isLetter(final char ch) {
        return Character.isLetter(ch);
    }

    /**
     * Checks if the specified character is a letter or digit.
     *
     * <p>This method delegates to {@link Character#isLetterOrDigit(char)} to determine if the character
     * is either a letter or a digit according to Unicode standards. This includes letters and digits
     * from all Unicode scripts, not just ASCII.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isLetterOrDigit('a') = true
     * isLetterOrDigit('A') = true
     * isLetterOrDigit('1') = true
     * isLetterOrDigit('') = true
     * isLetterOrDigit('') = true
     * isLetterOrDigit(' ') = false
     * isLetterOrDigit('!') = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a letter or digit, {@code false} otherwise
     * @see Character#isLetterOrDigit(char)
     */
    public static boolean isLetterOrDigit(final char ch) {
        return Character.isLetterOrDigit(ch);
    }

    // --------------------------------------------------------------------------

    /**
     * Checks whether the character is ASCII 7 bit.
     *
     * <p>This method checks if the character value is less than 128, which means it belongs to the
     * standard ASCII character set (0-127). ASCII 7-bit includes control characters, printable
     * characters, letters, digits, and special symbols.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAscii('a')  = true
     * isAscii('A')  = true
     * isAscii('3')  = true
     * isAscii('-')  = true
     * isAscii('\n') = true
     * isAscii('')  = false (value 169)
     * isAscii('')  = false (value 241)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character value is less than 128, {@code false} otherwise
     */
    public static boolean isAscii(final char ch) {
        return ch < 128;
    }

    /**
     * Checks whether the character is ASCII 7 bit printable.
     *
     * <p>This method checks if the character is in the range of printable ASCII characters,
     * which are characters with values from 32 to 126 inclusive. This range includes space,
     * letters, digits, punctuation, and symbols, but excludes control characters.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiPrintable('a')  = true
     * isAsciiPrintable('A')  = true
     * isAsciiPrintable('3')  = true
     * isAsciiPrintable('-')  = true
     * isAsciiPrintable(' ')  = true (space, value 32)
     * isAsciiPrintable('~')  = true (tilde, value 126)
     * isAsciiPrintable('\n') = false (newline, value 10)
     * isAsciiPrintable('\t') = false (tab, value 9)
     * isAsciiPrintable('')  = false (value 169)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 32 and 126 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiPrintable(final char ch) {
        return ch > 31 && ch < 127;
    }

    /**
     * Checks whether the character is ASCII 7 bit control.
     *
     * <p>This method checks if the character is an ASCII control character. Control characters
     * are those with values less than 32 or equal to 127 (DEL). These include characters like
     * newline, carriage return, tab, and other non-printable control codes.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiControl('\n') = true (newline, value 10)
     * isAsciiControl('\r') = true (carriage return, value 13)
     * isAsciiControl('\t') = true (tab, value 9)
     * isAsciiControl('\0') = true (null, value 0)
     * isAsciiControl('\u007F') = true (DEL, value 127)
     * isAsciiControl('a')  = false
     * isAsciiControl('A')  = false
     * isAsciiControl(' ')  = false (space, value 32)
     * isAsciiControl('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if less than 32 or equals 127, {@code false} otherwise
     */
    public static boolean isAsciiControl(final char ch) {
        return ch < 32 || ch == 127;
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic.
     *
     * <p>This method checks if the character is an ASCII letter, either uppercase (A-Z) or
     * lowercase (a-z). It does not include letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiAlpha('a')  = true
     * isAsciiAlpha('A')  = true
     * isAsciiAlpha('z')  = true
     * isAsciiAlpha('Z')  = true
     * isAsciiAlpha('3')  = false
     * isAsciiAlpha('-')  = false
     * isAsciiAlpha('\n') = false
     * isAsciiAlpha('')  = false
     * isAsciiAlpha('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 65 and 90 or 97 and 122 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiAlpha(final char ch) {
        return isAsciiAlphaUpper(ch) || isAsciiAlphaLower(ch);
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic upper case.
     *
     * <p>This method checks if the character is an ASCII uppercase letter (A-Z).
     * It does not include uppercase letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiAlphaUpper('A')  = true
     * isAsciiAlphaUpper('Z')  = true
     * isAsciiAlphaUpper('a')  = false
     * isAsciiAlphaUpper('3')  = false
     * isAsciiAlphaUpper('-')  = false
     * isAsciiAlphaUpper('\n') = false
     * isAsciiAlphaUpper('')  = false
     * isAsciiAlphaUpper('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 65 and 90 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiAlphaUpper(final char ch) {
        return ch >= 'A' && ch <= 'Z';
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic lower case.
     *
     * <p>This method checks if the character is an ASCII lowercase letter (a-z).
     * It does not include lowercase letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiAlphaLower('a')  = true
     * isAsciiAlphaLower('z')  = true
     * isAsciiAlphaLower('A')  = false
     * isAsciiAlphaLower('3')  = false
     * isAsciiAlphaLower('-')  = false
     * isAsciiAlphaLower('\n') = false
     * isAsciiAlphaLower('')  = false
     * isAsciiAlphaLower('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 97 and 122 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiAlphaLower(final char ch) {
        return ch >= 'a' && ch <= 'z';
    }

    /**
     * Checks whether the character is ASCII 7 bit numeric.
     *
     * <p>This method checks if the character is an ASCII digit (0-9). It does not include
     * digits from extended character sets or other Unicode scripts.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiNumeric('0')  = true
     * isAsciiNumeric('9')  = true
     * isAsciiNumeric('5')  = true
     * isAsciiNumeric('a')  = false
     * isAsciiNumeric('A')  = false
     * isAsciiNumeric('-')  = false
     * isAsciiNumeric('\n') = false
     * isAsciiNumeric('')  = false (Arabic-Indic digit)
     * isAsciiNumeric('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 48 and 57 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiNumeric(final char ch) {
        return ch >= '0' && ch <= '9';
    }

    /**
     * Checks whether the character is ASCII 7 bit alphanumeric.
     *
     * <p>This method checks if the character is either an ASCII letter (A-Z, a-z) or an
     * ASCII digit (0-9). It combines the checks from {@link #isAsciiAlpha(char)} and
     * {@link #isAsciiNumeric(char)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiAlphanumeric('a')  = true
     * isAsciiAlphanumeric('A')  = true
     * isAsciiAlphanumeric('3')  = true
     * isAsciiAlphanumeric('z')  = true
     * isAsciiAlphanumeric('Z')  = true
     * isAsciiAlphanumeric('0')  = true
     * isAsciiAlphanumeric('-')  = false
     * isAsciiAlphanumeric(' ')  = false
     * isAsciiAlphanumeric('\n') = false
     * isAsciiAlphanumeric('')  = false
     * isAsciiAlphanumeric('')  = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 48 and 57 or 65 and 90 or 97 and 122 inclusive, {@code false} otherwise
     */
    public static boolean isAsciiAlphanumeric(final char ch) {
        return isAsciiAlpha(ch) || isAsciiNumeric(ch);
    }

    /**
     * Checks if the CharSequence contains only ASCII printable characters.
     *
     * <p>This method checks if all characters in the CharSequence are ASCII printable characters
     * (values 32-126). An empty CharSequence returns {@code true}, while {@code null} returns
     * {@code false}. The method will return {@code false} if any character is outside the
     * printable ASCII range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * isAsciiPrintable(null)     = false
     * isAsciiPrintable("")       = true
     * isAsciiPrintable(" ")      = true
     * isAsciiPrintable("Ceki")   = true
     * isAsciiPrintable("ab2c")   = true
     * isAsciiPrintable("!ab-c~") = true
     * isAsciiPrintable("\u0020") = true (space)
     * isAsciiPrintable("\u0021") = true (!)
     * isAsciiPrintable("\u007e") = true (~)
     * isAsciiPrintable("\u007f") = false (DEL)
     * isAsciiPrintable("Ceki Glc") = false (contains non-ASCII)
     * isAsciiPrintable("abc\n")  = false (contains newline)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be null
     * @return {@code true} if every character is ASCII printable, {@code false} if the CharSequence is null or contains non-printable characters
     */
    public static boolean isAsciiPrintable(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiPrintable(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphabetic characters (a-z, A-Z).
     *
     * <p>ASCII alphabetic characters are those in the ranges 'a' through 'z' (lowercase) and 'A' through 'Z' (uppercase).
     * The method does not consider non-ASCII Unicode letters as alphabetic.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // ASCII alphabetic strings
     * isAsciiAlpha("abcDEF");                // returns true
     * isAsciiAlpha("HelloWorld");            // returns true
     * 
     * // Non-ASCII alphabetic strings
     * isAsciiAlpha(null);                    // returns false
     * isAsciiAlpha("");                      // returns false
     * isAsciiAlpha("abc123");                // returns false (contains digits)
     * isAsciiAlpha("hello world");           // returns false (contains space)
     * isAsciiAlpha("caf");                  // returns false (contains non-ASCII character)
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence contains only ASCII alphabetic characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isAlpha(CharSequence)
     * @see #isAsciiAlphaSpace(CharSequence)
     */
    public static boolean isAsciiAlpha(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiAlpha(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphabetic characters (a-z, A-Z) and spaces.
     *
     * <p>ASCII alphabetic characters are those in the ranges 'a' through 'z' (lowercase) and 'A' through 'Z' (uppercase).
     * Space character (' ') is also allowed. The method does not consider non-ASCII Unicode letters or other whitespace characters.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // ASCII alphabetic strings with spaces
     * isAsciiAlphaSpace("Hello World");      // returns true
     * isAsciiAlphaSpace("The Quick Brown");  // returns true
     * isAsciiAlphaSpace("");                 // returns true
     * 
     * // Invalid strings
     * isAsciiAlphaSpace(null);               // returns false
     * isAsciiAlphaSpace("Hello123");         // returns false (contains digits)
     * isAsciiAlphaSpace("Hello\tWorld");     // returns false (contains tab)
     * isAsciiAlphaSpace("caf");             // returns false (contains non-ASCII character)
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence contains only ASCII alphabetic characters and spaces and is non-null, {@code false} otherwise.
     * @see #isAsciiAlpha(CharSequence)
     * @see #isAlphaSpace(CharSequence)
     */
    public static boolean isAsciiAlphaSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!isAsciiAlpha(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphanumeric characters (a-z, A-Z, 0-9).
     *
     * <p>ASCII alphanumeric characters include letters in the ranges 'a' through 'z' (lowercase),
     * 'A' through 'Z' (uppercase), and digits '0' through '9'. The method does not consider
     * non-ASCII Unicode letters or digits as alphanumeric.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // ASCII alphanumeric strings
     * isAsciiAlphanumeric("abc123");         // returns true
     * isAsciiAlphanumeric("HelloWorld2023"); // returns true
     * isAsciiAlphanumeric("ABC");            // returns true
     * isAsciiAlphanumeric("123");            // returns true
     * 
     * // Non-ASCII alphanumeric strings
     * isAsciiAlphanumeric(null);             // returns false
     * isAsciiAlphanumeric("");               // returns false
     * isAsciiAlphanumeric("hello world");    // returns false (contains space)
     * isAsciiAlphanumeric("user@email");     // returns false (contains special character)
     * isAsciiAlphanumeric("caf123");        // returns false (contains non-ASCII character)
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence contains only ASCII alphanumeric characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isAlphanumeric(CharSequence)
     * @see #isAsciiAlpha(CharSequence)
     * @see #isAsciiNumeric(CharSequence)
     */
    public static boolean isAsciiAlphanumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiAlphanumeric(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphanumeric characters (a-z, A-Z, 0-9) and spaces.
     *
     * <p>ASCII alphanumeric characters include letters in the ranges 'a' through 'z' (lowercase),
     * 'A' through 'Z' (uppercase), and digits '0' through '9'. Space character (' ') is also allowed.
     * The method does not consider non-ASCII Unicode letters, digits, or other whitespace characters.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // ASCII alphanumeric strings with spaces
     * isAsciiAlphanumericSpace("Hello World 123");  // returns true
     * isAsciiAlphanumericSpace("Test 2023");        // returns true
     * isAsciiAlphanumericSpace("");                 // returns true
     * 
     * // Invalid strings
     * isAsciiAlphanumericSpace(null);               // returns false
     * isAsciiAlphanumericSpace("Hello@World");      // returns false (contains special character)
     * isAsciiAlphanumericSpace("Test\t123");        // returns false (contains tab)
     * isAsciiAlphanumericSpace("caf 2023");        // returns false (contains non-ASCII character)
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence contains only ASCII alphanumeric characters and spaces and is non-null, {@code false} otherwise.
     * @see #isAsciiAlphanumeric(CharSequence)
     * @see #isAlphanumericSpace(CharSequence)
     */
    public static boolean isAsciiAlphanumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!isAsciiAlphanumeric(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII numeric characters (0-9).
     *
     * <p>ASCII numeric characters are those in the range '0' through '9'. The method does not
     * consider decimal points, signs (+ or -), or non-ASCII Unicode digits as numeric.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // ASCII numeric strings
     * isAsciiNumeric("123");                 // returns true
     * isAsciiNumeric("0");                   // returns true
     * isAsciiNumeric("9876543210");          // returns true
     * 
     * // Non-ASCII numeric strings
     * isAsciiNumeric(null);                  // returns false
     * isAsciiNumeric("");                    // returns false
     * isAsciiNumeric("12.3");                // returns false (contains decimal point)
     * isAsciiNumeric("-123");                // returns false (contains minus sign)
     * isAsciiNumeric("12 34");               // returns false (contains space)
     * isAsciiNumeric("12a");                 // returns false (contains letter)
     * }</pre>
     *
     * @param cs The CharSequence to be checked. It can be {@code null} or empty.
     * @return {@code true} if the CharSequence contains only ASCII numeric characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isNumeric(CharSequence)
     * @see #isAsciiDigitalNumber(String)
     */
    public static boolean isAsciiNumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiNumeric(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    // Character Tests
    // -----------------------------------------------------------------------

    /**
     * Checks if the CharSequence contains only Unicode letters.
     *
     * <p>This method uses {@link Character#isLetter(char)} to check each character, which includes
     * all Unicode letters from any language, not just ASCII letters. This is broader than
     * {@link #isAsciiAlpha(CharSequence)} which only checks for ASCII letters.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode letter strings
     * isAlpha("abc");                        // returns true
     * isAlpha("ABC");                        // returns true
     * isAlpha("");                        // returns true (Greek letters)
     * isAlpha("");                        // returns true (Chinese characters)
     * isAlpha("caf");                       // returns true (includes accented letter)
     * 
     * // Non-letter strings
     * isAlpha(null);                         // returns false
     * isAlpha("");                           // returns false
     * isAlpha("  ");                         // returns false (contains spaces)
     * isAlpha("ab2c");                       // returns false (contains digit)
     * isAlpha("ab-c");                       // returns false (contains hyphen)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains letters and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isLetter(char)
     * @see #isAsciiAlpha(CharSequence)
     */
    public static boolean isAlpha(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLetter(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters and space (' ').
     *
     * <p>This method uses {@link Character#isLetter(char)} to check each character (except spaces),
     * which includes all Unicode letters from any language. Only the space character (' ') is
     * allowed as whitespace; tabs, newlines, and other whitespace characters are not allowed.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode letter strings with spaces
     * isAlphaSpace("Hello World");           // returns true
     * isAlphaSpace("caf au lait");          // returns true
     * isAlphaSpace(" ");               // returns true (Chinese with space)
     * isAlphaSpace("");                      // returns true (empty string)
     * isAlphaSpace("  ");                    // returns true (only spaces)
     * 
     * // Invalid strings
     * isAlphaSpace(null);                    // returns false
     * isAlphaSpace("ab c");                  // returns true
     * isAlphaSpace("ab2c");                  // returns false (contains digit)
     * isAlphaSpace("ab-c");                  // returns false (contains hyphen)
     * isAlphaSpace("ab\tc");                 // returns false (contains tab)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains letters and spaces and is non-null, {@code false} otherwise.
     * @see #isAlpha(CharSequence)
     * @see #isAsciiAlphaSpace(CharSequence)
     */
    public static boolean isAlphaSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isLetter(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters or digits.
     *
     * <p>This method uses {@link Character#isLetterOrDigit(char)} to check each character,
     * which includes all Unicode letters and digits from any language, not just ASCII.
     * This is broader than {@link #isAsciiAlphanumeric(CharSequence)}.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode alphanumeric strings
     * isAlphanumeric("abc");                 // returns true
     * isAlphanumeric("abc123");              // returns true
     * isAlphanumeric("123");              // returns true (Greek letters with digits)
     * isAlphanumeric("123");              // returns true (Chinese with digits)
     * isAlphanumeric("caf2023");            // returns true
     * 
     * // Invalid strings
     * isAlphanumeric(null);                  // returns false
     * isAlphanumeric("");                    // returns false
     * isAlphanumeric("  ");                  // returns false (contains spaces)
     * isAlphanumeric("ab c");                // returns false (contains space)
     * isAlphanumeric("ab2c");                // returns true
     * isAlphanumeric("ab-c");                // returns false (contains hyphen)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains letters or digits and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isLetterOrDigit(char)
     * @see #isAsciiAlphanumeric(CharSequence)
     */
    public static boolean isAlphanumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLetterOrDigit(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters, digits or space (' ').
     *
     * <p>This method uses {@link Character#isLetterOrDigit(char)} to check each character (except spaces),
     * which includes all Unicode letters and digits from any language. Only the space character (' ')
     * is allowed as whitespace; tabs, newlines, and other whitespace characters are not allowed.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode alphanumeric strings with spaces
     * isAlphanumericSpace("Hello World 123");       // returns true
     * isAlphanumericSpace("caf au lait 2023");     // returns true
     * isAlphanumericSpace(" 123");                // returns true
     * isAlphanumericSpace("");                      // returns true (empty string)
     * isAlphanumericSpace("  ");                    // returns true (only spaces)
     * 
     * // Invalid strings
     * isAlphanumericSpace(null);                    // returns false
     * isAlphanumericSpace("ab c");                  // returns true
     * isAlphanumericSpace("ab2c");                  // returns true
     * isAlphanumericSpace("ab-c");                  // returns false (contains hyphen)
     * isAlphanumericSpace("ab\tc");                 // returns false (contains tab)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains letters, digits or spaces and is non-null, {@code false} otherwise.
     * @see #isAlphanumeric(CharSequence)
     * @see #isAsciiAlphanumericSpace(CharSequence)
     */
    public static boolean isAlphanumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isLetterOrDigit(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode digits.
     *
     * <p>This method uses {@link Character#isDigit(char)} to check each character, which includes
     * all Unicode digit characters from any language, not just ASCII digits 0-9. A decimal point
     * is not a Unicode digit and returns {@code false}.</p>
     *
     * <p>The method returns {@code false} for null or empty input.</p>
     *
     * <p>Note that the method does not allow for a leading sign, either positive or negative.
     * Also, if a String passes the numeric test, it may still generate a NumberFormatException
     * when parsed by Integer.parseInt or Long.parseLong, e.g., if the value is outside the
     * range for int or long respectively.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode numeric strings
     * isNumeric("123");                      // returns true
     * isNumeric("");                      // returns true (Devanagari digits)
     * isNumeric("");                      // returns true (Arabic-Indic digits)
     * 
     * // Invalid strings
     * isNumeric(null);                       // returns false
     * isNumeric("");                         // returns false
     * isNumeric("  ");                       // returns false (contains spaces)
     * isNumeric("12 3");                     // returns false (contains space)
     * isNumeric("ab2c");                     // returns false (contains letters)
     * isNumeric("12-3");                     // returns false (contains hyphen)
     * isNumeric("12.3");                     // returns false (contains decimal point)
     * isNumeric("-123");                     // returns false (contains minus sign)
     * isNumeric("+123");                     // returns false (contains plus sign)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains digits and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isDigit(char)
     * @see #isAsciiNumeric(CharSequence)
     * @see #isNumber(String)
     */
    public static boolean isNumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isDigit(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode digits or space (' ').
     *
     * <p>This method uses {@link Character#isDigit(char)} to check each character (except spaces),
     * which includes all Unicode digit characters from any language. A decimal point is not a
     * Unicode digit and returns {@code false}. Only the space character (' ') is allowed as
     * whitespace.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Unicode numeric strings with spaces
     * isNumericSpace("123 456");             // returns true
     * isNumericSpace(" ");             // returns true (Devanagari digits with space)
     * isNumericSpace("");                    // returns true (empty string)
     * isNumericSpace("  ");                  // returns true (only spaces)
     * isNumericSpace("\u0967\u0968\u0969"); // returns true
     * isNumericSpace("\u0967\u0968 \u0969");// returns true
     * 
     * // Invalid strings
     * isNumericSpace(null);                  // returns false
     * isNumericSpace("ab2c");                // returns false (contains letters)
     * isNumericSpace("12-3");                // returns false (contains hyphen)
     * isNumericSpace("12.3");                // returns false (contains decimal point)
     * isNumericSpace("12\t3");               // returns false (contains tab)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains digits or spaces and is non-null, {@code false} otherwise.
     * @see #isNumeric(CharSequence)
     * @see Character#isDigit(char)
     */
    public static boolean isNumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isDigit(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only whitespace.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}, which includes space,
     * tab, newline, carriage return, form feed, and other Unicode whitespace characters.</p>
     *
     * <p>The method returns {@code false} for null input, but {@code true} for empty string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Whitespace strings
     * isWhitespace("");                      // returns true (empty string)
     * isWhitespace("  ");                    // returns true (spaces)
     * isWhitespace("\t\n\r");                // returns true (tab, newline, carriage return)
     * isWhitespace("  \t  ");                // returns true (mixed whitespace)
     * 
     * // Non-whitespace strings
     * isWhitespace(null);                    // returns false
     * isWhitespace("abc");                   // returns false (contains letters)
     * isWhitespace("ab2c");                  // returns false (contains letters and digit)
     * isWhitespace("ab-c");                  // returns false (contains letters and hyphen)
     * isWhitespace(" a ");                   // returns false (contains letter)
     * }</pre>
     *
     * @param cs The CharSequence to check, which may be null
     * @return {@code true} if only contains whitespace and is non-null, {@code false} otherwise.
     * @see Character#isWhitespace(char)
     */
    public static boolean isWhitespace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Note: It's copied from NumberUtils in Apache Commons Lang under Apache
     * License 2.0
     *
     * <p>
     * Checks whether the String a valid Java number. {@code true} is
     * returned if there is a number which can be initialized by
     * {@code createNumber} with specified String.
     * </p>
     *
     * <p>
     * {@code Null} and empty String will return {@code false}.
     * </p>
     *
     * @param str the {@code String} to check
     * @return {@code true} if the string is a correctly formatted number
     * @see Numbers#isNumber(String)
     * @see Numbers#isCreatable(String)
     * @see Numbers#isParsable(String)
     *        validation
     * @deprecated use {@link Numbers#isNumber(String)} instead
     */
    @Deprecated
    public static boolean isNumber(final String str) {
        return Numbers.isNumber(str);
    }

    /**
     * Checks if the given string contains only ASCII digital number characters.
     *
     * <p>ASCII digital numbers can include digits (0-9), decimal point (.), signs (+ or -),
     * and exponential notation (e or E). The method validates proper number format including
     * optional sign, integer part, optional decimal part, and optional exponential part.</p>
     *
     * <p>The method returns {@code false} for null, empty strings, or strings containing spaces.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid ASCII digital numbers
     * isAsciiDigitalNumber("0");             // returns true
     * isAsciiDigitalNumber("123");           // returns true
     * isAsciiDigitalNumber("-456");          // returns true
     * isAsciiDigitalNumber("+789");          // returns true
     * isAsciiDigitalNumber("12.34");         // returns true
     * isAsciiDigitalNumber("2e10");          // returns true
     * isAsciiDigitalNumber("2E-10");         // returns true
     * isAsciiDigitalNumber("-3.14e+5");      // returns true
     * 
     * // Invalid strings
     * isAsciiDigitalNumber(null);            // returns false
     * isAsciiDigitalNumber("");              // returns false
     * isAsciiDigitalNumber(" 0.1 ");         // returns false (contains spaces)
     * isAsciiDigitalNumber("abc");           // returns false (contains letters)
     * isAsciiDigitalNumber("1 a");           // returns false (contains space and letter)
     * isAsciiDigitalNumber("1.2.3");         // returns false (multiple decimal points)
     * isAsciiDigitalNumber("e10");           // returns false (no digits before 'e')
     * }</pre>
     *
     * @param str The string to check, which may be null
     * @return {@code true} if the string represents a valid ASCII digital number, {@code false} otherwise.
     * @see #isAsciiDigitalInteger(String)
     * @see #isNumber(String)
     */
    public static boolean isAsciiDigitalNumber(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        int count = 0;
        final int len = str.length();
        char ch = str.charAt(0);
        int i = 0;

        if (ch == '+' || ch == '-') {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (i < len && str.charAt(i) == '.') {
            if (count == 0) {
                return false;
            } else {
                count = 0;
            }

            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (count == 0) {
            return false;
        }

        if (i == len) {
            return true;
        }

        ch = str.charAt(i);

        if (ch != 'e' && ch != 'E') {
            return false;
        } else {
            i++;
        }

        count = 0;

        if (i < len && (str.charAt(i) == '+' || str.charAt(i) == '-')) {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        //NOSONAR
        return (count != 0) && (i == len);
    }

    /**
     * Checks if the given string contains only ASCII digital integer characters.
     *
     * <p>ASCII digital integers can include digits (0-9) and optional leading sign (+ or -).
     * The method does not allow decimal points, exponential notation, or any other characters.
     * Empty strings and strings containing only a sign are considered invalid.</p>
     *
     * <p>The method returns {@code false} for null, empty strings, or strings containing spaces.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid ASCII digital integers
     * isAsciiDigitalInteger("0");            // returns true
     * isAsciiDigitalInteger("123");          // returns true
     * isAsciiDigitalInteger("-123");         // returns true
     * isAsciiDigitalInteger("+123");         // returns true
     * isAsciiDigitalInteger("+0");           // returns true
     * isAsciiDigitalInteger("-0");           // returns true
     * 
     * // Invalid strings
     * isAsciiDigitalInteger(null);           // returns false
     * isAsciiDigitalInteger("");             // returns false
     * isAsciiDigitalInteger(" 0.1 ");        // returns false (contains spaces and decimal)
     * isAsciiDigitalInteger("12.34");        // returns false (contains decimal point)
     * isAsciiDigitalInteger("abc");          // returns false (contains letters)
     * isAsciiDigitalInteger("1 a");          // returns false (contains space and letter)
     * isAsciiDigitalInteger("2e10");         // returns false (contains exponential notation)
     * isAsciiDigitalInteger("+");            // returns false (only sign, no digits)
     * }</pre>
     *
     * @param str The string to check, which may be null
     * @return {@code true} if the string represents a valid ASCII digital integer, {@code false} otherwise.
     * @see #isAsciiDigitalNumber(String)
     * @see #isAsciiNumeric(CharSequence)
     */
    public static boolean isAsciiDigitalInteger(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        int count = 0;

        final int len = str.length();
        char ch = str.charAt(0);
        int i = 0;

        if (ch == '+' || ch == '-') {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (count == 0) {
            return false;
        }

        return i == len;
    }

    /**
     * Returns the index within this string of the first occurrence of the specified character.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence
     * represented by this {@code String} object, then the index of the first such occurrence
     * is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} for null or empty input strings.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Character found
     * indexOf("hello", 'h');                 // returns 0
     * indexOf("hello", 'e');                 // returns 1
     * indexOf("hello", 'o');                 // returns 4
     * indexOf("hello world", ' ');           // returns 5
     * 
     * // Character not found
     * indexOf("hello", 'x');                 // returns -1
     * indexOf(null, 'a');                    // returns -1
     * indexOf("", 'a');                      // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param charValueToFind The Unicode code of the character to be found.
     * @return The index of the first occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur.
     * @see String#indexOf(int)
     */
    public static int indexOf(final String str, final int charValueToFind) {
        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(charValueToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified character, starting the search at the specified index.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first such occurrence is returned. If {@code fromIndex} is negative,
     * it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} for null or empty input strings.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Character found
     * indexOf("hello", 'l', 0);              // returns 2
     * indexOf("hello", 'l', 3);              // returns 3
     * indexOf("hello", 'o', 0);              // returns 4
     * 
     * // Character not found
     * indexOf("hello", 'h', 1);              // returns -1
     * indexOf("hello", 'x', 0);              // returns -1
     * indexOf(null, 'a', 0);                 // returns -1
     * indexOf("", 'a', 0);                   // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param charValueToFind The Unicode code of the character to be found.
     * @param fromIndex The index to start the search from.
     * @return The index of the first occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur.
     * @see String#indexOf(int, int)
     */
    public static int indexOf(final String str, final int charValueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(charValueToFind, fromIndex);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first character
     * of the first such substring is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if the substring is not found, or if either parameter is null,
     * or if the substring is longer than the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Substring found
     * indexOf("hello world", "world");       // returns 6
     * indexOf("hello world", "hello");       // returns 0
     * indexOf("hello world", "o");           // returns 4
     * indexOf("hello world", "");            // returns 0 (empty string always found at index 0)
     * 
     * // Substring not found
     * indexOf("hello", "world");             // returns -1
     * indexOf(null, "test");                 // returns -1
     * indexOf("test", null);                 // returns -1
     * indexOf("", "test");                   // returns -1 (substring longer than string)
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see String#indexOf(String)
     */
    public static int indexOf(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(valueToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, starting the search at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first character of the first such substring is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if the substring is not found, or if either parameter is null,
     * or if the substring cannot fit in the remaining portion of the string from {@code fromIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Substring found
     * indexOf("hello world", "o", 0);        // returns 4
     * indexOf("hello world", "o", 5);        // returns 7
     * indexOf("hello world", "world", 0);    // returns 6
     * 
     * // Substring not found
     * indexOf("hello", "o", 5);              // returns -1 (fromIndex beyond string)
     * indexOf("hello", "world", 0);          // returns -1
     * indexOf(null, "test", 0);              // returns -1
     * indexOf("test", null, 0);              // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found.
     * @param fromIndex The index to start the search from.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see String#indexOf(String, int)
     */
    public static int indexOf(final String str, final String valueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || valueToFind == null || valueToFind.length() > str.length() - fromIndex) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(valueToFind, fromIndex);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified character.
     *
     * <p>If any character within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first such occurrence
     * is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if none of the characters are found, or if the input string
     * is null or empty, or if the character array is null or empty.</p>
     * 
     * <p>Note: Use the {@code indexOf(String, int)} method when searching for a single character to avoid ambiguous compilation errors.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Characters found
     * indexOfAny("hello", 'e', 'o');         // returns 1 (first 'e')
     * indexOfAny("hello", 'o', 'l');         // returns 2 (first 'l')
     * indexOfAny("hello", 'x', 'y', 'h');    // returns 0 (first 'h')
     * 
     * // Characters not found
     * indexOfAny("hello", 'x', 'y', 'z');    // returns -1
     * indexOfAny(null, 'a');                 // returns -1
     * indexOfAny("", 'a');                   // returns -1
     * indexOfAny("hello");                   // returns -1 (empty array)
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of characters to be found.
     * @return The index of the first occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur.
     * @see #indexOfAny(String, int, char...)
     * @see #indexOf(String, int)
     */
    public static int indexOfAny(final String str, final char... valuesToFind) {
        return indexOfAny(str, 0, valuesToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified character, starting the search at the specified index.
     *
     * <p>If any character within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first such occurrence is returned. If {@code fromIndex} is negative,
     * it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if none of the characters are found, or if the input string
     * is null or empty, or if the character array is null or empty.</p>
     * 
     * <p>Note: Use the {@code indexOf(String, int, int)} method when searching for a single character to avoid ambiguous compilation errors.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Characters found
     * indexOfAny("hello", 0, 'e', 'o');      // returns 1 (first 'e')
     * indexOfAny("hello", 2, 'e', 'o');      // returns 4 (first 'o' after index 2)
     * indexOfAny("hello", 0, 'l');           // returns 2 (first 'l')
     * 
     * // Characters not found
     * indexOfAny("hello", 5, 'h', 'e');      // returns -1 (no match after index 5)
     * indexOfAny("hello", 0, 'x', 'y');      // returns -1
     * indexOfAny(null, 0, 'a');              // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param fromIndex The index to start the search from.
     * @param valuesToFind The array of characters to be found.
     * @return The index of the first occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur.
     * @see #indexOfAny(String, char...)
     * @see #indexOf(String, int, int)
     */
    public static int indexOfAny(final String str, int fromIndex, final char... valuesToFind) {
        // public static int indexOfAny(final String str, int fromIndex, final char... valuesToFind) { // indexOfAny is ambiguous both method indexOfAny(java.lang.String,int,char...) in com.landawn.abacus.util.Strings and method indexOfAny(java.lang.String,int,java.lang.String...)
        fromIndex = Math.max(0, fromIndex);

        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        final int strLen = str.length();
        char ch = 0;

        for (int i = fromIndex; i < strLen; i++) {
            ch = str.charAt(i);

            for (final char c : valuesToFind) {
                if (c == ch) {
                    // checked by checkInputChars

                    //    if (i < strLast && j < chsLast && Character.isHighSurrogate(ch)) {
                    //        // ch is a supplementary character
                    //        if (valuesToFind[j + 1] == str.charAt(i + 1)) {
                    //            return i;
                    //        }
                    //    } else {
                    //        return i;
                    //    }

                    return i;
                }
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified substring.
     *
     * <p>If any substring within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first character of
     * the first such substring is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if none of the substrings are found, or if the input string
     * is null, or if the substring array is null or empty. Empty substrings in the array are ignored.</p>
     * 
     * <p>Note: Use the {@code indexOf(String, String)} method when searching for a single string to avoid ambiguous compilation errors.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Substrings found
     * indexOfAny("hello world", "world", "hello");    // returns 0 ("hello" comes first)
     * indexOfAny("hello world", "xyz", "world");      // returns 6 ("world" found)
     * indexOfAny("hello world", "o", "e");            // returns 1 ("e" comes first)
     * 
     * // Substrings not found
     * indexOfAny("hello", "xyz", "abc");              // returns -1
     * indexOfAny(null, "test");                       // returns -1
     * indexOfAny("test", (String[]) null);            // returns -1
     * indexOfAny("test", new String[0]);              // returns -1 (empty array)
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of substrings to be found.
     * @return The index of the first occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur.
     * @see #indexOfAny(String, int, String...)
     * @see #indexOf(String, String)
     */
    public static int indexOfAny(final String str, final String... valuesToFind) {
        return indexOfAny(str, 0, valuesToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified substring, starting the search at the specified index.
     *
     * <p>If any substring within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first character of the first such substring is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if none of the substrings are found, or if the input string
     * is null, or if the substring array is null or empty. Empty substrings in the array are ignored.</p>
     * 
     * <p>Note: Use the {@code indexOf(String, String, int)} method when searching for a single string to avoid ambiguous compilation errors.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Substrings found
     * indexOfAny("hello world", 0, "world", "hello"); // returns 0 ("hello" at index 0)
     * indexOfAny("hello world", 6, "world", "hello"); // returns 6 ("world" at index 6)
     * indexOfAny("hello world", 7, "world", "o");     // returns 7 ("o" at index 7)
     * 
     * // Substrings not found
     * indexOfAny("hello", 0, "xyz", "abc");           // returns -1
     * indexOfAny("hello", 10, "h", "e");              // returns -1 (fromIndex beyond string)
     * indexOfAny(null, 0, "test");                    // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param fromIndex The index to start the search from.
     * @param valuesToFind The array of substrings to be found.
     * @return The index of the first occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String...)
     * @see #indexOf(String, String, int)
     */
    public static int indexOfAny(final String str, int fromIndex, final String... valuesToFind) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        int idx = 0;

        for (final String element : valuesToFind) {
            if (isEmpty(element)) {
                continue;
            }

            idx = indexOf(str, element, fromIndex);

            if (idx != N.INDEX_NOT_FOUND) {
                return idx;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of any character
     * that is not in the specified array of characters to exclude.
     *
     * <p>If a character not within the array {@code valuesToExclude} occurs in the character
     * sequence represented by the input {@code String} object, then the index of the first
     * such occurrence is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if all characters in the string are in the exclusion array,
     * or if the string is null or empty. If the exclusion array is null or empty, returns 0
     * (the first character is not excluded).</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Characters not in exclusion array found
     * indexOfAnyBut("hello", 'h', 'e');      // returns 2 (first 'l')
     * indexOfAnyBut("hello", 'x', 'y');      // returns 0 (first 'h')
     * indexOfAnyBut("aaabbb", 'a');          // returns 3 (first 'b')
     * 
     * // All characters excluded or special cases
     * indexOfAnyBut("aaa", 'a');             // returns -1 (all excluded)
     * indexOfAnyBut(null, 'a');              // returns -1
     * indexOfAnyBut("", 'a');                // returns -1
     * indexOfAnyBut("hello");                // returns 0 (empty exclusion array)
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToExclude The array of characters to exclude from the search.
     * @return The index of the first occurrence of any character not in the array of characters
     *         to exclude, or -1 if all characters are in the array or the string is {@code null} or empty.
     * @see #indexOfAnyBut(String, int, char...)
     */
    public static int indexOfAnyBut(final String str, final char... valuesToExclude) {
        return indexOfAnyBut(str, 0, valuesToExclude);
    }

    /**
     * Returns the index within the input string of the first occurrence of any character
     * that is not in the specified array of characters to exclude, starting the search at the specified index.
     *
     * <p>If a character not within the array {@code valuesToExclude} occurs in the character
     * sequence represented by the input {@code String} object at an index no smaller than
     * {@code fromIndex}, then the index of the first such occurrence is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if all characters from {@code fromIndex} onwards are
     * in the exclusion array, or if the string is null or empty. If the exclusion array is
     * null or empty, returns {@code fromIndex} (if valid).</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Characters not in exclusion array found
     * indexOfAnyBut("hello", 0, 'h', 'e');   // returns 2 (first 'l')
     * indexOfAnyBut("hello", 3, 'h', 'e');   // returns 3 (first 'l' from index 3)
     * indexOfAnyBut("aaabbb", 0, 'a');       // returns 3 (first 'b')
     * indexOfAnyBut("aaabbb", 3, 'a');       // returns 3 (first 'b' from index 3)
     * 
     * // All characters excluded or special cases
     * indexOfAnyBut("aaa", 0, 'a');          // returns -1 (all excluded)
     * indexOfAnyBut("hello", 10, 'x');       // returns -1 (fromIndex beyond string)
     * indexOfAnyBut(null, 0, 'a');           // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param fromIndex The index to start the search from.
     * @param valuesToExclude The array of characters to exclude from the search.
     * @return The index of the first occurrence of any character not in the array of characters
     *         to exclude, or -1 if all characters are in the array or the string is {@code null} or empty.
     * @see #indexOfAnyBut(String, char...)
     */
    public static int indexOfAnyBut(final String str, int fromIndex, final char... valuesToExclude) {
        fromIndex = Math.max(0, fromIndex);

        checkInputChars(valuesToExclude, cs.valuesToExclude, true);

        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        if (N.isEmpty(valuesToExclude)) {
            return 0;
        }

        final int strLen = str.length();
        char ch = 0;

        outer: for (int i = fromIndex; i < strLen; i++) {//NOSONAR
            ch = str.charAt(i);

            for (final char c : valuesToExclude) {
                if (c == ch) {
                    // checked by checkInputChars

                    //    if (i < strLast && j < chsLast && Character.isHighSurrogate(ch)) {
                    //        if (valuesToExclude[j + 1] == str.charAt(i + 1)) {
                    //            continue outer;
                    //        }
                    //    } else {
                    //        continue outer;
                    //    }

                    continue outer;
                }
            }

            return i;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring,
     * using the specified delimiter to separate the search.
     *
     * <p>The method searches for {@code valueToFind} as a whole word/token delimited by {@code delimiter}.
     * A match is valid only if the substring is preceded by the delimiter (or is at the start of the string)
     * and followed by the delimiter (or is at the end of the string).</p>
     *
     * <p>If the delimiter is empty, this method behaves the same as {@link #indexOf(String, String)}.
     * The method returns {@code -1} if the substring is not found as a delimited token.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Delimited substring found
     * indexOf("apple,banana,cherry", "banana", ",");     // returns 6
     * indexOf("apple banana cherry", "banana", " ");     // returns 6
     * indexOf(",banana,", "banana", ",");                // returns 1
     * indexOf("banana", "banana", ",");                  // returns 0 (whole string matches)
     * 
     * // Delimited substring not found
     * indexOf("applesauce", "apple", ",");               // returns -1 (not delimited)
     * indexOf("apple,ban,cherry", "banana", ",");        // returns -1 (partial match)
     * indexOf(null, "test", ",");                        // returns -1
     * indexOf("test", null, ",");                        // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found.
     * @param delimiter The delimiter to separate the search.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see #indexOf(String, String, String, int)
     */
    public static int indexOf(final String str, final String valueToFind, final String delimiter) {
        return indexOf(str, valueToFind, delimiter, 0);
    }

    // Character Tests
    // -----------------------------------------------------------------------

    /**
     * Returns the index within the input string of the first occurrence of the specified substring,
     * using the specified delimiter to separate the search, starting the search at the specified index.
     *
     * <p>The method searches for {@code valueToFind} as a whole word/token delimited by {@code delimiter}.
     * A match is valid only if the substring is preceded by the delimiter (or is at the start of the search)
     * and followed by the delimiter (or is at the end of the string). If {@code fromIndex} is negative,
     * it is treated as zero.</p>
     *
     * <p>If the delimiter is empty, this method behaves the same as {@link #indexOf(String, String, int)}.
     * The method returns {@code -1} if the substring is not found as a delimited token.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Delimited substring found
     * indexOf("apple,banana,cherry", "banana", ",", 0);  // returns 6
     * indexOf("apple,banana,banana", "banana", ",", 7);  // returns 13 (second occurrence)
     * indexOf("apple banana cherry", "banana", " ", 0);  // returns 6
     * 
     * // Delimited substring not found
     * indexOf("applesauce", "apple", ",", 0);            // returns -1 (not delimited)
     * indexOf("apple,ban,cherry", "banana", ",", 0);     // returns -1 (partial match)
     * indexOf("test", "test", ",", 5);                   // returns -1 (fromIndex beyond match)
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found.
     * @param delimiter The delimiter to separate the search.
     * @param fromIndex The index to start the search from.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see #indexOf(String, String, String)
     */
    public static int indexOf(final String str, final String valueToFind, final String delimiter, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (isEmpty(delimiter)) {
            return indexOf(str, valueToFind, fromIndex);
        }

        if (str == null || valueToFind == null) {
            return N.INDEX_NOT_FOUND;
        }

        final int len = str.length();
        final int targetLen = fromIndex > 0 ? len - fromIndex : len;
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (targetLen < substrLen || (targetLen > substrLen && targetLen - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        final int index = str.indexOf(valueToFind, fromIndex);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        if ((index == fromIndex || (index - fromIndex >= delimiterLen && delimiter.equals(str.substring(index - delimiterLen, index))))
                && (index + substrLen == len
                        || (len >= index + substrLen + delimiterLen && delimiter.equals(str.substring(index + substrLen, index + substrLen + delimiterLen))))) {
            return index;
        }

        int idx = str.indexOf(delimiter + valueToFind + delimiter, index);

        if (idx >= 0) {
            return idx + delimiterLen;
        } else {
            idx = str.indexOf(delimiter + valueToFind, index);

            if (idx >= 0 && idx + delimiterLen + substrLen == len) {
                return idx + delimiterLen;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object,
     * then the index of the first such occurrence is returned. The search is case-insensitive, meaning that uppercase and lowercase
     * characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indexOfIgnoreCase("Hello World", "WORLD");     // returns 6
     * indexOfIgnoreCase("Hello World", "world");     // returns 6
     * indexOfIgnoreCase("Hello World", "xyz");       // returns -1
     * indexOfIgnoreCase(null, "test");               // returns -1
     * indexOfIgnoreCase("test", null);               // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind) {
        return indexOfIgnoreCase(str, valueToFind, 0);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * starting the search at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object
     * at or after the specified {@code fromIndex}, then the index of the first such occurrence is returned. The search is case-insensitive,
     * meaning that uppercase and lowercase characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null}.
     * If {@code fromIndex} is negative, it is treated as 0. If {@code fromIndex} is greater than the string length, -1 is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indexOfIgnoreCase("Hello World Hello", "hello", 0);    // returns 0
     * indexOfIgnoreCase("Hello World Hello", "hello", 7);    // returns 13
     * indexOfIgnoreCase("Hello World", "WORLD", 10);         // returns -1
     * indexOfIgnoreCase("test", "TEST", -5);                 // returns 0
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param fromIndex The index to start the search from. Negative values are treated as 0.
     * @return The index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either string parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || valueToFind == null || valueToFind.length() > str.length() - fromIndex) {
            return N.INDEX_NOT_FOUND;
        }

        // performance optimization
        if (valueToFind.length() <= 3 && valueToFind.toUpperCase().equals(valueToFind.toLowerCase())) {
            return str.indexOf(valueToFind, fromIndex);
        }

        for (int i = fromIndex, len = str.length(), substrLen = valueToFind.length(), end = len - substrLen + 1; i < end; i++) {
            if (str.regionMatches(true, i, valueToFind, 0, substrLen)) {
                return i;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * where the substring is bounded by the specified delimiter.
     *
     * <p>This method searches for the substring within the input string, but only considers it a match if it is preceded and/or followed
     * by the specified delimiter (or at the beginning/end of the string). The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries, or if any parameter is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indexOfIgnoreCase("apple,APPLE,banana", "apple", ",");    // returns 0
     * indexOfIgnoreCase("apple,APPLE,banana", "APPLE", ",");    // returns 0
     * indexOfIgnoreCase("pineapple,apple", "apple", ",");       // returns 10
     * indexOfIgnoreCase("test", "test", ",");                   // returns 0
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param delimiter The delimiter to be used for the search. May be {@code null} or empty.
     * @return The index of the first occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if any parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, final String delimiter) {
        return indexOfIgnoreCase(str, valueToFind, delimiter, 0);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * where the substring is bounded by the specified delimiter, starting the search at the specified index.
     *
     * <p>This method searches for the substring within the input string starting from {@code fromIndex}, but only considers it a match
     * if it is preceded and/or followed by the specified delimiter (or at the beginning/end of the string). The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries, or if the input string or
     * substring to find is {@code null}. If the delimiter is empty or {@code null}, the method behaves the same as
     * {@link #indexOfIgnoreCase(String, String, int)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indexOfIgnoreCase("apple,APPLE,banana", "apple", ",", 0);     // returns 0
     * indexOfIgnoreCase("apple,APPLE,banana", "apple", ",", 7);     // returns 6
     * indexOfIgnoreCase("pineapple,apple", "apple", ",", 0);        // returns 10
     * indexOfIgnoreCase("test value test", "test", " ", 5);         // returns 11
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param delimiter The delimiter to be used for the search. May be {@code null} or empty.
     * @param fromIndex The index to start the search from. Negative values are treated as 0.
     * @return The index of the first occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if the input string or substring to find is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, final String delimiter, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (isEmpty(delimiter)) {
            return indexOfIgnoreCase(str, valueToFind, fromIndex);
        }

        if (str == null || valueToFind == null) {
            return N.INDEX_NOT_FOUND;
        }

        final int len = str.length();
        final int targetLen = fromIndex > 0 ? len - fromIndex : len;
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (targetLen < substrLen || (targetLen > substrLen && targetLen - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        final int index = indexOfIgnoreCase(str, valueToFind, fromIndex);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        if ((index == fromIndex || (index - fromIndex >= delimiterLen && delimiter.equalsIgnoreCase(str.substring(index - delimiterLen, index))))
                && (index + substrLen == len || (len >= index + substrLen + delimiterLen
                        && delimiter.equalsIgnoreCase(str.substring(index + substrLen, index + substrLen + delimiterLen))))) {
            return index;
        }

        int idx = indexOfIgnoreCase(str, delimiter + valueToFind + delimiter, index);

        if (idx >= 0) {
            return idx + delimiterLen;
        } else {
            idx = indexOfIgnoreCase(str, delimiter + valueToFind, index);

            if (idx >= 0 && idx + delimiterLen + substrLen == len) {
                return idx + delimiterLen;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within this string of the last occurrence of the specified character.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence represented by
     * this {@code String} object, then the index of the last such occurrence is returned. The search proceeds
     * from the end of the string towards the beginning.</p>
     *
     * <p>The method returns -1 if the character is not found, or if the input string is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("Hello World", 'o');         // returns 7
     * lastIndexOf("Hello World", 'x');         // returns -1
     * lastIndexOf("", 'a');                    // returns -1
     * lastIndexOf(null, 'a');                  // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param charValueToFind The character to be found.
     * @return The index of the last occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur or if the string is {@code null} or empty.
     */
    public static int lastIndexOf(final String str, final int charValueToFind) {
        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.lastIndexOf(charValueToFind);
    }

    /**
     * Returns the index within this string of the last occurrence of the specified character,
     * searching backward starting at the specified index.
     *
     * <p>For values of {@code charValueToFind} in the range from 0 to 0xFFFF (inclusive),
     * the index returned is the largest value <i>k</i> such that:
     * {@code (this.charAt(k) == charValueToFind) && (k <= startIndexFromBack)} is {@code true}.
     * For other values of {@code charValueToFind}, it is the largest value <i>k</i> such that:
     * {@code (this.codePointAt(k) == charValueToFind) && (k <= startIndexFromBack)} is {@code true}.</p>
     *
     * <p>If no such character occurs in this string at or before position {@code startIndexFromBack},
     * then -1 is returned. All indices are specified in {@code char} values (Unicode code units).</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("Hello World", 'o', 10);     // returns 7
     * lastIndexOf("Hello World", 'o', 5);      // returns 4
     * lastIndexOf("Hello World", 'o', 3);      // returns -1
     * lastIndexOf("Hello", 'l', -1);           // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param charValueToFind A character (Unicode code point).
     * @param startIndexFromBack The index to start the search from. There is no restriction on
     *            the value of {@code startIndexFromBack}. If it is greater than or
     *            equal to the length of this string, it has the same effect as
     *            if it were equal to one less than the length of this string:
     *            this entire string may be searched. If it is negative, -1 is returned.
     * @return The index of the last occurrence of the character in the
     *         character sequence represented by this object that is less than
     *         or equal to {@code startIndexFromBack}, or {@code -1} if the
     *         character does not occur before that point.
     */
    public static int lastIndexOf(final String str, final int charValueToFind, int startIndexFromBack) {
        if (str == null || str.isEmpty() || startIndexFromBack < 0) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        return str.lastIndexOf(charValueToFind, startIndexFromBack);
    }

    /**
     * Returns the index within this string of the last occurrence of the specified substring.
     *
     * <p>The returned index is the index of the beginning of the last occurrence of the substring.
     * If the substring does not occur, -1 is returned. The search proceeds from the end of the string
     * towards the beginning.</p>
     *
     * <p>The method returns -1 if either the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("Hello World Hello", "Hello");    // returns 13
     * lastIndexOf("Hello World", "World");          // returns 6
     * lastIndexOf("Hello World", "xyz");            // returns -1
     * lastIndexOf(null, "test");                    // returns -1
     * lastIndexOf("test", null);                    // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @return The index of the last occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.lastIndexOf(valueToFind);
    }

    /**
     * Returns the index within {@code str} of the last occurrence of the specified {@code valueToFind},
     * searching backward starting at the specified index.
     *
     * <p>The returned index is the largest value <i>k</i> for which:
     * {@code k <= startIndexFromBack && str.startsWith(valueToFind, k)} is {@code true}.
     * If no such value of <i>k</i> exists, then {@code -1} is returned.</p>
     *
     * <p>The method returns -1 if either the input string or the substring to find is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("Hello World Hello", "Hello", 15);    // returns 13
     * lastIndexOf("Hello World Hello", "Hello", 10);    // returns 0
     * lastIndexOf("Hello World", "World", 5);           // returns -1
     * lastIndexOf("test", "test", -1);                  // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param startIndexFromBack The index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return The index of the last occurrence of the substring at or before the specified index,
     *         or -1 if the substring does not occur or if any parameter is invalid.
     */
    public static int lastIndexOf(final String str, final String valueToFind, int startIndexFromBack) {
        if (str == null || valueToFind == null || startIndexFromBack < 0 || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        return str.lastIndexOf(valueToFind, startIndexFromBack);
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * where the substring is bounded by the specified delimiter.
     *
     * <p>This method searches for the substring within the input string from the end, but only considers it a match
     * if it is preceded and/or followed by the specified delimiter (or at the beginning/end of the string).</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if any parameter is {@code null}. If the delimiter is empty or {@code null}, the method behaves
     * the same as {@link #lastIndexOf(String, String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("apple,banana,apple", "apple", ",");     // returns 13
     * lastIndexOf("pineapple,apple", "apple", ",");        // returns 10
     * lastIndexOf("apple test", "apple", " ");             // returns 0
     * lastIndexOf("test", "test", ",");                    // returns 0
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param delimiter The delimiter to separate the search. May be {@code null} or empty.
     * @return The index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if any parameter is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind, final String delimiter) {
        return lastIndexOf(str, valueToFind, delimiter, str.length());
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * where the substring is bounded by the specified delimiter, starting the search at the specified index.
     *
     * <p>This method searches for the substring within the input string from {@code startIndexFromBack} backwards,
     * but only considers it a match if it is preceded and/or followed by the specified delimiter
     * (or at the beginning/end of the string).</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if the input string or substring to find is {@code null}. If the delimiter is empty or {@code null},
     * the method behaves the same as {@link #lastIndexOf(String, String, int)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOf("apple,banana,apple", "apple", ",", 20);    // returns 13
     * lastIndexOf("apple,banana,apple", "apple", ",", 10);    // returns 0
     * lastIndexOf("pineapple,apple", "apple", ",", 20);       // returns 10
     * lastIndexOf("test value test", "test", " ", 10);        // returns 0
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param delimiter The delimiter to separate the search. May be {@code null} or empty.
     * @param startIndexFromBack The index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return The index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if the input string or substring to find is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind, final String delimiter, int startIndexFromBack) {
        if (isEmpty(delimiter)) {
            return lastIndexOf(str, valueToFind, startIndexFromBack);
        } else if (str == null || valueToFind == null || startIndexFromBack < 0) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (len < substrLen || (len > substrLen && len - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        int index = str.lastIndexOf(delimiter + valueToFind, startIndexFromBack);

        if (index >= 0 && index + delimiter.length() + valueToFind.length() == len) {
            return index + delimiter.length();
        }

        index = str.lastIndexOf(delimiter + valueToFind + delimiter, startIndexFromBack);

        if (index >= 0) {
            return index + delimiter.length();
        }

        index = str.lastIndexOf(valueToFind, startIndexFromBack);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        //noinspection DuplicateExpressions
        if (index == 0 && (index + valueToFind.length() == len || (len >= index + valueToFind.length() + delimiter.length()
                && delimiter.equals(str.substring(index + valueToFind.length(), index + valueToFind.length() + delimiter.length()))))) {
            return index;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring, ignoring case considerations.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object,
     * then the index of the last such occurrence is returned. The search is case-insensitive, meaning that uppercase and lowercase
     * characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOfIgnoreCase("Hello World HELLO", "hello");    // returns 13
     * lastIndexOfIgnoreCase("Hello World", "WORLD");          // returns 6
     * lastIndexOfIgnoreCase("Hello World", "xyz");            // returns -1
     * lastIndexOfIgnoreCase(null, "test");                    // returns -1
     * lastIndexOfIgnoreCase("test", null);                    // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @return The index of the last occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return lastIndexOfIgnoreCase(str, valueToFind, str.length());
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring, ignoring case considerations,
     * searching backward starting at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object
     * at or before the specified {@code startIndexFromBack}, then the index of the last such occurrence is returned.
     * The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found at or before the specified index, or if either the input string
     * or the substring to find is {@code null}, if {@code startIndexFromBack} is negative, or if the substring is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOfIgnoreCase("Hello World HELLO", "hello", 15);    // returns 13
     * lastIndexOfIgnoreCase("Hello World HELLO", "hello", 10);    // returns 0
     * lastIndexOfIgnoreCase("Hello World", "WORLD", 5);           // returns -1
     * lastIndexOfIgnoreCase("test", "TEST", -1);                  // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The substring to be found. May be {@code null}.
     * @param startIndexFromBack The index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return The index of the last occurrence of the substring at or before the specified index,
     *         or -1 if the substring does not occur or if any parameter is invalid.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind, int startIndexFromBack) {
        if (str == null || valueToFind == null || startIndexFromBack < 0 || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        for (int i = N.min(startIndexFromBack, str.length() - valueToFind.length()), substrLen = valueToFind.length(); i >= 0; i--) {
            if (str.regionMatches(true, i, valueToFind, 0, substrLen)) {
                return i;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of any specified character.
     *
     * <p>This method searches the string from the end and returns the index of the first character found
     * that matches any character in the {@code valuesToFind} array. Note that the returned index may not be
     * the largest or smallest last index among all matching characters - it returns the index of the first match found
     * during the backward search.</p>
     *
     * <p>The method returns -1 if none of the characters are found, or if the input string is {@code null} or empty,
     * or if the character array is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOfAny("Hello World", 'o', 'l');        // returns 9 or 7 (implementation dependent)
     * lastIndexOfAny("Hello World", 'x', 'y', 'z');   // returns -1
     * lastIndexOfAny("", 'a', 'b');                   // returns -1
     * lastIndexOfAny(null, 'a');                      // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of characters to be found. May be {@code null} or empty.
     * @return The index of the last occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur or if the string or character array is {@code null} or empty.
     * @see #smallestLastIndexOfAll(String, String[])
     * @see #smallestLastIndexOfAll(String, int, String[])
     * @see #largestLastIndexOfAll(String, String[])
     * @see #largestLastIndexOfAll(String, int, String[])
     */
    public static int lastIndexOfAny(final String str, final char... valuesToFind) {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        int idx = 0;

        for (final char ch : valuesToFind) {
            idx = str.lastIndexOf(ch);

            if (idx != N.INDEX_NOT_FOUND) {
                return idx;
            }
        }

        final int strLen = str.length();
        final int chsLen = valuesToFind.length;
        char ch = 0;

        for (int i = strLen - 1; i >= 0; i--) {
            ch = str.charAt(i);

            for (int j = chsLen - 1; j >= 0; j--) {
                if (valuesToFind[j] == ch) {
                    // checked by checkInputChars

                    //    if (i > 0 && j > 0 && Character.isHighSurrogate(ch = str.charAt(i - 1))) {
                    //        // ch is a supplementary character
                    //        if (valuesToFind[j - 1] == ch) {
                    //            return i - 1;
                    //        }
                    //    } else {
                    //        return i;
                    //    }

                    return i;
                }
            }
        }

        return N.INDEX_NOT_FOUND;

    }

    /**
     * Returns the index within the input string of the last occurrence of any specified substring.
     *
     * <p>This method searches for any of the substrings in the {@code valuesToFind} array within the input string.
     * The returned index corresponds to the beginning of the matched substring. Note that the returned index may not be
     * the largest last index among all matching substrings - it returns the index of the first match found during the search.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastIndexOfAny("Hello World", "World", "Hello");       // returns 6 or 0 (implementation dependent)
     * lastIndexOfAny("Hello World", "xyz", "abc");           // returns -1
     * lastIndexOfAny("test", null, "test");                  // returns 0
     * lastIndexOfAny(null, "test");                          // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of substrings to be found. May be {@code null} or empty.
     * @return The index of the last occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur or if the string or substring array is {@code null} or empty.
     * @see #smallestLastIndexOfAll(String, String[])
     * @see #smallestLastIndexOfAll(String, int, String[])
     * @see #largestLastIndexOfAll(String, String[])
     * @see #largestLastIndexOfAll(String, int, String[])
     */
    public static int lastIndexOfAny(final String str, final String... valuesToFind) {
        if (str == null || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        final int len = str.length();
        int idx = 0;

        for (final String substr : valuesToFind) {
            if (substr == null || substr.length() > len) {
                continue;
            }

            idx = str.lastIndexOf(substr);

            if (idx != N.INDEX_NOT_FOUND) {
                return idx;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    // Shared code between ordinalIndexOf(String,String,int) and

    /**
     * Ordinal index of.
     *
     * @param str
     * @param substr
     * @param ordinal
     * @param isLastIndex
     * @return
     */
    // lastOrdinalIndexOf(String,String,int)
    private static int ordinalIndexOf(final String str, final String substr, final int ordinal, final boolean isLastIndex) {
        if (ordinal < 1) {
            throw new IllegalArgumentException("ordinal(" + ordinal + ") must be >= 1");
        }

        if (str == null || substr == null || substr.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        int fromIndex = isLastIndex ? str.length() : 0;

        for (int found = 0; fromIndex >= 0;) {
            fromIndex = isLastIndex ? str.lastIndexOf(substr, fromIndex) : str.indexOf(substr, fromIndex);

            if (fromIndex < 0) {
                return N.INDEX_NOT_FOUND;
            }

            if (++found >= ordinal) {
                break;
            }

            fromIndex = isLastIndex ? (fromIndex - substr.length()) : (fromIndex + substr.length());
        }

        return fromIndex;
    }

    /**
     * Finds the smallest index of all specified substrings within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string,
     * and returns the smallest (leftmost) index among all found substrings. Each substring in the array
     * is searched at most once from the beginning of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * smallestIndexOfAll("Hello World", "World", "o");        // returns 4
     * smallestIndexOfAll("Hello World", "xyz", "abc");        // returns -1
     * smallestIndexOfAll("test string", "string", "test");    // returns 0
     * smallestIndexOfAll(null, "test");                       // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of substrings to be found. May be {@code null} or empty.
     * @return The smallest index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int smallestIndexOfAll(final String str, final String... valuesToFind) {
        return smallestIndexOfAll(str, 0, valuesToFind);
    }

    /**
     * Finds the smallest index of all substrings in {@code valuesToFind} within the input string from {@code fromIndex}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * starting from the specified {@code fromIndex}, and returns the smallest (leftmost) index among all found substrings.
     * Each substring in the array is searched at most once from the specified {@code fromIndex}.</p>
     *
     * <p>The method returns -1 if none of the substrings are found from the specified index, or if the input string is {@code null},
     * if {@code fromIndex} is greater than the string length, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored. If {@code fromIndex} is negative, it is treated as 0.</p>
     *
     * <p>Example:
     * <pre>{@code
     * smallestIndexOfAll("Hello World", 0, "World", "o");       // returns 4
     * smallestIndexOfAll("Hello World", 5, "World", "o");       // returns 6
     * smallestIndexOfAll("Hello World", 8, "World", "o");       // returns -1
     * smallestIndexOfAll("test", -5, "test");                   // returns 0
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param fromIndex The index to start the search from. Negative values are treated as 0.
     * @param valuesToFind The array of substrings to be found. May be {@code null} or empty.
     * @return The smallest index of all substrings within the input string from {@code fromIndex} or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int smallestIndexOfAll(final String str, int fromIndex, final String... valuesToFind) {
        if (str == null || fromIndex > str.length() || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        fromIndex = Math.max(0, fromIndex);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || (substr.length() > len - fromIndex)) {
                continue;
            }

            final int tmp = indexOf(str, substr, fromIndex);

            result = tmp >= 0 && (result == N.INDEX_NOT_FOUND || tmp < result) ? tmp : result;

            if (result == fromIndex) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the largest index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string,
     * and returns the largest (rightmost) index among all found substrings. Each substring in the array
     * is searched at most once from the beginning of the string. The search is optimized by prioritizing
     * longer substrings when they might affect the result.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * largestIndexOfAll("Hello World", "o", "World");         // returns 6
     * largestIndexOfAll("Hello World", "H", "d");             // returns 10
     * largestIndexOfAll("Hello World", "xyz", "abc");         // returns -1
     * largestIndexOfAll(null, "test");                        // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valuesToFind The array of substrings to be found. May be {@code null} or empty.
     * @return The largest index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int largestIndexOfAll(final String str, final String... valuesToFind) {
        return largestIndexOfAll(str, 0, valuesToFind);
    }

    /**
     * Finds the largest index of all substrings in {@code valuesToFind} within the input string from {@code fromIndex}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * starting from the specified {@code fromIndex}, and returns the largest (rightmost) index among all found substrings.
     * Each substring in the array is searched at most once from the specified {@code fromIndex}.
     * The search is optimized by prioritizing longer substrings when they might affect the result.</p>
     *
     * <p>The method returns -1 if none of the substrings are found from the specified index, or if the input string is {@code null},
     * if {@code fromIndex} is greater than the string length, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored. If {@code fromIndex} is negative, it is treated as 0.</p>
     *
     * <p>Example:
     * <pre>{@code
     * largestIndexOfAll("Hello World", 0, "o", "World");      // returns 6
     * largestIndexOfAll("Hello World", 5, "o", "H");          // returns 7
     * largestIndexOfAll("Hello World", 8, "o", "World");      // returns -1
     * largestIndexOfAll("test", -5, "test", "t");             // returns 3
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param fromIndex The index to start the search from. Negative values are treated as 0.
     * @param valuesToFind The array of substrings to be found. May be {@code null} or empty.
     * @return The largest index of all substrings within the input string from {@code fromIndex} or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int largestIndexOfAll(final String str, final int fromIndex, final String... valuesToFind) {
        if (str == null || fromIndex > str.length() || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        final int fromIndexToUse = Math.max(0, fromIndex);

        final int len = str.length();
        final List<String> subStringsSortedByLen = Stream.of(valuesToFind) //
                .filter(it -> !(it == null || (fromIndexToUse + it.length() > len)))
                .sortedByInt(N::len)
                .toList();

        int result = N.INDEX_NOT_FOUND;

        for (final String substr : subStringsSortedByLen) {
            if (result >= 0 && substr.length() >= len - result) {
                continue;
            }

            result = N.max(result, indexOf(str, substr, fromIndex));

            if (result == len - substr.length()) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the smallest last index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from the end, and returns the smallest (leftmost) last index among all found substrings.
     * Each substring in the array is searched at most once from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * smallestLastIndexOfAll("Hello World", "o", "World");      // returns 6
     * smallestLastIndexOfAll("Hello Hello", "Hello", "o");      // returns 7
     * smallestLastIndexOfAll("test", "xyz", "abc");             // returns -1
     * smallestLastIndexOfAll(null, "test");                     // returns -1
     * }</pre>
     *
     * @param str The string to search within. It may be {@code null}.
     * @param valuesToFind The substrings to find within the string. These may be empty or {@code null}.
     * @return The smallest last index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int smallestLastIndexOfAll(final String str, final String... valuesToFind) {
        return smallestLastIndexOfAll(str, N.len(str), valuesToFind);
    }

    /**
     * Finds the smallest last index of all substrings in {@code valuesToFind} within the input string from {@code startIndexFromBack}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from {@code startIndexFromBack} backwards, and returns the smallest (leftmost) last index among all found substrings.
     * Each substring in the array is searched at most once from {@code startIndexFromBack} from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found at or before the specified index, or if the input string is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * smallestLastIndexOfAll("Hello World", 10, "o", "World");    // returns 6
     * smallestLastIndexOfAll("Hello World", 5, "o", "World");     // returns 4
     * smallestLastIndexOfAll("Hello World", 3, "o", "World");     // returns -1
     * smallestLastIndexOfAll("test", -1, "test");                 // returns -1
     * }</pre>
     *
     * @param str The string to search within. It may be {@code null}.
     * @param startIndexFromBack The index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind The substrings to find within the string. These may be empty or {@code null}.
     * @return The smallest index of all substrings within the input string from {@code startIndexFromBack} or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int smallestLastIndexOfAll(final String str, int startIndexFromBack, final String... valuesToFind) {
        if (str == null || startIndexFromBack < 0 || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || substr.length() > len) {
                continue;
            }

            final int tmp = lastIndexOf(str, substr, startIndexFromBack);

            result = tmp >= 0 && (result == N.INDEX_NOT_FOUND || tmp < result) ? tmp : result;

            if (result == 0) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the largest last index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from the end, and returns the largest (rightmost) last index among all found substrings.
     * Each substring in the array is searched at most once from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * largestLastIndexOfAll("Hello World", "o", "World");       // returns 7
     * largestLastIndexOfAll("Hello Hello", "Hello", "e");       // returns 8
     * largestLastIndexOfAll("test", "xyz", "abc");              // returns -1
     * largestLastIndexOfAll(null, "test");                      // returns -1
     * }</pre>
     *
     * @param str The string to search within. It may be {@code null}.
     * @param valuesToFind The substrings to find within the string. These may be empty or {@code null}.
     * @return The largest last index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int largestLastIndexOfAll(final String str, final String... valuesToFind) {
        return largestLastIndexOfAll(str, N.len(str), valuesToFind);
    }

    /**
     * Finds the largest last index of all substrings in {@code valuesToFind} within the input string from {@code startIndexFromBack}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from {@code startIndexFromBack} backwards, and returns the largest (rightmost) last index among all found substrings.
     * Each substring in the array is searched at most once from {@code startIndexFromBack} from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found at or before the specified index, or if the input string is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored.</p>
     *
     * <p>Example:
     * <pre>{@code
     * largestLastIndexOfAll("Hello World", 10, "o", "World");     // returns 7
     * largestLastIndexOfAll("Hello World", 6, "o", "World");      // returns 6
     * largestLastIndexOfAll("Hello World", 3, "o", "H");          // returns 0
     * largestLastIndexOfAll("test", -1, "test");                  // returns -1
     * }</pre>
     *
     * @param str The string to search within. It may be {@code null}.
     * @param startIndexFromBack The index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind The substrings to find within the string. These may be empty or {@code null}.
     * @return The largest index of all substrings within the input string from {@code startIndexFromBack} or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int largestLastIndexOfAll(final String str, int startIndexFromBack, final String... valuesToFind) {
        if (str == null || startIndexFromBack < 0 || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || substr.length() > len) {
                continue;
            }

            result = N.max(result, str.lastIndexOf(substr, startIndexFromBack));

            if (result == startIndexFromBack) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the n-th occurrence of the specified value within the input string.
     *
     * <p>This method searches for the {@code ordinal}-th occurrence of {@code valueToFind} within the input string,
     * searching from the beginning of the string. The ordinal parameter must be greater than or equal to 1.</p>
     *
     * <p>The method returns -1 if the value does not occur as many times as requested, or if either the input string
     * or the value to find is {@code null}, or if the value is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * ordinalIndexOf("aabaabaa", "a", 1);      // returns 0
     * ordinalIndexOf("aabaabaa", "a", 3);      // returns 5
     * ordinalIndexOf("aabaabaa", "b", 2);      // returns 4
     * ordinalIndexOf("aabaabaa", "ab", 2);     // returns 3
     * ordinalIndexOf("aabaabaa", "c", 1);      // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The value to be found. May be {@code null}.
     * @param ordinal The n-th occurrence to find. Must be greater than or equal to 1.
     * @return The index of the n-th occurrence of the specified value within the input string,
     *         or -1 if the value does not occur as many times as requested.
     * @throws IllegalArgumentException if ordinal is less than 1
     */
    public static int ordinalIndexOf(final String str, final String valueToFind, final int ordinal) {
        return ordinalIndexOf(str, valueToFind, ordinal, false);
    }

    /**
     * Finds the n-th last occurrence of the specified value within the input string.
     *
     * <p>This method searches for the {@code ordinal}-th occurrence of {@code valueToFind} within the input string,
     * searching from the end of the string backwards. The ordinal parameter must be greater than or equal to 1.</p>
     *
     * <p>The method returns -1 if the value does not occur as many times as requested, or if either the input string
     * or the value to find is {@code null}, or if the value is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastOrdinalIndexOf("aabaabaa", "a", 1);      // returns 7
     * lastOrdinalIndexOf("aabaabaa", "a", 3);      // returns 3
     * lastOrdinalIndexOf("aabaabaa", "b", 2);      // returns 2
     * lastOrdinalIndexOf("aabaabaa", "ab", 2);     // returns 1
     * lastOrdinalIndexOf("aabaabaa", "c", 1);      // returns -1
     * }</pre>
     *
     * @param str The string to be checked. May be {@code null} or empty.
     * @param valueToFind The value to be found. May be {@code null}.
     * @param ordinal The n-th last occurrence to find. Must be greater than or equal to 1.
     * @return The index of the n-th last occurrence of the specified value within the input string,
     *         or -1 if the value does not occur as many times as requested.
     * @throws IllegalArgumentException if ordinal is less than 1
     */
    public static int lastOrdinalIndexOf(final String str, final String valueToFind, final int ordinal) {
        return ordinalIndexOf(str, valueToFind, ordinal, true);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string and returns
     * a stream of their indices. The search is case-sensitive. If the substring is empty, it returns
     * indices of all positions in the string (0 through string length).</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indicesOf("abca", "a").join(", ");       // returns "0, 3"
     * indicesOf("abcA", "a").join(", ");       // returns "0"
     * indicesOf("abcA", null).join(", ");      // returns ""
     * indicesOf(null, "").join(", ");          // returns ""
     * indicesOf("", null).join(", ");          // returns ""
     * indicesOf("abcA", "").join(", ");        // returns "0, 1, 2, 3"
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOf(final String str, final String valueToFind) {
        return indicesOf(str, valueToFind, 0);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, starting the search at the specified index.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string starting from {@code fromIndex}
     * and returns a stream of their indices. The search is case-sensitive. If the substring is empty, it returns
     * indices of all positions in the string from {@code fromIndex} to string length.</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the remaining part of the input string from {@code fromIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * indicesOf("abcabc", "a", 0).join(", ");      // returns "0, 3"
     * indicesOf("abcabc", "a", 2).join(", ");      // returns "3"
     * indicesOf("abcabc", "a", 4).join(", ");      // returns ""
     * indicesOf("abcA", "", 2).join(", ");         // returns "2, 3, 4"
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param fromIndex the index to start the search from
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOf(final String str, final String valueToFind, final int fromIndex) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return IntStream.empty();
        }

        final int increment = Math.max(valueToFind.length(), 1);

        return IntStream.ofIndices(str, fromIndex, increment, (s, from) -> s.indexOf(valueToFind, from));
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, ignoring case considerations.
     *
     * <pre>
     * <code>
     * Strings.indicesOf("abca", "a").join(", ") ==> "0, 3"
     * Strings.indicesOf("abcA", "a").join(", ") ==> "0"
     * Strings.indicesOf("abcA", null).join(", ") ==> ""
     * Strings.indicesOf(null, "").join(", ") ==> ""
     * Strings.indicesOf("", null).join(", ") ==> ""
     * Strings.indicesOf("abcA", "").join(", ") ==> "0, 1, 2, 3"
     * Strings.indicesOfIgnoreCase("abcA", "a").join(", ") ==> "0, 3"
     * </code>
     * </pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOfIgnoreCase(final String str, final String valueToFind) {
        return indicesOfIgnoreCase(str, valueToFind, 0);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, starting the search at the specified index, ignoring case considerations.
     *
     * <pre>
     * <code>
     * Strings.indicesOf("abca", "a").join(", ") ==> "0, 3"
     * Strings.indicesOf("abcA", "a").join(", ") ==> "0"
     * Strings.indicesOf("abcA", null).join(", ") ==> ""
     * Strings.indicesOf(null, "").join(", ") ==> ""
     * Strings.indicesOf("", null).join(", ") ==> ""
     * Strings.indicesOf("abcA", "").join(", ") ==> "0, 1, 2, 3"
     * Strings.indicesOfIgnoreCase("abcA", "a").join(", ") ==> "0, 3"
     * </code>
     * </pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param fromIndex the index to start the search from
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOfIgnoreCase(final String str, final String valueToFind, final int fromIndex) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return IntStream.empty();
        }

        final int strLen = str.length();
        final int increment = Math.max(valueToFind.length(), 1);
        final int end = strLen - increment + 1;

        return IntStream.ofIndices(str, fromIndex, increment, (s, from) -> {
            for (int idx = from; idx < end; idx++) {
                if (str.regionMatches(true, idx, valueToFind, 0, increment)) {
                    return idx;
                }
            }

            return N.INDEX_NOT_FOUND;
        });
    }

    /**
     * Counts the number of occurrences of the specified character in the given string.
     *
     * <p>This method counts how many times a specific character appears in the input string.
     * If the input string is {@code null} or empty, the method returns 0.</p>
     *
     * <p>The method performs a simple character-by-character comparison to count occurrences.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Count character occurrences
     * countMatches("hello world", 'l');              // returns 3
     * countMatches("programming", 'm');              // returns 2
     * countMatches("test", 'x');                     // returns 0
     * countMatches("", 'a');                         // returns 0
     * countMatches(null, 'a');                       // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param charValueToFind the character to be counted
     * @return the number of occurrences of the specified character in the string, or 0 if the string is {@code null} or empty
     * @see N#occurrencesOf(String, char)
     */
    @SuppressWarnings("deprecation")
    public static int countMatches(final String str, final char charValueToFind) {
        if (isEmpty(str)) {
            return 0;
        }

        int occurrences = 0;

        for (final char e : InternalUtil.getCharsForReadOnly(str)) {
            if (e == charValueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the number of occurrences of the specified substring in the given string.
     *
     * <p>This method counts how many times a specific substring appears in the input string.
     * The search is case-sensitive and does not count overlapping occurrences.
     * If either the input string or the substring to find is {@code null} or empty, the method returns 0.</p>
     *
     * <p>The method performs a sequential search through the string, advancing past each found occurrence.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Count substring occurrences
     * countMatches("abcabcabc", "abc");              // returns 3
     * countMatches("hello world", "o");              // returns 2
     * countMatches("programming", "mm");             // returns 1
     * countMatches("test", "xyz");                   // returns 0
     * countMatches("aaa", "aa");                     // returns 1 (non-overlapping)
     * countMatches(null, "test");                    // returns 0
     * countMatches("test", null);                    // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be counted
     * @return the number of occurrences of the specified substring in the string, or 0 if either parameter is {@code null} or empty
     * @see N#occurrencesOf(String, String)
     */
    public static int countMatches(final String str, final String valueToFind) {
        if (isEmpty(str) || isEmpty(valueToFind)) {
            return 0;
        }

        int occurrences = 0;

        for (int len = N.len(str), substrLen = N.len(valueToFind), index = 0, fromIndex = 0, toIndex = len - substrLen; fromIndex <= toIndex;) {
            index = str.indexOf(valueToFind, fromIndex);

            if (index < 0) {
                break;
            } else {
                fromIndex = index + substrLen;
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Checks if the specified character is present in the given string.
     *
     * <p>This method determines whether a specific character appears at least once in the input string.
     * If the input string is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method uses the indexOf method internally for efficient searching.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check character presence
     * contains("hello", 'e');                        // returns true
     * contains("world", 'x');                        // returns false
     * contains("", 'a');                             // returns false
     * contains(null, 'a');                           // returns false
     * contains("test", 't');                         // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param charValueToFind the character to be found
     * @return {@code true} if the character is found in the string, {@code false} otherwise
     */
    public static boolean contains(final String str, final char charValueToFind) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        return indexOf(str, charValueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string.
     *
     * <p>This method determines whether a specific substring appears at least once in the input string.
     * The search is case-sensitive. If either the input string or the substring is {@code null}, 
     * the method returns {@code false}.</p>
     *
     * <p>The method uses the indexOf method internally for efficient searching.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check substring presence
     * contains("hello world", "world");              // returns true
     * contains("hello world", "World");              // returns false (case-sensitive)
     * contains("programming", "gram");               // returns true
     * contains("test", "xyz");                       // returns false
     * contains(null, "test");                        // returns false
     * contains("test", null);                        // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found
     * @return {@code true} if the substring is found in the string, {@code false} otherwise
     */
    public static boolean contains(final String str, final String valueToFind) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOf(str, valueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, considering the specified delimiter.
     *
     * <p>This method determines whether a specific substring appears as a complete token in the input string,
     * where tokens are separated by the specified delimiter. The method only returns {@code true} if the
     * substring appears as a complete token, not as part of another token.</p>
     *
     * <p>If either the input string or the substring is {@code null}, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check token presence with delimiter
     * contains("apple,banana,orange", "banana", ","); // returns true
     * contains("apple,banana,orange", "ban", ",");    // returns false (partial match)
     * contains("one two three", "two", " ");          // returns true
     * contains("one-two-three", "two", "-");          // returns true
     * contains("testing", "test", ",");               // returns false (no delimiter)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found
     * @param delimiter the delimiter to be considered
     * @return {@code true} if the substring is found as a complete token in the string considering the delimiter, {@code false} otherwise
     */
    public static boolean contains(final String str, final String valueToFind, final String delimiter) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOf(str, valueToFind, delimiter) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether a specific substring appears at least once in the input string,
     * performing a case-insensitive comparison. If either the input string or the substring is {@code null},
     * the method returns {@code false}.</p>
     *
     * <p>The method converts both strings to lowercase internally for comparison.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check substring presence ignoring case
     * containsIgnoreCase("Hello World", "world");    // returns true
     * containsIgnoreCase("Hello World", "HELLO");    // returns true
     * containsIgnoreCase("Programming", "GRAM");     // returns true
     * containsIgnoreCase("test", "XYZ");             // returns false
     * containsIgnoreCase(null, "test");              // returns false
     * containsIgnoreCase("test", null);              // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found
     * @return {@code true} if the substring is found in the string ignoring case considerations, {@code false} otherwise
     */
    public static boolean containsIgnoreCase(final String str, final String valueToFind) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOfIgnoreCase(str, valueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, considering the specified delimiter and ignoring case considerations.
     *
     * <p>This method determines whether a specific substring appears as a complete token in the input string,
     * where tokens are separated by the specified delimiter. The comparison is case-insensitive.
     * The method only returns {@code true} if the substring appears as a complete token, not as part of another token.</p>
     *
     * <p>If either the input string or the substring is {@code null}, the method returns {@code false}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check token presence with delimiter ignoring case
     * containsIgnoreCase("Apple,Banana,Orange", "banana", ","); // returns true
     * containsIgnoreCase("Apple,Banana,Orange", "BAN", ",");    // returns false (partial)
     * containsIgnoreCase("ONE TWO THREE", "two", " ");          // returns true
     * containsIgnoreCase("One-Two-Three", "TWO", "-");          // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found
     * @param delimiter the delimiter to be considered
     * @return {@code true} if the substring is found as a complete token in the string considering the delimiter and ignoring case considerations, {@code false} otherwise
     */
    public static boolean containsIgnoreCase(final String str, final String valueToFind, final String delimiter) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOfIgnoreCase(str, valueToFind, delimiter) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if all the specified characters are present in the given string.
     *
     * <p>This method determines whether every character in the specified array appears at least once
     * in the input string. The method returns {@code true} if the specified character array is empty
     * or {@code null}. If the input string is {@code null} or empty but the character array is not empty,
     * the method returns {@code false}.</p>
     *
     * <p>The method checks each character independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if all characters are present
     * containsAll("hello world", 'h', 'e', 'l');    // returns true
     * containsAll("hello world", 'h', 'x');         // returns false ('x' not present)
     * containsAll("test", 't', 'e', 's');           // returns true
     * containsAll("test");                          // returns true (empty array)
     * containsAll(null, 'a');                       // returns false
     * containsAll("", 'a');                         // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be found
     * @return {@code true} if all the characters are found in the given string or the specified {@code valuesToFind} char array is {@code null} or empty, {@code false} otherwise
     */
    public static boolean containsAll(final String str, final char... valuesToFind) {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final char ch : valuesToFind) {
            if (str.indexOf(ch) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the specified substrings are present in the given string.
     *
     * <p>This method determines whether every substring in the specified array appears at least once
     * in the input string. The search is case-sensitive. The method returns {@code true} if the 
     * specified substring array is empty or {@code null}. If the input string is {@code null} or empty 
     * but the substring array is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks each substring independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if all substrings are present
     * containsAll("hello world", "hello", "world"); // returns true
     * containsAll("hello world", "hello", "xyz");   // returns false
     * containsAll("programming", "gram", "pro");    // returns true
     * containsAll("test");                          // returns true (empty array)
     * containsAll(null, "test");                    // returns false
     * containsAll("", "test");                      // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if all the substrings are found in the given string or the specified substring array is {@code null} or empty, {@code false} otherwise
     */
    public static boolean containsAll(final String str, final String... valuesToFind) {
        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final String searchStr : valuesToFind) {
            if (!Strings.contains(str, searchStr)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether every substring in the specified array appears at least once
     * in the input string, performing case-insensitive comparisons. The method returns {@code true} if 
     * the specified substring array is empty or {@code null}. If the input string is {@code null} or empty 
     * but the substring array is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks each substring independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if all substrings are present ignoring case
     * containsAllIgnoreCase("Hello World", "HELLO", "world"); // returns true
     * containsAllIgnoreCase("Hello World", "HELLO", "XYZ");   // returns false
     * containsAllIgnoreCase("Programming", "GRAM", "PRO");    // returns true
     * containsAllIgnoreCase("test");                          // returns true (empty array)
     * containsAllIgnoreCase(null, "test");                    // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if all the substrings are found in the given string or the specified substring array is {@code null} or empty, ignoring case considerations, {@code false} otherwise
     */
    public static boolean containsAllIgnoreCase(final String str, final String... valuesToFind) {
        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final String searchStr : valuesToFind) {
            if (!Strings.containsIgnoreCase(str, searchStr)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if any of the specified characters are present in the given string.
     *
     * <p>This method determines whether at least one character from the specified array appears
     * in the input string. If either the input string or the character array is {@code null} or empty,
     * the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any character is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if any character is present
     * containsAny("hello", 'a', 'e', 'i');          // returns true ('e' is present)
     * containsAny("hello", 'x', 'y', 'z');          // returns false
     * containsAny("test", 't');                     // returns true
     * containsAny("", 'a');                         // returns false
     * containsAny(null, 'a');                       // returns false
     * containsAny("test");                          // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be found
     * @return {@code true} if any of the characters are found in the given string, {@code false} otherwise if not or if the specified {@code valuesToFind} char array is {@code null} or empty
     * @see #containsNone(String, char[])
     */
    public static boolean containsAny(final String str, final char... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAny(str, valuesToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if any of the specified substrings are present in the given string.
     *
     * <p>This method determines whether at least one substring from the specified array appears
     * in the input string. The search is case-sensitive. If either the input string or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any substring is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if any substring is present
     * containsAny("hello world", "xyz", "world");   // returns true ("world" is present)
     * containsAny("hello world", "xyz", "abc");     // returns false
     * containsAny("programming", "gram", "xyz");    // returns true
     * containsAny("", "test");                      // returns false
     * containsAny(null, "test");                    // returns false
     * containsAny("test");                          // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if any of the substrings are found in the given string, {@code false} otherwise if not or if the specified substrings array is {@code null} or empty
     * @see #containsNone(String, String[])
     */
    public static boolean containsAny(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAny(str, valuesToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if any of the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether at least one substring from the specified array appears
     * in the input string, performing case-insensitive comparisons. If either the input string 
     * or the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any substring is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if any substring is present ignoring case
     * containsAnyIgnoreCase("Hello World", "xyz", "WORLD");  // returns true
     * containsAnyIgnoreCase("Hello World", "XYZ", "ABC");    // returns false
     * containsAnyIgnoreCase("Programming", "GRAM", "xyz");   // returns true
     * containsAnyIgnoreCase("", "test");                     // returns false
     * containsAnyIgnoreCase(null, "test");                   // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if any of the substrings are found in the given string, ignoring case considerations, {@code false} otherwise if not or if the specified substrings array is {@code null} or empty
     * @see #containsNoneIgnoreCase(String, String[])
     */
    public static boolean containsAnyIgnoreCase(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        if (valuesToFind.length == 1) {
            return containsIgnoreCase(str, valuesToFind[0]);
        } else if (valuesToFind.length == 2) {
            if (containsIgnoreCase(str, valuesToFind[0])) {
                return true;
            }

            return containsIgnoreCase(str, valuesToFind[1]);
        }

        final String sourceText = str.toLowerCase();

        for (final String searchStr : valuesToFind) {
            if (isNotEmpty(searchStr) && indexOf(sourceText, searchStr.toLowerCase()) != N.INDEX_NOT_FOUND) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if none of the specified characters are present in the given string.
     *
     * <p>This method determines whether none of the characters in the specified array appear
     * in the input string. The method returns {@code true} if the string is {@code null} or empty, 
     * or if the specified character array is empty or {@code null}.</p>
     *
     * <p>The method stops checking and returns {@code false} as soon as any character is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if none of the characters are present
     * containsNone("hello", 'x', 'y', 'z');         // returns true
     * containsNone("hello", 'h', 'x');              // returns false ('h' is present)
     * containsNone("test", 'a', 'b', 'c');          // returns true
     * containsNone("", 'a');                        // returns true
     * containsNone(null, 'a');                      // returns true
     * containsNone("test");                         // returns true (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be checked
     * @return {@code true} if none of the characters are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, {@code false} otherwise
     * @see #containsAny(String, char[])
     */
    public static boolean containsNone(final String str, final char... valuesToFind) {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        final int strLen = str.length();
        char ch = 0;

        for (int i = 0; i < strLen; i++) {
            ch = str.charAt(i);

            for (final char c : valuesToFind) {
                if (c == ch) {
                    // checked by checkInputChars

                    //    if (Character.isHighSurrogate(ch)) {
                    //        if ((j == chsLast) || (i < strLast && valuesToFind[j + 1] == str.charAt(i + 1))) {
                    //            return false;
                    //        }
                    //    } else {
                    //        // ch is in the Basic Multilingual Plane
                    //        return false;
                    //    }

                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if none of the specified substrings are present in the given string.
     *
     * <p>This method determines whether none of the substrings in the specified array appear
     * in the input string. The search is case-sensitive. The method returns {@code true} if 
     * the string is {@code null} or empty, or if the specified substring array is empty or {@code null}.</p>
     *
     * <p>This method is equivalent to {@code !containsAny(str, valuesToFind)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if none of the substrings are present
     * containsNone("hello world", "xyz", "abc");    // returns true
     * containsNone("hello world", "hello", "xyz");  // returns false ("hello" is present)
     * containsNone("test", "abc", "xyz");           // returns true
     * containsNone("", "test");                     // returns true
     * containsNone(null, "test");                   // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be checked
     * @return {@code true} if none of the substrings are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, {@code false} otherwise
     * @see #containsAny(String, String[])
     */
    public static boolean containsNone(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(str, valuesToFind);
    }

    /**
     * Checks if none of the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether none of the substrings in the specified array appear
     * in the input string, performing case-insensitive comparisons. The method returns {@code true} 
     * if the string is {@code null} or empty, or if the specified substring array is empty or {@code null}.</p>
     *
     * <p>This method is equivalent to {@code !containsAnyIgnoreCase(str, valuesToFind)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if none of the substrings are present ignoring case
     * containsNoneIgnoreCase("Hello World", "xyz", "abc");   // returns true
     * containsNoneIgnoreCase("Hello World", "HELLO", "xyz"); // returns false
     * containsNoneIgnoreCase("test", "ABC", "XYZ");          // returns true
     * containsNoneIgnoreCase("", "test");                    // returns true
     * containsNoneIgnoreCase(null, "test");                  // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be checked
     * @return {@code true} if none of the substrings are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, ignoring case considerations, {@code false} otherwise
     * @see #containsAnyIgnoreCase(String, String[])
     */
    public static boolean containsNoneIgnoreCase(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAnyIgnoreCase(str, valuesToFind);
    }

    /**
     * Checks if the given string contains only the specified characters.
     *
     * <p>This method determines whether every character in the input string is contained
     * in the specified character array. The method returns {@code true} if the string is 
     * {@code null} or empty. If the character array is {@code null} or empty but the string 
     * is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks that all characters in the string are from the allowed set.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string contains only specified characters
     * containsOnly("aaa", 'a');                     // returns true
     * containsOnly("abc", 'a', 'b', 'c', 'd');     // returns true
     * containsOnly("abcd", 'a', 'b', 'c');         // returns false ('d' not allowed)
     * containsOnly("", 'a');                        // returns true
     * containsOnly(null, 'a');                      // returns true
     * containsOnly("test");                         // returns false (empty allowed set)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the character to be checked
     * @return {@code true} if the given string contains only the specified character or the given string is {@code null} or empty, {@code false} otherwise
     */
    public static boolean containsOnly(final String str, final char... valuesToFind) {
        if (isEmpty(str)) {
            return true;
        } else if (N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAnyBut(str, valuesToFind) == N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the given string contains any whitespace characters.
     *
     * <p>This method determines whether the input string contains at least one whitespace character
     * as defined by {@link Character#isWhitespace(char)}. This includes spaces, tabs, newlines,
     * and other Unicode whitespace characters. If the string is {@code null} or empty, 
     * the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a whitespace character is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check for whitespace presence
     * containsWhitespace("hello world");            // returns true (space)
     * containsWhitespace("hello\tworld");           // returns true (tab)
     * containsWhitespace("hello\nworld");           // returns true (newline)
     * containsWhitespace("helloworld");             // returns false
     * containsWhitespace("");                       // returns false
     * containsWhitespace(null);                     // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @return {@code true} if the string contains any whitespace characters, {@code false} otherwise
     */
    // From org.springframework.util.StringUtils, under Apache License 2.0
    public static boolean containsWhitespace(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        for (int i = 0, len = str.length(); i < len; i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string starts with the specified prefix.
     *
     * <p>This method determines whether the input string begins with the specified prefix string.
     * The comparison is case-sensitive. If either the string or the prefix is {@code null}, 
     * or if the prefix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>This method delegates to the standard {@link String#startsWith(String)} method.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string starts with prefix
     * startsWith("hello world", "hello");           // returns true
     * startsWith("hello world", "Hello");           // returns false (case-sensitive)
     * startsWith("hello", "hello world");           // returns false (prefix too long)
     * startsWith("test", "");                       // returns true (empty prefix)
     * startsWith(null, "test");                     // returns false
     * startsWith("test", null);                     // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @return {@code true} if the string starts with the specified prefix, {@code false} otherwise
     */
    public static boolean startsWith(final String str, final String prefix) {
        return startsWith(str, prefix, false);
    }

    /**
     * Checks if the given string starts with the specified prefix, ignoring case considerations.
     *
     * <p>This method determines whether the input string begins with the specified prefix string,
     * performing a case-insensitive comparison. If either the string or the prefix is {@code null}, 
     * or if the prefix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>The method uses {@link String#regionMatches(boolean, int, String, int, int)} for comparison.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string starts with prefix ignoring case
     * startsWithIgnoreCase("Hello World", "hello"); // returns true
     * startsWithIgnoreCase("Hello World", "HELLO"); // returns true
     * startsWithIgnoreCase("test", "TEST");         // returns true
     * startsWithIgnoreCase("hello", "hello world"); // returns false (prefix too long)
     * startsWithIgnoreCase(null, "test");           // returns false
     * startsWithIgnoreCase("test", null);           // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @return {@code true} if the string starts with the specified prefix, ignoring case considerations, {@code false} otherwise
     */
    public static boolean startsWithIgnoreCase(final String str, final String prefix) {
        return startsWith(str, prefix, true);
    }

    /**
     * Checks if the given string starts with the specified prefix, with an option to ignore case considerations.
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @param ignoreCase if {@code true}, the comparison is case-insensitive
     * @return {@code true} if the string starts with the specified prefix, considering the case sensitivity option, {@code false} otherwise
     */
    private static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {
        if (str == null || prefix == null || prefix.length() > str.length()) {
            return false;
        }

        return ignoreCase ? str.regionMatches(true, 0, prefix, 0, prefix.length()) : str.startsWith(prefix);
    }

    /**
     * Checks if the given string starts with any of the specified substrings.
     *
     * <p>This method determines whether the input string begins with at least one of the specified
     * prefix strings. The comparison is case-sensitive. If the string is {@code null} or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching prefix is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string starts with any prefix
     * startsWithAny("hello world", "hi", "hello");  // returns true
     * startsWithAny("hello world", "Hi", "Hello");  // returns false (case-sensitive)
     * startsWithAny("test", "a", "b", "t");         // returns true
     * startsWithAny("test", "a", "b", "c");         // returns false
     * startsWithAny(null, "test");                  // returns false
     * startsWithAny("test");                        // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string starts with any of the specified substrings, {@code false} otherwise
     */
    public static boolean startsWithAny(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String substr : substrs) {
            if (startsWith(str, substr)) {

                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string starts with any of the specified substrings, ignoring case considerations.
     *
     * <p>This method determines whether the input string begins with at least one of the specified
     * prefix strings, performing case-insensitive comparisons. If the string is {@code null} or 
     * the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching prefix is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string starts with any prefix ignoring case
     * startsWithAnyIgnoreCase("Hello World", "hi", "hello"); // returns true
     * startsWithAnyIgnoreCase("Hello World", "HI", "HELLO"); // returns true
     * startsWithAnyIgnoreCase("test", "A", "B", "T");        // returns true
     * startsWithAnyIgnoreCase("test", "A", "B", "C");        // returns false
     * startsWithAnyIgnoreCase(null, "test");                 // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string starts with any of the specified substrings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean startsWithAnyIgnoreCase(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String substr : substrs) {
            if (startsWithIgnoreCase(str, substr)) {

                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with the specified suffix.
     *
     * <p>This method determines whether the input string ends with the specified suffix string.
     * The comparison is case-sensitive. If either the string or the suffix is {@code null}, 
     * or if the suffix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>This method delegates to the standard {@link String#endsWith(String)} method.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string ends with suffix
     * endsWith("hello world", "world");             // returns true
     * endsWith("hello world", "World");             // returns false (case-sensitive)
     * endsWith("hello", "hello world");             // returns false (suffix too long)
     * endsWith("test", "");                         // returns true (empty suffix)
     * endsWith(null, "test");                       // returns false
     * endsWith("test", null);                       // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @return {@code true} if the string ends with the specified suffix, {@code false} otherwise
     */
    public static boolean endsWith(final String str, final String suffix) {
        return endsWith(str, suffix, false);
    }

    /**
     * Checks if the given string ends with the specified suffix, ignoring case considerations.
     *
     * <p>This method determines whether the input string ends with the specified suffix string,
     * performing a case-insensitive comparison. If either the string or the suffix is {@code null}, 
     * or if the suffix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>The method uses {@link String#regionMatches(boolean, int, String, int, int)} for comparison.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string ends with suffix ignoring case
     * endsWithIgnoreCase("Hello World", "world");   // returns true
     * endsWithIgnoreCase("Hello World", "WORLD");   // returns true
     * endsWithIgnoreCase("test", "TEST");           // returns true
     * endsWithIgnoreCase("hello", "hello world");   // returns false (suffix too long)
     * endsWithIgnoreCase(null, "test");             // returns false
     * endsWithIgnoreCase("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @return {@code true} if the string ends with the specified suffix, ignoring case considerations, {@code false} otherwise
     */
    public static boolean endsWithIgnoreCase(final String str, final String suffix) {
        return endsWith(str, suffix, true);
    }

    /**
     * Checks if the given string ends with any of the specified substrings.
     *
     * <p>This method determines whether the input string ends with at least one of the specified
     * suffix strings. The comparison is case-sensitive. If the string is {@code null} or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching suffix is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string ends with any suffix
     * endsWithAny("hello.txt", ".txt", ".doc");     // returns true
     * endsWithAny("hello.txt", ".TXT", ".DOC");     // returns false (case-sensitive)
     * endsWithAny("test", "st", "ing");             // returns true
     * endsWithAny("test", "ing", "ed");             // returns false
     * endsWithAny(null, "test");                    // returns false
     * endsWithAny("test");                          // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string ends with any of the specified substrings, {@code false} otherwise
     */
    public static boolean endsWithAny(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String searchString : substrs) {
            if (endsWith(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with any of the specified substrings, ignoring case considerations.
     *
     * <p>This method determines whether the input string ends with at least one of the specified
     * suffix strings, performing case-insensitive comparisons. If the string is {@code null} or 
     * the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching suffix is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string ends with any suffix ignoring case
     * endsWithAnyIgnoreCase("hello.txt", ".TXT", ".DOC");    // returns true
     * endsWithAnyIgnoreCase("HELLO.TXT", ".txt", ".doc");    // returns true
     * endsWithAnyIgnoreCase("test", "ST", "ING");            // returns true
     * endsWithAnyIgnoreCase("test", "ING", "ED");            // returns false
     * endsWithAnyIgnoreCase(null, "test");                   // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string ends with any of the specified substrings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean endsWithAnyIgnoreCase(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String searchString : substrs) {
            if (endsWithIgnoreCase(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with the specified suffix, with an option to ignore case considerations.
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @param ignoreCase if {@code true}, the comparison is case-insensitive
     * @return {@code true} if the string ends with the specified suffix, considering the case sensitivity option, {@code false} otherwise
     */
    private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {
        if (str == null || suffix == null || suffix.length() > str.length()) {
            return false;
        }

        final int strOffset = str.length() - suffix.length();

        return ignoreCase ? str.regionMatches(true, strOffset, suffix, 0, suffix.length()) : str.endsWith(suffix);
    }

    /**
     * Compares two strings for equality.
     *
     * <p>This method checks if two strings are equal, handling {@code null} values safely.
     * Two {@code null} values are considered equal. The comparison is case-sensitive and
     * includes a length check for optimization before comparing content.</p>
     *
     * <p>This method is null-safe and more efficient than using {@link String#equals(Object)}
     * when either string might be {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Compare strings for equality
     * equals("hello", "hello");                     // returns true
     * equals("hello", "Hello");                     // returns false (case-sensitive)
     * equals(null, null);                           // returns true
     * equals("test", null);                         // returns false
     * equals(null, "test");                         // returns false
     * equals("", "");                               // returns true
     * }</pre>
     *
     * @param a the first string to compare, which may be null
     * @param b the second string to compare, which may be null
     * @return {@code true} if the strings are equal, {@code false} otherwise
     */
    public static boolean equals(final String a, final String b) {
        return (a == null) ? b == null : (b != null && a.length() == b.length() && a.equals(b));
    }

    /**
     * Compares two strings for equality, ignoring case considerations.
     *
     * <p>This method checks if two strings are equal ignoring their case, handling {@code null} 
     * values safely. Two {@code null} values are considered equal. The comparison uses
     * {@link String#equalsIgnoreCase(String)} for non-null values.</p>
     *
     * <p>This method is null-safe alternative to {@link String#equalsIgnoreCase(String)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Compare strings for equality ignoring case
     * equalsIgnoreCase("hello", "HELLO");           // returns true
     * equalsIgnoreCase("Hello", "hello");           // returns true
     * equalsIgnoreCase(null, null);                 // returns true
     * equalsIgnoreCase("test", null);               // returns false
     * equalsIgnoreCase(null, "test");               // returns false
     * equalsIgnoreCase("", "");                     // returns true
     * }</pre>
     *
     * @param a the first string to compare, which may be null
     * @param b the second string to compare, which may be null
     * @return {@code true} if the strings are equal, ignoring case considerations, {@code false} otherwise
     */
    public static boolean equalsIgnoreCase(final String a, final String b) {
        return (a == null) ? b == null : (a.equalsIgnoreCase(b));
    }

    /**
     * Checks if the given string is equal to any of the specified search strings.
     *
     * <p>This method determines whether the input string equals at least one of the strings
     * in the specified array. The comparison is case-sensitive and null-safe. If the search
     * string array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a match is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string equals any value
     * equalsAny("test", "test", "demo", "sample");  // returns true
     * equalsAny("test", "Test", "TEST");            // returns false (case-sensitive)
     * equalsAny(null, "test", null, "demo");        // returns true (null match)
     * equalsAny("test", "demo", "sample");          // returns false
     * equalsAny("test");                            // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, which may be null
     * @param searchStrings the array of strings to compare against, may be {@code null} or empty
     * @return {@code true} if the string is equal to any of the specified search strings, {@code false} otherwise
     */
    public static boolean equalsAny(final String str, final String... searchStrings) {
        if (N.isEmpty(searchStrings)) {
            return false;
        }

        for (final String searchString : searchStrings) {
            if (equals(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string is equal to any of the specified search strings, ignoring case considerations.
     *
     * <p>This method determines whether the input string equals at least one of the strings
     * in the specified array, performing case-insensitive comparisons. The comparison is null-safe.
     * If the search string array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a match is found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Check if string equals any value ignoring case
     * equalsAnyIgnoreCase("test", "TEST", "demo");  // returns true
     * equalsAnyIgnoreCase("Test", "test", "TEST");  // returns true
     * equalsAnyIgnoreCase(null, "test", null);      // returns true (null match)
     * equalsAnyIgnoreCase("test", "demo", "sample");// returns false
     * equalsAnyIgnoreCase("test");                  // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, which may be null
     * @param searchStrs the array of strings to compare against, may be {@code null} or empty
     * @return {@code true} if the string is equal to any of the specified search strings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean equalsAnyIgnoreCase(final String str, final String... searchStrs) {
        if (N.isEmpty(searchStrs)) {
            return false;
        } else if (searchStrs.length == 1) {
            return equalsIgnoreCase(str, searchStrs[0]);
        } else if (searchStrs.length == 2) {
            if (equalsIgnoreCase(str, searchStrs[0])) {
                return true;
            }

            return equalsIgnoreCase(str, searchStrs[1]);
        }

        final String sourceText = str.toLowerCase();

        for (final String searchStr : searchStrs) {
            if (equals(sourceText, searchStr.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Compares two strings lexicographically, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive lexicographical comparison of two strings,
     * handling {@code null} values safely. {@code null} is considered less than any non-null string.
     * If both strings are {@code null}, they are considered equal (returns 0).</p>
     *
     * <p>The comparison uses {@link String#compareToIgnoreCase(String)} for non-null values.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Compare strings ignoring case
     * compareIgnoreCase("abc", "ABC");              // returns 0
     * compareIgnoreCase("abc", "def");              // returns negative value
     * compareIgnoreCase("def", "abc");              // returns positive value
     * compareIgnoreCase(null, "abc");               // returns -1
     * compareIgnoreCase("abc", null);               // returns 1
     * compareIgnoreCase(null, null);                // returns 0
     * }</pre>
     *
     * @param a the first string to compare, which may be null
     * @param b the second string to compare, which may be null
     * @return a negative integer, zero, or a positive integer as the first string is less than, equal to, or greater than the second string, ignoring case considerations
     */
    public static int compareIgnoreCase(final String a, final String b) {
        return a == null ? (b == null ? 0 : -1) : (b == null ? 1 : a.compareToIgnoreCase(b));
    }

    /**
     * Compares two Strings and returns the index at which the Strings begin to differ.
     *
     * <p>This method finds the first position where two strings have different characters.
     * If the strings are equal or both are empty (including {@code null}), the method returns -1.
     * If one string is a prefix of the other, the method returns the length of the shorter string.</p>
     *
     * <p>The comparison is case-sensitive and character-by-character.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Find index of first difference
     * indexOfDifference("i am a machine", "i am a robot");    // returns 7
     * indexOfDifference("abc", "abc");                        // returns -1 (identical)
     * indexOfDifference("ab", "abxyz");                       // returns 2
     * indexOfDifference("abcde", "abxyz");                    // returns 2
     * indexOfDifference("abcde", "xyz");                      // returns 0
     * indexOfDifference("", "abc");                           // returns 0
     * indexOfDifference(null, null);                          // returns -1
     * }</pre>
     *
     * @param a the first String, which may be null
     * @param b the second String, which may be null
     * @return the index where the strings begin to differ, or -1 if they are equal
     */
    public static int indexOfDifference(final String a, final String b) {
        if (N.equals(a, b) || (isEmpty(a) && isEmpty(b))) {
            return N.INDEX_NOT_FOUND;
        }

        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        int i = 0;
        for (final int len = N.min(a.length(), b.length()); i < len; i++) {
            if (a.charAt(i) != b.charAt(i)) {
                break;
            }
        }

        if (i < b.length() || i < a.length()) {
            return i;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Compares all Strings in an array and returns the index at which the Strings begin to differ.
     *
     * <p>This method finds the first position where any two strings in the array have different
     * characters. If all strings are equal, the array is empty, has only one element, or all
     * elements are {@code null}/empty, the method returns -1. If any string is {@code null},
     * it's treated as having length 0.</p>
     *
     * <p>The comparison stops at the length of the shortest string. If all strings are identical
     * up to that point but have different lengths, the method returns the length of the shortest string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Find index of first difference across multiple strings
     * indexOfDifference("i am a machine", "i am a robot");     // returns 7
     * indexOfDifference("abc", "abc", "abc");                  // returns -1
     * indexOfDifference("abc", "a");                           // returns 1
     * indexOfDifference("ab", "abxyz", "abcde");               // returns 2
     * indexOfDifference("", "abc", "xyz");                     // returns 0
     * indexOfDifference((String[]) null);                      // returns -1
     * }</pre>
     *
     * @param strs array of Strings, entries may be null
     * @return the index where strings begin to differ, or -1 if all strings are equal or null/empty
     */
    public static int indexOfDifference(final String... strs) {
        if (N.isEmpty(strs) || strs.length == 1) {
            return N.INDEX_NOT_FOUND;
        }

        final int arrayLen = strs.length;
        int shortestStrLen = Integer.MAX_VALUE;
        int longestStrLen = 0;

        // find the min and max string lengths; this avoids checking to make
        // sure we are not exceeding the length of the string each time through
        // the bottom loop.
        for (final String str : strs) {
            if (str == null) {
                shortestStrLen = 0;
            } else {
                shortestStrLen = Math.min(str.length(), shortestStrLen);
                longestStrLen = Math.max(str.length(), longestStrLen);
            }
        }

        // handle lists containing all nulls or all empty strings
        if (longestStrLen == 0) {
            return N.INDEX_NOT_FOUND;
        }

        if (shortestStrLen == 0) {
            return 0;
        }

        // find the position with the first difference across all strings
        int firstDiff = -1;
        char comparisonChar = 0;

        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
            comparisonChar = strs[0].charAt(stringPos);

            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {
                    firstDiff = stringPos;
                    break;
                }
            }

            if (firstDiff != -1) {
                break;
            }
        }

        if (firstDiff == -1 && shortestStrLen != longestStrLen) {
            // we compared all the characters up to the length of the
            // shortest string and didn't find a match, but the string lengths
            // vary, so return the length of the shortest string.
            return shortestStrLen;
        }

        return firstDiff;
    }

    /**
     * Returns the length of the common prefix between two CharSequences.
     *
     * <p>This method compares the two CharSequences character by character from the beginning and returns
     * the number of characters that are identical. The comparison stops when a mismatch is found or when
     * the end of either CharSequence is reached. The method properly handles Unicode surrogate pairs.</p>
     *
     * <p>The method returns 0 if either CharSequence is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lengthOfCommonPrefix("hello", "help");         // returns 3 (common prefix "hel")
     * lengthOfCommonPrefix("abc", "abcdef");         // returns 3 (common prefix "abc")
     * lengthOfCommonPrefix("test", "best");          // returns 0 (no common prefix)
     * lengthOfCommonPrefix("", "hello");             // returns 0 (empty string)
     * lengthOfCommonPrefix(null, "hello");           // returns 0 (null input)
     * lengthOfCommonPrefix("hello", "hello");        // returns 5 (identical strings)
     * }</pre>
     *
     * @param a The first CharSequence to compare. It can be {@code null}.
     * @param b The second CharSequence to compare. It can be {@code null}.
     * @return The length of the common prefix, or 0 if either CharSequence is {@code null} or empty.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #lengthOfCommonSuffix(CharSequence, CharSequence)
     */
    public static int lengthOfCommonPrefix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        final int maxPrefixLength = Math.min(a.length(), b.length());
        int cnt = 0;

        while (cnt < maxPrefixLength && a.charAt(cnt) == b.charAt(cnt)) {
            cnt++;
        }

        if (validSurrogatePairAt(a, cnt - 1) || validSurrogatePairAt(b, cnt - 1)) {
            cnt--;
        }

        return cnt;
    }

    /**
     * Returns the length of the common suffix between two CharSequences.
     *
     * <p>This method compares the two CharSequences character by character from the end and returns
     * the number of characters that are identical. The comparison stops when a mismatch is found or when
     * the beginning of either CharSequence is reached. The method properly handles Unicode surrogate pairs.</p>
     *
     * <p>The method returns 0 if either CharSequence is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lengthOfCommonSuffix("hello", "jello");        // returns 4 (common suffix "ello")
     * lengthOfCommonSuffix("testing", "ing");        // returns 3 (common suffix "ing")
     * lengthOfCommonSuffix("test", "best");          // returns 3 (common suffix "est")
     * lengthOfCommonSuffix("abc", "xyz");            // returns 0 (no common suffix)
     * lengthOfCommonSuffix("", "hello");             // returns 0 (empty string)
     * lengthOfCommonSuffix(null, "hello");           // returns 0 (null input)
     * }</pre>
     *
     * @param a The first CharSequence to compare. It can be {@code null}.
     * @param b The second CharSequence to compare. It can be {@code null}.
     * @return The length of the common suffix, or 0 if either CharSequence is {@code null} or empty.
     * @see #commonSuffix(CharSequence, CharSequence)
     * @see #lengthOfCommonPrefix(CharSequence, CharSequence)
     */
    public static int lengthOfCommonSuffix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        final int aLength = a.length();
        final int bLength = b.length();
        final int maxSuffixLength = Math.min(aLength, bLength);
        int cnt = 0;

        while (cnt < maxSuffixLength && a.charAt(aLength - cnt - 1) == b.charAt(bLength - cnt - 1)) {
            cnt++;
        }

        if (validSurrogatePairAt(a, aLength - cnt - 1) || validSurrogatePairAt(b, bLength - cnt - 1)) {
            cnt--;
        }

        return cnt;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * Returns the longest string {@code prefix} such that
     * {@code a.toString().startsWith(prefix) && b.toString().startsWith(prefix)}
     * , taking care not to split surrogate pairs. If {@code a} and {@code b}
     * have no common prefix, returns the empty string.
     *
     * @param a the first CharSequence to compare
     * @param b the second CharSequence to compare
     * @return the longest common prefix, or an empty string if there is no common prefix
     */
    public static String commonPrefix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int commonPrefixLen = lengthOfCommonPrefix(a, b);

        if (commonPrefixLen == a.length()) {
            return a.toString();
        } else if (commonPrefixLen == b.length()) {
            return b.toString();
        } else {
            return a.subSequence(0, commonPrefixLen).toString();
        }
    }

    /**
     * Returns the longest common prefix among an array of CharSequences.
     *
     * <p>This method finds the longest string that appears at the beginning of all provided CharSequences.
     * It compares all CharSequences in the array and returns the characters that are common to all of them
     * from the beginning. The comparison is case-sensitive.</p>
     *
     * <p>The method returns an empty string if the array is empty, {@code null}, any CharSequence is {@code null} or empty,
     * or if there is no common prefix among the CharSequences.</p>
     *
     * <p>Example:
     * <pre>{@code
     * commonPrefix("flower", "flow", "flight");      // returns "fl"
     * commonPrefix("dog", "racecar", "car");         // returns "" (no common prefix)
     * commonPrefix("interspecies", "interstellar", "interstate"); // returns "inters"
     * commonPrefix("prefix");                        // returns "prefix" (single element)
     * commonPrefix();                                // returns "" (empty array)
     * commonPrefix("test", null, "testing");         // returns "" (null element)
     * commonPrefix("", "hello");                     // returns "" (empty element)
     * }</pre>
     *
     * @param strs The array of CharSequences to compare. It can be empty or contain {@code null} elements.
     * @return The longest common prefix among the given CharSequences, or an empty string if no common prefix exists.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #lengthOfCommonPrefix(CharSequence, CharSequence)
     */
    public static String commonPrefix(final CharSequence... strs) {
        if (N.isEmpty(strs)) {
            return EMPTY;
        }

        if (strs.length == 1) {
            return isEmpty(strs[0]) ? EMPTY : strs[0].toString();
        } else if (isAnyEmpty(strs)) {
            return EMPTY;
        }

        String commonPrefix = commonPrefix(strs[0], strs[1]);

        if (isEmpty(commonPrefix)) {
            return EMPTY;
        }

        for (int i = 2, len = strs.length; i < len; i++) {
            commonPrefix = commonPrefix(commonPrefix, strs[i]);

            if (isEmpty(commonPrefix)) {
                return commonPrefix;
            }
        }

        return commonPrefix;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p> 
     *
     * Returns the longest string {@code suffix} such that
     * {@code a.toString().endsWith(suffix) && b.toString().endsWith(suffix)},
     * taking care not to split surrogate pairs. If {@code a} and {@code b} have
     * no common suffix, returns the empty string.
     *
     * @param a the first CharSequence to compare
     * @param b the second CharSequence to compare
     * @return the longest common suffix, or an empty string if there is no common suffix
     */
    public static String commonSuffix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int aLength = a.length();
        final int commonSuffixLen = lengthOfCommonSuffix(a, b);

        if (commonSuffixLen == aLength) {
            return a.toString();
        } else if (commonSuffixLen == b.length()) {
            return b.toString();
        } else {
            return a.subSequence(aLength - commonSuffixLen, aLength).toString();
        }
    }

    /**
     * Returns the longest common suffix among an array of CharSequences.
     *
     * <p>This method finds the longest string that appears at the end of all provided CharSequences.
     * It compares all CharSequences in the array and returns the characters that are common to all of them
     * from the end. The comparison is case-sensitive.</p>
     *
     * <p>The method returns an empty string if the array is empty, {@code null}, any CharSequence is {@code null} or empty,
     * or if there is no common suffix among the CharSequences.</p>
     *
     * <p>Example:
     * <pre>{@code
     * commonSuffix("testing", "eating", "meeting");  // returns "ting"
     * commonSuffix("hello", "jello", "yellow");      // returns "llo"
     * commonSuffix("abc", "xyz", "123");             // returns "" (no common suffix)
     * commonSuffix("suffix");                        // returns "suffix" (single element)
     * commonSuffix();                                // returns "" (empty array)
     * commonSuffix("test", null, "best");            // returns "" (null element)
     * commonSuffix("", "hello");                     // returns "" (empty element)
     * }</pre>
     *
     * @param strs The array of CharSequences to compare. It can be empty or contain {@code null} elements.
     * @return The longest common suffix among the given CharSequences, or an empty string if no common suffix exists.
     * @see #commonSuffix(CharSequence, CharSequence)
     * @see #lengthOfCommonSuffix(CharSequence, CharSequence)
     */
    public static String commonSuffix(final CharSequence... strs) {
        if (N.isEmpty(strs)) {
            return EMPTY;
        }

        if (strs.length == 1) {
            return isEmpty(strs[0]) ? EMPTY : strs[0].toString();
        } else if (isAnyEmpty(strs)) {
            return EMPTY;
        }

        String commonSuffix = commonSuffix(strs[0], strs[1]);

        if (isEmpty(commonSuffix)) {
            return EMPTY;
        }

        for (int i = 2, len = strs.length; i < len; i++) {
            commonSuffix = commonSuffix(commonSuffix, strs[i]);

            if (isEmpty(commonSuffix)) {
                return commonSuffix;
            }
        }

        return commonSuffix;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * True when a valid surrogate pair starts at the given {@code index} in the
     * given {@code string}. Out-of-range indexes return {@code false}.
     *
     * @param str
     * @param index
     * @return
     */
    static boolean validSurrogatePairAt(final CharSequence str, final int index) {
        return index >= 0 && index <= (str.length() - 2) && Character.isHighSurrogate(str.charAt(index)) && Character.isLowSurrogate(str.charAt(index + 1));
    }

    /**
     * Returns the longest common substring between two given CharSequences.
     *
     * <p>This method finds the longest sequence of characters that appears in both CharSequences at any position.
     * Unlike common prefix/suffix methods, the common substring can appear anywhere in both CharSequences.
     * The comparison is case-sensitive and uses dynamic programming for efficient computation.</p>
     *
     * <p>The method returns an empty string if either CharSequence is {@code null}, empty, or if there is no common substring.</p>
     *
     * <p>Example:
     * <pre>{@code
     * longestCommonSubstring("abcdxyz", "xyzabcd");  // returns "abcd" (or "xyz")
     * longestCommonSubstring("zxabcdezy", "yzabcdezx"); // returns "abcdez"
     * longestCommonSubstring("hello", "yellow");     // returns "ello"
     * longestCommonSubstring("abc", "def");          // returns "" (no common substring)
     * longestCommonSubstring("", "hello");           // returns "" (empty string)
     * longestCommonSubstring(null, "hello");         // returns "" (null input)
     * }</pre>
     *
     * @param a The first CharSequence to compare. It can be {@code null}.
     * @param b The second CharSequence to compare. It can be {@code null}.
     * @return The longest common substring, or an empty string if no common substring exists.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #commonSuffix(CharSequence, CharSequence)
     */
    public static String longestCommonSubstring(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int lenA = N.len(a);
        final int lenB = N.len(b);

        char[] charsToCheck = null;
        if (lenA < lenB) {
            charsToCheck = a.toString().toCharArray();
        } else {
            charsToCheck = b.toString().toCharArray();
        }

        checkInputChars(charsToCheck, lenA < lenB ? "a" : "b", true);

        final int[] dp = new int[lenB + 1];
        int endIndex = 0;
        int maxLen = 0;

        if (lenA > 16 || lenB > 16) {
            final char[] chsA = lenA < lenB ? charsToCheck : a.toString().toCharArray();
            final char[] chsB = lenA < lenB ? b.toString().toCharArray() : charsToCheck;

            for (int i = 1; i <= lenA; i++) {
                for (int j = lenB; j > 0; j--) {
                    if (chsA[i - 1] == chsB[j - 1]) {
                        dp[j] = 1 + dp[j - 1];

                        if (dp[j] > maxLen) {
                            maxLen = dp[j];
                            endIndex = i;
                        }
                    } else {
                        dp[j] = 0;
                    }
                }
            }
        } else {
            for (int i = 1; i <= lenA; i++) {
                for (int j = lenB; j > 0; j--) {
                    if (a.charAt(i - 1) == b.charAt(j - 1)) {
                        dp[j] = 1 + dp[j - 1];

                        if (dp[j] > maxLen) {
                            maxLen = dp[j];
                            endIndex = i;
                        }
                    } else {
                        dp[j] = 0;
                    }
                }
            }
        }

        if (maxLen == 0) {
            return EMPTY;
        }

        return a.subSequence(endIndex - maxLen, endIndex).toString();
    }

    /**
     * Returns the first character of the given string as an OptionalChar.
     *
     * <p>This method extracts the first character from the provided string and wraps it in an OptionalChar.
     * If the string is {@code null} or empty, an empty OptionalChar is returned, allowing for safe handling
     * of edge cases without throwing exceptions.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstChar("Hello");                    // returns OptionalChar.of('H')
     * firstChar("A");                        // returns OptionalChar.of('A')
     * firstChar("");                         // returns OptionalChar.empty()
     * firstChar(null);                       // returns OptionalChar.empty()
     * firstChar("  spaces");                 // returns OptionalChar.of(' ')
     * }</pre>
     *
     * @param str The input string from which to extract the first character. It can be {@code null} or empty.
     * @return An OptionalChar containing the first character of the string, or an empty OptionalChar if the string is {@code null} or empty.
     * @see #lastChar(String)
     * @see OptionalChar
     */
    public static OptionalChar firstChar(final String str) {
        if (str == null || str.isEmpty()) {
            return OptionalChar.empty();
        }

        return OptionalChar.of(str.charAt(0));
    }

    /**
     * Returns the last character of the given string as an OptionalChar.
     *
     * <p>This method extracts the last character from the provided string and wraps it in an OptionalChar.
     * If the string is {@code null} or empty, an empty OptionalChar is returned, allowing for safe handling
     * of edge cases without throwing exceptions.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastChar("Hello");                     // returns OptionalChar.of('o')
     * lastChar("A");                         // returns OptionalChar.of('A')
     * lastChar("");                          // returns OptionalChar.empty()
     * lastChar(null);                        // returns OptionalChar.empty()
     * lastChar("test ");                     // returns OptionalChar.of(' ')
     * }</pre>
     *
     * @param str The input string from which to extract the last character. It can be {@code null} or empty.
     * @return An OptionalChar containing the last character of the string, or an empty OptionalChar if the string is {@code null} or empty.
     * @see #firstChar(String)
     * @see OptionalChar
     */
    public static OptionalChar lastChar(final String str) {
        if (str == null || str.isEmpty()) {
            return OptionalChar.empty();
        }

        return OptionalChar.of(str.charAt(str.length() - 1));
    }

    /**
     * Returns at most the first {@code n} characters of the specified string.
     *
     * <p>This method extracts up to {@code n} characters from the beginning of the string.
     * If the string length is less than or equal to {@code n}, the entire string is returned.
     * If the string is {@code null} or empty, or if {@code n} is 0, an empty string is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * firstChars("Hello World", 5);          // returns "Hello"
     * firstChars("Hi", 5);                   // returns "Hi" (string shorter than n)
     * firstChars("Testing", 0);              // returns ""
     * firstChars("", 5);                     // returns ""
     * firstChars(null, 5);                   // returns ""
     * firstChars("Example", 7);              // returns "Example" (exact length)
     * }</pre>
     *
     * @param str The input string from which to extract characters. It can be {@code null} or empty.
     * @param n The maximum number of characters to return from the beginning of the string.
     * @return At most the first {@code n} characters of the string, or an empty string if the input is {@code null} or empty.
     * @throws IllegalArgumentException if {@code n} is negative.
     * @see #lastChars(String, int)
     */
    @Beta
    public static String firstChars(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (str == null || str.isEmpty() || n == 0) {
            return EMPTY;
        } else if (str.length() <= n) {
            return str;
        } else {
            return str.substring(0, n);
        }
    }

    /**
     * Returns at most the last {@code n} characters of the specified string.
     *
     * <p>This method extracts up to {@code n} characters from the end of the string.
     * If the string length is less than or equal to {@code n}, the entire string is returned.
     * If the string is {@code null} or empty, or if {@code n} is 0, an empty string is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lastChars("Hello World", 5);           // returns "World"
     * lastChars("Hi", 5);                    // returns "Hi" (string shorter than n)
     * lastChars("Testing", 0);               // returns ""
     * lastChars("", 5);                      // returns ""
     * lastChars(null, 5);                    // returns ""
     * lastChars("Example", 7);               // returns "Example" (exact length)
     * }</pre>
     *
     * @param str The input string from which to extract characters. It can be {@code null} or empty.
     * @param n The maximum number of characters to return from the end of the string.
     * @return At most the last {@code n} characters of the string, or an empty string if the input is {@code null} or empty.
     * @throws IllegalArgumentException if {@code n} is negative.
     * @see #firstChars(String, int)
     */
    @Beta
    public static String lastChars(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (str == null || str.isEmpty() || n == 0) {
            return EMPTY;
        } else if (str.length() <= n) {
            return str;
        } else {
            return str.substring(str.length() - n);
        }
    }

    /**
     * Returns a substring from the specified string starting at the given index.
     *
     * <p>This method extracts a substring from the provided string starting at {@code inclusiveBeginIndex}
     * and continuing to the end of the string. Unlike {@code String.substring()}, this method returns
     * {@code null} instead of throwing an exception for invalid indices.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the index is negative,
     * or the index is greater than the string length.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello World", 6);           // returns "World"
     * substring("Hello", 0);                 // returns "Hello"
     * substring("Hello", 5);                 // returns "" (index at string length)
     * substring("Hello", -1);                // returns null (negative index)
     * substring("Hello", 10);                // returns null (index > length)
     * substring(null, 0);                    // returns null
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param inclusiveBeginIndex The starting index of the substring (inclusive).
     * @return The substring starting from the specified index, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int)
     * @see #substring(String, int, int)
     * @see #substringAfter(String, char)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex) {
        if (str == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        return str.substring(inclusiveBeginIndex);
    }

    //    /**
    //     * Returns {@code null} which means it doesn't exist if {@code (str == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length())},
    //     * otherwise returns: {@code str.substring(inclusiveBeginIndex)}.
    //     *
    //     * @param str
    //     * @param inclusiveBeginIndex
    //     * @return
    //     * @see #substring(String, int)
    //     * @see StrUtil#substring(String, int)
    //     * @see #substring(String, int, int)
    //     * @see #largestSubstring(String, int, int)
    //     */
    //    @MayReturnNull
    //    public static String substringAfter(String str, int inclusiveBeginIndex) {
    //        if (str == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
    //            return null;
    //        }
    //
    //        return str.substring(inclusiveBeginIndex);
    //    }

    /**
     * Returns a substring from the specified string between the given indices.
     *
     * <p>This method extracts a substring from the provided string starting at {@code inclusiveBeginIndex}
     * and ending before {@code exclusiveEndIndex}. Unlike {@code String.substring()}, this method returns
     * {@code null} instead of throwing an exception for invalid indices. If {@code exclusiveEndIndex}
     * exceeds the string length, it is adjusted to the string length.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, either index is negative,
     * or the begin index is greater than the end index or string length.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello World", 0, 5);        // returns "Hello"
     * substring("Hello World", 6, 11);       // returns "World"
     * substring("Hello", 1, 10);             // returns "ello" (end index adjusted)
     * substring("Hello", 2, 2);              // returns "" (empty range)
     * substring("Hello", -1, 3);             // returns null (negative index)
     * substring("Hello", 3, 1);              // returns null (begin > end)
     * substring(null, 0, 5);                 // returns null
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param inclusiveBeginIndex The starting index of the substring (inclusive).
     * @param exclusiveEndIndex The ending index of the substring (exclusive).
     * @return The substring between the specified indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || inclusiveBeginIndex < 0 || exclusiveEndIndex < 0 || inclusiveBeginIndex > exclusiveEndIndex || inclusiveBeginIndex > str.length()) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, N.min(exclusiveEndIndex, str.length()));
    }

    /**
     * Returns a substring from the specified string using a function to determine the end index.
     *
     * <p>This method extracts a substring starting at {@code inclusiveBeginIndex}. The end index is
     * determined by applying the provided {@code IntUnaryOperator} function to the begin index.
     * This allows for dynamic calculation of the substring length based on the starting position.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the begin index is negative,
     * or if the function returns a negative end index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Get next 3 characters from index
     * substring("Hello World", 0, i -> i + 3);      // returns "Hel"
     * substring("Hello World", 6, i -> i + 5);      // returns "World"
     * 
     * // Get to string length
     * substring("Hello", 2, i -> 5);                // returns "llo"
     * 
     * // Invalid cases
     * substring("Hello", -1, i -> i + 3);           // returns null (negative index)
     * substring(null, 0, i -> i + 3);               // returns null
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param inclusiveBeginIndex The starting index of the substring (inclusive).
     * @param funcOfExclusiveEndIndex Function that calculates the end index based on the begin index.
     * @return The substring determined by the indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int, IntUnaryOperator)
     * @see #substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || inclusiveBeginIndex < 0) {
            return null;
        }

        return substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex.applyAsInt(inclusiveBeginIndex));
    }

    //    /**
    //     * Returns {@code null} which means it doesn't exist if {@code (str == null || inclusiveBeginIndex < 0)}, or {@code funcOfExclusiveEndIndex.apply(str, inclusiveBeginIndex) < 0}.
    //     *
    //     * @param str
    //     * @param inclusiveBeginIndex
    //     * @param funcOfExclusiveEndIndex {@code exclusiveEndIndex <- funcOfExclusiveEndIndex.apply(str, inclusiveBeginIndex) if inclusiveBeginIndex >= 0}
    //     * @return {@code null} if {@code (str == null || inclusiveBeginIndex < 0)}. (auto-generated java doc for return)
    //     * @see #substring(String, int, int)
    //     */
    //    @MayReturnNull
    //    @Beta
    //    public static String substring(final String str, final int inclusiveBeginIndex, final BiFunction<? super String, Integer, Integer> funcOfExclusiveEndIndex) {
    //        if (str == null || inclusiveBeginIndex < 0) {
    //            return null;
    //        }
    //
    //        return substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex.apply(str, inclusiveBeginIndex));
    //    }

    /**
     * Returns a substring from the specified string using a function to determine the begin index.
     *
     * <p>This method extracts a substring ending before {@code exclusiveEndIndex}. The begin index is
     * determined by applying the provided {@code IntUnaryOperator} function to the end index.
     * This allows for dynamic calculation of the substring start based on the ending position.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the end index is negative,
     * or if the function returns a negative begin index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Get 3 characters before end index
     * substring("Hello World", i -> i - 3, 8);      // returns "Wor"
     * substring("Hello World", i -> i - 5, 5);      // returns "Hello"
     * 
     * // Get from start to index
     * substring("Hello", i -> 0, 3);                // returns "Hel"
     * 
     * // Invalid cases
     * substring("Hello", i -> i - 3, -1);           // returns null (negative end index)
     * substring(null, i -> 0, 5);                   // returns null
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param funcOfInclusiveBeginIndex Function that calculates the begin index based on the end index.
     * @param exclusiveEndIndex The ending index of the substring (exclusive).
     * @return The substring determined by the indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, IntUnaryOperator, int)
     * @see #substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex < 0) {
            return null;
        }

        return substring(str, funcOfInclusiveBeginIndex.applyAsInt(exclusiveEndIndex), exclusiveEndIndex);
    }

    //    /**
    //     * Returns {@code null} which means it doesn't exist if {@code (str == null || exclusiveEndIndex < 0)}, or {@code funcOfInclusiveBeginIndex.apply(str, exclusiveEndIndex) < 0}.
    //     *
    //     *
    //     * @param str
    //     * @param funcOfInclusiveBeginIndex {@code inclusiveBeginIndex <- funcOfInclusiveBeginIndex.apply(str, exclusiveEndIndex)) if exclusiveEndIndex > 0}
    //     * @param exclusiveEndIndex
    //     * @return {@code null} if {@code (str == null || exclusiveEndIndex < 0)}. (auto-generated java doc for return)
    //     * @see #substring(String, int, int)
    //     */
    //    @MayReturnNull
    //    @Beta
    //    public static String substring(final String str, final BiFunction<? super String, Integer, Integer> funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
    //        if (str == null || exclusiveEndIndex < 0) {
    //            return null;
    //        }
    //
    //        return substring(str, funcOfInclusiveBeginIndex.apply(str, exclusiveEndIndex), exclusiveEndIndex);
    //    }

    /**
     * Returns a substring starting from the first occurrence of the specified character.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfInclusiveBeginIndex} in the string
     * and returns the substring starting from that character (inclusive) to the end of the string.
     * The delimiter character is included in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello World", ' ');         // returns " World"
     * substring("user@example.com", '@');    // returns "@example.com"
     * substring("Hello", 'x');               // returns null (not found)
     * substring("", 'a');                    // returns null (empty string)
     * substring(null, 'a');                  // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null} or empty.
     * @param delimiterOfInclusiveBeginIndex The character marking the start of the substring (inclusive).
     * @return The substring starting from the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, char)
     * @deprecated Use {@link #substringAfter(String, char)} for clearer semantics
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final char delimiterOfInclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        return substring(str, str.indexOf(delimiterOfInclusiveBeginIndex));
    }

    /**
     * Returns a substring starting from the first occurrence of the specified delimiter string.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfInclusiveBeginIndex} in the string
     * and returns the substring starting from that delimiter (inclusive) to the end of the string.
     * The delimiter string is included in the returned substring. If the delimiter is empty,
     * the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello World", "Wo");        // returns "World"
     * substring("user@example.com", "@");    // returns "@example.com"
     * substring("Hello", "xyz");             // returns null (not found)
     * substring("Hello", "");                // returns "Hello" (empty delimiter)
     * substring(null, "test");               // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfInclusiveBeginIndex The delimiter string marking the start of the substring (inclusive).
     * @return The substring starting from the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @deprecated Use {@link #substringAfter(String, String)} for clearer semantics
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final String delimiterOfInclusiveBeginIndex) {
        if (str == null || delimiterOfInclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfInclusiveBeginIndex.isEmpty()) {
            return str;
        }

        return substring(str, str.indexOf(delimiterOfInclusiveBeginIndex));
    }

    /**
     * Returns a substring between a starting index and the first occurrence of a delimiter character.
     *
     * <p>This method extracts a substring starting from {@code inclusiveBeginIndex} and ending before
     * the first occurrence of {@code delimiterOfExclusiveEndIndex} found after the begin index.
     * The search for the delimiter starts at {@code inclusiveBeginIndex + 1}.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, the begin index is invalid,
     * or if the delimiter is not found after the begin index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello, World!", 0, ',');    // returns "Hello"
     * substring("a-b-c-d", 2, '-');          // returns "b"
     * substring("test", 0, 'x');             // returns null (delimiter not found)
     * substring("test", -1, 't');            // returns null (invalid index)
     * substring(null, 0, ',');               // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null} or empty.
     * @param inclusiveBeginIndex The starting index of the substring (inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (exclusive).
     * @return The substring between the index and delimiter, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final int inclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.isEmpty() || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1);

        // inconsistant behavior
        //    if (index < 0 && str.charAt(inclusiveBeginIndex) == delimiterOfExclusiveEndIndex) {
        //        return EMPTY_STRING;
        //    }

        return substring(str, inclusiveBeginIndex, index);
    }

    /**
     * Returns a substring between a starting index and the first occurrence of a delimiter string.
     *
     * <p>This method extracts a substring starting from {@code inclusiveBeginIndex} and ending before
     * the first occurrence of {@code delimiterOfExclusiveEndIndex} found after the begin index.
     * The search for the delimiter starts at {@code inclusiveBeginIndex + 1}. If the delimiter is empty,
     * an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * the begin index is invalid, or if the delimiter is not found after the begin index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("Hello, World!", 0, ", ");   // returns "Hello"
     * substring("<tag>content</tag>", 5, "</"); // returns "content"
     * substring("test", 0, "xyz");           // returns null (delimiter not found)
     * substring("test", 0, "");              // returns "" (empty delimiter)
     * substring(null, 0, "test");            // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param inclusiveBeginIndex The starting index of the substring (inclusive).
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring (exclusive).
     * @return The substring between the index and delimiter, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        return substring(str, inclusiveBeginIndex, str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1));
    }

    /**
     * Returns a substring from the last occurrence of a delimiter character to a specified end index.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfInclusiveBeginIndex} before
     * {@code exclusiveEndIndex - 1} and returns the substring starting from that delimiter (inclusive)
     * up to the end index (exclusive).</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, the end index is negative,
     * or if the delimiter is not found before the end index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("a-b-c-d", '-', 7);          // returns "-d" (last '-' before index 6)
     * substring("hello world", ' ', 11);     // returns " world"
     * substring("test", 'x', 4);             // returns null (delimiter not found)
     * substring("test", 't', -1);            // returns null (negative index)
     * substring(null, 'a', 5);               // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null} or empty.
     * @param delimiterOfInclusiveBeginIndex The character marking the start of the substring (inclusive).
     * @param exclusiveEndIndex The ending index of the substring (exclusive).
     * @return The substring from the last delimiter to the end index, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final char delimiterOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || str.isEmpty() || exclusiveEndIndex < 0) {
            return null;
        }

        return substring(str, str.lastIndexOf(delimiterOfInclusiveBeginIndex, exclusiveEndIndex - 1), exclusiveEndIndex);
    }

    /**
     * Returns a substring from the last occurrence of a delimiter string to a specified end index.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfInclusiveBeginIndex} before
     * {@code exclusiveEndIndex - delimiterOfInclusiveBeginIndex.length()} and returns the substring
     * starting from that delimiter (inclusive) up to the end index (exclusive). If the delimiter is empty,
     * an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * the end index is negative, or if the delimiter is not found before the adjusted search position.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substring("<a><b><c>", "<", 9);        // returns "<c>" (last '<' before adjusted position)
     * substring("foo-bar-baz", "-", 11);     // returns "-baz"
     * substring("test", "xyz", 4);           // returns null (delimiter not found)
     * substring("test", "", 4);              // returns "" (empty delimiter)
     * substring(null, "test", 5);            // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfInclusiveBeginIndex The delimiter string marking the start of the substring (inclusive).
     * @param exclusiveEndIndex The ending index of the substring (exclusive).
     * @return The substring from the last delimiter to the end index, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final String delimiterOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfInclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfInclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        return substring(str, str.lastIndexOf(delimiterOfInclusiveBeginIndex, exclusiveEndIndex - delimiterOfInclusiveBeginIndex.length()), exclusiveEndIndex);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter character.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * This is useful for extracting content after a known separator.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfter("user@example.com", '@');      // returns "example.com"
     * substringAfter("Hello World", ' ');           // returns "World"
     * substringAfter("test", 'x');                  // returns null (not found)
     * substringAfter("test:", ':');                 // returns "" (delimiter at end)
     * substringAfter("", 'a');                      // returns null (empty string)
     * substringAfter(null, 'a');                    // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null} or empty.
     * @param delimiterOfExclusiveBeginIndex The character after which to extract the substring.
     * @return The substring after the delimiter, or {@code null} if the delimiter is not found.
     * @see #substringBefore(String, char)
     * @see #substringAfterLast(String, char)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final char delimiterOfExclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + 1);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter string.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * If the delimiter is empty, the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfter("www.example.com", "www.");    // returns "example.com"
     * substringAfter("Hello::World", "::");         // returns "World"
     * substringAfter("NoDelimiter", "xyz");         // returns null (not found)
     * substringAfter("test", "");                   // returns "test" (empty delimiter)
     * substringAfter(null, "test");                 // returns null
     * substringAfter("test", null);                 // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string after which to extract the substring.
     * @return The substring after the delimiter, or {@code null} if the delimiter is not found.
     * @see #substringBefore(String, String)
     * @see #substringAfterLast(String, String)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return str;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the first occurrence of a delimiter, up to a specified end index.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns the substring after it up to {@code exclusiveEndIndex}. The delimiter itself is not
     * included. If the delimiter is empty, returns the substring from start to the end index.</p>
     *
     * <p>The method returns {@code null} if any input is {@code null}, the end index is negative,
     * the delimiter is not found, or if the delimiter's position would exceed the end index.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfter("Hello, World!", ", ", 10);    // returns "Wo"
     * substringAfter("a-b-c-d", "-", 5);            // returns "b"
     * substringAfter("test", "t", 3);               // returns "es"
     * substringAfter("test", "", 2);                // returns "te" (empty delimiter)
     * substringAfter("test", "st", 4);              // returns null (delimiter end > endIndex)
     * substringAfter(null, "test", 5);              // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string after which to extract the substring.
     * @param exclusiveEndIndex The ending index of the substring (exclusive).
     * @return The substring after the delimiter up to the end index, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringBetween(String, String, int)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return substring(str, 0, exclusiveEndIndex);
        } else if (exclusiveEndIndex == 0) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0 || index + delimiterOfExclusiveBeginIndex.length() > exclusiveEndIndex) {
            return null;
        }

        return substring(str, index + delimiterOfExclusiveBeginIndex.length(), exclusiveEndIndex);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter, ignoring case.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of
     * {@code delimiterOfExclusiveBeginIndex} in the string and returns everything after it.
     * The delimiter itself is not included in the returned substring. If the delimiter is empty,
     * the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found (case-insensitive).</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterIgnoreCase("Hello WORLD", "hello ");  // returns "WORLD"
     * substringAfterIgnoreCase("user@EXAMPLE.com", "@");  // returns "EXAMPLE.com"
     * substringAfterIgnoreCase("Test", "TEST");           // returns "" (delimiter is entire string)
     * substringAfterIgnoreCase("NoMatch", "xyz");         // returns null (not found)
     * substringAfterIgnoreCase("test", "");               // returns "test" (empty delimiter)
     * substringAfterIgnoreCase(null, "test");             // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string after which to extract the substring.
     * @return The substring after the delimiter (case-insensitive), or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringAfterLastIgnoreCase(String, String)
     */
    @Beta
    @MayReturnNull
    public static String substringAfterIgnoreCase(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return str;
        }

        final int index = indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter character.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * This is useful for extracting file extensions, last path segments, or final components.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterLast("com.example.App", '.');       // returns "App"
     * substringAfterLast("/home/user/file.txt", '/');   // returns "file.txt"
     * substringAfterLast("NoDelimiter", '.');           // returns null (not found)
     * substringAfterLast("test.", '.');                 // returns "" (delimiter at end)
     * substringAfterLast("", 'a');                      // returns null (empty string)
     * substringAfterLast(null, 'a');                    // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null} or empty.
     * @param delimiterOfExclusiveBeginIndex The character after which to extract the substring.
     * @return The substring after the last occurrence of the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, char)
     * @see #substringBeforeLast(String, char)
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final char delimiterOfExclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + 1);
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter string.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * If the delimiter is empty, an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterLast("a.b.c.txt", ".");             // returns "txt"
     * substringAfterLast("folder1/folder2/file", "/");  // returns "file"
     * substringAfterLast("NoDelimiter", "::");          // returns null (not found)
     * substringAfterLast("test::", "::");               // returns "" (delimiter at end)
     * substringAfterLast("test", "");                   // returns "" (empty delimiter)
     * substringAfterLast(null, "test");                 // returns null
     * }</pre>
     *
     * @param str The input string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string after which to extract the substring.
     * @return The substring after the last occurrence of the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringBeforeLast(String, String)
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter within the given range.
     *
     * <p>This method searches for the last occurrence of the delimiter starting from the back of the string,
     * limited by the exclusiveEndIndex. The search is performed in the range [0, exclusiveEndIndex).
     * If found, it returns the substring after the delimiter up to the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the exclusiveEndIndex is negative, the delimiter is not found, or if the delimiter occurs at or beyond
     * the exclusiveEndIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterLast("com.example.Test", ".", 11);     // returns "example"
     * substringAfterLast("a.b.c.d", ".", 5);               // returns "b"
     * substringAfterLast("hello", ".", 5);                 // returns null (delimiter not found)
     * substringAfterLast("test.", ".", 5);                 // returns "" (empty string after delimiter)
     * substringAfterLast(null, ".", 5);                    // returns null
     * substringAfterLast("test", null, 5);                 // returns null
     * substringAfterLast("test", ".", -1);                 // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter to search for. It can be {@code null}.
     * @param exclusiveEndIndex The exclusive end index for the search range.
     * @return The substring after the last occurrence of the delimiter within the range, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        } else if (exclusiveEndIndex == 0) {
            return null;
        }

        final int lengthOfDelimiter = delimiterOfExclusiveBeginIndex.length();

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex, exclusiveEndIndex - lengthOfDelimiter);

        if (index < 0 || index + lengthOfDelimiter > exclusiveEndIndex) {
            return null;
        }

        return str.substring(index + lengthOfDelimiter, exclusiveEndIndex);
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the last occurrence of the delimiter in the string.
     * If found, it returns the substring after the delimiter. The comparison ignores differences in case
     * between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterLastIgnoreCase("com.Example.Test", ".example.");  // returns "Test"
     * substringAfterLastIgnoreCase("COM.EXAMPLE.TEST", ".example.");  // returns "TEST"
     * substringAfterLastIgnoreCase("test.example", ".EXAMPLE");       // returns ""
     * substringAfterLastIgnoreCase("hello", ".");                     // returns null
     * substringAfterLastIgnoreCase(null, ".");                        // returns null
     * substringAfterLastIgnoreCase("test", null);                     // returns null
     * substringAfterLastIgnoreCase("test", "");                       // returns ""
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter to search for, case-insensitive. It can be {@code null}.
     * @return The substring after the last occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringAfterLastIgnoreCase(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        final int index = lastIndexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the first occurrence of any of the specified delimiter characters.
     *
     * <p>This method searches for the first occurrence of any character in the delimiters array.
     * When found, it returns the substring after that delimiter character. The search stops
     * at the first match.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter characters are found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterAny("user@example.com", '@', '.');     // returns "example.com"
     * substringAfterAny("first.last@domain", '.', '@');    // returns "last@domain"
     * substringAfterAny("no-delimiters", '@', '.');        // returns null
     * substringAfterAny("@leading", '@');                  // returns "leading"
     * substringAfterAny(null, '@');                        // returns null
     * substringAfterAny("test", null);                     // returns null
     * substringAfterAny("test", new char[0]);              // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimitersOfExclusiveBeginIndex The array of delimiter characters to search for.
     * @return The substring after the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     */
    @MayReturnNull
    public static String substringAfterAny(final String str, final char... delimitersOfExclusiveBeginIndex) {
        checkInputChars(delimitersOfExclusiveBeginIndex, cs.delimitersOfExclusiveBeginIndex, true);

        if (str == null || N.isEmpty(delimitersOfExclusiveBeginIndex)) {
            return null;
        }

        int index = -1;

        for (final char delimiterOfExclusiveBeginIndex : delimitersOfExclusiveBeginIndex) {
            index = str.indexOf(delimiterOfExclusiveBeginIndex);

            if (index >= 0) {
                return str.substring(index + 1);
            }
        }

        return null;
    }

    /**
     * Returns the substring after the first occurrence of any of the specified delimiter strings.
     *
     * <p>This method searches for the first occurrence of any string in the delimiters array.
     * When found, it returns the substring after that delimiter string. The search stops
     * at the first match. Each delimiter is checked in the order provided.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter strings are found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringAfterAny("user@@domain.com", "@@", "@");    // returns "domain.com"
     * substringAfterAny("Hello World Java", " ", ", ");    // returns "World Java"
     * substringAfterAny("no-match", "@@", "##");           // returns null
     * substringAfterAny("@@leading", "@@");                // returns "leading"
     * substringAfterAny(null, "@@");                       // returns null
     * substringAfterAny("test", null);                     // returns null
     * substringAfterAny("test", new String[0]);            // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimitersOfExclusiveBeginIndex The array of delimiter strings to search for.
     * @return The substring after the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     */
    @MayReturnNull
    public static String substringAfterAny(final String str, final String... delimitersOfExclusiveBeginIndex) {
        if (str == null || N.isEmpty(delimitersOfExclusiveBeginIndex)) {
            return null;
        }

        String substr = null;

        for (final String delimiterOfExclusiveBeginIndex : delimitersOfExclusiveBeginIndex) {
            substr = substringAfter(str, delimiterOfExclusiveBeginIndex);

            if (substr != null) {
                return substr;
            }
        }

        return null;
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter character.
     *
     * <p>This method searches for the first occurrence of the delimiter character in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null} or if the delimiter
     * character is not found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBefore("user@example.com", '@');           // returns "user"
     * substringBefore("first.last", '.');                 // returns "first"
     * substringBefore("no-delimiter", '@');               // returns null
     * substringBefore("@leading", '@');                   // returns ""
     * substringBefore(null, '@');                         // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter character to search for.
     * @return The substring before the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final char delimiterOfExclusiveEndIndex) {
        if (str == null) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter string.
     *
     * <p>This method searches for the first occurrence of the delimiter string in the input string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBefore("user@example.com", "@");           // returns "user"
     * substringBefore("Hello World Java", " World");      // returns "Hello"
     * substringBefore("no-delimiter", "@");               // returns null
     * substringBefore("@leading", "@");                   // returns ""
     * substringBefore(null, "@");                         // returns null
     * substringBefore("test", null);                      // returns null
     * substringBefore("test", "");                        // returns ""
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for. It can be {@code null}.
     * @return The substring before the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(0, endIndex);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter starting from a given index.
     *
     * <p>This method searches for the first occurrence of the delimiter string starting from the
     * inclusiveBeginIndex + 1. If found, it returns the substring from inclusiveBeginIndex up to
     * (but not including) the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the inclusiveBeginIndex is negative or greater than the string length, the delimiter is not found,
     * or if the delimiter is empty and inclusiveBeginIndex equals the string length.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBefore("user@example@com", 5, "@");        // returns "example"
     * substringBefore("Hello World Java", 6, " ");        // returns "World"
     * substringBefore("test", 0, "@");                    // returns null (delimiter not found)
     * substringBefore("test@end", 4, "@");                // returns null (no delimiter after index 4)
     * substringBefore(null, 0, "@");                      // returns null
     * substringBefore("test", -1, "@");                   // returns null
     * substringBefore("test", 0, "");                     // returns ""
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param inclusiveBeginIndex The index to start the substring from (inclusive).
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for. It can be {@code null}.
     * @return The substring from inclusiveBeginIndex to the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        } else if (inclusiveBeginIndex == str.length()) {
            return null;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, endIndex);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the delimiter in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter. The comparison ignores differences in case between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeIgnoreCase("User@Example.com", "@EXAMPLE");  // returns "User"
     * substringBeforeIgnoreCase("HELLO world", " WORLD");         // returns "HELLO"
     * substringBeforeIgnoreCase("test", "TEST");                  // returns ""
     * substringBeforeIgnoreCase("no-match", "@");                 // returns null
     * substringBeforeIgnoreCase(null, "@");                       // returns null
     * substringBeforeIgnoreCase("test", null);                    // returns null
     * substringBeforeIgnoreCase("test", "");                      // returns ""
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for, case-insensitive. It can be {@code null}.
     * @return The substring before the first occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBeforeIgnoreCase(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        final int endIndex = indexOfIgnoreCase(str, delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(0, endIndex);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter character.
     *
     * <p>This method searches for the last occurrence of the delimiter character in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, empty, or if the
     * delimiter character is not found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeLast("com.example.Test", '.');       // returns "com.example"
     * substringBeforeLast("user@example@com", '@');       // returns "user@example"
     * substringBeforeLast("no-delimiter", '.');           // returns null
     * substringBeforeLast(".leading", '.');               // returns ""
     * substringBeforeLast(null, '.');                     // returns null
     * substringBeforeLast("", '.');                       // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null} or empty.
     * @param delimiterOfExclusiveEndIndex The delimiter character to search for.
     * @return The substring before the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter string.
     *
     * <p>This method searches for the last occurrence of the delimiter string in the input string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns the original string if the delimiter is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeLast("com.example.Test", ".");       // returns "com.example"
     * substringBeforeLast("Hello World World", " World"); // returns "Hello World"
     * substringBeforeLast("no-delimiter", ".");           // returns null
     * substringBeforeLast(".leading", ".");               // returns ""
     * substringBeforeLast(null, ".");                     // returns null
     * substringBeforeLast("test", null);                  // returns null
     * substringBeforeLast("test", "");                    // returns "test"
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for. It can be {@code null}.
     * @return The substring before the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter starting from a given index.
     *
     * <p>This method searches for the last occurrence of the delimiter string in the input string.
     * If found and it occurs at or after the inclusiveBeginIndex, it returns the substring from
     * inclusiveBeginIndex up to (but not including) the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the inclusiveBeginIndex is negative or greater than the string length, the delimiter is not found,
     * or if the delimiter is found before the inclusiveBeginIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeLast("com.example.Test", 4, ".");    // returns "example"
     * substringBeforeLast("a.b.c.d", 2, ".");             // returns "b.c"
     * substringBeforeLast("test", 0, ".");                // returns null (delimiter not found)
     * substringBeforeLast("a.b", 3, ".");                 // returns null (delimiter before index)
     * substringBeforeLast(null, 0, ".");                  // returns null
     * substringBeforeLast("test", -1, ".");               // returns null
     * substringBeforeLast("test", 0, "");                 // returns "test"
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param inclusiveBeginIndex The index to start the substring from (inclusive).
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for. It can be {@code null}.
     * @return The substring from inclusiveBeginIndex to the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str.substring(inclusiveBeginIndex);
        } else if (inclusiveBeginIndex == str.length()) {
            return null;
        }

        final int endIndex = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0 || endIndex < inclusiveBeginIndex) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, endIndex);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the last occurrence of the delimiter in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter. The comparison ignores differences in case between the string
     * and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns the original string if the delimiter is empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeLastIgnoreCase("Com.Example.TEST", ".test");  // returns "Com.Example"
     * substringBeforeLastIgnoreCase("HELLO world WORLD", " world"); // returns "HELLO world"
     * substringBeforeLastIgnoreCase("test", "TEST");                // returns ""
     * substringBeforeLastIgnoreCase("no-match", "@");               // returns null
     * substringBeforeLastIgnoreCase(null, "@");                     // returns null
     * substringBeforeLastIgnoreCase("test", null);                  // returns null
     * substringBeforeLastIgnoreCase("test", "");                    // returns "test"
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string to search for, case-insensitive. It can be {@code null}.
     * @return The substring before the last occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBeforeLastIgnoreCase(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str;
        }

        final int index = lastIndexOfIgnoreCase(str, delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the first occurrence of any of the specified delimiter characters.
     *
     * <p>This method searches for the first occurrence of any character in the delimiters array.
     * When found, it returns the substring from the beginning of the string up to (but not including)
     * that delimiter character. The search stops at the first match.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter characters are found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeAny("user@example.com", '@', '.');    // returns "user"
     * substringBeforeAny("first.last@domain", '.', '@');   // returns "first"
     * substringBeforeAny("no-delimiters", '@', '.');       // returns null
     * substringBeforeAny("@leading", '@');                 // returns ""
     * substringBeforeAny(null, '@');                       // returns null
     * substringBeforeAny("test", null);                    // returns null
     * substringBeforeAny("test", new char[0]);             // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimitersOfExclusiveEndIndex The array of delimiter characters to search for.
     * @return The substring before the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringBefore(String, String)
     */
    @MayReturnNull
    public static String substringBeforeAny(final String str, final char... delimitersOfExclusiveEndIndex) {
        checkInputChars(delimitersOfExclusiveEndIndex, cs.delimitersOfExclusiveEndIndex, true);

        if (str == null || N.isEmpty(delimitersOfExclusiveEndIndex)) {
            return null;
        }

        int index = -1;

        for (final char delimiterOfExclusiveEndIndex : delimitersOfExclusiveEndIndex) {
            index = str.indexOf(delimiterOfExclusiveEndIndex);

            if (index >= 0) {
                return str.substring(0, index);
            }
        }

        return null;
    }

    /**
     * Returns the substring before the first occurrence of any of the specified delimiter strings.
     *
     * <p>This method searches for the first occurrence of any string in the delimiters array.
     * When found, it returns the substring from the beginning of the string up to (but not including)
     * that delimiter string. The search stops at the first match. Each delimiter is checked in the
     * order provided.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter strings are found in the string.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBeforeAny("user@@domain.com", "@@", "@");   // returns "user"
     * substringBeforeAny("Hello World Java", " World", " ");// returns "Hello"
     * substringBeforeAny("no-match", "@@", "##");          // returns null
     * substringBeforeAny("@@leading", "@@");               // returns ""
     * substringBeforeAny(null, "@@");                      // returns null
     * substringBeforeAny("test", null);                    // returns null
     * substringBeforeAny("test", new String[0]);           // returns null
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimitersOfExclusiveEndIndex The array of delimiter strings to search for.
     * @return The substring before the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringBefore(String, String)
     */
    @MayReturnNull
    public static String substringBeforeAny(final String str, final String... delimitersOfExclusiveEndIndex) {
        if (str == null || N.isEmpty(delimitersOfExclusiveEndIndex)) {
            return null;
        }

        String substr = null;

        for (final String delimiterOfExclusiveEndIndex : delimitersOfExclusiveEndIndex) {
            substr = substringBefore(str, delimiterOfExclusiveEndIndex);

            if (substr != null) {
                return substr;
            }
        }

        return null;
    }

    /**
     * Returns the substring between two specified indices.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending at exclusiveEndIndex - 1. The character at exclusiveBeginIndex and the character at
     * exclusiveEndIndex are not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveBeginIndex is less than -1,
     * exclusiveBeginIndex is greater than or equal to exclusiveEndIndex, or exclusiveBeginIndex is greater than
     * or equal to the string length.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("abcdef", 0, 3);                    // returns "bc"
     * substringBetween("abcdef", -1, 3);                  // returns "abc"
     * substringBetween("abcdef", 2, 6);                    // returns "def"
     * substringBetween("abcdef", 2, 10);                  // returns "def" (endIndex capped at length)
     * substringBetween(null, 0, 3);                        // returns null
     * substringBetween("test", 3, 3);                      // returns null (beginIndex >= endIndex)
     * substringBetween("test", -2, 3);                     // returns null (beginIndex < -1)
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param exclusiveBeginIndex The exclusive beginning index (the character at this index is not included).
     * @param exclusiveEndIndex The exclusive ending index (the character at this index is not included).
     * @return The substring between the specified indices, or {@code null} if the indices are invalid.
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= exclusiveEndIndex || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        return str.substring(exclusiveBeginIndex + 1, N.min(exclusiveEndIndex, str.length()));
    }

    /**
     * Returns the substring between a specified index and the first occurrence of a delimiter character.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending before the first occurrence of the delimiter character found after that position.
     * The delimiter itself is not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveBeginIndex is less than -1,
     * exclusiveBeginIndex is greater than or equal to the string length, or if the delimiter is not found
     * after the exclusiveBeginIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("user@example.com", 3, '@');       // returns "r"
     * substringBetween("a,b,c,d", 1, ',');                // returns "b"
     * substringBetween("test", -1, 's');                  // returns "te"
     * substringBetween("test", 2, 'x');                   // returns null (delimiter not found)
     * substringBetween(null, 0, '@');                     // returns null
     * substringBetween("test", 4, '@');                   // returns null (beginIndex >= length)
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param exclusiveBeginIndex The exclusive beginning index (the character at this index is not included).
     * @param delimiterOfExclusiveEndIndex The delimiter character marking the end of the substring.
     * @return The substring between the index and the delimiter, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int startIndex = exclusiveBeginIndex + 1;
        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between a specified index and the first occurrence of a delimiter string.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending before the first occurrence of the delimiter string found after that position.
     * The delimiter itself is not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * exclusiveBeginIndex is less than -1, exclusiveBeginIndex is greater than or equal to the string length,
     * or if the delimiter is not found after the exclusiveBeginIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("Hello World Java", 5, " ");       // returns "World"
     * substringBetween("user@@domain.com", 3, "@@");      // returns "r"
     * substringBetween("test", -1, "st");                 // returns "te"
     * substringBetween("test", 2, "xyz");                 // returns null (delimiter not found)
     * substringBetween(null, 0, "@");                     // returns null
     * substringBetween("test", 0, null);                  // returns null
     * substringBetween("test", 4, "@");                   // returns null (beginIndex >= length)
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param exclusiveBeginIndex The exclusive beginning index (the character at this index is not included).
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring. It can be {@code null}.
     * @return The substring between the index and the delimiter, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int startIndex = exclusiveBeginIndex + 1;
        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between the first occurrence of a delimiter character and a specified index.
     *
     * <p>This method searches for the first occurrence of the delimiter character in the string.
     * If found and it occurs before the exclusiveEndIndex, it returns the substring starting after
     * the delimiter and ending before the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveEndIndex is less than
     * or equal to 0, the delimiter is not found, or if the delimiter occurs at or after the exclusiveEndIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("user@example", '@', 11);          // returns "example"
     * substringBetween("a,b,c", ',', 3);                  // returns "b"
     * substringBetween("test", 't', 4);                   // returns "es"
     * substringBetween("test", 'x', 4);                   // returns null (delimiter not found)
     * substringBetween("test", 't', 1);                   // returns null (delimiter at or after endIndex)
     * substringBetween(null, '@', 5);                     // returns null
     * substringBetween("test", '@', 0);                   // returns null (endIndex <= 0)
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter character marking the beginning of the substring.
     * @param exclusiveEndIndex The exclusive ending index (the character at this index is not included).
     * @return The substring between the delimiter and the index, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex <= 0) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0 || startIndex >= exclusiveEndIndex) {
            return null;
        }

        startIndex += 1;

        if (startIndex > exclusiveEndIndex) {
            return null;
        }

        return str.substring(startIndex, exclusiveEndIndex);
    }

    /**
     * Returns the substring between the first occurrence of a delimiter string and a specified index.
     *
     * <p>This method searches for the first occurrence of the delimiter string in the input string.
     * If found and it occurs before the exclusiveEndIndex, it returns the substring starting after
     * the delimiter and ending before the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * exclusiveEndIndex is negative, the delimiter is not found, or if the delimiter's end position is
     * greater than the exclusiveEndIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("Hello World Java", " ", 11);      // returns "World"
     * substringBetween("user@@domain", "@@", 13);         // returns "domain"
     * substringBetween("test", "es", 4);                  // returns "t"
     * substringBetween("test", "xyz", 4);                 // returns null (delimiter not found)
     * substringBetween("test", "st", 2);                  // returns null (delimiter ends after endIndex)
     * substringBetween(null, "@", 5);                     // returns null
     * substringBetween("test", null, 5);                  // returns null
     * substringBetween("test", "@", -1);                  // returns null (endIndex < 0)
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string marking the beginning of the substring. It can be {@code null}.
     * @param exclusiveEndIndex The exclusive ending index (the character at this index is not included).
     * @return The substring between the delimiter and the index, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0 || startIndex > exclusiveEndIndex) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        if (startIndex > exclusiveEndIndex) {
            return null;
        }

        return str.substring(startIndex, exclusiveEndIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter character.
     *
     * <p>This method searches for the first occurrence of the delimiter character, then searches for
     * the next occurrence of the same delimiter character after the first one. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the string length is 1 or less,
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("a,b,c", ',', ',');                 // returns "b"
     * substringBetween("'quoted'", '\'', '\'');           // returns "quoted"
     * substringBetween("test", 't', 't');                 // returns "es"
     * substringBetween("abc", 'a', 'c');                  // returns "b"
     * substringBetween("no-match", 'x', 'y');             // returns null (first delimiter not found)
     * substringBetween("a,b", ',', ',');                  // returns null (second delimiter not found)
     * substringBetween(null, ',', ',');                   // returns null
     * substringBetween("", ',', ',');                     // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter character marking the beginning of the substring.
     * @param delimiterOfExclusiveEndIndex The delimiter character marking the end of the substring.
     * @return The substring between the two delimiter occurrences, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.length() <= 1) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return null;
        }

        // even delimiterOfExclusiveBeginIndex and delimiterOfExclusiveEndIndex are equal, but should consider them as different chars. see: substringBetween(String str, String tag)
        //    if (delimiterOfExclusiveBeginIndex == delimiterOfExclusiveEndIndex) {
        //        return EMPTY_STRING;
        //    }

        startIndex += 1;

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter string.
     *
     * <p>This method searches for the first occurrence of the delimiter string, then searches for
     * the next occurrence of the same delimiter string after the first one. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("{{content}}", "{{");               // returns "content"
     * substringBetween("<tag>value</tag>", "<tag>");      // returns "value</tag>"
     * substringBetween("@@text@@", "@@");                 // returns "text"
     * substringBetween("no-match", "{{");                 // returns null (delimiter not found)
     * substringBetween("{{only-one", "{{");               // returns null (second delimiter not found)
     * substringBetween(null, "{{");                       // returns null
     * substringBetween("test", null);                     // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiter The delimiter string marking both the beginning and end of the substring. It can be {@code null}.
     * @return The substring between two occurrences of the delimiter, or {@code null} if not found.
     * @see #substringBetween(String, String, String)
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiter) {
        return substringBetween(str, delimiter, delimiter);
    }

    /**
     * Returns the substring between two different delimiter strings.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter, then searches for
     * the first occurrence of the ending delimiter after the beginning delimiter. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * the beginning delimiter is not found, or the ending delimiter is not found after the beginning delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("<tag>content</tag>", "<tag>", "</tag>");  // returns "content"
     * substringBetween("{{start}}middle{{end}}", "{{start}}", "{{end}}"); // returns "middle"
     * substringBetween("Hello [World]!", "[", "]");               // returns "World"
     * substringBetween("no-match", "{{", "}}");                   // returns null (begin delimiter not found)
     * substringBetween("{{no-end", "{{", "}}");                   // returns null (end delimiter not found)
     * substringBetween(null, "{{", "}}");                         // returns null
     * substringBetween("test", null, "}}");                       // returns null
     * substringBetween("test", "{{", null);                       // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string marking the beginning of the substring. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring. It can be {@code null}.
     * @return The substring between the two delimiters, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringBetween(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
    }

    /**
     * Returns the substring between two delimiter strings, starting the search from a specified index.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter starting from the fromIndex.
     * If fromIndex is less than or equal to 0, the search starts from the beginning of the string.
     * Then it searches for the first occurrence of the ending delimiter after the beginning delimiter.
     * If both are found, it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * fromIndex is greater than the string length, the beginning delimiter is not found, or the ending delimiter
     * is not found after the beginning delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetween("<a>text1</a><a>text2</a>", 5, "<a>", "</a>");  // returns "text2"
     * substringBetween("{{x}}{{y}}", 3, "{{", "}}");                    // returns "y"
     * substringBetween("Hello World", 0, "Hello", "World");             // returns " "
     * substringBetween("test", 10, "t", "t");                           // returns null (fromIndex > length)
     * substringBetween("no-match", 0, "{{", "}}");                      // returns null (delimiter not found)
     * substringBetween(null, 0, "{{", "}}");                            // returns null
     * substringBetween("test", 0, null, "}}");                          // returns null
     * substringBetween("test", 0, "{{", null);                          // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param fromIndex The index to start searching from. If less than or equal to 0, search starts from the beginning.
     * @param delimiterOfExclusiveBeginIndex The delimiter string marking the beginning of the substring. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring. It can be {@code null}.
     * @return The substring between the two delimiters, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null || fromIndex > str.length()) {
            return null;
        }

        int startIndex = fromIndex <= 0 ? str.indexOf(delimiterOfExclusiveBeginIndex) : str.indexOf(delimiterOfExclusiveBeginIndex, fromIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter string, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the delimiter string,
     * then searches for the next occurrence of the same delimiter string after the first one.
     * If both are found, it returns the substring between them (exclusive of both delimiters).
     * The comparison ignores differences in case between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetweenIgnoreCaes("{{CONTENT}}", "{{");              // returns "CONTENT"
     * substringBetweenIgnoreCaes("<TAG>value</TAG>", "<tag>");      // returns "value</TAG>"
     * substringBetweenIgnoreCaes("@@Text@@", "@@");                 // returns "Text"
     * substringBetweenIgnoreCaes("no-match", "{{");                 // returns null (delimiter not found)
     * substringBetweenIgnoreCaes("{{only-one", "{{");               // returns null (second delimiter not found)
     * substringBetweenIgnoreCaes(null, "{{");                       // returns null
     * substringBetweenIgnoreCaes("test", null);                     // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiter The delimiter string marking both the beginning and end of the substring, case-insensitive. It can be {@code null}.
     * @return The substring between two occurrences of the delimiter (case-insensitive), or {@code null} if not found.
     * @see #substringBetweenIgnoreCaes(String, String, String)
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final String delimiter) {
        return substringBetweenIgnoreCaes(str, delimiter, delimiter);
    }

    /**
     * Returns the substring between two different delimiter strings, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the beginning delimiter,
     * then searches for the first occurrence of the ending delimiter after the beginning delimiter.
     * If both are found, it returns the substring between them (exclusive of both delimiters).
     * The comparison ignores differences in case between the string and the delimiters.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * the beginning delimiter is not found, or the ending delimiter is not found after the beginning delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetweenIgnoreCaes("<TAG>content</TAG>", "<tag>", "</tag>");  // returns "content"
     * substringBetweenIgnoreCaes("{{START}}middle{{END}}", "{{start}}", "{{end}}"); // returns "middle"
     * substringBetweenIgnoreCaes("Hello [WORLD]!", "[", "]");               // returns "WORLD"
     * substringBetweenIgnoreCaes("no-match", "{{", "}}");                   // returns null (begin delimiter not found)
     * substringBetweenIgnoreCaes("{{no-end", "{{", "}}");                   // returns null (end delimiter not found)
     * substringBetweenIgnoreCaes(null, "{{", "}}");                         // returns null
     * substringBetweenIgnoreCaes("test", null, "}}");                       // returns null
     * substringBetweenIgnoreCaes("test", "{{", null);                       // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter string marking the beginning of the substring, case-insensitive. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring, case-insensitive. It can be {@code null}.
     * @return The substring between the two delimiters (case-insensitive), or {@code null} if not found.
     * @see #substringBetweenIgnoreCaes(String, int, String, String)
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringBetweenIgnoreCaes(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
    }

    /**
     * Returns the substring between two delimiter strings, starting the search from a specified index and ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the beginning delimiter
     * starting from the fromIndex. If fromIndex is less than or equal to 0, the search starts from the
     * beginning of the string. Then it searches for the first occurrence of the ending delimiter after
     * the beginning delimiter. If both are found, it returns the substring between them (exclusive of
     * both delimiters). The comparison ignores differences in case between the string and the delimiters.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * fromIndex is greater than the string length, the beginning delimiter is not found, or the ending delimiter
     * is not found after the beginning delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * substringBetweenIgnoreCaes("<A>text1</A><A>text2</A>", 5, "<a>", "</a>");  // returns "text2"
     * substringBetweenIgnoreCaes("{{X}}{{Y}}", 3, "{{", "}}");                    // returns "Y"
     * substringBetweenIgnoreCaes("HELLO world", 0, "hello", "WORLD");             // returns " "
     * substringBetweenIgnoreCaes("test", 10, "t", "t");                           // returns null (fromIndex > length)
     * substringBetweenIgnoreCaes("no-match", 0, "{{", "}}");                      // returns null (delimiter not found)
     * substringBetweenIgnoreCaes(null, 0, "{{", "}}");                            // returns null
     * substringBetweenIgnoreCaes("test", 0, null, "}}");                          // returns null
     * substringBetweenIgnoreCaes("test", 0, "{{", null);                          // returns null
     * }</pre>
     *
     * @param str The string to extract from. It can be {@code null}.
     * @param fromIndex The index to start searching from. If less than or equal to 0, search starts from the beginning.
     * @param delimiterOfExclusiveBeginIndex The delimiter string marking the beginning of the substring, case-insensitive. It can be {@code null}.
     * @param delimiterOfExclusiveEndIndex The delimiter string marking the end of the substring, case-insensitive. It can be {@code null}.
     * @return The substring between the two delimiters (case-insensitive), or {@code null} if not found.
     * @see #substringBetweenIgnoreCaes(String, String, String)
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null || fromIndex > str.length()) {
            return null;
        }

        int startIndex = fromIndex <= 0 ? indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex)
                : indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex, fromIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = indexOfIgnoreCase(str, delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Extracts a substring between two exclusive indices, where the end index is calculated by a function.
     *
     * <p>This method extracts a substring from the input string starting from {@code exclusiveBeginIndex + 1}
     * and ending at the position calculated by {@code funcOfExclusiveEndIndex.applyAsInt(exclusiveBeginIndex)}.
     * Both the begin and end indices are exclusive, meaning the characters at these positions are not included
     * in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the begin index is less than -1
     * or greater than or equal to the string length, or if the calculated end index is invalid.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract substring with dynamic end index
     * substringBetween("Hello World", 0, i -> i + 6);     // returns "ello "
     * substringBetween("Hello World", 5, i -> i + 6);     // returns " World"
     * substringBetween("Hello World", -1, i -> 5);        // returns "Hello"
     * 
     * // Invalid cases
     * substringBetween(null, 0, i -> 5);                  // returns null
     * substringBetween("Hello", 10, i -> 15);             // returns null
     * substringBetween("Hello", 2, i -> 2);               // returns null (end <= begin)
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param exclusiveBeginIndex The exclusive beginning index (the character at this index is not included).
     * @param funcOfExclusiveEndIndex A function that calculates the exclusive end index based on the begin index.
     * @return The substring between the specified indices, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int endIndex = N.min(funcOfExclusiveEndIndex.applyAsInt(exclusiveBeginIndex), str.length());

        if (endIndex < 0 || endIndex <= exclusiveBeginIndex) {
            return null;
        }

        return str.substring(exclusiveBeginIndex + 1, endIndex);
    }

    //    /**
    //     *
    //     * @param str
    //     * @param exclusiveBeginIndex
    //     * @param funcOfExclusiveEndIndex {@code exclusiveEndIndex <- funcOfExclusiveEndIndex.apply(str, exclusiveBeginIndex) if inclusiveBeginIndex >= 0}
    //     * @return {@code null} if {@code (str == null || exclusiveBeginIndex < 0 || exclusiveBeginIndex >= str.length())}. (auto-generated java doc for return)
    //     * @see #substringBetween(String, int, int)
    //     */
    //    @MayReturnNull
    //    @Beta
    //    public static String substringBetween(String str, int exclusiveBeginIndex, final BiFunction<? super String, Integer, Integer> funcOfExclusiveEndIndex) {
    //        if (str == null || exclusiveBeginIndex < 0 || exclusiveBeginIndex >= str.length()) {
    //            return null;
    //        }
    //
    //        return substringBetween(str, exclusiveBeginIndex, funcOfExclusiveEndIndex.apply(str, exclusiveBeginIndex));
    //    }

    /**
     * Extracts a substring between two exclusive indices, where the begin index is calculated by a function.
     *
     * <p>This method extracts a substring from the input string starting from a position calculated by
     * {@code funcOfExclusiveBeginIndex.applyAsInt(exclusiveEndIndex) + 1} and ending at {@code exclusiveEndIndex}.
     * Both the begin and end indices are exclusive, meaning the characters at these positions are not included
     * in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the end index is less than or equal to 0,
     * or if the calculated begin index is invalid.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract substring with dynamic begin index
     * substringBetween("Hello World", i -> i - 6, 11);    // returns "World"
     * substringBetween("Hello World", i -> -1, 5);        // returns "Hello"
     * substringBetween("Hello World", i -> 2, 8);         // returns "lo Wo"
     * 
     * // Invalid cases
     * substringBetween(null, i -> 0, 5);                  // returns null
     * substringBetween("Hello", i -> 0, 0);               // returns null (end <= 0)
     * substringBetween("Hello", i -> 5, 3);               // returns null (begin >= end)
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param funcOfExclusiveBeginIndex A function that calculates the exclusive begin index based on the end index.
     * @param exclusiveEndIndex The exclusive ending index (the character at this index is not included).
     * @return The substring between the specified indices, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex <= 0) {
            return null;
        }

        final int endIndex = N.min(exclusiveEndIndex, str.length());
        int startIndex = funcOfExclusiveBeginIndex.applyAsInt(endIndex);

        if (startIndex < -1 || startIndex >= endIndex) {
            return null;
        }

        return str.substring(startIndex + 1, endIndex);
    }

    //    /**
    //     *
    //     * @param str
    //     * @param funcOfExclusiveBeginIndex {@code exclusiveBeginIndex <- funcOfExclusiveBeginIndex.apply(str, exclusiveEndIndex)) if exclusiveEndIndex >= 0}
    //     * @param exclusiveEndIndex
    //     * @return {@code null} if {@code (str == null || exclusiveEndIndex < 0)}. (auto-generated java doc for return)
    //     * @see #substringBetween(String, int, int)
    //     */
    //    @MayReturnNull
    //    @Beta
    //    public static String substringBetween(String str, final BiFunction<? super String, Integer, Integer> funcOfExclusiveBeginIndex, int exclusiveEndIndex) {
    //        if (str == null || exclusiveEndIndex < 0) {
    //            return null;
    //        }
    //
    //        return substringBetween(str, funcOfExclusiveBeginIndex.apply(str, exclusiveEndIndex), exclusiveEndIndex);
    //    }

    /**
     * Extracts a substring between a delimiter and a calculated end index.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the input string,
     * then extracts a substring starting from the position after this delimiter and ending at the position
     * calculated by {@code funcOfExclusiveEndIndex.applyAsInt(startIndex)}, where {@code startIndex} is the
     * position right after the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the delimiter is {@code null}
     * or not found, if the delimiter length is greater than or equal to the string length, or if the calculated
     * end index is invalid.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract substring after delimiter with dynamic end
     * substringBetween("Hello:World", ":", i -> i + 5);     // returns "World"
     * substringBetween("A=B=C", "=", i -> i + 1);           // returns "B"
     * substringBetween("[content]", "[", i -> i + 7);       // returns "content"
     * 
     * // Invalid cases
     * substringBetween(null, ":", i -> 5);                  // returns null
     * substringBetween("Hello", "x", i -> 10);              // returns null (delimiter not found)
     * substringBetween("Hello", "Hello", i -> 10);          // returns null (delimiter too long)
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The delimiter marking the beginning of the substring (non-inclusive).
     * @param funcOfExclusiveEndIndex A function that calculates the exclusive end index based on the start index after the delimiter.
     * @return The substring between the delimiter and calculated end index, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveBeginIndex.length() >= str.length()) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = N.min(funcOfExclusiveEndIndex.applyAsInt(startIndex), str.length());

        if (endIndex < 0 || endIndex < startIndex) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Extracts a substring between a calculated begin index and a delimiter.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveEndIndex} in the input string,
     * then extracts a substring starting from a position calculated by
     * {@code funcOfExclusiveBeginIndex.applyAsInt(endIndex) + 1} and ending at the position of the delimiter,
     * where {@code endIndex} is the position of the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the delimiter is {@code null}
     * or not found, if the delimiter length is greater than or equal to the string length, or if the calculated
     * begin index is invalid.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract substring with dynamic begin before delimiter
     * substringBetween("Hello:World", i -> i - 5, ":");     // returns "Hello"
     * substringBetween("A=B=C", i -> i - 1, "=");           // returns "B"
     * substringBetween("[content]", i -> 0, "]");           // returns "content"
     * 
     * // Invalid cases
     * substringBetween(null, i -> 0, ":");                  // returns null
     * substringBetween("Hello", i -> 0, "x");               // returns null (delimiter not found)
     * substringBetween("Hello", i -> 0, "Hello");           // returns null (delimiter too long)
     * }</pre>
     *
     * @param str The input string from which to extract the substring. It can be {@code null}.
     * @param funcOfExclusiveBeginIndex A function that calculates the exclusive begin index based on the end index of the delimiter.
     * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (non-inclusive).
     * @return The substring between the calculated begin index and delimiter, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || delimiterOfExclusiveEndIndex.length() >= str.length()) {
            return null;
        }

        final int endIndex = N.min(str.lastIndexOf(delimiterOfExclusiveEndIndex), str.length());

        if (endIndex < 0) {
            return null;
        }

        final int startIndex = funcOfExclusiveBeginIndex.applyAsInt(endIndex);

        if (startIndex < -1 || startIndex >= endIndex) {
            return null;
        }

        return str.substring(startIndex + 1, endIndex);
    }

    /**
     * Finds all substrings between specified character delimiters.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters. It uses the default extraction strategy which performs simple
     * sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract content between brackets
     * substringsBetween("3[a]2[b]", '[', ']');              // returns ["a", "b"]
     * substringsBetween("(hello)(world)", '(', ')');        // returns ["hello", "world"]
     * substringsBetween("<tag>content</tag>", '<', '>');    // returns ["tag", "/tag"]
     * 
     * // Empty results
     * substringsBetween(null, '[', ']');                    // returns []
     * substringsBetween("no delimiters", '[', ']');         // returns []
     * substringsBetween("", '[', ']');                      // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified character delimiters using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // With nested delimiters
     * String str = "3[a2[c]]2[a]";
     * substringsBetween(str, '[', ']', ExtractStrategy.DEFAULT);        // returns ["a2[c", "a"]
     * substringsBetween(str, '[', ']', ExtractStrategy.STACK_BASED);    // returns ["c", "a2[c]", "a"]
     * substringsBetween(str, '[', ']', ExtractStrategy.IGNORE_NESTED);  // returns ["a2[c]", "a"]
     * 
     * // Simple cases
     * substringsBetween("(a)(b)", '(', ')', ExtractStrategy.DEFAULT);   // returns ["a", "b"]
     * substringsBetween(null, '[', ']', ExtractStrategy.DEFAULT);       // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        return substringsBetween(str, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex), extractStrategy);
    }

    /**
     * Finds all substrings between specified character delimiters within a given range.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter characters.
     * It uses the default extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found
     * within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Search within specific range
     * substringsBetween("a[b]c[d]e[f]", 2, 8, '[', ']');    // returns ["b", "d"]
     * substringsBetween("(1)(2)(3)", 0, 6, '(', ')');       // returns ["1", "2"]
     * substringsBetween("no match", 0, 8, '[', ']');        // returns []
     * 
     * // Edge cases
     * substringsBetween("a[b]c", 4, 5, '[', ']');           // returns []
     * substringsBetween(null, 0, 5, '[', ']');              // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The index to start the search from (inclusive).
     * @param toIndex The index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final char delimiterOfExclusiveBeginIndex,
            final char delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, fromIndex, toIndex, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                ExtractStrategy.DEFAULT, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings. It uses the default extraction strategy which performs simple
     * sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract content between string delimiters
     * substringsBetween("a<tag>b</tag>c<tag>d</tag>", "<tag>", "</tag>");  // returns ["b", "d"]
     * substringsBetween("start:middle:end", "start:", ":end");             // returns ["middle"]
     * substringsBetween("[[content]]", "[[", "]]");                        // returns ["content"]
     * 
     * // Empty results
     * substringsBetween(null, "<", ">");                                   // returns []
     * substringsBetween("no match", "<", ">");                             // returns []
     * substringsBetween("test", null, ">");                                // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified string delimiters using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.DEFAULT);       // returns ["a2[c", "a"]
     * substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.STACK_BASED);   // returns ["c", "a2[c]", "a"]
     * substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.IGNORE_NESTED); // returns ["a2[c]", "a"]
     * 
     * // String: [[b[a]]c]
     * substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.DEFAULT);          // returns ["[b[a"]
     * substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.STACK_BASED);      // returns ["a", "b[a]", "[b[a]]c"]
     * substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.IGNORE_NESTED);    // returns ["[b[a]]c"]
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringsBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<String> substringsBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        return substringsBetween(str, 0, N.len(str), delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter strings.
     * It uses the default extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Search within specific range
     * substringsBetween("a<b>c<d>e<f>", 2, 10, "<", ">");   // returns ["b", "d"]
     * substringsBetween("[[1]][[2]][[3]]", 0, 10, "[[", "]]"); // returns ["1", "2"]
     * substringsBetween("no match", 0, 8, "<", ">");        // returns []
     * 
     * // Edge cases
     * substringsBetween("a<b>c", 4, 5, "<", ">");           // returns []
     * substringsBetween(null, 0, 5, "<", ">");              // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The index to start the search from (inclusive).
     * @param toIndex The index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT,
                Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range using the given extraction strategy.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for occurrences of text between the specified beginning and ending delimiter strings, up to a maximum
     * count specified by {@code maxCount}. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * if {@code maxCount} is 0, or if no matches are found within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extract with different strategies
     * String str = "3[a2[c]]2[a]";
     * substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.DEFAULT, 10);       // returns ["a2[c", "a"]
     * substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.STACK_BASED, 10);   // returns ["c", "a2[c]", "a"]
     * substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.IGNORE_NESTED, 10); // returns ["a2[c]", "a"]
     * 
     * // Limit results
     * substringsBetween("a[b]c[d]e[f]", 0, 15, "[", "]", ExtractStrategy.DEFAULT, 2);       // returns ["b", "d"]
     * substringsBetween("test", 0, 4, "[", "]", ExtractStrategy.DEFAULT, 0);               // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The index to start the search from (inclusive).
     * @param toIndex The index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @param maxCount The maximum number of substrings to extract; if {@code Integer.MAX_VALUE}, all matching substrings will be extracted.
     * @return A list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @throws IllegalArgumentException if maxCount is negative or extractStrategy is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex, final ExtractStrategy extractStrategy, final int maxCount) {

        final List<int[]> substringIndices = substringIndicesBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex,
                extractStrategy, maxCount);

        final List<String> res = new ArrayList<>(substringIndices.size());

        for (final int[] e : substringIndices) {
            res.add(str.substring(e[0], e[1]));
        }

        return res;

    }

    /**
     * Finds all substrings between specified character delimiters and returns their indices.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). It uses the default
     * extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Get indices of content between brackets
     * substringIndicesBetween("3[a]2[b]", '[', ']');        // returns [[2, 3], [6, 7]]
     * substringIndicesBetween("(hello)(world)", '(', ')');  // returns [[1, 6], [8, 13]]
     * substringIndicesBetween("<tag>text</tag>", '<', '>'); // returns [[1, 4], [10, 14]]
     * 
     * // Empty results
     * substringIndicesBetween(null, '[', ']');              // returns []
     * substringIndicesBetween("", '[', ']');                // returns []
     * substringIndicesBetween("no match", '[', ']');        // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        return substringIndicesBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified character delimiters and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.DEFAULT);       // returns [[2, 6], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.STACK_BASED);   // returns [[5, 6], [2, 7], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.IGNORE_NESTED); // returns [[2, 7], [10, 11]]
     * 
     * // Simple cases
     * substringIndicesBetween("(a)(b)", '(', ')', ExtractStrategy.DEFAULT);             // returns [[1, 2], [4, 5]]
     * substringIndicesBetween(null, '[', ']', ExtractStrategy.DEFAULT);                 // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        if (str == null || str.isEmpty()) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, 0, str.length(), String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified character delimiters within a given range and returns their indices.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter characters, and returns
     * a list of int arrays where each array contains the start and end indices of a matched substring
     * (exclusive of the delimiters themselves). It uses the default extraction strategy which performs
     * simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found
     * within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Search within specific range
     * substringIndicesBetween("a[b]c[d]e[f]", 2, 8, '[', ']');  // returns [[3, 4], [6, 7]]
     * substringIndicesBetween("(1)(2)(3)", 0, 6, '(', ')');     // returns [[1, 2], [4, 5]]
     * substringIndicesBetween("no match", 0, 8, '[', ']');      // returns []
     * 
     * // Edge cases
     * substringIndicesBetween("a[b]c", 4, 5, '[', ']');         // returns []
     * substringIndicesBetween(null, 0, 5, '[', ']');            // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The starting index to search from (inclusive).
     * @param toIndex The ending index to search until (exclusive).
     * @param delimiterOfExclusiveBeginIndex The character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The character marking the end of the substring (non-inclusive).
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final char delimiterOfExclusiveBeginIndex,
            final char delimiterOfExclusiveEndIndex) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));

        if (str == null || str.isEmpty()) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, fromIndex, toIndex, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                ExtractStrategy.DEFAULT, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters and returns their indices.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). It uses the default
     * extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Get indices of content between string delimiters
     * substringIndicesBetween("a<tag>b</tag>c<tag>d</tag>", "<tag>", "</tag>");  // returns [[6, 7], [19, 20]]
     * substringIndicesBetween("start:middle:end", "start:", ":end");             // returns [[6, 12]]
     * substringIndicesBetween("[[content]]", "[[", "]]");                        // returns [[2, 9]]
     * 
     * // Empty results
     * substringIndicesBetween(null, "<", ">");                                   // returns []
     * substringIndicesBetween("no match", "<", ">");                             // returns []
     * substringIndicesBetween("test", null, ">");                                // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        return substringIndicesBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified string delimiters and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.DEFAULT);       // returns [[2, 6], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.STACK_BASED);   // returns [[5, 6], [2, 7], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.IGNORE_NESTED); // returns [[2, 7], [10, 11]]
     * 
     * // String: [[b[a]]c]
     * substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.DEFAULT);          // returns [[1, 5]]
     * substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.STACK_BASED);      // returns [[4, 5], [2, 6], [1, 8]]
     * substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.IGNORE_NESTED);    // returns [[1, 8]]
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        if (str == null || isEmpty(delimiterOfExclusiveBeginIndex) || isEmpty(delimiterOfExclusiveEndIndex)) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, 0, str.length(), delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range and returns their indices.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter strings, and returns
     * a list of int arrays where each array contains the start and end indices of a matched substring
     * (exclusive of the delimiters themselves). It uses the default extraction strategy which performs
     * simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Search within specific range
     * substringIndicesBetween("a<b>c<d>e<f>", 2, 10, "<", ">");     // returns [[3, 4], [6, 7]]
     * substringIndicesBetween("[[1]][[2]][[3]]", 0, 10, "[[", "]]"); // returns [[2, 3], [7, 8]]
     * substringIndicesBetween("no match", 0, 8, "<", ">");          // returns []
     * 
     * // Edge cases
     * substringIndicesBetween("a<b>c", 4, 5, "<", ">");             // returns []
     * substringIndicesBetween(null, 0, 5, "<", ">");                // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The starting index to search from (inclusive).
     * @param toIndex The ending index to search until (exclusive).
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) throws IndexOutOfBoundsException {
        return substringIndicesBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT,
                Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for occurrences of text between the specified beginning and ending delimiter strings, up to a maximum
     * count specified by {@code maxCount}. It returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul></p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, if {@code maxCount} is 0, or if no matches are found within the specified range.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.DEFAULT, 10);       // returns [[2, 6], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.STACK_BASED, 10);   // returns [[5, 6], [2, 7], [10, 11]]
     * substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.IGNORE_NESTED, 10); // returns [[2, 7], [10, 11]]
     * 
     * // Limit results
     * substringIndicesBetween("a[b]c[d]e[f]", 0, 15, "[", "]", ExtractStrategy.DEFAULT, 2);        // returns [[2, 3], [6, 7]]
     * substringIndicesBetween("test", 0, 4, "[", "]", ExtractStrategy.DEFAULT, 0);                 // returns []
     * }</pre>
     *
     * @param str The string to search in. It can be {@code null}.
     * @param fromIndex The index to start the search from (inclusive).
     * @param toIndex The index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex The string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex The string marking the end of the substring (non-inclusive).
     * @param extractStrategy The strategy to use for handling nested delimiters.
     * @param maxCount The maximum number of matches to find.
     * @return A list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @throws IllegalArgumentException if maxCount is negative or extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringsBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex, final ExtractStrategy extractStrategy, final int maxCount) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));
        N.checkArgNotNegative(maxCount, cs.max);
        N.checkArgNotNull(extractStrategy, cs.extractStrategy);

        if (str == null || isEmpty(delimiterOfExclusiveBeginIndex) || isEmpty(delimiterOfExclusiveEndIndex) || maxCount == 0) {
            return new ArrayList<>();
        }

        int idx = str.indexOf(delimiterOfExclusiveBeginIndex, fromIndex);

        if (idx < 0) {
            return new ArrayList<>();
        }

        final List<int[]> res = new ArrayList<>(N.min(maxCount, 10));

        final int lengthOfDelimiterOfExclusiveBeginIndex = delimiterOfExclusiveBeginIndex.length();
        final int lengthOfDelimiterOfExclusiveEndIndex = delimiterOfExclusiveEndIndex.length();

        idx += lengthOfDelimiterOfExclusiveBeginIndex;

        if (extractStrategy == ExtractStrategy.DEFAULT) {
            int endIndex = -1;

            do {
                endIndex = indexOf(str, delimiterOfExclusiveEndIndex, idx);

                if (endIndex < 0 || endIndex >= toIndex) {
                    break;
                }

                res.add(new int[] { idx, endIndex });

                if (res.size() >= maxCount) {
                    break;
                }

                idx = indexOf(str, delimiterOfExclusiveBeginIndex, endIndex + lengthOfDelimiterOfExclusiveEndIndex);

                if (idx < 0) {
                    break;
                }

                idx += lengthOfDelimiterOfExclusiveBeginIndex;
            } while (idx < toIndex);
        } else {
            final Deque<Integer> queue = new LinkedList<>();

            queue.add(idx);
            int next = -1;

            for (int i = idx; i < toIndex;) {
                if (queue.size() == 0) {
                    idx = next >= i ? next : str.indexOf(delimiterOfExclusiveBeginIndex, i);

                    if (idx < 0) {
                        break;
                    } else {
                        idx += lengthOfDelimiterOfExclusiveBeginIndex;
                        queue.add(idx);
                        i = idx;
                    }
                }

                idx = str.indexOf(delimiterOfExclusiveEndIndex, i);

                if (idx < 0) {
                    break;
                } else {
                    final int endIndex = idx;
                    //noinspection DataFlowIssue
                    idx = res.size() > 0 ? Math.max(res.get(res.size() - 1)[1] + lengthOfDelimiterOfExclusiveEndIndex, queue.peekLast()) : queue.peekLast();

                    while ((idx = str.indexOf(delimiterOfExclusiveBeginIndex, idx)) >= 0 && idx < endIndex) {
                        idx += lengthOfDelimiterOfExclusiveBeginIndex;
                        queue.push(idx);
                    }

                    if (idx > 0) {
                        next = idx;
                    }

                    final int startIndex = queue.pop();

                    if (extractStrategy == ExtractStrategy.IGNORE_NESTED && res.size() > 0 && startIndex < res.get(res.size() - 1)[0]) {
                        while (res.size() > 0 && startIndex < res.get(res.size() - 1)[0]) {
                            res.remove(res.size() - 1);
                        }
                    }

                    res.add(new int[] { startIndex, endIndex });

                    if (res.size() >= maxCount) {
                        break;
                    }

                    i = endIndex + lengthOfDelimiterOfExclusiveEndIndex;
                }
            }
        }

        return res;
    }

    /**
     * Returns a new String with the specified range replaced with the replacement String.
     *
     * <p>This method creates a new string by replacing the characters from {@code fromIndex} (inclusive)
     * to {@code toIndex} (exclusive) with the specified replacement string. The original string remains unchanged.
     * If the replacement is {@code null}, it is treated as an empty string.</p>
     *
     * <p>The method handles special cases gracefully: if the input string is {@code null} or empty,
     * it returns the replacement string (or empty if replacement is {@code null}). If {@code fromIndex}
     * equals {@code toIndex} and replacement is empty, the original string is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Replace range with new text
     * replaceRange("Hello World", 6, 11, "Java");           // returns "Hello Java"
     * replaceRange("Hello World", 0, 5, "Hi");              // returns "Hi World"
     * replaceRange("Hello World", 5, 5, " Beautiful");      // returns "Hello Beautiful World"
     * 
     * // Delete range (null or empty replacement)
     * replaceRange("Hello World", 5, 11, null);            // returns "Hello"
     * replaceRange("Hello World", 5, 11, "");              // returns "Hello"
     * 
     * // Edge cases
     * replaceRange(null, 0, 0, "Text");                    // returns "Text"
     * replaceRange("", 0, 0, "Text");                      // returns "Text"
     * }</pre>
     *
     * @param str The original string. It can be {@code null}.
     * @param fromIndex The initial index of the range to be replaced, inclusive.
     * @param toIndex The final index of the range to be replaced, exclusive.
     * @param replacement The string to replace the specified range in the original string. It can be {@code null}.
     * @return A new string with the specified range replaced by the replacement string.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds.
     * @see N#replaceRange(String, int, int, String)
     */
    @Beta
    public static String replaceRange(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));

        if (N.isEmpty(str)) {
            return replacement == null ? EMPTY : replacement;
        } else if (fromIndex == toIndex && N.isEmpty(replacement)) {
            return str;
        }

        if (N.isEmpty(replacement)) {
            return str.substring(0, fromIndex) + str.substring(toIndex);
        } else {
            return str.substring(0, fromIndex) + N.nullToEmpty(replacement) + str.substring(toIndex);
        }
    }

    /**
     * Moves a specified range of characters within a string to a new position.
     *
     * <p>This method extracts a substring from the range [fromIndex, toIndex) and moves it to the specified
     * new position. The newPositionStartIndexAfterMove parameter indicates where the start of the moved range
     * should be positioned in the resulting string. The original string remains unchanged, and a new string
     * with the rearranged characters is returned.</p>
     *
     * <p>The method returns an empty string for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Moving a range of characters
     * moveRange("ABCDEFGH", 2, 5, 0);      // returns "CDEABFGH" (moves "CDE" to position 0)
     * moveRange("ABCDEFGH", 2, 5, 6);      // returns "ABFGHCDE" (moves "CDE" to position 6)
     * moveRange("Hello World", 0, 5, 6);   // returns " WorldHello" (moves "Hello" after "World")
     * 
     * // Edge cases
     * moveRange(null, 0, 0, 0);            // returns ""
     * moveRange("", 0, 0, 0);              // returns ""
     * moveRange("ABC", 1, 1, 2);           // returns "ABC" (no change when fromIndex == toIndex)
     * moveRange("ABC", 0, 2, 0);           // returns "ABC" (no change when already at position)
     * }</pre>
     *
     * @param str the original string to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndexAfterMove the start index of the specified range after the move operation, not before the move operation. 
     *          It must in the range: [0, array.length - (toIndex - fromIndex)]
     * @return a new string with the specified range moved to the new position. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds or newPositionStartIndexAfterMove is invalid
     * @see N#moveRange(String, int, int, int)
     */
    @Beta
    public static String moveRange(final String str, final int fromIndex, final int toIndex, final int newPositionStartIndexAfterMove)
            throws IndexOutOfBoundsException {
        final int len = N.len(str);
        N.checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndexAfterMove, len);

        if (N.isEmpty(str)) {
            return EMPTY;
        }

        if (fromIndex == toIndex || fromIndex == newPositionStartIndexAfterMove) {
            return str;
        }

        if (newPositionStartIndexAfterMove < fromIndex) {
            return Strings.concat(str.substring(0, newPositionStartIndexAfterMove), str.substring(fromIndex, toIndex),
                    str.substring(newPositionStartIndexAfterMove, fromIndex), str.substring(toIndex));
        } else {
            final int m = toIndex + (newPositionStartIndexAfterMove - fromIndex);

            return Strings.concat(str.substring(0, fromIndex), str.substring(toIndex, m), str.substring(fromIndex, toIndex), str.substring(m));
        }
    }

    /**
     * Deletes a specified range of characters from a string.
     *
     * <p>This method removes characters from the range [fromIndex, toIndex) in the given string.
     * The original string remains unchanged, and a new string without the specified range is returned.
     * If the range is empty (fromIndex == toIndex) or starts beyond the string length, the original string is returned.</p>
     *
     * <p>The method returns an empty string for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Deleting a range of characters
     * deleteRange("ABCDEFGH", 2, 5);       // returns "ABFGH" (removes "CDE")
     * deleteRange("Hello World", 5, 11);   // returns "Hello" (removes " World")
     * deleteRange("Test", 0, 2);           // returns "st" (removes "Te")
     * 
     * // Edge cases
     * deleteRange(null, 0, 1);             // returns ""
     * deleteRange("", 0, 0);               // returns ""
     * deleteRange("ABC", 1, 1);            // returns "ABC" (no deletion when fromIndex == toIndex)
     * deleteRange("ABC", 3, 5);            // returns "ABC" (no deletion when fromIndex >= length)
     * deleteRange("ABC", 0, 10);           // returns "" (deletes entire string and beyond)
     * }</pre>
     *
     * @param str the input string from which a range of characters are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new string with the specified range of characters deleted. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds
     * @see N#deleteRange(String, int, int)
     */
    @Beta
    public static String deleteRange(final String str, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        final int len = N.len(str);

        N.checkFromToIndex(fromIndex, toIndex, len);

        if (N.isEmpty(str)) {
            return EMPTY;
        }

        if (fromIndex == toIndex || fromIndex >= len) {
            return str;
        } else if (toIndex - fromIndex >= len) {
            return Strings.EMPTY;
        }

        return Strings.concat(str.substring(0, fromIndex) + str.substring(toIndex));
    }

    /**
     * Joins the elements of a boolean array into a single String using the default element separator.
     *
     * <p>This method concatenates all elements in the array, separating them with the default
     * element separator. The boolean values are converted to their string representations ("true" or "false").</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining boolean arrays
     * join(new boolean[]{true, false, true});    // returns "true, false, true" (using default separator)
     * join(new boolean[]{true});                 // returns "true"
     * 
     * // Edge cases
     * join((boolean[]) null);                    // returns ""
     * join(new boolean[]{});                     // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a boolean array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all elements in the array, separating them with the provided
     * delimiter string. The boolean values are converted to their string representations ("true" or "false").
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining boolean arrays with string delimiters
     * join(new boolean[]{true, false, true}, ", ");    // returns "true, false, true"
     * join(new boolean[]{true, false, true}, " - ");   // returns "true - false - true"
     * join(new boolean[]{true, false, true}, "");      // returns "truefalsetrue"
     * 
     * // Edge cases
     * join((boolean[]) null, ", ");                    // returns ""
     * join(new boolean[]{}, ", ");                     // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a boolean array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The boolean values are converted to their
     * string representations ("true" or "false"). If the delimiter is empty, the elements are
     * concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining a range of boolean array elements
     * boolean[] arr = {true, false, true, false, true};
     * join(arr, 1, 4, ", ");                   // returns "false, true, false"
     * join(arr, 0, 3, " - ");                  // returns "true - false - true"
     * join(arr, 2, 5, "");                     // returns "truefalsetrue"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ");                   // returns "" (fromIndex == toIndex)
     * join((boolean[]) null, 0, 0, ", ");      // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a boolean array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. The boolean values are converted to their string representations ("true" or "false").
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining with prefix and suffix
     * boolean[] arr = {true, false, true, false, true};
     * join(arr, 0, 3, ", ", "[", "]");         // returns "[true, false, true]"
     * join(arr, 1, 4, " | ", "Results: ", "");  // returns "Results: false | true | false"
     * join(arr, 2, 3, ", ", "(", ")");         // returns "(true)"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ", "[", "]");         // returns "[]" (empty range)
     * join(null, 0, 0, ", ", "[", "]");        // returns "[]"
     * join(arr, 0, 2, "", "<", ">");           // returns "<truefalse>"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final boolean[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 5 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a char array into a single String using the default element separator.
     *
     * <p>This method concatenates all characters in the array, separating them with the default
     * element separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining char arrays
     * join(new char[]{'a', 'b', 'c'});         // returns "a, b, c" (using default separator)
     * join(new char[]{'x'});                   // returns "x"
     * 
     * // Edge cases
     * join((char[]) null);                     // returns ""
     * join(new char[]{});                      // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a char array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all characters in the array, separating them with the provided
     * delimiter string. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining char arrays with string delimiters
     * join(new char[]{'a', 'b', 'c'}, ", ");    // returns "a, b, c"
     * join(new char[]{'x', 'y', 'z'}, " - ");   // returns "x - y - z"
     * join(new char[]{'A', 'B', 'C'}, "");      // returns "ABC"
     * 
     * // Edge cases
     * join((char[]) null, ", ");                // returns ""
     * join(new char[]{}, ", ");                 // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a char array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. If the delimiter is empty, the elements are
     * concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining a range of char array elements
     * char[] arr = {'a', 'b', 'c', 'd', 'e'};
     * join(arr, 1, 4, ", ");                   // returns "b, c, d"
     * join(arr, 0, 3, " - ");                  // returns "a - b - c"
     * join(arr, 2, 5, "");                     // returns "cde"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ");                   // returns "" (fromIndex == toIndex)
     * join((char[]) null, 0, 0, ", ");         // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a char array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining with prefix and suffix
     * char[] arr = {'a', 'b', 'c', 'd', 'e'};
     * join(arr, 0, 3, ", ", "[", "]");         // returns "[a, b, c]"
     * join(arr, 1, 4, " | ", "Chars: ", "");   // returns "Chars: b | c | d"
     * join(arr, 2, 3, ", ", "(", ")");         // returns "(c)"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ", "[", "]");         // returns "[]" (empty range)
     * join(null, 0, 0, ", ", "[", "]");        // returns "[]"
     * join(arr, 0, 2, "", "<", ">");           // returns "<ab>"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final char[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 1 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a byte array into a single String using the default element separator.
     *
     * <p>This method concatenates all byte values in the array, separating them with the default
     * element separator. The byte values are converted to their string representations.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining byte arrays
     * join(new byte[]{1, 2, 3});               // returns "1, 2, 3" (using default separator)
     * join(new byte[]{127});                   // returns "127"
     * 
     * // Edge cases
     * join((byte[]) null);                     // returns ""
     * join(new byte[]{});                      // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a byte array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all byte values in the array, separating them with the provided
     * delimiter string. The byte values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining byte arrays with string delimiters
     * join(new byte[]{1, 2, 3}, ", ");         // returns "1, 2, 3"
     * join(new byte[]{10, 20, 30}, " - ");     // returns "10 - 20 - 30"
     * join(new byte[]{1, 2, 3}, "");           // returns "123"
     * 
     * // Edge cases
     * join((byte[]) null, ", ");               // returns ""
     * join(new byte[]{}, ", ");                // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a byte array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The byte values are converted to their
     * string representations. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining a range of byte array elements
     * byte[] arr = {1, 2, 3, 4, 5};
     * join(arr, 1, 4, ", ");                   // returns "2, 3, 4"
     * join(arr, 0, 3, " - ");                  // returns "1 - 2 - 3"
     * join(arr, 2, 5, "");                     // returns "345"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ");                   // returns "" (fromIndex == toIndex)
     * join((byte[]) null, 0, 0, ", ");         // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a byte array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. The byte values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining with prefix and suffix
     * byte[] arr = {1, 2, 3, 4, 5};
     * join(arr, 0, 3, ", ", "[", "]");         // returns "[1, 2, 3]"
     * join(arr, 1, 4, " | ", "Bytes: ", "");   // returns "Bytes: 2 | 3 | 4"
     * join(arr, 2, 3, ", ", "(", ")");         // returns "(3)"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ", "[", "]");         // returns "[]" (empty range)
     * join(null, 0, 0, ", ", "[", "]");        // returns "[]"
     * join(arr, 0, 2, "", "<", ">");           // returns "<12>"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final byte[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 4 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a short array into a single String using the default element separator.
     *
     * <p>This method concatenates all short values in the array, separating them with the default
     * element separator. The short values are converted to their string representations.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining short arrays
     * join(new short[]{1, 2, 3});              // returns "1, 2, 3" (using default separator)
     * join(new short[]{32767});                // returns "32767"
     * 
     * // Edge cases
     * join((short[]) null);                    // returns ""
     * join(new short[]{});                     // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(short[], int, int, String, String, String)
     */
    public static String join(final short[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a short array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all short values in the array, separating them with the provided
     * delimiter string. The short values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining short arrays with string delimiters
     * join(new short[]{1, 2, 3}, ", ");        // returns "1, 2, 3"
     * join(new short[]{100, 200, 300}, " - "); // returns "100 - 200 - 300"
     * join(new short[]{1, 2, 3}, "");          // returns "123"
     * 
     * // Edge cases
     * join((short[]) null, ", ");              // returns ""
     * join(new short[]{}, ", ");               // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(short[], int, int, String, String, String)
     */
    public static String join(final short[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**     
     * oins a range of elements from a short array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The short values are converted to their
     * string representations. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for null or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Joining a range of short array elements
     * short[] arr = {10, 20, 30, 40, 50};
     * join(arr, 1, 4, ", ");                   // returns "20, 30, 40"
     * join(arr, 0, 3, " - ");                  // returns "10 - 20 - 30"
     * join(arr, 2, 5, "");                     // returns "30304050"
     * 
     * // Edge cases
     * join(arr, 1, 1, ", ");                   // returns "" (fromIndex == toIndex)
     * join((short[]) null, 0, 0, ", ");        // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     */
    public static String join(final short[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided short array into a single String.
     *
     * <p>This method concatenates the string representations of array elements from the specified range
     * using the provided delimiter, prefix, and suffix. Elements are converted to their string representation
     * and joined in the order they appear in the array.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * short[] numbers = {1, 2, 3, 4, 5};
     * 
     * // Basic joining with delimiter
     * join(numbers, 0, 5, ", ", "", "");           // returns "1, 2, 3, 4, 5"
     * join(numbers, 1, 4, "-", "", "");            // returns "2-3-4"
     * 
     * // With prefix and suffix
     * join(numbers, 0, 3, ", ", "[", "]");         // returns "[1, 2, 3]"
     * join(numbers, 0, 5, ", ", "Numbers: ", "");  // returns "Numbers: 1, 2, 3, 4, 5"
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "", "");              // returns ""
     * join(numbers, 2, 2, ", ", "[", "]");         // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final short[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 5 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided int array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * join(numbers);                    // returns "1, 2, 3, 4, 5" (using default separator)
     * 
     * int[] empty = {};
     * join(empty);                      // returns ""
     * join(null);                       // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided int array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * join(numbers, ", ");              // returns "1, 2, 3, 4, 5"
     * join(numbers, " - ");             // returns "1 - 2 - 3 - 4 - 5"
     * join(numbers, "");                // returns "12345"
     * join(numbers, " and ");           // returns "1 and 2 and 3 and 4 and 5"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided int array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p>Example:
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * join(numbers, 1, 4, ", ");        // returns "2, 3, 4"
     * join(numbers, 0, 3, " - ");       // returns "1 - 2 - 3"
     * join(numbers, 2, 5, "");          // returns "345"
     * 
     * // Edge cases
     * join(numbers, 2, 2, ", ");        // returns "" (fromIndex == toIndex)
     * join(numbers, 0, 1, ", ");        // returns "1" (single element)
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided int array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * 
     * // Basic joining with delimiter
     * join(numbers, 0, 5, ", ", "", "");           // returns "1, 2, 3, 4, 5"
     * join(numbers, 1, 4, "-", "", "");            // returns "2-3-4"
     * 
     * // With prefix and suffix
     * join(numbers, 0, 3, ", ", "[", "]");         // returns "[1, 2, 3]"
     * join(numbers, 0, 5, ", ", "Numbers: ", "");  // returns "Numbers: 1, 2, 3, 4, 5"
     * join(numbers, 2, 4, " | ", "Result: ", "!");  // returns "Result: 3 | 4!"
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]");            // returns "[]"
     * join(numbers, 2, 2, ", ", "[", "]");         // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final int[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided long array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L};
     * join(numbers);                    // returns "100, 200, 300" (using default separator)
     * 
     * long[] empty = {};
     * join(empty);                      // returns ""
     * join(null);                       // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided long array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L};
     * join(numbers, ", ");              // returns "100, 200, 300"
     * join(numbers, " - ");             // returns "100 - 200 - 300"
     * join(numbers, "");                // returns "100200300"
     * join(numbers, " and ");           // returns "100 and 200 and 300"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided long array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p>Example:
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * join(numbers, 1, 4, ", ");        // returns "200, 300, 400"
     * join(numbers, 0, 3, " - ");       // returns "100 - 200 - 300"
     * join(numbers, 2, 5, "");          // returns "300400500"
     * 
     * // Edge cases
     * join(numbers, 2, 2, ", ");        // returns "" (fromIndex == toIndex)
     * join(numbers, 0, 1, ", ");        // returns "100" (single element)
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided long array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * 
     * // Basic joining with delimiter
     * join(numbers, 0, 5, ", ", "", "");           // returns "100, 200, 300, 400, 500"
     * join(numbers, 1, 4, "-", "", "");            // returns "200-300-400"
     * 
     * // With prefix and suffix
     * join(numbers, 0, 3, ", ", "[", "]");         // returns "[100, 200, 300]"
     * join(numbers, 0, 5, ", ", "Values: ", "");   // returns "Values: 100, 200, 300, 400, 500"
     * join(numbers, 2, 4, " | ", "Result: ", "!");  // returns "Result: 300 | 400!"
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]");            // returns "[]"
     * join(numbers, 2, 2, ", ", "[", "]");         // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final long[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided float array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * float[] numbers = {1.5f, 2.7f, 3.14f};
     * join(numbers);                    // returns "1.5, 2.7, 3.14" (using default separator)
     * 
     * float[] empty = {};
     * join(empty);                      // returns ""
     * join(null);                       // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided float array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * float[] numbers = {1.5f, 2.7f, 3.14f};
     * join(numbers, ", ");              // returns "1.5, 2.7, 3.14"
     * join(numbers, " - ");             // returns "1.5 - 2.7 - 3.14"
     * join(numbers, "");                // returns "1.52.73.14"
     * join(numbers, " and ");           // returns "1.5 and 2.7 and 3.14"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided float array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p>Example:
     * <pre>{@code
     * float[] numbers = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
     * join(numbers, 1, 4, ", ");        // returns "2.2, 3.3, 4.4"
     * join(numbers, 0, 3, " - ");       // returns "1.1 - 2.2 - 3.3"
     * join(numbers, 2, 5, "");          // returns "3.34.45.5"
     * 
     * // Edge cases
     * join(numbers, 2, 2, ", ");        // returns "" (fromIndex == toIndex)
     * join(numbers, 0, 1, ", ");        // returns "1.1" (single element)
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided float array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * float[] numbers = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
     * 
     * // Basic joining with delimiter
     * join(numbers, 0, 5, ", ", "", "");           // returns "1.1, 2.2, 3.3, 4.4, 5.5"
     * join(numbers, 1, 4, "-", "", "");            // returns "2.2-3.3-4.4"
     * 
     * // With prefix and suffix
     * join(numbers, 0, 3, ", ", "[", "]");         // returns "[1.1, 2.2, 3.3]"
     * join(numbers, 0, 5, ", ", "Values: ", "");   // returns "Values: 1.1, 2.2, 3.3, 4.4, 5.5"
     * join(numbers, 2, 4, " | ", "Result: ", "!");  // returns "Result: 3.3 | 4.4!"
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]");            // returns "[]"
     * join(numbers, 2, 2, ", ", "[", "]");         // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty and <i>prefix'/'suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final float[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided double array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * double[] numbers = {1.5, 2.7, 3.14159};
     * join(numbers);                    // returns "1.5, 2.7, 3.14159" (using default separator)
     * 
     * double[] empty = {};
     * join(empty);                      // returns ""
     * join(null);                       // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided double array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p>Example:
     * <pre>{@code
     * double[] numbers = {1.5, 2.7, 3.14159};
     * join(numbers, ", ");              // returns "1.5, 2.7, 3.14159"
     * join(numbers, " - ");             // returns "1.5 - 2.7 - 3.14159"
     * join(numbers, "");                // returns "1.52.73.14159"
     * join(numbers, " and ");           // returns "1.5 and 2.7 and 3.14159"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided double array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p>Example:
     * <pre>{@code
     * double[] numbers = {1.1, 2.2, 3.3, 4.4, 5.5};
     * join(numbers, 1, 4, ", ");        // returns "2.2, 3.3, 4.4"
     * join(numbers, 0, 3, " - ");       // returns "1.1 - 2.2 - 3.3"
     * join(numbers, 2, 5, "");          // returns "3.34.45.5"
     * 
     * // Edge cases
     * join(numbers, 2, 2, ", ");        // returns "" (fromIndex == toIndex)
     * join(numbers, 0, 1, ", ");        // returns "1.1" (single element)
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided double array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * double[] numbers = {1.1, 2.2, 3.3, 4.4, 5.5};
     * 
     * // Basic joining with delimiter
     * join(numbers, 0, 5, ", ", "", "");           // returns "1.1, 2.2, 3.3, 4.4, 5.5"
     * join(numbers, 1, 4, "-", "", "");            // returns "2.2-3.3-4.4"
     * 
     * // With prefix and suffix
     * join(numbers, 0, 3, ", ", "[", "]");         // returns "[1.1, 2.2, 3.3]"
     * join(numbers, 0, 5, ", ", "Values: ", "");   // returns "Values: 1.1, 2.2, 3.3, 4.4, 5.5"
     * join(numbers, 2, 4, " | ", "Result: ", "!");  // returns "Result: 3.3 | 4.4!"
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]");            // returns "[]"
     * join(numbers, 2, 2, ", ", "[", "]");         // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null} or empty.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final double[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of the provided array into a single String.
     *
     * <p>This method concatenates all elements in the array using the default element separator.
     * Each element is converted to a string representation using its {@code toString()} method.
     * Null elements are handled as "null" strings.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * join(arr);                                     // returns "apple, banana, cherry"
     * 
     * Object[] mixed = {1, "hello", true};
     * join(mixed);                                   // returns "1, hello, true"
     * 
     * join(null);                                    // returns ""
     * join(new String[0]);                           // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * join(arr, " - ");                              // returns "apple - banana - cherry"
     * join(arr, "");                                 // returns "applebananacherry"
     * join(arr, ", ");                               // returns "apple, banana, cherry"
     * 
     * Object[] mixed = {1, 2, 3};
     * join(mixed, " and ");                          // returns "1 and 2 and 3"
     * 
     * join(null, ", ");                              // returns ""
     * join(new String[0], ", ");                     // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty and both prefix and suffix are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * join(arr, ", ", "[", "]");                     // returns "[apple, banana, cherry]"
     * join(arr, " | ", "Items: ", ".");              // returns "Items: apple | banana | cherry."
     * 
     * join(new String[0], ", ", "[", "]");           // returns "[]"
     * join(null, ", ", "Start: ", " :End");          // returns "Start:  :End"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string with prefix and suffix applied.
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a, final String delimiter, final String prefix, final String suffix) {
        return join(a, 0, N.len(a), delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty and both prefix and suffix are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry "};
     * join(arr, ", ", "[", "]", true);               // returns "[apple, banana, cherry]"
     * join(arr, ", ", "[", "]", false);              // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Object[] mixed = {1, "  hello  ", true};
     * join(mixed, " | ", "", "", true);              // returns "1 | hello | true"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Object[] a, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        return join(a, 0, N.len(a), delimiter, prefix, suffix, trim);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry", "date", "elderberry"};
     * join(arr, 1, 4, " - ");                        // returns "banana - cherry - date"
     * join(arr, 0, 3, ", ");                         // returns "apple, banana, cherry"
     * join(arr, 2, 4, "");                           // returns "cherrydate"
     * }</pre>
     *
     * @param a The array containing the elements to join together.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Object[], int, int, String, String, String, boolean)
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter) {
        return join(a, fromIndex, toIndex, delimiter, false);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter and optional trimming.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry ", " date "};
     * join(arr, 1, 3, " - ", true);                  // returns "banana - cherry"
     * join(arr, 1, 3, " - ", false);                 // returns " banana  -  cherry "
     * join(arr, 0, 4, "", true);                     // returns "applebananacherrydate"
     * }</pre>
     *
     * @param a The array containing the elements to join together.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Object[], int, int, String, String, String, boolean)
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final boolean trim) {
        return join(a, fromIndex, toIndex, delimiter, null, null, trim);
    }

    /** 
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and both prefix and suffix are empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry", "date"};
     * join(arr, 1, 3, ", ", "[", "]");               // returns "[banana, cherry]"
     * join(arr, 0, 4, " | ", "Fruits: ", ".");       // returns "Fruits: apple | banana | cherry | date."
     * join(arr, 2, 2, ", ", "[", "]");               // returns "[]"
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix) {
        return join(a, fromIndex, toIndex, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is {@code null} or empty, or if {@code fromIndex == toIndex},
     * it returns just the concatenation of prefix and suffix (or an empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry ", " date "};
     * join(arr, 1, 3, ", ", "[", "]", true);         // returns "[banana, cherry]"
     * join(arr, 1, 3, ", ", "[", "]", false);        // returns "[ banana ,  cherry ]"
     * join(arr, 0, 4, " | ", "Items: ", ".", true);  // returns "Items: apple | banana | cherry | date."
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]", true);        // returns "[]"
     * join(new String[0], 0, 0, ", ", "", "", true); // returns ""
     * }</pre>
     *
     * @param a The array containing the elements to join together. It can be {@code null}.
     * @param fromIndex The start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix,
            final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return toString(a[fromIndex], trim);
        }

        final int len = toIndex - fromIndex;
        final String[] elements = new String[len];

        for (int i = fromIndex, j = 0; i < toIndex; i++, j++) {
            elements[j] = toString(a[i], trim);
        }

        elements[0] = concat(prefix, elements[0]);
        elements[len - 1] = concat(elements[len - 1], suffix);

        return String.join(nullToEmpty(delimiter), elements);
    }

    /**
     * Joins the elements of the provided Iterable into a single String.
     *
     * <p>This method concatenates all elements in the iterable using the default element separator.
     * Each element is converted to a string representation using its {@code toString()} method.
     * Null elements are handled as "null" strings.</p>
     *
     * <p>The method returns an empty string if the specified Iterable is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list);                                    // returns "apple, banana, cherry"
     * 
     * Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
     * join(numbers);                                 // returns "1, 2, 3" (order may vary)
     * 
     * join(null);                                    // returns ""
     * join(new ArrayList<>());                       // returns ""
     * }</pre>
     *
     * @param c The Iterable containing the elements to join together. It can be {@code null}.
     * @return The concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c) {
        return join(c, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified Iterable is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list, " - ");                             // returns "apple - banana - cherry"
     * join(list, "");                                // returns "applebananacherry"
     * join(list, ", ");                              // returns "apple, banana, cherry"
     * 
     * List<Integer> numbers = Arrays.asList(1, 2, 3);
     * join(numbers, " and ");                        // returns "1 and 2 and 3"
     * 
     * join(null, ", ");                              // returns ""
     * join(new ArrayList<>(), ", ");                 // returns ""
     * }</pre>
     *
     * @param c The Iterable containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c, final String delimiter) {
        return join(c == null ? null : c.iterator(), delimiter);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the Iterable is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list, ", ", "[", "]");                    // returns "[apple, banana, cherry]"
     * join(list, " | ", "Items: ", ".");             // returns "Items: apple | banana | cherry."
     * 
     * join(new ArrayList<>(), ", ", "[", "]");       // returns "[]"
     * join(null, ", ", "Start: ", " :End");          // returns "Start:  :End"
     * }</pre>
     *
     * @param c The Iterable containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty and <i>prefix, suffix</i> are empty.
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c, final String delimiter, final String prefix, final String suffix) {
        return join(c == null ? null : c.iterator(), delimiter, prefix, suffix);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>For Collection types, this method delegates to the more efficient range-based join method.
     * For other Iterable types, it uses iterator-based processing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ");
     * join(list, ", ", "[", "]", true);              // returns "[apple, banana, cherry]"
     * join(list, ", ", "[", "]", false);             // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Set<String> set = new HashSet<>(Arrays.asList("  one  ", "  two  "));
     * join(set, " | ", "", "", true);                // returns "one | two" (order may vary)
     * }</pre>
     *
     * @param c The Iterable containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Iterable<?> c, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        if (c instanceof final Collection<?> coll) { // NOSONAR
            return join(coll, 0, coll.size(), delimiter, prefix, suffix, trim);
        } else {
            return join(c == null ? null : c.iterator(), delimiter, prefix, suffix, trim);
        }
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified Collection is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
     * join(list, 1, 4, " - ");                       // returns "banana - cherry - date"
     * join(list, 0, 3, ", ");                        // returns "apple, banana, cherry"
     * join(list, 2, 4, "");                          // returns "cherrydate"
     * }</pre>
     *
     * @param c The Collection containing the elements to join together.
     * @param fromIndex The start index in the collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified Collection is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Collection, int, int, String, String, String, boolean)
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter) {
        return join(c, fromIndex, toIndex, delimiter, false);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter and optional trimming.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified Collection is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ", " date ");
     * join(list, 1, 3, " - ", true);                 // returns "banana - cherry"
     * join(list, 1, 3, " - ", false);                // returns " banana  -  cherry "
     * join(list, 0, 4, "", true);                    // returns "applebananacherrydate"
     * }</pre>
     *
     * @param c The Collection containing the elements to join together.
     * @param fromIndex The start index in the collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified Collection is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Collection, int, int, String, String, String, boolean)
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final boolean trim) {
        return join(c, fromIndex, toIndex, delimiter, null, null, trim);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the collection is {@code null} or empty or {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry", "date");
     * join(list, 1, 3, ", ", "[", "]");              // returns "[banana, cherry]"
     * join(list, 0, 4, " | ", "Fruits: ", ".");      // returns "Fruits: apple | banana | cherry | date."
     * join(list, 2, 2, ", ", "[", "]");              // returns "[]"
     * }</pre>
     *
     * @param c The Collection containing the elements to join together. It can be {@code null}.
     * @param fromIndex The start index in the Collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the Collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified Collection is {@code null} or empty or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the Collection size.
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix) {
        return join(c, fromIndex, toIndex, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method efficiently handles List types with RandomAccess for better performance.
     * It returns just the concatenation of prefix and suffix if the collection is {@code null} or empty or {@code fromIndex == toIndex}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ", " date ");
     * join(list, 1, 3, ", ", "[", "]", true);        // returns "[banana, cherry]"
     * join(list, 1, 3, ", ", "[", "]", false);       // returns "[ banana ,  cherry ]"
     * join(list, 0, 4, " | ", "Items: ", ".", true); // returns "Items: apple | banana | cherry | date."
     * 
     * // Edge cases
     * join(null, 0, 0, ", ", "[", "]", true);        // returns "[]"
     * join(new ArrayList<>(), 0, 0, ", ", "", "", true); // returns ""
     * }</pre>
     *
     * @param c The Collection containing the elements to join together. It can be {@code null}.
     * @param fromIndex The start index in the Collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex The end index in the Collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the Collection size.
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix,
            final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.size(c));

        if (N.isEmpty(c) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final int len = toIndex - fromIndex;
        final String[] elements = new String[len];

        if (c instanceof final List<?> list && c instanceof RandomAccess) {

            for (int i = fromIndex, j = 0; i < toIndex; i++, j++) {
                elements[j] = toString(list.get(i), trim);
            }
        } else {
            int i = 0, j = 0;

            for (final Object e : c) {
                if (i++ >= fromIndex) {
                    elements[j++] = toString(e, trim);
                }

                if (i >= toIndex) {
                    break;
                }
            }
        }

        elements[0] = concat(prefix, elements[0]);
        elements[len - 1] = concat(elements[len - 1], suffix);

        return String.join(nullToEmpty(delimiter), elements);
    }

    /**
     * Joins the elements of the provided Iterator into a single String.
     *
     * <p>This method concatenates all elements from the iterator using the default element separator.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns an empty string if the specified Iterator is {@code null} or has no elements.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list.iterator());                         // returns "apple, banana, cherry"
     * 
     * Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
     * join(numbers.iterator());                      // returns "1, 2, 3" (order may vary)
     * 
     * join(null);                                    // returns ""
     * join(new ArrayList<>().iterator());            // returns ""
     * }</pre>
     *
     * @param iter The Iterator containing the elements to join together. It can be {@code null}.
     * @return The concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter) {
        return join(iter, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns an empty string if the specified Iterator is {@code null} or has no elements.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list.iterator(), " - ");                  // returns "apple - banana - cherry"
     * join(list.iterator(), "");                     // returns "applebananacherry"
     * join(list.iterator(), ", ");                   // returns "apple, banana, cherry"
     * 
     * List<Integer> numbers = Arrays.asList(1, 2, 3);
     * join(numbers.iterator(), " and ");             // returns "1 and 2 and 3"
     * 
     * join(null, ", ");                              // returns ""
     * join(new ArrayList<>().iterator(), ", ");      // returns ""
     * }</pre>
     *
     * @param iter The Iterator containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return The concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter, final String delimiter) {
        return join(iter, delimiter, EMPTY, EMPTY, false);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the Iterator is {@code null} or has no elements.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * join(list.iterator(), ", ", "[", "]");         // returns "[apple, banana, cherry]"
     * join(list.iterator(), " | ", "Items: ", ".");  // returns "Items: apple | banana | cherry."
     * 
     * join(new ArrayList<>().iterator(), ", ", "[", "]"); // returns "[]"
     * join(null, ", ", "Start: ", " :End");          // returns "Start:  :End"
     * }</pre>
     *
     * @param iter The Iterator containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty and <i>prefix, suffix</i> are empty.
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter, final String delimiter, final String prefix, final String suffix) {
        return join(iter, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code toString()} method.
     * If trim is true, leading and trailing whitespace is removed from each element's string representation.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method internally converts the iterator to a list and then uses the collection-based join method for processing.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ");
     * join(list.iterator(), ", ", "[", "]", true);   // returns "[apple, banana, cherry]"
     * join(list.iterator(), ", ", "[", "]", false);  // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Set<String> set = new HashSet<>(Arrays.asList("  one  ", "  two  "));
     * join(set.iterator(), " | ", "", "", true);     // returns "one | two" (order may vary)
     * }</pre>
     *
     * @param iter The Iterator containing the elements to join together. It can be {@code null}.
     * @param delimiter The delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each element.
     * @return The concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Iterator<?> iter, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        if (iter == null) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final List<?> list = N.toList(iter);

        return join(list, 0, list.size(), delimiter, prefix, suffix, trim);
    }

    /**
     * Joins the entries of the provided Map into a single String.
     *
     * <p>This method creates a string representation of the map entries using default delimiters.
     * Each entry is formatted as "key=value" and entries are separated by the default element separator.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for null or empty maps.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new HashMap<>();
     * map.put("apple", 5);
     * map.put("banana", 3);
     * joinEntries(map);                              // returns "apple=5, banana=3" (order may vary)
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * joinEntries(emptyMap);                         // returns ""
     * joinEntries(null);                             // returns ""
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @return A string representation of the map entries, or an empty string if the map is null or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m) {
        return joinEntries(m, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the entries of the provided Map into a single String using the specified entry delimiter.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key=value"
     * and entries are separated by the specified delimiter string.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for null or empty maps.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("name", 1);
     * map.put("age", 25);
     * joinEntries(map, ", ");                        // returns "name=1, age=25"
     * joinEntries(map, " AND ");                     // returns "name=1 AND age=25"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * joinEntries(emptyMap, ", ");                   // returns ""
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @return A string representation of the map entries, or an empty string if the map is null or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter) {
        if (N.isEmpty(m)) {
            return EMPTY;
        }

        return joinEntries(m, 0, m.size(), entryDelimiter);
    }

    /**
     * Joins the entries of the provided Map into a single String using specified delimiters.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value"
     * and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for null or empty maps.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("min", 10);
     * map.put("max", 100);
     * joinEntries(map, ", ", " = ");                 // returns "min = 10, max = 100"
     * joinEntries(map, " AND ", " IS ");             // returns "min IS 10 AND max IS 100"
     * joinEntries(map, "|", "");                     // returns "min10|max100"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * joinEntries(emptyMap, ", ", " = ");            // returns ""
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param keyValueDelimiter The delimiter string that separates the key and value within each entry. It can be empty.
     * @return A string representation of the map entries, or an empty string if the map is null or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter) {
        if (N.isEmpty(m)) {
            return EMPTY;
        }

        return joinEntries(m, 0, m.size(), entryDelimiter, keyValueDelimiter);
    }

    /**
     * Joins the entries of the provided Map into a single String with specified delimiters and wrapping.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value",
     * entries are separated by the specified entry delimiter, and the entire result is wrapped with prefix and suffix strings.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is null or empty, the method returns only the concatenated prefix and suffix (or empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("x", 1);
     * map.put("y", 2);
     * joinEntries(map, ", ", "=", "[", "]");         // returns "[x=1, y=2]"
     * joinEntries(map, " AND ", " IS ", "WHERE ", ";"); // returns "WHERE x IS 1 AND y IS 2;"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * joinEntries(emptyMap, ", ", "=", "[", "]");    // returns "[]"
     * joinEntries(emptyMap, ", ", "=", "", "");      // returns ""
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param keyValueDelimiter The delimiter string that separates the key and value within each entry. It can be empty.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string with prefix and suffix, or just prefix+suffix if the map is null or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter, final String prefix, final String suffix) {
        return joinEntries(m, 0, N.size(m), entryDelimiter, keyValueDelimiter, prefix, suffix, false);
    }

    /**
     * Joins the entries of the provided Map into a single String with full control over formatting.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value",
     * entries are separated by the specified entry delimiter, and the entire result is wrapped with prefix and suffix strings.
     * The entryDelimiter and keyValueDelimiter can be empty for direct concatenation.
     * If trim is true, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is null or empty, the method returns only the concatenated prefix and suffix (or empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" name ", " John ");
     * map.put(" age ", " 25 ");
     * 
     * joinEntries(map, ", ", "=", "{", "}", false);  // returns "{ name = John ,  age = 25 }"
     * joinEntries(map, ", ", "=", "{", "}", true);   // returns "{name=John, age=25}"
     * 
     * Map<Integer, Integer> numbers = new LinkedHashMap<>();
     * numbers.put(1, 100);
     * numbers.put(2, 200);
     * joinEntries(numbers, " + ", "*", "(", ")", false); // returns "(1*100 + 2*200)"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param entryDelimiter The delimiter that separates each entry. It can be empty.
     * @param keyValueDelimiter The delimiter that separates the key and value within each entry. It can be empty.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, trims the string representations of each key and value.
     * @return The concatenated string with prefix and suffix, or just prefix+suffix if the map is null or empty.
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter, final String prefix, final String suffix,
            final boolean trim) {
        return joinEntries(m, 0, N.size(m), entryDelimiter, keyValueDelimiter, prefix, suffix, trim);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key=value" and entries are separated by the specified delimiter string.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is null, empty, or if fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("first", 1);
     * map.put("second", 2);
     * map.put("third", 3);
     * 
     * joinEntries(map, 0, 2, ", ");                  // returns "first=1, second=2"
     * joinEntries(map, 1, 3, " AND ");               // returns "second=2 AND third=3"
     * joinEntries(map, 2, 2, ", ");                  // returns ""
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The starting index (inclusive) of entries to include.
     * @param toIndex The ending index (exclusive) of entries to include.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @return A string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with optional trimming.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key=value" and entries are separated by the specified delimiter string.
     * If trim is true, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is null, empty, or if fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" key1 ", " value1 ");
     * map.put(" key2 ", " value2 ");
     * map.put(" key3 ", " value3 ");
     * 
     * joinEntries(map, 0, 2, ", ", false);           // returns " key1 = value1 ,  key2 = value2 "
     * joinEntries(map, 0, 2, ", ", true);            // returns "key1=value1, key2=value2"
     * joinEntries(map, 1, 3, " | ", true);           // returns "key2=value2 | key3=value3"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The starting index (inclusive) of entries to include.
     * @param toIndex The ending index (exclusive) of entries to include.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param trim If {@code true}, trims the string representations of each key and value.
     * @return A string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final boolean trim) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, WD.EQUAL, null, null, trim);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with specified delimiters.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value" and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is null, empty, or if fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("min", 10);
     * map.put("max", 100);
     * map.put("avg", 55);
     * 
     * joinEntries(map, 0, 2, ", ", " = ");           // returns "min = 10, max = 100"
     * joinEntries(map, 1, 3, " AND ", " IS ");       // returns "max IS 100 AND avg IS 55"
     * joinEntries(map, 0, 1, "|", "");               // returns "min10"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The starting index (inclusive) of entries to include.
     * @param toIndex The ending index (exclusive) of entries to include.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param keyValueDelimiter The delimiter string that separates the key and value within each entry. It can be empty.
     * @return A string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with specified delimiters and optional trimming.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value" and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * If trim is true, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is null, empty, or if fromIndex equals toIndex.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" name ", " John ");
     * map.put(" age ", " 25 ");
     * map.put(" city ", " NYC ");
     * 
     * joinEntries(map, 0, 2, ", ", "=", false);      // returns " name = John ,  age = 25 "
     * joinEntries(map, 0, 2, ", ", "=", true);       // returns "name=John, age=25"
     * joinEntries(map, 1, 3, " AND ", " IS ", true); // returns "age IS 25 AND city IS NYC"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The starting index (inclusive) of entries to include.
     * @param toIndex The ending index (exclusive) of entries to include.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param keyValueDelimiter The delimiter string that separates the key and value within each entry. It can be empty.
     * @param trim If {@code true}, leading and trailing whitespace of each key and value will be removed.
     * @return A string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final boolean trim) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, null, null, trim);
    }

    /**     
     * Joins a subset of entries from the provided Map into a single String with specified delimiters and wrapping.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value", entries are separated by the specified entry delimiter,
     * and the entire result is wrapped with prefix and suffix strings.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is null, empty, or if fromIndex equals toIndex, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("x", 1);
     * map.put("y", 2);
     * map.put("z", 3);
     * 
     * joinEntries(map, 0, 2, ", ", "=", "[", "]");   // returns "[x=1, y=2]"
     * joinEntries(map, 1, 3, " AND ", " IS ", "WHERE ", ";"); // returns "WHERE y IS 2 AND z IS 3;"
     * joinEntries(map, 2, 2, ", ", "=", "{", "}");   // returns "{}"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The starting index (inclusive) of entries to include.
     * @param toIndex The ending index (exclusive) of entries to include.
     * @param entryDelimiter The delimiter string that separates each entry.
     * @param keyValueDelimiter The delimiter string that separates the key and value within each entry. It can be empty.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @return The concatenated string with prefix and suffix.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final String prefix, final String suffix) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, prefix, suffix, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with full control over formatting.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value", entries are separated by the specified entry delimiter,
     * and the entire result is wrapped with prefix and suffix strings.
     * The entryDelimiter and keyValueDelimiter can be empty for direct concatenation.
     * If trim is true, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is null, empty, or if fromIndex equals toIndex, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" id ", " 123 ");
     * map.put(" name ", " John ");
     * map.put(" role ", " Admin ");
     * 
     * joinEntries(map, 0, 2, ", ", ":", "{", "}", false); // returns "{ id : 123 ,  name : John }"
     * joinEntries(map, 0, 2, ", ", ":", "{", "}", true);  // returns "{id:123, name:John}"
     * joinEntries(map, 1, 3, " AND ", "=", "WHERE ", ";", true); // returns "WHERE name=John AND role=Admin;"
     * 
     * // Empty range example
     * joinEntries(map, 2, 2, ", ", "=", "[", "]", false); // returns "[]"
     * }</pre>
     *
     * @param m The Map containing the entries to join. It can be {@code null} or empty.
     * @param fromIndex The start index in the entry set from which to start joining entries. It should be non-negative and no larger than the size of the map.
     * @param toIndex The end index in the entry set up to which to join entries. It should be non-negative, no larger than the size of the map, and not less than fromIndex.
     * @param entryDelimiter The delimiter that separates each entry. It can be empty.
     * @param keyValueDelimiter The delimiter that separates the key and value within each entry. It can be empty.
     * @param prefix The prefix to be added at the beginning. It can be empty.
     * @param suffix The suffix to be added at the end. It can be empty.
     * @param trim If {@code true}, leading and trailing whitespace of each key and value will be removed.
     * @return The concatenated string with prefix and suffix, or just prefix+suffix if the range is empty.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final String prefix, final String suffix, final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.size(m));

        if (N.isEmpty(m) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final StringBuilder sb = Objectory.createStringBuilder(
                calculateBufferSize(toIndex - fromIndex, 32 + N.len(entryDelimiter) + N.len(keyValueDelimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            int i = 0;

            for (final Map.Entry<?, ?> entry : m.entrySet()) {
                if (i++ > fromIndex) {
                    sb.append(entryDelimiter);
                }

                if (i > fromIndex) {
                    if (trim) {
                        sb.append(N.toString(entry.getKey()).trim());
                        sb.append(keyValueDelimiter);
                        sb.append(N.toString(entry.getValue()).trim());
                    } else {
                        sb.append(N.toString(entry.getKey()));
                        sb.append(keyValueDelimiter);
                        sb.append(N.toString(entry.getValue()));
                    }
                }

                if (i >= toIndex) {
                    break;
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the entries of the provided Iterable into a single String using the specified delimiters.
     *
     * <p>This method is designed to handle collections of objects that can be transformed into key-value pairs.
     * Each element in the iterable is processed using the provided key and value extractor functions,
     * formatted as "key[keyValueDelimiter]value", and joined together with the entry delimiter.
     * The iteration order depends on the Iterable implementation.</p>
     *
     * <p>The method returns an empty string for null or empty iterables.</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<Person> people = Arrays.asList(
     *     new Person("John", 25),
     *     new Person("Jane", 30)
     * );
     * 
     * joinEntries(people, ", ", "=", 
     *     person -> person.getName(), 
     *     person -> person.getAge());                // returns "John=25, Jane=30"
     * 
     * joinEntries(people, " AND ", " IS ", 
     *     person -> person.getName(), 
     *     person -> person.getAge());                // returns "John IS 25 AND Jane IS 30"
     * 
     * List<Person> emptyList = new ArrayList<>();
     * joinEntries(emptyList, ", ", "=", 
     *     Person::getName, Person::getAge);          // returns ""
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable whose elements are to be joined. It can be {@code null} or empty.
     * @param entryDelimiter the delimiter to use between entries
     * @param keyValueDelimiter the delimiter to use between keys and values
     * @param keyExtractor function to extract keys from elements. Must not be {@code null}.
     * @param valueExtractor function to extract values from elements. Must not be {@code null}.
     * @return a string representation of the iterable's elements, or an empty string if the iterable is null or empty.
     * @throws IllegalArgumentException if keyExtractor or valueExtractor is null
     */
    public static <T> String joinEntries(final Iterable<? extends T> c, final String entryDelimiter, final String keyValueDelimiter,
            final Function<? super T, ?> keyExtractor, final Function<? super T, ?> valueExtractor) throws IllegalArgumentException {
        return joinEntries(c, entryDelimiter, keyValueDelimiter, EMPTY, EMPTY, false, keyExtractor, valueExtractor);
    }

    /**
     * Joins the entries of the provided Iterable into a single String with full control over formatting.
     *
     * <p>This method is designed to handle collections of objects that can be transformed into key-value pairs.
     * Each element in the iterable is processed using the provided key and value extractor functions,
     * formatted as "key[keyValueDelimiter]value", joined together with the entry delimiter,
     * and wrapped with prefix and suffix strings.
     * If trim is true, the string representations of extracted keys and values will be trimmed.
     * The iteration order depends on the Iterable implementation.</p>
     *
     * <p>If the iterable is null or empty, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p>Example:
     * <pre>{@code
     * List<Map.Entry<String, Integer>> entries = Arrays.asList(
     *     Map.entry(" name ", 1),
     *     Map.entry(" age ", 25)
     * );
     * 
     * joinEntries(entries, ", ", "=", "[", "]", false,
     *     Map.Entry::getKey, Map.Entry::getValue);   // returns "[ name =1,  age =25]"
     * 
     * joinEntries(entries, ", ", "=", "[", "]", true,
     *     Map.Entry::getKey, Map.Entry::getValue);   // returns "[name=1, age=25]"
     * 
     * List<Product> products = Arrays.asList(
     *     new Product("Apple", 1.99),
     *     new Product("Banana", 0.99)
     * );
     * 
     * joinEntries(products, " + ", " costs $", "Total: ", "", false,
     *     Product::getName, Product::getPrice);       // returns "Total: Apple costs $1.99 + Banana costs $0.99"
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable whose elements are to be joined. It can be {@code null} or empty.
     * @param entryDelimiter the delimiter to use between entries
     * @param keyValueDelimiter the delimiter to use between keys and values
     * @param prefix the string to place at the start of the result. It can be empty.
     * @param suffix the string to place at the end of the result. It can be empty.
     * @param trim If {@code true}, trims the string representations of extracted keys and values.
     * @param keyExtractor function to extract keys from elements. Must not be {@code null}.
     * @param valueExtractor function to extract values from elements. Must not be {@code null}.
     * @return a string representation of the iterable's elements with prefix and suffix, or just prefix+suffix if the iterable is null or empty.
     * @throws IllegalArgumentException if keyExtractor or valueExtractor is null
     * 
     * @see #join(Iterable)
     * @see #join(Iterable, String)
     * @see #joinEntries(Map, String, String)
     */
    public static <T> String joinEntries(final Iterable<? extends T> c, final String entryDelimiter, final String keyValueDelimiter, final String prefix,
            final String suffix, final boolean trim, final Function<? super T, ?> keyExtractor, final Function<? super T, ?> valueExtractor)
            throws IllegalArgumentException {
        N.checkArgNotNull(keyExtractor, cs.keyExtractor);
        N.checkArgNotNull(valueExtractor, cs.valueExtractor);

        if (N.isEmpty(c)) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(c instanceof Collection coll ? coll.size() : 16,
                32 + N.len(entryDelimiter) + N.len(keyValueDelimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            int i = 0;

            for (T e : c) {
                if (i++ > 0) {
                    sb.append(entryDelimiter);
                }

                if (trim) {
                    sb.append(N.toString(keyExtractor.apply(e)).trim());
                    sb.append(keyValueDelimiter);
                    sb.append(N.toString(valueExtractor.apply(e)).trim());
                } else {
                    sb.append(N.toString(keyExtractor.apply(e)));
                    sb.append(keyValueDelimiter);
                    sb.append(N.toString(valueExtractor.apply(e)));
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Concatenates two strings into a single string.
     *
     * <p>This method concatenates the two given strings efficiently. If either string is {@code null} or empty,
     * it is treated as an empty string before concatenation. The method optimizes for cases where one or both
     * strings are empty to avoid unnecessary string operations.</p>
     *
     * <p>The method returns an empty string if both input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", "World");          // returns "HelloWorld"
     * concat("Hello", null);             // returns "Hello"
     * concat(null, "World");             // returns "World"
     * concat("", "World");               // returns "World"
     * concat(null, null);                // returns ""
     * concat("", "");                    // returns ""
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if both inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b) {
        if (N.isEmpty(a)) {
            return N.isEmpty(b) ? Strings.EMPTY : b;
        } else {
            return N.isEmpty(b) ? a : a.concat(b);
        }
    }

    /**
     * Concatenates three strings into a single string.
     *
     * <p>This method concatenates the three given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", " ", "World");     // returns "Hello World"
     * concat("A", "B", "C");             // returns "ABC"
     * concat("Hello", null, "World");    // returns "HelloWorld"
     * concat(null, null, null);          // returns ""
     * concat("", "", "");                // returns ""
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c));
    }

    /**
     * Concatenates four strings into a single string.
     *
     * <p>This method concatenates the four given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", " ", "World", "!");        // returns "Hello World!"
     * concat("A", "B", "C", "D");                // returns "ABCD"
     * concat("Hello", null, "World", null);      // returns "HelloWorld"
     * concat(null, null, null, null);            // returns ""
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @param d The fourth string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d));
    }

    /**
     * Concatenates five strings into a single string.
     *
     * <p>This method concatenates the five given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", " ", "World", "!", "!");   // returns "Hello World!!"
     * concat("A", "B", "C", "D", "E");           // returns "ABCDE"
     * concat("1", null, "2", null, "3");         // returns "123"
     * concat(null, null, null, null, null);      // returns ""
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @param d The fourth string to concatenate. It can be {@code null} or empty.
     * @param e The fifth string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e));
    }

    /**
     * Concatenates six strings into a single string.
     *
     * <p>This method concatenates the six given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F");      // returns "ABCDEF"
     * concat("1", "2", "3", "4", "5", "6");      // returns "123456"
     * concat("H", "e", "l", "l", "o", "!");      // returns "Hello!"
     * concat(null, null, null, null, null, null); // returns ""
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @param d The fourth string to concatenate. It can be {@code null} or empty.
     * @param e The fifth string to concatenate. It can be {@code null} or empty.
     * @param f The sixth string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f));
    }

    /**
     * Concatenates seven strings into a single string.
     *
     * <p>This method concatenates the seven given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G"); // returns "ABCDEFG"
     * concat("1", "2", "3", "4", "5", "6", "7"); // returns "1234567"
     * concat("H", "e", "l", "l", "o", " ", "7"); // returns "Hello 7"
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @param d The fourth string to concatenate. It can be {@code null} or empty.
     * @param e The fifth string to concatenate. It can be {@code null} or empty.
     * @param f The sixth string to concatenate. It can be {@code null} or empty.
     * @param g The seventh string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g));
    }

    /**
     * Concatenates eight strings into a single string.
     *
     * <p>This method concatenates the eight given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G", "H"); // returns "ABCDEFGH"
     * concat("1", "2", "3", "4", "5", "6", "7", "8"); // returns "12345678"
     * concat("H", "e", "l", "l", "o", " ", "8", "!"); // returns "Hello 8!"
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null} or empty.
     * @param b The second string to concatenate. It can be {@code null} or empty.
     * @param c The third string to concatenate. It can be {@code null} or empty.
     * @param d The fourth string to concatenate. It can be {@code null} or empty.
     * @param e The fifth string to concatenate. It can be {@code null} or empty.
     * @param f The sixth string to concatenate. It can be {@code null} or empty.
     * @param g The seventh string to concatenate. It can be {@code null} or empty.
     * @param h The eighth string to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g,
            final String h) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g),
                nullToEmpty(h));
    }

    /**
     * Concatenates nine strings into a single string.
     *
     * <p>This method concatenates the nine given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G", "H", "I"); // returns "ABCDEFGHI"
     * concat("1", "2", "3", "4", "5", "6", "7", "8", "9"); // returns "123456789"
     * concat("H", "e", "l", "l", "o", " ", "9", "!", "!"); // returns "Hello 9!!"
     * }</pre>
     *
     * @param a The first string to concatenate. It can be {@code null}.
     * @param b The second string to concatenate. It can be {@code null}.
     * @param c The third string to concatenate. It can be {@code null}.
     * @param d The fourth string to concatenate. It can be {@code null}.
     * @param e The fifth string to concatenate. It can be {@code null}.
     * @param f The sixth string to concatenate. It can be {@code null}.
     * @param g The seventh string to concatenate. It can be {@code null}.
     * @param h The eighth string to concatenate. It can be {@code null}.
     * @param i The ninth string to concatenate. It can be {@code null}.
     * @return The concatenated string. Returns {@code ""} if all input strings are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g, final String h,
            final String i) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g),
                nullToEmpty(h), nullToEmpty(i));
    }

    /**
     * Concatenates the given array of strings into a single string.
     *
     * <p>This method concatenates all strings in the provided array in the order they appear.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * optimizes for different array lengths, using specialized implementations for arrays
     * with up to 7 elements for better performance.</p>
     *
     * <p>The method returns an empty string if the array is {@code null}, empty, or contains only {@code null} elements.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat(new String[]{"Hello", " ", "World"});      // returns "Hello World"
     * concat(new String[]{"A", "B", "C", "D"});         // returns "ABCD"
     * concat(new String[]{"Hello", null, "World"});     // returns "HelloWorld"
     * concat(new String[]{null, null});                 // returns ""
     * concat(new String[0]);                            // returns ""
     * concat((String[]) null);                          // returns ""
     * }</pre>
     *
     * @param a The array of strings to concatenate. It can be {@code null} or empty.
     * @return The concatenated string. Returns an empty string if the array is {@code null} or empty.
     */
    public static String concat(final String... a) {
        final int len = N.len(a);

        switch (len) {
            case 0:
                return EMPTY;

            case 1:
                return nullToEmpty(a[0]);

            case 2:
                return concat(a[0], a[1]);

            case 3:
                return concat(a[0], a[1], a[2]);

            case 4:
                return concat(a[0], a[1], a[2], a[3]);

            case 5:
                return concat(a[0], a[1], a[2], a[3], a[4]);

            case 6:
                return concat(a[0], a[1], a[2], a[3], a[4], a[5]);

            case 7:
                return concat(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);

            default: {
                final String[] b = N.copyThenReplaceAll(a, Fn.nullToEmpty());

                return String.join(Strings.EMPTY, b);
            }
        }
    }

    /**
     * Concatenates the string representations of two objects into a single string.
     *
     * <p>This method converts both objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if both objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", 123);              // returns "Hello123"
     * concat(42, " is the answer");      // returns "42 is the answer"
     * concat(null, "World");             // returns "World"
     * concat("Hello", null);             // returns "Hello"
     * concat(null, null);                // returns ""
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     */
    public static String concat(final Object a, final Object b) {
        return Strings.concat(N.toString(a), N.toString(b));
    }

    /**
     * Concatenates the string representations of three objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("Hello", " ", "World");     // returns "Hello World"
     * concat(1, 2, 3);                   // returns "123"
     * concat("Value: ", 42, "!");        // returns "Value: 42!"
     * concat(null, null, null);          // returns ""
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c));
    }

    /**
     * Concatenates the string representations of four objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D");                // returns "ABCD"
     * concat(1, "+", 2, "=3");                   // returns "1+2=3"
     * concat("Result: ", 10, " out of ", 20);   // returns "Result: 10 out of 20"
     * concat(null, null, null, null);            // returns ""
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d));
    }

    /**
     * Concatenates the string representations of five objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E");           // returns "ABCDE"
     * concat(1, " ", 2, " ", 3);                 // returns "1 2 3"
     * concat("Sum of ", 1, "+", 2, "=3");        // returns "Sum of 1+2=3"
     * concat(null, null, null, null, null);      // returns ""
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @param e The fifth object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e));
    }

    /**
     * Concatenates the string representations of six objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F");      // returns "ABCDEF"
     * concat(1, 2, 3, 4, 5, 6);                  // returns "123456"
     * concat("H", "e", "l", "l", "o", "!");      // returns "Hello!"
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @param e The fifth object to concatenate. It can be {@code null}.
     * @param f The sixth object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f));
    }

    /**
     * Concatenates the string representations of seven objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G"); // returns "ABCDEFG"
     * concat(1, 2, 3, 4, 5, 6, 7);               // returns "1234567"
     * concat("H", "e", "l", "l", "o", " ", 7);   // returns "Hello 7"
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @param e The fifth object to concatenate. It can be {@code null}.
     * @param f The sixth object to concatenate. It can be {@code null}.
     * @param g The seventh object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g));
    }

    /**
     * Concatenates the string representations of eight objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G", "H"); // returns "ABCDEFGH"
     * concat(1, 2, 3, 4, 5, 6, 7, 8);                 // returns "12345678"
     * concat("H", "e", "l", "l", "o", " ", 8, "!");   // returns "Hello 8!"
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @param e The fifth object to concatenate. It can be {@code null}.
     * @param f The sixth object to concatenate. It can be {@code null}.
     * @param g The seventh object to concatenate. It can be {@code null}.
     * @param h The eighth object to concatenate. It can be {@code null}.
     * @return The concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g,
            final Object h) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g), N.toString(h));
    }

    /**
     * Concatenates the string representations of nine objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * concat("A", "B", "C", "D", "E", "F", "G", "H", "I"); // returns "ABCDEFGHI"
     * concat(1, 2, 3, 4, 5, 6, 7, 8, 9);                   // returns "123456789"
     * concat("H", "e", "l", "l", "o", " ", 9, "!", "!");   // returns "Hello 9!!"
     * }</pre>
     *
     * @param a The first object to concatenate. It can be {@code null}.
     * @param b The second object to concatenate. It can be {@code null}.
     * @param c The third object to concatenate. It can be {@code null}.
     * @param d The fourth object to concatenate. It can be {@code null}.
     * @param e The fifth object to concatenate. It can be {@code null}.
     * @param f The sixth object to concatenate. It can be {@code null}.
     * @param g The seventh object to concatenate. It can be {@code null}.
     * @param h The eighth object to concatenate. It can be {@code null}.
     * @param i The ninth object to concatenate. It can be {@code null}.
     * @return The concatenated string. Returns {@code ""} if all input objects are {@code null} or empty.
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g, final Object h,
            final Object i) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g), N.toString(h),
                N.toString(i));
    }

    //    /**
    //     *
    //     * @param a
    //     * @return
    //     * @see #concat(Object, Object)
    //     * @deprecated
    //     */
    //    @Deprecated
    //    @SafeVarargs
    //    public static String concat(final Object... a) {
    //        if (N.isEmpty(a)) {
    //            return EMPTY_STRING;
    //        } else if (a.getClass().equals(String[].class)) {
    //            return Strings.concat((String[]) a);
    //        }
    //
    //        final StringBuilder sb = ObjectFactory.createStringBuilder();
    //
    //        try {
    //            for (Object e : a) {
    //                sb.append(N.toString(e));
    //            }
    //            return sb.toString();
    //        } finally {
    //            ObjectFactory.recycle(sb);
    //        }
    //    }
    //
    //    /**
    //     *
    //     * @param c
    //     * @return
    //     * @deprecated
    //     */
    //    @Deprecated
    //    public static String concat(final Collection<?> c) {
    //        if (N.isEmpty(c)) {
    //            return EMPTY_STRING;
    //        }
    //
    //        final StringBuilder sb = ObjectFactory.createStringBuilder();
    //
    //        try {
    //            for (Object e : c) {
    //                sb.append(N.toString(e));
    //            }
    //            return sb.toString();
    //        } finally {
    //            ObjectFactory.recycle(sb);
    //        }
    //    }

    private static String toString(final Object e, final boolean trim) {
        if (e == null) {
            return NULL;
        }

        if (trim) {
            return N.toString(e).trim();
        } else {
            return N.toString(e);
        }
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * Returns a formatted string using the specified template string and arguments (Copied from Google Guava).
     *
     * <p>This method replaces each occurrence of {@code "%s"} in the template with the corresponding argument value.
     * If there are more placeholders than arguments, the extra placeholders remain unchanged. If there are more
     * arguments than placeholders, the extra arguments are appended to the end in square brackets.</p>
     *
     * <p>This method is designed for lenient formatting, particularly useful for debugging and logging where
     * exception handling during formatting would be counterproductive. Unlike {@code String.format}, this method
     * will not throw exceptions for mismatched arguments.</p>
     *
     * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
     * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
     * full range of <a
     * href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax">format
     * specifiers</a>, and alert you to usage errors by throwing {@link
     * java.util.IllegalFormatException}.</p>
     *
     * <p>In certain cases, such as outputting debugging information or constructing a message to be
     * used for another unchecked exception, an exception during string formatting would serve little
     * purpose except to supplant the real information you were trying to provide. These are the cases
     * this method is made for; it instead generates a best-effort string with all supplied argument
     * values present. This method is also useful in environments such as GWT where {@code
     * String.format} is not available. As an example, method implementations of the {@code Preconditions} class use this formatter, for both of the reasons just discussed.</p>
     *
     * <p><b>Warning:</b> Only the exact two-character placeholder sequence {@code "%s"} is
     * recognized.</p>
     *
     * <p>Example:
     * <pre>{@code
     * lenientFormat("Hello %s", "World");              // returns "Hello World"
     * lenientFormat("Hello %s %s", "New", "World");    // returns "Hello New World"
     * lenientFormat("Hello %s", "World", "Extra");     // returns "Hello World: [Extra]"
     * lenientFormat("Hello %s %s", "World");           // returns "Hello World %s"
     * lenientFormat("Hello", "World");                 // returns "Hello: [World]"
     * lenientFormat(null, "arg1", "arg2");             // returns "null: [arg1, arg2]"
     * }</pre>
     *
     * @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code
     *     null} is treated as the four-character string {@code "null"}.
     * @param args the arguments to be substituted into the message template. The first argument
     *     specified is substituted for the first occurrence of {@code "%s"} in the template, and so
     *     forth. A {@code null} argument is converted to the four-character string {@code "null"};
     *     {@code non-null} values are converted to strings using {@link Object#toString()}.
     * @return The formatted string with placeholders replaced by arguments.
     */
    // TODO(diamondm) consider using Arrays.toString() for array parameters
    public static String lenientFormat(String template, Object... args) {
        template = String.valueOf(template); // null -> "null"

        if (args == null) {
            args = new Object[] { "(Object[])null" };
        } else {
            for (int i = 0; i < args.length; i++) {
                args[i] = lenientToString(args[i]);
            }
        }

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + 16 * args.length);
        int templateStart = 0;
        int i = 0;
        while (i < args.length) {
            final int placeholderStart = template.indexOf("%s", templateStart);
            if (placeholderStart == -1) {
                break;
            }
            sb.append(template, templateStart, placeholderStart);
            sb.append(args[i++]);
            templateStart = placeholderStart + 2;
        }
        sb.append(template, templateStart, template.length());

        // if we run out of placeholders, append the extra args in square braces
        if (i < args.length) {
            sb.append(": [");
            sb.append(args[i++]);
            while (i < args.length) {
                sb.append(", ");
                sb.append(args[i++]);
            }
            sb.append(']');
        }

        final String result = sb.toString();
        Objectory.recycle(sb);
        return result;
    }

    /**
     * Lenient to string.
     *
     * @param obj
     * @return
     */
    private static String lenientToString(final Object obj) {
        try {
            return String.valueOf(obj);
        } catch (final Exception e) {
            // Default toString() behavior - see Object.toString()
            final String objectToString = obj.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(obj));
            // Logger is created inline with fixed name to avoid forcing Proguard to create another class.
            // Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);

            LOGGER.warn("Exception during lenientFormat for " + objectToString, e); //NOSONAR

            return "<" + objectToString + " threw " + e.getClass().getName() + ">";
        }
    }

    /**
     * Reverses the characters in the given string.
     *
     * <p>This method creates a new string with all characters in reverse order. It uses
     * {@code StringBuilder.reverse()} internally for efficient reversal. If the input string
     * is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p>The method properly handles Unicode characters and maintains character pairs.</p>
     *
     * <p>Example:
     * <pre>{@code
     * reverse("Hello");                  // returns "olleH"
     * reverse("12345");                  // returns "54321"
     * reverse("A");                      // returns "A"
     * reverse("");                       // returns ""
     * reverse(null);                     // returns null
     * }</pre>
     *
     * @param str The string to be reversed. May be {@code null} or empty.
     * @return A new string with the characters reversed. If the input string is {@code null} or empty or its length <= 1, the input string is returned.
     */
    public static String reverse(final String str) {
        if (N.len(str) <= 1) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length());

        try {
            sb.append(str);

            return sb.reverse().toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Reverses a string that is delimited by a specific character.
     *
     * <p>This method splits the string by the specified delimiter character, reverses the order
     * of the resulting segments, and then joins them back together using the same delimiter.
     * The individual segments themselves are not reversed - only their order is changed.</p>
     *
     * <p>If the delimiter is not found in the string, the original string is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * reverseDelimited(null, '*');       // returns null
     * reverseDelimited("", '*');         // returns ""
     * reverseDelimited("a.b.c", 'x');    // returns "a.b.c"
     * reverseDelimited("a.b.c", '.');    // returns "c.b.a"
     * reverseDelimited("java.lang.String", '.'); // returns "String.lang.java"
     * }</pre>
     *
     * @param str The string to reverse, which may be {@code null}.
     * @param delimiter The delimiter character to use for splitting and joining.
     * @return The string with its delimited segments reversed. If the input string is {@code null} or empty or its length <= 1, the input string is returned.
     */
    public static String reverseDelimited(final String str, final char delimiter) {
        if (N.len(str) <= 1) {
            return str;
        }

        // could implement manually, but simple way is to reuse other,
        // probably slower, methods.
        final String[] strs = split(str, delimiter);

        N.reverse(strs);

        return join(strs, String.valueOf(delimiter));
    }

    /**
     * Reverses the order of delimited elements in a string.
     *
     * <p>This method splits the string by the specified delimiter string, reverses the order
     * of the resulting segments, and then joins them back together using the same delimiter.
     * The individual segments themselves are not reversed - only their order is changed.</p>
     *
     * <p>If the delimiter is not found in the string, the original string is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * reverseDelimited(null, " ");                // returns null
     * reverseDelimited("", " ");                  // returns ""
     * reverseDelimited("Hello World", "xyz");     // returns "Hello World"
     * reverseDelimited("Hello World Java", " ");  // returns "Java World Hello"
     * reverseDelimited("A::B::C", "::");         // returns "C::B::A"
     * }</pre>
     *
     * @param str The string to be reversed. May be {@code null} or empty.
     * @param delimiter The delimiter that separates the elements in the string.
     * @return The reversed string. If the input string is {@code null} or empty or its length <= 1, the input string is returned.
     */
    public static String reverseDelimited(final String str, final String delimiter) {
        if (N.len(str) <= 1) {
            return str;
        }

        // could implement manually, but simple way is to reuse other,
        // probably slower, methods.
        final String[] strs = split(str, delimiter);

        N.reverse(strs);

        return join(strs, delimiter);
    }

    /**
     * Sorts the characters in the given string in ascending order.
     *
     * <p>This method creates a new string with all characters sorted according to their natural
     * ordering (Unicode values). The sorting is performed by converting the string to a character
     * array, sorting the array, and then creating a new string from the sorted array.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * sort("dcba");                      // returns "abcd"
     * sort("54321");                     // returns "12345"
     * sort("Hello");                     // returns "Helo" (duplicate 'l' preserved)
     * sort("a");                         // returns "a"
     * sort("");                          // returns ""
     * sort(null);                        // returns null
     * }</pre>
     *
     * @param str The string whose characters are to be sorted. May be {@code null} or empty.
     * @return A new sorted string if the specified {@code str} is not {@code null} or empty, otherwise the specified {@code str} is returned. If the input string is {@code null} or empty or its length <= 1, the input string is returned.
     */
    public static String sort(final String str) {
        if (N.len(str) <= 1) {
            return str;
        }

        final char[] chs = str.toCharArray();
        N.sort(chs);
        return String.valueOf(chs);
    }

    // Rotating (circular shift)
    //-----------------------------------------------------------------------

    /**
     * Rotates (circular shift) a string by the specified number of positions.
     *
     * <p>This method performs a circular shift on the string characters. A positive shift value
     * rotates the string to the right (characters from the end move to the beginning), while
     * a negative shift value rotates to the left (characters from the beginning move to the end).</p>
     *
     * <p>The shift value is normalized using modulo operation, so shifts larger than the string
     * length will wrap around appropriately.</p>
     *
     * <p>Example:
     * <pre>{@code
     * rotate(null, *);        // returns null
     * rotate("", *);          // returns ""
     * rotate("abcdefg", 0);   // returns "abcdefg"
     * rotate("abcdefg", 2);   // returns "fgabcde"
     * rotate("abcdefg", -2);  // returns "cdefgab"
     * rotate("abcdefg", 7);   // returns "abcdefg"
     * rotate("abcdefg", -7);  // returns "abcdefg"
     * rotate("abcdefg", 9);   // returns "fgabcde"
     * rotate("abcdefg", -9);  // returns "cdefgab"
     * }</pre>
     *
     * @param str the String to rotate, which may be null
     * @param shift number of time to shift (positive : right shift, negative : left shift)
     * @return the rotated String,
     *          or the original String if {@code shift == 0},
     *          or {@code null} if {@code null} String input
     */
    public static String rotate(final String str, final int shift) {
        final int strLen = N.len(str);

        if (strLen <= 1 || shift == 0 || shift % strLen == 0) {
            return str;
        }

        int offset = -(shift % strLen);

        if (offset < 0) {
            offset = str.length() + offset;
        }

        if (offset < 0) {
            offset = 0;
        }

        return substring(str, offset) + Strings.substring(str, 0, offset);
    }

    /**
     * Shuffles the characters in the given string using a default random number generator.
     *
     * <p>This method randomly rearranges the characters in the string using the Fisher-Yates
     * shuffle algorithm. Each possible permutation of the characters has equal probability
     * of being produced. The shuffling uses the default {@code Random} instance.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * shuffle("Hello");                  // might return "leHol", "olleH", etc.
     * shuffle("12345");                  // might return "31524", "45213", etc.
     * shuffle("a");                      // returns "a"
     * shuffle("");                       // returns ""
     * shuffle(null);                     // returns null
     * }</pre>
     *
     * @param str The string to be shuffled. May be {@code null} or empty.
     * @return A new string with the characters shuffled. If the input string is {@code null} or empty, the input string is returned.
     */
    public static String shuffle(final String str) {
        return shuffle(str, N.RAND);
    }

    /**
     * Shuffles the characters in the given string using the provided Random instance.
     *
     * <p>This method randomly rearranges the characters in the string using the Fisher-Yates
     * shuffle algorithm with the specified Random instance. This allows for reproducible
     * shuffling when using a Random instance with a fixed seed.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p>Example:
     * <pre>{@code
     * Random rnd = new Random(42);
     * shuffle("Hello", rnd);             // returns a deterministic shuffle
     * shuffle("12345", rnd);             // returns another deterministic shuffle
     * shuffle("a", rnd);                 // returns "a"
     * shuffle("", rnd);                  // returns ""
     * shuffle(null, rnd);                // returns null
     * }</pre>
     *
     * @param str The string to be shuffled. May be {@code null} or empty.
     * @param rnd The Random instance used to shuffle the characters.
     * @return A new string with the characters shuffled. If the input string is {@code null} or empty, the input string is returned.
     */
    public static String shuffle(final String str, final Random rnd) {
        final int strLen = N.len(str);

        if (strLen <= 1) {
            return str;
        }

        final char[] chars = str.toCharArray();

        N.shuffle(chars, rnd);

        return String.valueOf(chars);
    }

    // Overlay
    //-----------------------------------------------------------------------

    /**
     * Overlays part of a String with another String.
     *
     * <p>This method replaces a portion of the original string (from {@code start} to {@code end - 1})
     * with the overlay string. The characters before {@code start} and from {@code end} onwards
     * remain unchanged. This is functionally equivalent to {@code replace(str, start, end, overlay)}.</p>
     *
     * <p>If the overlay string is {@code null} or empty, the specified portion is simply removed.</p>
     *
     * <p>Example:
     * <pre>{@code
     * overlay(null, "abc", 0, 0);          // returns "abc"
     * overlay("", "abc", 0, 0);            // returns "abc"
     * overlay("abcdef", null, 2, 4);      // returns "abef"
     * overlay("abcdef", "", 2, 4);        // returns "abef"
     * overlay("abcdef", "zzzz", 2, 4);    // returns "abzzzzef"
     * }</pre>
     *
     * @param str the String to do overlaying in, which may be null
     * @param overlay the String to overlay, which may be null
     * @param start the position to start overlaying at
     * @param end the position to stop overlaying before
     * @return overlayed String, or {@code overlay} if {@code null} String input
     * @throws IndexOutOfBoundsException if start or end is negative, or end is greater than the length of str
     * @deprecated replaced by {@code replace(String, int, int, String)}
     * @see #replace(String, int, int, String)
     * @see N#replaceRange(String, int, int, String)
     */
    @Deprecated
    public static String overlay(final String str, final String overlay, final int start, final int end) throws IndexOutOfBoundsException {
        return replace(str, start, end, overlay);
    }

    /**
     * Parses the string argument as a boolean.
     *
     * <p>This method returns {@code true} if and only if the string is not {@code null},
     * not empty, and is equal, ignoring case, to the string "true". This differs from
     * {@code Boolean.parseBoolean} which returns {@code false} for empty strings.</p>
     *
     * <p>The method provides a more strict parsing than {@code Boolean.parseBoolean}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * parseBoolean("true");              // returns true
     * parseBoolean("True");              // returns true
     * parseBoolean("TRUE");              // returns true
     * parseBoolean("false");             // returns false
     * parseBoolean("yes");               // returns false
     * parseBoolean("");                  // returns false
     * parseBoolean(null);                // returns false
     * }</pre>
     *
     * @param str The string to be parsed. May be {@code null}.
     * @return The boolean represented by the string argument.
     * @see Boolean#parseBoolean(String)
     */
    public static boolean parseBoolean(final String str) {
        return !Strings.isEmpty(str) && Boolean.parseBoolean(str);
    }

    /**
     * Parses the string argument as a char.
     *
     * <p>This method handles three cases:
     * <ul>
     *   <li>If the string is {@code null} or empty, returns {@code '\0'} (the null character)</li>
     *   <li>If the string has exactly one character, returns that character</li>
     *   <li>Otherwise, parses the string as an integer and casts it to char</li>
     * </ul>
     * </p>
     *
     * <p>This allows for both direct character representation and numeric character codes.</p>
     *
     * <p>Example:
     * <pre>{@code
     * parseChar("A");                    // returns 'A'
     * parseChar("65");                   // returns 'A' (ASCII code 65)
     * parseChar("$");                    // returns '$'
     * parseChar("36");                   // returns '$' (ASCII code 36)
     * parseChar("");                     // returns '\0'
     * parseChar(null);                   // returns '\0'
     * }</pre>
     *
     * @param str The string to be parsed. May be {@code null}.
     * @return The char represented by the string argument.
     * @throws NumberFormatException if the string has more than one character and cannot be parsed as an integer
     */
    public static char parseChar(final String str) {
        if (Strings.isEmpty(str)) {
            return CHAR_ZERO;
        } else if (str.length() == 1) {
            return str.charAt(0);
        } else {
            int intValue = Integer.parseInt(str);
            if (intValue < Character.MIN_VALUE || intValue > Character.MAX_VALUE) {
                throw new IllegalArgumentException("Integer value out of char range: " + intValue);
            }
            return (char) intValue;
        }
    }

    /**
     * Returns the value by calling {@code Byte.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code byte} is
     * returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code byte}.
     * @see Numbers#toByte(String)
     * @deprecated replaced by {@code Numbers.toByte(String)}
     */
    @Deprecated
    public static byte parseByte(final String str) throws NumberFormatException {
        return Numbers.toByte(str);
    }

    /**
     * Returns the value by calling {@code Short.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code short} is
     * returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code short}.
     * @see Numbers#toShort(String)
     * @deprecated replaced by {@code Numbers.toShort(String)}
     */
    @Deprecated
    public static short parseShort(final String str) throws NumberFormatException {
        return Numbers.toShort(str);
    }

    /**
     * Returns the value by calling {@code Integer.valueOf(String)} if
     * {@code str} is not {@code null}, otherwise, the default value 0 for
     * {@code int} is returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code int}.
     * @see Numbers#toInt(String)
     * @deprecated replaced by {@code Numbers.toInt(String)}
     */
    @Deprecated
    public static int parseInt(final String str) throws NumberFormatException {
        return Numbers.toInt(str);
    }

    /**
     * Returns the value by calling {@code Long.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code long} is
     * returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code long}.
     * @see Numbers#toLong(String)
     * @deprecated replaced by {@code Numbers.toLong(String)}
     */
    @Deprecated
    public static long parseLong(final String str) throws NumberFormatException {
        return Numbers.toLong(str);
    }

    /**
     * Returns the value by calling {@code Float.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0f for {@code float} is
     * returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code float}.
     * @see Numbers#toFloat(String)
     * @deprecated replaced by {@code Numbers.toFloat(String)}
     */
    @Deprecated
    public static float parseFloat(final String str) throws NumberFormatException {
        return Numbers.toFloat(str);
    }

    /**
     * Returns the value by calling {@code Double.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0d for {@code double} is
     * returned.
     *
     * @param str
     * @return
     * @throws NumberFormatException If the string is not a parsable {@code double}.
     * @see Numbers#toDouble(String)
     * @deprecated replaced by {@code Numbers.toDouble(String)}
     */
    @Deprecated
    public static double parseDouble(final String str) throws NumberFormatException {
        return Numbers.toDouble(str);
    }

    /**
     * Encodes the given binary data into a Base64 encoded string.
     *
     * <p>This method converts a byte array to its Base64 string representation using standard
     * Base64 encoding. The encoding uses the standard Base64 alphabet as specified in RFC 4648.</p>
     *
     * <p>If the input byte array is {@code null} or empty, an empty string is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * base64Encode("Hello".getBytes());  // returns "SGVsbG8="
     * base64Encode(new byte[]{1,2,3});   // returns "AQID"
     * base64Encode(new byte[0]);         // returns ""
     * base64Encode(null);                // returns ""
     * }</pre>
     *
     * @param binaryData The byte array to be encoded.
     * @return The Base64 encoded string, or an empty String {@code ""} if the input byte array is {@code null} or empty.
     */
    public static String base64Encode(final byte[] binaryData) {
        if (N.isEmpty(binaryData)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(binaryData);
    }

    /**
     * Encodes the given string into a Base64 encoded string using the platform's default charset.
     *
     * <p>This method converts a string to its Base64 representation by first converting the string
     * to bytes using the platform's default charset, then encoding those bytes using standard
     * Base64 encoding.</p>
     *
     * <p>If the input string is {@code null} or empty, an empty string is returned.</p>
     *
     * <p>Example:
     * <pre>{@code
     * base64EncodeString("Hello");       // returns "SGVsbG8="
     * base64EncodeString("Hello World"); // returns "SGVsbG8gV29ybGQ="
     * base64EncodeString("");            // returns ""
     * base64EncodeString(null);          // returns ""
     * }</pre>
     *
     * @param str The string to be encoded.
     * @return The Base64 encoded string, or an empty String {@code ""} if the input string is {@code null} or empty
     */
    public static String base64EncodeString(final String str) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(str.getBytes()); // NOSONAR
    }

    /**
     * Encodes the given string into a Base64 encoded string using UTF-8 encoding.
     *
     * <p>This method converts the input string to bytes using UTF-8 encoding and then encodes
     * these bytes to Base64 format. Base64 encoding is commonly used to encode binary data
     * as ASCII text, making it suitable for transmission over text-based protocols.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Basic encoding
     * base64EncodeUtf8String("Hello World");         // returns "SGVsbG8gV29ybGQ="
     * base64EncodeUtf8String("test@123");            // returns "dGVzdEAxMjM="
     * base64EncodeUtf8String("UTF-8 chars: ");     // returns "VVRGLTggY2hhcnM6IMOx"
     * 
     * // Edge cases
     * base64EncodeUtf8String(null);                  // returns ""
     * base64EncodeUtf8String("");                    // returns ""
     * }</pre>
     *
     * @param str The string to be encoded.
     * @return The Base64 encoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     * @see #base64EncodeString(String, Charset)
     */
    public static String base64EncodeUtf8String(final String str) {
        return base64EncodeString(str, Charsets.UTF_8);
    }

    /**
     * Encodes the given string to a Base64 encoded string using the specified charset.
     *
     * <p>This method converts the input string to bytes using the specified charset and then encodes
     * these bytes to Base64 format. The charset parameter allows encoding strings that contain
     * characters from different character sets.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Different charset encodings
     * base64EncodeString("Hello", StandardCharsets.UTF_8);      // returns "SGVsbG8="
     * base64EncodeString("Hello", StandardCharsets.US_ASCII);   // returns "SGVsbG8="
     * base64EncodeString("Test123", StandardCharsets.UTF_16);   // returns different encoding
     * 
     * // Edge cases
     * base64EncodeString(null, StandardCharsets.UTF_8);         // returns ""
     * base64EncodeString("", StandardCharsets.UTF_8);           // returns ""
     * }</pre>
     *
     * @param str The string to be encoded.
     * @param charset The charset to be used to encode the input string.
     * @return The Base64 encoded string.
     * @see String#getBytes(Charset)
     */
    public static String base64EncodeString(final String str, final Charset charset) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(str.getBytes(charset)); // NOSONAR
    }

    /**
     * Decodes the given Base64 encoded string to a byte array.
     *
     * <p>This method takes a Base64 encoded string and converts it back to its original byte array
     * representation. Base64 decoding is the reverse process of Base64 encoding.</p>
     *
     * <p>The method returns an empty byte array if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Basic decoding
     * base64Decode("SGVsbG8gV29ybGQ=");             // returns byte array for "Hello World"
     * base64Decode("dGVzdEAxMjM=");                  // returns byte array for "test@123"
     * 
     * // Edge cases
     * base64Decode(null);                            // returns empty byte array
     * base64Decode("");                              // returns empty byte array
     * }</pre>
     *
     * @param base64String The Base64 encoded string to be decoded.
     * @return The decoded byte array, or an empty byte array if the input string is {@code null} or empty.
     */
    public static byte[] base64Decode(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        return BASE64_DECODER.decode(base64String);
    }

    /**
     * Decodes the given Base64 encoded string to its original string representation.
     *
     * <p>This method decodes a Base64 encoded string back to its original string form using
     * the platform's default charset. It combines Base64 decoding with string construction
     * from the resulting byte array.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Basic decoding to string
     * base64DecodeToString("SGVsbG8gV29ybGQ=");     // returns "Hello World"
     * base64DecodeToString("dGVzdEAxMjM=");          // returns "test@123"
     * 
     * // Edge cases
     * base64DecodeToString(null);                    // returns ""
     * base64DecodeToString("");                      // returns ""
     * }</pre>
     *
     * @param base64String The Base64 encoded string to be decoded.
     * @return The decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64DecodeToString(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(base64Decode(base64String)); // NOSONAR
    }

    /**
     * Decodes the given Base64 URL encoded string to a UTF-8 string.
     *
     * <p>This method specifically decodes Base64 encoded strings to UTF-8 format, ensuring proper
     * handling of Unicode characters. UTF-8 is the most common encoding for international text.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // UTF-8 specific decoding
     * base64DecodeToUtf8String("SGVsbG8gV29ybGQ=");         // returns "Hello World"
     * base64DecodeToUtf8String("VVRGLTggY2hhcnM6IMOx");     // returns "UTF-8 chars: "
     * 
     * // Edge cases
     * base64DecodeToUtf8String(null);                        // returns ""
     * base64DecodeToUtf8String("");                          // returns ""
     * }</pre>
     *
     * @param base64String The Base64 URL encoded string to be decoded.
     * @return The decoded UTF-8 string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64DecodeToUtf8String(final String base64String) {
        return base64DecodeToString(base64String, Charsets.UTF_8);
    }

    /**
     * Decodes the given Base64 encoded string to a string using the specified charset.
     *
     * <p>This method allows decoding Base64 encoded strings with a specific charset, providing
     * flexibility for handling strings encoded with different character sets. The charset parameter
     * determines how the decoded bytes are interpreted as characters.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Different charset decoding
     * base64DecodeToString("SGVsbG8=", StandardCharsets.UTF_8);      // returns "Hello"
     * base64DecodeToString("SGVsbG8=", StandardCharsets.US_ASCII);   // returns "Hello"
     * base64DecodeToString("base64String", StandardCharsets.UTF_16); // charset-specific decoding
     * 
     * // Edge cases
     * base64DecodeToString(null, StandardCharsets.UTF_8);            // returns ""
     * base64DecodeToString("", StandardCharsets.UTF_8);              // returns ""
     * }</pre>
     *
     * @param base64String The Base64 encoded string to be decoded.
     * @param charset The charset to be used to decode the resulting byte array.
     * @return The decoded string.
     * @see String#String(byte[], Charset)
     */
    public static String base64DecodeToString(final String base64String, final Charset charset) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(base64Decode(base64String), charset); // NOSONAR
    }

    /**
     * Encodes the given byte array to a Base64 URL encoded string.
     *
     * <p>Base64 URL encoding is a variant of Base64 encoding that uses URL-safe characters.
     * It replaces '+' with '-' and '/' with '_', and typically omits padding characters '='.
     * This makes it suitable for use in URLs and filenames.</p>
     *
     * <p>The method returns an empty string if the input byte array is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // URL-safe encoding
     * base64UrlEncode("Hello World".getBytes());     // returns URL-safe Base64 string
     * base64UrlEncode("test/data+123".getBytes());   // returns string with - and _ instead of / and +
     * 
     * // Edge cases
     * base64UrlEncode(null);                         // returns ""
     * base64UrlEncode(new byte[0]);                  // returns ""
     * }</pre>
     *
     * @param binaryData The byte array to be encoded.
     * @return The Base64 URL encoded string, or an empty String {@code ""} if the input byte array is {@code null} or empty.
     */
    public static String base64UrlEncode(final byte[] binaryData) {
        if (N.isEmpty(binaryData)) {
            return Strings.EMPTY;
        }

        return BASE64_URL_ENCODER.encodeToString(binaryData);
    }

    /**
     * Decodes the given Base64 URL encoded string to a byte array.
     *
     * <p>This method decodes URL-safe Base64 encoded strings back to their original byte array
     * representation. It handles the URL-safe variants where '+' is replaced with '-' and '/'
     * is replaced with '_'.</p>
     *
     * <p>The method returns an empty byte array if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // URL-safe decoding
     * base64UrlDecode("SGVsbG8gV29ybGQ");            // returns byte array for "Hello World"
     * base64UrlDecode("dGVzdC1kYXRhXzEyMw");         // handles URL-safe characters
     * 
     * // Edge cases
     * base64UrlDecode(null);                         // returns empty byte array
     * base64UrlDecode("");                           // returns empty byte array
     * }</pre>
     *
     * @param base64String The Base64 URL encoded string to be decoded.
     * @return The decoded byte array, an empty byte array if the input string is {@code null} or empty.
     */
    public static byte[] base64UrlDecode(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        return BASE64_URL_DECODER.decode(base64String);
    }

    /**
     * Decodes the given Base64 URL encoded string to a regular string.
     *
     * <p>This method combines Base64 URL decoding with string construction, converting a URL-safe
     * Base64 encoded string directly to its original string representation using the platform's
     * default charset.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // URL-safe decoding to string
     * base64UrlDecodeToString("SGVsbG8gV29ybGQ");    // returns "Hello World"
     * base64UrlDecodeToString("dGVzdEAxMjM");         // returns "test@123"
     * 
     * // Edge cases
     * base64UrlDecodeToString(null);                 // returns ""
     * base64UrlDecodeToString("");                   // returns ""
     * }</pre>
     *
     * @param base64String The Base64 URL encoded string to be decoded.
     * @return The decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64UrlDecodeToString(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(BASE64_URL_DECODER.decode(base64String)); // NOSONAR
    }

    /**
     * Decodes the given Base64 URL encoded string to a UTF-8 string.
     *
     * <p>This method specifically decodes URL-safe Base64 encoded strings to UTF-8 format,
     * combining the URL-safe decoding with UTF-8 charset interpretation. This is useful
     * for handling international text that was Base64 URL encoded.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // URL-safe UTF-8 decoding
     * base64UrlDecodeToUtf8String("SGVsbG8gV29ybGQ");       // returns "Hello World"
     * base64UrlDecodeToUtf8String("VVRGLTggY2hhcnM6IMOx");  // returns "UTF-8 chars: "
     * 
     * // Edge cases
     * base64UrlDecodeToUtf8String(null);                     // returns ""
     * base64UrlDecodeToUtf8String("");                       // returns ""
     * }</pre>
     *
     * @param base64String The Base64 URL encoded string to be decoded.
     * @return The decoded UTF-8 string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64UrlDecodeToUtf8String(final String base64String) {
        return base64UrlDecodeToString(base64String, Charsets.UTF_8);
    }

    /**
     * Decodes the given Base64 URL encoded string to a string using the specified charset.
     *
     * <p>This method provides full control over the decoding process, allowing specification
     * of both URL-safe Base64 decoding and the charset to be used for interpreting the
     * resulting bytes. This is the most flexible decoding method for Base64 URL encoded data.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Different charset URL-safe decoding
     * base64UrlDecodeToString("SGVsbG8", StandardCharsets.UTF_8);      // returns "Hello"
     * base64UrlDecodeToString("SGVsbG8", StandardCharsets.US_ASCII);   // returns "Hello"
     * base64UrlDecodeToString("base64Url", StandardCharsets.UTF_16);   // charset-specific decoding
     * 
     * // Edge cases
     * base64UrlDecodeToString(null, StandardCharsets.UTF_8);           // returns ""
     * base64UrlDecodeToString("", StandardCharsets.UTF_8);             // returns ""
     * }</pre>
     *
     * @param base64String The Base64 URL encoded string to be decoded.
     * @param charset The charset to be used to decode the based decoded {@code bytes}
     * @return The decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64UrlDecodeToString(final String base64String, final Charset charset) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(BASE64_URL_DECODER.decode(base64String), charset);
    }

    /**
     * Encodes the given parameters into a URL-encoded string.
     *
     * <p>This method converts an object (typically a Map or JavaBean) into a URL-encoded string
     * suitable for use in HTTP requests. The encoding follows the application/x-www-form-urlencoded
     * format where key-value pairs are separated by '&' and spaces are encoded as '+'.</p>
     *
     * <p>The method handles various object types including Maps, JavaBeans, and collections.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Encoding a Map
     * Map<String, String> params = new HashMap<>();
     * params.put("name", "John Doe");
     * params.put("age", "30");
     * urlEncode(params);                              // returns "name=John+Doe&age=30"
     * 
     * // Encoding with special characters
     * Map<String, String> data = new HashMap<>();
     * data.put("email", "test@example.com");
     * data.put("info", "hello world!");
     * urlEncode(data);                                // returns "email=test%40example.com&info=hello+world%21"
     * }</pre>
     *
     * @param parameters The parameters to be URL-encoded.
     * @return The URL-encoded string representation of the parameters.
     * @see URLEncodedUtil#encode(Object)
     */
    public static String urlEncode(final Object parameters) {
        return URLEncodedUtil.encode(parameters);
    }

    /**
     * Encodes the given parameters into a URL-encoded string using the specified charset.
     *
     * <p>This method is similar to {@link #urlEncode(Object)} but allows specifying a custom
     * charset for encoding. This is useful when dealing with non-ASCII characters that need
     * to be encoded using a specific character set.</p>
     *
     * <p>The method handles various object types and encodes them according to the specified charset.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Encoding with UTF-8
     * Map<String, String> params = new HashMap<>();
     * params.put("name", "Jos");
     * params.put("city", "So Paulo");
     * urlEncode(params, StandardCharsets.UTF_8);     // returns properly encoded UTF-8 string
     * 
     * // Encoding with different charset
     * urlEncode(params, StandardCharsets.ISO_8859_1); // returns ISO-8859-1 encoded string
     * }</pre>
     *
     * @param parameters The parameters to be URL-encoded.
     * @param charset The charset to be used for encoding.
     * @return The URL-encoded string representation of the parameters.
     * @see URLEncodedUtil#encode(Object, Charset)
     */
    public static String urlEncode(final Object parameters, final Charset charset) {
        return URLEncodedUtil.encode(parameters, charset);
    }

    /**
     * Decodes the given URL query string into a map of key-value pairs.
     *
     * <p>This method parses a URL-encoded query string and converts it back into a Map where
     * keys are parameter names and values are parameter values. The decoding handles special
     * characters and converts '+' back to spaces.</p>
     *
     * <p>The method returns an empty map if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Basic decoding
     * urlDecode("name=John+Doe&age=30");             // returns {name=John Doe, age=30}
     * urlDecode("email=test%40example.com");         // returns {email=test@example.com}
     * 
     * // Multiple values
     * urlDecode("key1=value1&key2=value2&key3=");    // returns {key1=value1, key2=value2, key3=}
     * 
     * // Edge cases
     * urlDecode(null);                               // returns empty map
     * urlDecode("");                                 // returns empty map
     * }</pre>
     *
     * @param urlQuery The URL query string to be decoded.
     * @return A map containing the decoded key-value pairs from the URL query string.
     * @see URLEncodedUtil#decode(String)
     */
    public static Map<String, String> urlDecode(final String urlQuery) {
        return URLEncodedUtil.decode(urlQuery);
    }

    /**
     * Decodes the given URL query string into a map of key-value pairs using the specified charset.
     *
     * <p>This method is similar to {@link #urlDecode(String)} but allows specifying a custom
     * charset for decoding. This ensures proper handling of characters encoded with a specific
     * character set.</p>
     *
     * <p>The method returns an empty map if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // UTF-8 decoding
     * urlDecode("name=Jos%C3%A9&city=S%C3%A3o+Paulo", StandardCharsets.UTF_8);
     * // returns {name=Jos, city=So Paulo}
     * 
     * // Different charset
     * urlDecode("data=test%20data", StandardCharsets.ISO_8859_1);
     * // returns {data=test data}
     * }</pre>
     *
     * @param urlQuery The URL query string to be decoded.
     * @param charset The charset to be used for decoding.
     * @return A map containing the decoded key-value pairs from the URL query string.
     * @see URLEncodedUtil#decode(String, Charset)
     */
    public static Map<String, String> urlDecode(final String urlQuery, final Charset charset) {
        return URLEncodedUtil.decode(urlQuery, charset);
    }

    /**
     * Decodes the given URL query string into an object of the specified type.
     *
     * <p>This method parses a URL-encoded query string and maps it to an instance of the
     * specified class. The class should have properties that match the parameter names in
     * the query string. This is useful for directly converting URL parameters to Java objects.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Define a class
     * public class UserParams {
     *     private String name;
     *     private int age;
     *     // getters and setters
     * }
     * 
     * // Decode to object
     * UserParams params = urlDecode("name=John+Doe&age=30", UserParams.class);
     * // params.getName() returns "John Doe"
     * // params.getAge() returns 30
     * }</pre>
     *
     * @param <T> The type of the object to be returned.
     * @param urlQuery The URL query string to be decoded.
     * @param targetType The class of the object to be returned.
     * @return An object of the specified type containing the decoded data from the URL query string.
     * @see URLEncodedUtil#decode(String, Class)
     */
    public static <T> T urlDecode(final String urlQuery, final Class<? extends T> targetType) {
        return URLEncodedUtil.decode(urlQuery, targetType);
    }

    /**
     * Decodes a URL query string into an object of the specified type.
     * The query string is expected to be in <i>application/x-www-form-urlencoded</i> format.
     *
     * <p>This method combines URL decoding with object mapping, allowing specification of
     * both the charset for decoding and the target class for mapping. This provides full
     * control over the decoding and mapping process.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Define a class
     * public class Product {
     *     private String name;
     *     private String description;
     *     // getters and setters
     * }
     * 
     * // Decode with specific charset
     * Product product = urlDecode("name=Caf%C3%A9&description=Delicious+coffee", 
     *                            StandardCharsets.UTF_8, Product.class);
     * // product.getName() returns "Caf"
     * // product.getDescription() returns "Delicious coffee"
     * }</pre>
     *
     * @param <T> The type of the object to be returned.
     * @param urlQuery The URL query string to be decoded.
     * @param charset The charset to be used for decoding.
     * @param targetType The class of the object to be returned.
     * @return An object of type T that represents the decoded URL query string.
     * @see URLEncodedUtil#decode(String, Charset, Class)
     */
    public static <T> T urlDecode(final String urlQuery, final Charset charset, final Class<? extends T> targetType) {
        return URLEncodedUtil.decode(urlQuery, charset, targetType);
    }

    /**
     * This array is a lookup table that translates Unicode characters drawn from the "Base64 Alphabet" (as specified
     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
     * alphabet but fall within the bounds of the array are translated to -1.
     * <p>
     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both
     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).
     * </p>
     * <p>
     * Thanks to "commons" project in ws.apache.org for this code.
     * <a href="http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/">commons</a>
     * </p>
     */
    private static final byte[] DECODE_TABLE = {
            //   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, // 20-2f + - /
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
            -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // 40-4f A-O
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, // 50-5f P-Z _
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // 60-6f a-o
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 // 70-7a p-z
    };

    /**
     * Byte used to pad output.
     */
    protected static final byte PAD_DEFAULT = '='; // Allow static access to default

    /**
     * Returns whether the {@code octet} is in the base 64 alphabet.
     *
     * <p>This method checks if a given byte value is a valid Base64 character according to
     * the Base64 alphabet. Valid characters include A-Z, a-z, 0-9, +, /, and the padding
     * character '='. This is useful for validating individual bytes in Base64 operations.</p>
     *
     * <p>The method uses a lookup table for efficient validation.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid Base64 characters
     * isBase64((byte)'A');                           // returns true
     * isBase64((byte)'z');                           // returns true
     * isBase64((byte)'0');                           // returns true
     * isBase64((byte)'+');                           // returns true
     * isBase64((byte)'/');                           // returns true
     * isBase64((byte)'=');                           // returns true (padding)
     * 
     * // Invalid Base64 characters
     * isBase64((byte)'!');                           // returns false
     * isBase64((byte)' ');                           // returns false
     * isBase64((byte)'@');                           // returns false
     * }</pre>
     *
     * @param octet The value to test
     * @return {@code true} if the value is defined in the base 64 alphabet, {@code false} otherwise.
     */
    public static boolean isBase64(final byte octet) {
        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * <p>This method validates an entire byte array to ensure all bytes are valid Base64 characters
     * or whitespace. Currently the method treats whitespace as valid, which allows for Base64
     * strings that may contain line breaks or spaces for formatting purposes.</p>
     *
     * <p>The method returns {@code true} for empty arrays.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid Base64 byte arrays
     * isBase64("SGVsbG8=".getBytes());               // returns true
     * isBase64("SGVs bG8=".getBytes());              // returns true (whitespace allowed)
     * isBase64(new byte[0]);                         // returns true (empty array)
     * 
     * // Invalid Base64 byte arrays
     * isBase64("Hello!".getBytes());                 // returns false (contains '!')
     * isBase64("SGVs@G8=".getBytes());               // returns false (contains '@')
     * }</pre>
     *
     * @param arrayOctet byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false}, otherwise
     */
    public static boolean isBase64(final byte[] arrayOctet) {
        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !Character.isWhitespace(element)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Tests a given String to see if it contains only valid characters within the Base64 alphabet.
     *
     * <p>This method validates a string to ensure it contains only valid Base64 characters.
     * Like the byte array version, this method currently treats whitespace as valid, allowing
     * for formatted Base64 strings with line breaks or spaces.</p>
     *
     * <p>The method returns {@code true} for empty strings.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Valid Base64 strings
     * isBase64("SGVsbG8gV29ybGQ=");                 // returns true
     * isBase64("SGVs bG8g V29y bGQ=");              // returns true (whitespace allowed)
     * isBase64("");                                  // returns true (empty string)
     * 
     * // Invalid Base64 strings
     * isBase64("Hello World!");                      // returns false
     * isBase64("SGVs!G8=");                          // returns false (contains '!')
     * isBase64("test@123");                          // returns false (contains '@')
     * }</pre>
     *
     * @param base64 String to test
     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
     *         the String is empty; {@code false}, otherwise
     */
    public static boolean isBase64(final String base64) {
        return isBase64(getBytes(base64, Charsets.DEFAULT));
    }

    /**
     * Searches for the first occurrence of an email address within the given CharSequence.
     *
     * <p>This method uses a regular expression to find an email address in the input CharSequence.
     * The regex follows RFC 5322 standards for email address validation. If an email address is
     * found, it is returned; otherwise, the method returns {@code null}.</p>
     *
     * <p>The method returns {@code null} for null or empty input.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Finding email addresses
     * findFirstEmailAddress("Contact: john@example.com");    // returns "john@example.com"
     * findFirstEmailAddress("Email: test.user@domain.co.uk"); // returns "test.user@domain.co.uk"
     * findFirstEmailAddress("Multiple: a@b.com and c@d.com"); // returns "a@b.com" (first only)
     * 
     * // No email found
     * findFirstEmailAddress("No email here");                 // returns null
     * findFirstEmailAddress(null);                           // returns null
     * findFirstEmailAddress("");                             // returns null
     * }</pre>
     *
     * @param cs The CharSequence to be searched. It can be {@code null} or empty.
     * @return The first email address found in the CharSequence, or {@code null} if no email address is found.
     * @see #isValidEmailAddress(CharSequence)
     * @see #findAllEmailAddresses(CharSequence)
     */
    public static String findFirstEmailAddress(final CharSequence cs) {
        if (isEmpty(cs)) {
            return null;
        }

        final Matcher matcher = RegExUtil.EMAIL_ADDRESS_RFC_5322_FINDER.matcher(cs);

        // ^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$"
        // Matcher matcher = Pattern.compile("[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+").matcher(str);

        if (matcher.find()) {
            return matcher.group();
        }

        return null;
    }

    /**
     * Finds all the email addresses in the given CharSequence.
     *
     * <p>This method uses a regular expression to find all occurrences of email addresses in the
     * input CharSequence. The regex follows RFC 5322 standards for email address validation.
     * It returns a list of all found email addresses. If no email address is found, it returns
     * an empty list.</p>
     *
     * <p>The method never returns {@code null}, always returning at least an empty list.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Finding multiple email addresses
     * findAllEmailAddresses("Contact: john@example.com and jane@test.org");
     * // returns ["john@example.com", "jane@test.org"]
     * 
     * findAllEmailAddresses("Emails: a@b.com, c@d.net, e@f.org");
     * // returns ["a@b.com", "c@d.net", "e@f.org"]
     * 
     * // No emails found
     * findAllEmailAddresses("No emails here");       // returns []
     * findAllEmailAddresses(null);                   // returns []
     * findAllEmailAddresses("");                     // returns []
     * }</pre>
     *
     * @param cs The CharSequence to be searched. It can be {@code null} or empty.
     * @return A list of all found email addresses, or an empty list if no email address is found.
     * @see #isValidEmailAddress(CharSequence)
     * @see #findFirstEmailAddress(CharSequence)
     */
    public static List<String> findAllEmailAddresses(final CharSequence cs) {
        if (isEmpty(cs)) {
            return new ArrayList<>();
        }

        final Matcher matcher = RegExUtil.EMAIL_ADDRESS_RFC_5322_FINDER.matcher(cs);

        final List<String> result = new ArrayList<>();

        while (matcher.find()) {
            result.add(matcher.group());
        }

        return result;
    }

    /**
     * Creates a copy of the given array of strings and trims each string in the array.
     *
     * <p>Trimming a string removes any leading or trailing whitespace characters. This method
     * creates a new array to avoid modifying the original array. Each string in the new array
     * will have its leading and trailing whitespace removed.</p>
     *
     * <p>The method returns {@code null} if the input array is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Trimming strings
     * String[] input = {"  hello  ", " world ", "test"};
     * String[] result = copyThenTrim(input);         // returns ["hello", "world", "test"]
     * 
     * // Handling null and empty strings
     * String[] mixed = {"  ", "text", null, " value "};
     * String[] trimmed = copyThenTrim(mixed);        // returns ["", "text", null, "value"]
     * 
     * // Edge cases
     * copyThenTrim(null);                            // returns null
     * copyThenTrim(new String[0]);                   // returns empty array
     * }</pre>
     *
     * @param strs The array of strings to be copied and trimmed. May be {@code null}.
     * @return A new array with the trimmed strings. Returns {@code null} if the input array is {@code null}.
     * @see N#copyThenReplaceAll(Object[], java.util.function.UnaryOperator)
     * @see Fn#trim()
     * @see Fn#trimToEmpty()
     * @see Fn#trimToNull()
     */
    @Beta
    @MayReturnNull
    public static String[] copyThenTrim(final String[] strs) {
        return N.copyThenReplaceAll(strs, Fn.trim());
    }

    /**
     * Creates a copy of the given array of strings and strips each string in the array.
     *
     * <p>Stripping a string removes any leading or trailing whitespace characters, including
     * Unicode whitespace. This method is similar to {@link #copyThenTrim(String[])} but uses
     * the strip operation which handles Unicode whitespace characters.</p>
     *
     * <p>The method returns {@code null} if the input array is {@code null}.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Stripping strings
     * String[] input = {"  hello  ", " world ", "test"};
     * String[] result = copyThenStrip(input);        // returns ["hello", "world", "test"]
     * 
     * // Unicode whitespace handling
     * String[] unicode = {"\u2000text\u2000", " normal "};
     * String[] stripped = copyThenStrip(unicode);    // strips Unicode whitespace too
     * 
     * // Edge cases
     * copyThenStrip(null);                           // returns null
     * copyThenStrip(new String[0]);                  // returns empty array
     * }</pre>
     *
     * @param strs The array of strings to be copied and stripped. May be {@code null}.
     * @return A new array with the stripped strings. Returns {@code null} if the input array is {@code null}.
     * @see N#copyThenReplaceAll(Object[], java.util.function.UnaryOperator)
     * @see Fn#strip()
     * @see Fn#stripToEmpty()
     * @see Fn#stripToNull()
     */
    @Beta
    @MayReturnNull
    public static String[] copyThenStrip(final String[] strs) {
        return N.copyThenReplaceAll(strs, Fn.strip());
    }

    /**
     * Extracts the first occurrence of an integer from the given string.
     *
     * <p>This method searches for the first sequence of digits (optionally preceded by a minus sign
     * for negative numbers) in the input string and returns it as a string. The method uses regular
     * expressions to find integer patterns.</p>
     *
     * <p>The method returns an empty string if no integer is found or if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extracting integers
     * extractFirstInteger("Price: $123");            // returns "123"
     * extractFirstInteger("Temperature: -5 degrees"); // returns "-5"
     * extractFirstInteger("Room 404, Floor 2");      // returns "404" (first integer)
     * 
     * // No integer found
     * extractFirstInteger("No numbers here");        // returns ""
     * extractFirstInteger(null);                     // returns ""
     * extractFirstInteger("");                       // returns ""
     * }</pre>
     *
     * @param str The string to extract the integer from. It can be {@code null} or empty.
     * @return The extracted integer as a string, or an empty string {@code ""} if no integer is found.
     * @see #replaceFirstInteger(String, String)
     * @see Numbers#extractFirstInt(String)
     * @see Numbers#extractFirstLong(String)
     */
    public static String extractFirstInteger(final String str) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        final Matcher matcher = RegExUtil.INTEGER_FINDER.matcher(str);
        if (matcher.find()) {
            return matcher.group(1);
        }

        return Strings.EMPTY;
    }

    /**
     * Extracts the first occurrence of a double from the given string.
     *
     * <p>This method searches for the first number (integer or decimal) in the input string
     * and returns it as a string. It handles both integer and floating-point numbers with
     * decimal points. Scientific notation is not included by default.</p>
     *
     * <p>The method returns an empty string if no number is found or if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Extracting doubles
     * extractFirstDouble("Price: $12.99");           // returns "12.99"
     * extractFirstDouble("Temperature: -5.5C");     // returns "-5.5"
     * extractFirstDouble("Value: 42");               // returns "42"
     * 
     * // No double found
     * extractFirstDouble("No numbers");              // returns ""
     * extractFirstDouble(null);                      // returns ""
     * extractFirstDouble("");                        // returns ""
     * }</pre>
     *
     * @param str The string to extract the double from. It can be {@code null} or empty.
     * @return The extracted double as a string, or an empty string {@code ""} if no double is found.
     * @see #extractFirstInteger(String)
     * @see #replaceFirstDouble(String, String)
     * @see Numbers#extractFirstDouble(String)
     */
    public static String extractFirstDouble(final String str) {
        return extractFirstDouble(str, false);
    }

    /**
     * Extracts the first occurrence of a double from the given string.
     *
     * <p>This method searches for the first number in the input string with an option to include
     * scientific notation. When scientific notation is enabled, it can extract numbers like
     * "1.23e10" or "5E-3". Otherwise, it only extracts regular decimal numbers.</p>
     *
     * <p>The method returns an empty string if no number is found or if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Regular number extraction
     * extractFirstDouble("Value: 3.14159", false);   // returns "3.14159"
     * extractFirstDouble("Count: -42.0", false);     // returns "-42.0"
     * 
     * // Scientific notation
     * extractFirstDouble("Result: 1.23e10", true);   // returns "1.23e10"
     * extractFirstDouble("Small: 5E-3", true);        // returns "5E-3"
     * extractFirstDouble("Result: 1.23e10", false);  // returns "1.23" (no scientific)
     * }</pre>
     *
     * @param str The string to extract the double from. It can be {@code null} or empty.
     * @param includingCientificNumber If {@code true}, it will also include scientific numbers in the search.
     * @return The extracted double as a string, or an empty string {@code ""} if no double is found.
     * @see #extractFirstInteger(String)
     * @see #extractFirstDouble(String)
     * @see #replaceFirstDouble(String, String)
     * @see Numbers#extractFirstDouble(String, boolean)
     */
    public static String extractFirstDouble(final String str, final boolean includingCientificNumber) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        final Matcher matcher = (includingCientificNumber ? RegExUtil.SCIENTIFIC_NUMBER_FINDER : RegExUtil.NUMBER_FINDER).matcher(str);

        if (matcher.find()) {
            return matcher.group(1);
        }

        return Strings.EMPTY;
    }

    /**
     * Replaces the first occurrences of integer in the given string with the specified replacement string.
     *
     * <p>This method finds the first integer (sequence of digits optionally preceded by a minus sign)
     * in the input string and replaces it with the provided replacement string. Only the first
     * occurrence is replaced.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Replacing integers
     * replaceFirstInteger("Room 404, Floor 2", "X");  // returns "Room X, Floor 2"
     * replaceFirstInteger("Price: $123", "[NUM]");    // returns "Price: $[NUM]"
     * replaceFirstInteger("Temp: -5C", "0");         // returns "Temp: 0C"
     * 
     * // No integer to replace
     * replaceFirstInteger("No numbers", "X");         // returns "No numbers"
     * replaceFirstInteger(null, "X");                 // returns ""
     * replaceFirstInteger("", "X");                   // returns ""
     * }</pre>
     *
     * @param str The string to be modified. It can be {@code null} or empty.
     * @param replacement The string to replace the integer with.
     * @return The modified string with the first integer replaced by the specified replacement string.
     * @see #extractFirstInteger(String)
     */
    public static String replaceFirstInteger(final String str, final String replacement) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return RegExUtil.INTEGER_FINDER.matcher(str).replaceFirst(replacement);
    }

    /**
     * Replaces the first occurrences of double in the given string with the specified replacement string.
     *
     * <p>This method finds the first number (integer or decimal) in the input string and replaces
     * it with the provided replacement string. It handles both integer and floating-point numbers
     * but does not include scientific notation by default.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Replacing doubles
     * replaceFirstDouble("Price: $12.99 (was $15.99)", "X"); // returns "Price: $X (was $15.99)"
     * replaceFirstDouble("Temp: -5.5C", "0.0");             // returns "Temp: 0.0C"
     * replaceFirstDouble("Count: 42", "[NUM]");              // returns "Count: [NUM]"
     * 
     * // No number to replace
     * replaceFirstDouble("No numbers", "X");                 // returns "No numbers"
     * replaceFirstDouble(null, "X");                         // returns ""
     * }</pre>
     *
     * @param str The string to be modified. It can be {@code null} or empty.
     * @param replacement The string to replace the double with.
     * @return The modified string with the first double replaced by the specified replacement string.
     * @see #extractFirstDouble(String)
     */
    public static String replaceFirstDouble(final String str, final String replacement) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return RegExUtil.NUMBER_FINDER.matcher(str).replaceFirst(replacement);
    }

    /**
     * Replaces the first occurrences of double in the given string with the specified replacement string.
     *
     * <p>This method finds the first number in the input string and replaces it with the provided
     * replacement string. When scientific notation is enabled, it can match and replace numbers
     * in scientific format (e.g., "1.23e10"). Otherwise, it only matches regular decimal numbers.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p>Example:
     * <pre>{@code
     * // Regular number replacement
     * replaceFirstDouble("Value: 3.14, Pi", "X", false);     // returns "Value: X, Pi"
     * 
     * // Scientific notation replacement
     * replaceFirstDouble("Result: 1.23e10 units", "X", true); // returns "Result: X units"
     * replaceFirstDouble("Normal: 5.0, Sci: 2E3", "X", true); // returns "Normal: X, Sci: 2E3"
     * replaceFirstDouble("Result: 1.23e10", "X", false);      // returns "Result: Xe10" (partial)
     * }</pre>
     *
     * @param str The string to be modified. It can be {@code null} or empty.
     * @param replacement The string to replace the double with.
     * @param includingCientificNumber If {@code true}, it will also include scientific numbers in the search.
     * @return The modified string with the first double replaced by the specified replacement string.
     * @see #extractFirstDouble(String, boolean)
     */
    public static String replaceFirstDouble(final String str, final String replacement, final boolean includingCientificNumber) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return (includingCientificNumber ? RegExUtil.SCIENTIFIC_NUMBER_FINDER : RegExUtil.NUMBER_FINDER).matcher(str).replaceFirst(replacement);
    }

    static void checkInputChars(final char[] chs, final String parameterName, final boolean canBeNullOrEmpty) {
        if (!canBeNullOrEmpty && N.isEmpty(chs)) {
            throw new IllegalArgumentException("Input char array or String parameter '" + parameterName + "' can't be null or empty");
        }

        for (final char ch : chs) {
            if (Character.isLowSurrogate(ch) || Character.isHighSurrogate(ch)) {
                throw new IllegalArgumentException("Element char in the input char array or String parameter '" + parameterName
                        + "' can't be low-surrogate or high-surrogate code unit. Please consider using String or String array instead if input parameter is char array");
            }
        }
    }

    static int calculateBufferSize(final int len, final int elementPlusDelimiterLen) {
        return len > Integer.MAX_VALUE / elementPlusDelimiterLen ? Integer.MAX_VALUE : len * elementPlusDelimiterLen;
    }

    static int calculateBufferSize(final int len, final int elementPlusDelimiterLen, final int prefixLen, final int suffixLen) {
        return len > (Integer.MAX_VALUE - prefixLen - suffixLen) / elementPlusDelimiterLen ? Integer.MAX_VALUE
                : len * elementPlusDelimiterLen + prefixLen + suffixLen;
    }

    /**
     * Enum defining different strategies for extracting substrings between delimiters.
     *
     * <p>This enum provides various approaches for handling nested delimiters when extracting
     * substrings. Each strategy offers different behavior for dealing with complex nested
     * structures in strings.</p>
     */
    public enum ExtractStrategy {
        /**
         * Default strategy used to extract substring between two delimiters.
         * <p>
         * <code>substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.DEFAULT) = ["a2[c", "a"]</code>.
         * </p>
         */
        DEFAULT,

        /**
         * Stack-based approach strategy used to extract substring between two delimiters.
         * <p>
         * <code>substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.STACK_BASED) = ["c", "a2[c]", "a"]</code>.
         * </p>
         */
        STACK_BASED,

        /**
         * Stack-based approach strategy used to extract substring between two delimiters but nested substrings are ignored.
         * <p>
         * <code>substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.IGNORE_NESTED) = ["a2[c]", "a"]</code>.
         * </p>
         */
        IGNORE_NESTED
    }

    /**
     * @deprecated replaced by {@code Strings}
     */
    @Deprecated
    @Beta
    public static final class StringUtil extends Strings {
        private StringUtil() {
            // Utility class.
        }
    }

    public static final class StrUtil {
        private StrUtil() {
            // Utility class.
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the index is negative or greater than or equal to the string length, or if the string is {@code null}, 
         * an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substring("hello", 0);      // returns Optional.of("hello")
         * substring("hello", 2);      // returns Optional.of("llo")
         * substring("hello", 5);      // returns Optional.empty()
         * substring("hello", -1);     // returns Optional.empty()
         * substring(null, 0);         // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @return An {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified inclusive begin index 
         * and ending at the exclusive end index. If the indices are invalid (negative, begin >= end, or out of bounds), 
         * or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substring("hello", 0, 5);   // returns Optional.of("hello")
         * substring("hello", 1, 4);   // returns Optional.of("ell")
         * substring("hello", 2, 2);   // returns Optional.empty() (begin == end)
         * substring("hello", 3, 1);   // returns Optional.empty() (begin > end)
         * substring(null, 0, 5);      // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return An {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int, int)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified inclusive begin index.
         * The exclusive end index is calculated by applying the provided function to the string length.
         * If the resulting indices are invalid or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substring("hello", 1, len -> len - 1);  // returns Optional.of("ell") (from 1 to 4)
         * substring("hello", 0, len -> len);      // returns Optional.of("hello")
         * substring("hello", 2, len -> 3);        // returns Optional.of("l")
         * substring("hello", 5, len -> len);      // returns Optional.empty() (invalid begin)
         * substring(null, 0, len -> len);         // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex A function that takes the string length and returns the exclusive end index.
         * @return An {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        //        /**
        //         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //         *
        //         * @param str
        //         * @param inclusiveBeginIndex
        //         * @param funcOfExclusiveEndIndex
        //         * @return
        //         * @see #substring(String, int, int)
        //         */
        //        @Beta
        //        public static Optional<String> substring(final String str, final int inclusiveBeginIndex,
        //                final BiFunction<? super String, Integer, Integer> funcOfExclusiveEndIndex) {
        //            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex));
        //        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string where the inclusive begin index is calculated 
         * by applying the provided function to the exclusive end index. If the resulting indices are invalid 
         * or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substring("hello", end -> 0, 5);        // returns Optional.of("hello")
         * substring("hello", end -> end - 3, 4);  // returns Optional.of("el") (from 1 to 4)
         * substring("hello", end -> end, 3);      // returns Optional.empty() (begin == end)
         * substring("hello", end -> 5, 3);        // returns Optional.empty() (begin > end)
         * substring(null, end -> 0, 5);           // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param funcOfInclusiveBeginIndex A function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return An {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        public static Optional<String> substring(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex));
        }

        //        /**
        //         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //         *
        //         * @param str
        //         * @param funcOfInclusiveBeginIndex
        //         * @param exclusiveEndIndex
        //         * @return
        //         * @see #substring(String, int, int)
        //         */
        //        @Beta
        //        public static Optional<String> substring(final String str, final BiFunction<? super String, Integer, Integer> funcOfInclusiveBeginIndex,
        //                final int exclusiveEndIndex) {
        //            return Optional.ofNullable(Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex));
        //        }

        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @return
        //     * @see Strings#substring(String, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, char delimiterOfInclusiveBeginIndex) {
        //        return Optional.ofNullable(Strings.substring(str, delimiterOfInclusiveBeginIndex));
        //    }
        //
        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @return
        //     * @see Strings#substring(String, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, String delimiterOfInclusiveBeginIndex) {
        //        return Optional.ofNullable(Strings.substring(str, delimiterOfInclusiveBeginIndex));
        //    }
        //
        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, int, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, int inclusiveBeginIndex, char delimiterOfExclusiveEndIndex) {
        //        return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        //    }
        //
        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, int, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, int inclusiveBeginIndex, String delimiterOfExclusiveEndIndex) {
        //        return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        //    }
        //
        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, char, int)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, char delimiterOfInclusiveBeginIndex, int exclusiveEndIndex) {
        //        return Optional.ofNullable(Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex));
        //    }
        //
        //    /**
        //     * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, String, int)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    public static Optional<String> substring(String str, String delimiterOfInclusiveBeginIndex, int exclusiveEndIndex) {
        //        return Optional.ofNullable(Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex));
        //    }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the substring cannot be extracted (due to invalid index or {@code null} string), the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElse("hello", 0, "default");     // returns "hello"
         * substringOrElse("hello", 2, "default");     // returns "llo"
         * substringOrElse("hello", 10, "default");    // returns "default"
         * substringOrElse(null, 0, "default");        // returns "default"
         * substringOrElse("hello", 2, null);          // returns "llo"
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param defaultStr The default string to return if substring extraction fails. Can be {@code null}.
         * @return The substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring from the given string between the specified indices.
         * If the substring cannot be extracted (due to invalid indices or {@code null} string), the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElse("hello", 0, 5, "default");  // returns "hello"
         * substringOrElse("hello", 1, 4, "default");  // returns "ell"
         * substringOrElse("hello", 5, 10, "default"); // returns "default"
         * substringOrElse(null, 0, 5, "default");     // returns "default"
         * substringOrElse("hello", 1, 4, null);       // returns "ell"
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @param defaultStr The default string to return if substring extraction fails. Can be {@code null}.
         * @return The substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, int, int)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring where the end index is calculated by the provided function.
         * If the substring cannot be extracted, the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElse("hello", 1, len -> len - 1, "default"); // returns "ell"
         * substringOrElse("hello", 0, len -> len, "default");     // returns "hello"
         * substringOrElse("hello", 10, len -> len, "default");    // returns "default"
         * substringOrElse(null, 0, len -> len, "default");        // returns "default"
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex A function that takes the string length and returns the exclusive end index.
         * @param defaultStr The default string to return if substring extraction fails. Can be {@code null}.
         * @return The substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex,
                final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring where the begin index is calculated by the provided function.
         * If the substring cannot be extracted, the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElse("hello", end -> 0, 5, "default");       // returns "hello"
         * substringOrElse("hello", end -> end - 3, 4, "default"); // returns "el"
         * substringOrElse("hello", end -> 10, 3, "default");      // returns "default"
         * substringOrElse(null, end -> 0, 5, "default");          // returns "default"
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param funcOfInclusiveBeginIndex A function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @param defaultStr The default string to return if substring extraction fails. Can be {@code null}.
         * @return The substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        @Beta
        public static String substringOrElse(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex,
                final String defaultStr) {
            final String ret = Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElse(String str, char delimiterOfInclusiveBeginIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElse(String str, String delimiterOfInclusiveBeginIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, int, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElse(String str, int inclusiveBeginIndex, char delimiterOfExclusiveEndIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, int, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElse(String str, int inclusiveBeginIndex, String delimiterOfExclusiveEndIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, char, int)
        //     * @deprecated
        //     */
        //    @Beta
        //    public static String substringOrElse(String str, char delimiterOfInclusiveBeginIndex, int exclusiveEndIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code defaultStr}.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @param defaultStr
        //     * @return
        //     * @see Strings#substring(String, String, int)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElse(String str, String delimiterOfInclusiveBeginIndex, int exclusiveEndIndex, final String defaultStr) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex);
        //
        //        return ret == null ? defaultStr : ret;
        //    }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the substring cannot be extracted (due to invalid index), the original string is returned.
         * If the string is {@code null}, {@code null} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElseItself("hello", 0);     // returns "hello"
         * substringOrElseItself("hello", 2);     // returns "llo"
         * substringOrElseItself("hello", 10);    // returns "hello"
         * substringOrElseItself("hello", -1);    // returns "hello"
         * substringOrElseItself(null, 0);        // returns null
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @return The substring if it exists, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring from the given string between the specified indices.
         * If the substring cannot be extracted (due to invalid indices), the original string is returned.
         * If the string is {@code null}, {@code null} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElseItself("hello", 0, 5);  // returns "hello"
         * substringOrElseItself("hello", 1, 4);  // returns "ell"
         * substringOrElseItself("hello", 5, 10); // returns "hello"
         * substringOrElseItself("hello", 2, 1);  // returns "hello"
         * substringOrElseItself(null, 0, 5);     // returns null
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return The substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, int, int)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring where the end index is calculated by the provided function.
         * If the substring cannot be extracted, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElseItself("hello", 1, len -> len - 1); // returns "ell"
         * substringOrElseItself("hello", 0, len -> len);     // returns "hello"
         * substringOrElseItself("hello", 10, len -> len);    // returns "hello"
         * substringOrElseItself(null, 0, len -> len);        // returns null
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param inclusiveBeginIndex The starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex A function that takes the string length and returns the exclusive end index.
         * @return The substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring where the begin index is calculated by the provided function.
         * If the substring cannot be extracted, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringOrElseItself("hello", end -> 0, 5);       // returns "hello"
         * substringOrElseItself("hello", end -> end - 3, 4); // returns "el"
         * substringOrElseItself("hello", end -> 10, 3);      // returns "hello"
         * substringOrElseItself(null, end -> 0, 5);          // returns null
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param funcOfInclusiveBeginIndex A function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return The substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        @Beta
        public static String substringOrElseItself(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @return
        //     * @see Strings#substring(String, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, char delimiterOfInclusiveBeginIndex) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex);
        //
        //        return ret == null ? str : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @return
        //     * @see Strings#substring(String, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, String delimiterOfInclusiveBeginIndex) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex);
        //
        //        return ret == null ? str : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, int, char)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, int inclusiveBeginIndex, char delimiterOfExclusiveEndIndex) {
        //        final String ret = Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);
        //
        //        return ret == null ? str : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param inclusiveBeginIndex
        //     * @param delimiterOfExclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, int, String)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, int inclusiveBeginIndex, String delimiterOfExclusiveEndIndex) {
        //        final String ret = Strings.substring(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);
        //
        //        return ret == null ? str : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, char, int)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, char delimiterOfInclusiveBeginIndex, int exclusiveEndIndex) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex);
        //
        //        return ret == null ? str : ret;
        //    }
        //
        //    /**
        //     * Returns the substring if it exists, otherwise returns {@code str} itself.
        //     *
        //     * @param str
        //     * @param delimiterOfInclusiveBeginIndex
        //     * @param exclusiveEndIndex
        //     * @return
        //     * @see Strings#substring(String, String, int)
        //     * @deprecated
        //     */
        //    @Deprecated
        //    @Beta
        //    public static String substringOrElseItself(String str, String delimiterOfInclusiveBeginIndex, int exclusiveEndIndex) {
        //        final String ret = Strings.substring(str, delimiterOfInclusiveBeginIndex, exclusiveEndIndex);
        //
        //        return ret == null ? str : ret;
        //    }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfter("hello.world", '.');    // returns Optional.of("world")
         * substringAfter("hello", '.');          // returns Optional.empty()
         * substringAfter("hello.", '.');         // returns Optional.of("")
         * substringAfter("", '.');               // returns Optional.empty()
         * substringAfter(null, '.');             // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter character after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the delimiter, or empty if not found.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final char delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfter("hello world", " ");    // returns Optional.of("world")
         * substringAfter("hello::world", "::");  // returns Optional.of("world")
         * substringAfter("hello", " ");          // returns Optional.empty()
         * substringAfter("hello ", " ");         // returns Optional.of("")
         * substringAfter(null, " ");             // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter string after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the delimiter, or empty if not found.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final String delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter string
         * and before the specified exclusive end index. If the delimiter is not found, the end index is invalid, 
         * or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfter("hello world", " ", 8);     // returns Optional.of("wor")
         * substringAfter("hello::world", "::", 10);  // returns Optional.of("world")
         * substringAfter("hello", " ", 5);           // returns Optional.empty()
         * substringAfter("hello ", " ", 6);          // returns Optional.of("")
         * substringAfter(null, " ", 5);              // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter string after which the substring begins.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return An {@code Optional<String>} containing the substring after the delimiter up to the end index, or empty if not found.
         * @see Strings#substringAfter(String, String, int)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLast("com.example.Test", '.');   // returns Optional.of("Test")
         * substringAfterLast("hello", '.');              // returns Optional.empty()
         * substringAfterLast("hello.", '.');             // returns Optional.of("")
         * substringAfterLast("a.b.c", '.');              // returns Optional.of("c")
         * substringAfterLast(null, '.');                 // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter character after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the last occurrence of the delimiter, or empty if not found.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final char delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLast("com.example.Test", ".");   // returns Optional.of("Test")
         * substringAfterLast("hello::world::test", "::"); // returns Optional.of("test")
         * substringAfterLast("hello", " ");              // returns Optional.empty()
         * substringAfterLast("hello ", " ");             // returns Optional.of("")
         * substringAfterLast(null, ".");                 // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter string after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the last occurrence of the delimiter, or empty if not found.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter string
         * and before the specified exclusive end index. If the delimiter is not found, the end index is invalid,
         * or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLast("com.example.Test", ".", 15);    // returns Optional.of("Tes")
         * substringAfterLast("a::b::c::d", "::", 12);         // returns Optional.of("d")
         * substringAfterLast("hello", " ", 5);                // returns Optional.empty()
         * substringAfterLast("hello ", " ", 6);               // returns Optional.of("")
         * substringAfterLast(null, ".", 10);                  // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter string after which the substring begins.
         * @param exclusiveEndIndex The ending index (exclusive) of the substring.
         * @return An {@code Optional<String>} containing the substring after the last delimiter up to the end index, or empty if not found.
         * @see Strings#substringAfterLast(String, String, int)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of any of the specified delimiter characters.
         * If none of the delimiters are found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterAny("hello.world", '.', '!');     // returns Optional.of("world")
         * substringAfterAny("hello!world", '.', '!');     // returns Optional.of("world")
         * substringAfterAny("hello", '.', '!');           // returns Optional.empty()
         * substringAfterAny("hello.", '.', '!');          // returns Optional.of("")
         * substringAfterAny(null, '.', '!');              // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimitersOfExclusiveBeginIndex The delimiter characters after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the first found delimiter, or empty if none found.
         * @see Strings#substringAfterAny(String, char[])
         */
        @Beta
        public static Optional<String> substringAfterAny(final String str, final char... delimitersOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterAny(str, delimitersOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of any of the specified delimiter strings.
         * If none of the delimiters are found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterAny("hello world", " ", "::");    // returns Optional.of("world")
         * substringAfterAny("hello::world", " ", "::");   // returns Optional.of("world")
         * substringAfterAny("hello", " ", "::");          // returns Optional.empty()
         * substringAfterAny("hello ", " ", "::");         // returns Optional.of("")
         * substringAfterAny(null, " ", "::");             // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimitersOfExclusiveBeginIndex The delimiter strings after which the substring begins.
         * @return An {@code Optional<String>} containing the substring after the first found delimiter, or empty if none found.
         * @see Strings#substringAfterAny(String, String[])
         */
        @Beta
        public static Optional<String> substringAfterAny(final String str, final String... delimitersOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterAny(str, delimitersOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears before the first occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBefore("hello.world", '.');    // returns Optional.of("hello")
         * substringBefore("hello", '.');          // returns Optional.empty()
         * substringBefore(".hello", '.');         // returns Optional.of("")
         * substringBefore("", '.');               // returns Optional.empty()
         * substringBefore(null, '.');             // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The delimiter character before which the substring ends.
         * @return An {@code Optional<String>} containing the substring before the delimiter, or empty if not found.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears before the first occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBefore("hello world", " ");    // returns Optional.of("hello")
         * substringBefore("hello::world", "::");  // returns Optional.of("hello")
         * substringBefore("hello", " ");          // returns Optional.empty()
         * substringBefore(" hello", " ");         // returns Optional.of("")
         * substringBefore(null, " ");             // returns Optional.empty()
         * }</pre>
         *
         * @param str The string from which to extract the substring. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The delimiter string before which the substring ends.
         * @return An {@code Optional<String>} containing the substring before the delimiter, or empty if not found.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the specified delimiter,
         * starting from the given inclusive begin index.
         *
         * <p>This method searches for the delimiter starting from the specified index and returns
         * the substring from that index up to (but not including) the delimiter. If the delimiter
         * is not found after the specified index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiter.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBefore("hello.world.java", 0, ".");      // returns Optional.of("hello")
         * substringBefore("hello.world.java", 6, ".");      // returns Optional.of("world")
         * substringBefore("hello.world.java", 0, "xyz");    // returns Optional.empty()
         * substringBefore(null, 0, ".");                    // returns Optional.empty()
         * substringBefore("hello", 0, null);                // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param inclusiveBeginIndex The index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBefore(String, int, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified character delimiter.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLast("hello.world.java", '.');     // returns Optional.of("hello.world")
         * substringBeforeLast("hello", '.');                // returns Optional.empty()
         * substringBeforeLast("hello.", '.');               // returns Optional.of("hello")
         * substringBeforeLast(null, '.');                   // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The character delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified string delimiter.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiter.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLast("hello.world.java", ".");     // returns Optional.of("hello.world")
         * substringBeforeLast("hello//world//java", "//");  // returns Optional.of("hello//world")
         * substringBeforeLast("hello", ".");                // returns Optional.empty()
         * substringBeforeLast(null, ".");                   // returns Optional.empty()
         * substringBeforeLast("hello", null);               // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified delimiter, starting from the given inclusive begin index.
         *
         * <p>This method searches for the last occurrence of the delimiter starting from the specified
         * index and returns the substring from that index up to (but not including) the delimiter.
         * If the delimiter is not found after the specified index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiter.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLast("hello.world.java", 0, ".");      // returns Optional.of("hello.world")
         * substringBeforeLast("hello.world.java", 6, ".");      // returns Optional.of("world")
         * substringBeforeLast("hello.world.java", 13, ".");     // returns Optional.empty()
         * substringBeforeLast(null, 0, ".");                    // returns Optional.empty()
         * substringBeforeLast("hello", 0, null);                // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param inclusiveBeginIndex The index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, int, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before any of the specified
         * character delimiters.
         *
         * <p>This method searches for the first occurrence of any of the delimiter characters and
         * returns the substring from the beginning up to (but not including) that delimiter. If none
         * of the delimiters are found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or null/empty delimiter array.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeAny("hello.world:java", '.', ':');     // returns Optional.of("hello")
         * substringBeforeAny("hello-world", '.', ':');          // returns Optional.empty()
         * substringBeforeAny("hello:world.java", '.', ':');     // returns Optional.of("hello")
         * substringBeforeAny(null, '.', ':');                   // returns Optional.empty()
         * substringBeforeAny("hello", (char[])null);            // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimitersOfExclusiveEndIndex The character delimiters marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeAny(String, char[])
         */
        @Beta
        public static Optional<String> substringBeforeAny(final String str, final char... delimitersOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeAny(str, delimitersOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before any of the specified
         * string delimiters.
         *
         * <p>This method searches for the first occurrence of any of the delimiter strings and
         * returns the substring from the beginning up to (but not including) that delimiter. If none
         * of the delimiters are found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or null/empty delimiter array.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeAny("hello.world::java", ".", "::");     // returns Optional.of("hello")
         * substringBeforeAny("hello-world", ".", "::");           // returns Optional.empty()
         * substringBeforeAny("hello::world.java", ".", "::");     // returns Optional.of("hello")
         * substringBeforeAny(null, ".", "::");                    // returns Optional.empty()
         * substringBeforeAny("hello", (String[])null);            // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimitersOfExclusiveEndIndex The string delimiters marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeAny(String, String[])
         */
        @Beta
        public static Optional<String> substringBeforeAny(final String str, final String... delimitersOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeAny(str, delimitersOfExclusiveEndIndex));
        }

        /**
         * Returns the substring after the specified delimiter if it exists, otherwise returns the default string.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * after (not including) that delimiter. If the delimiter is not found or the input is null,
         * the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterOrElse("hello.world", ".", "default");     // returns "world"
         * substringAfterOrElse("hello", ".", "default");           // returns "default"
         * substringAfterOrElse(null, ".", "default");              // returns "default"
         * substringAfterOrElse("hello.", ".", "default");          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter marking the beginning of the substring (exclusive).
         * @param defaultStr The default string to return if substring is not found.
         * @return The substring after the delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElse(final String str, final String delimiterOfExclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified delimiter if it exists,
         * otherwise returns the default string.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * after (not including) that delimiter. If the delimiter is not found or the input is null,
         * the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLastOrElse("hello.world.java", ".", "default");     // returns "java"
         * substringAfterLastOrElse("hello", ".", "default");                // returns "default"
         * substringAfterLastOrElse(null, ".", "default");                   // returns "default"
         * substringAfterLastOrElse("hello.world.", ".", "default");         // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter marking the beginning of the substring (exclusive).
         * @param defaultStr The default string to return if substring is not found.
         * @return The substring after the last delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElse(final String str, final String delimiterOfExclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring before the specified delimiter if it exists, otherwise returns the default string.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * from the beginning up to (but not including) that delimiter. If the delimiter is not found
         * or the input is null, the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeOrElse("hello.world", ".", "default");     // returns "hello"
         * substringBeforeOrElse("hello", ".", "default");           // returns "default"
         * substringBeforeOrElse(null, ".", "default");              // returns "default"
         * substringBeforeOrElse(".world", ".", "default");          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @param defaultStr The default string to return if substring is not found.
         * @return The substring before the delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElse(final String str, final String delimiterOfExclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified delimiter if it exists,
         * otherwise returns the default string.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * from the beginning up to (but not including) that delimiter. If the delimiter is not found
         * or the input is null, the default string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLastOrElse("hello.world.java", ".", "default");     // returns "hello.world"
         * substringBeforeLastOrElse("hello", ".", "default");                // returns "default"
         * substringBeforeLastOrElse(null, ".", "default");                   // returns "default"
         * substringBeforeLastOrElse("hello.", ".", "default");               // returns "hello"
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @param defaultStr The default string to return if substring is not found.
         * @return The substring before the last delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElse(final String str, final String delimiterOfExclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring after the specified character delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter character and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterOrElseItself("hello.world", '.');     // returns "world"
         * substringAfterOrElseItself("hello", '.');           // returns "hello"
         * substringAfterOrElseItself(null, '.');              // returns null
         * substringAfterOrElseItself("hello.", '.');          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The character delimiter marking the beginning of the substring (exclusive).
         * @return The substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final char delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the specified string delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter string and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterOrElseItself("hello::world", "::");     // returns "world"
         * substringAfterOrElseItself("hello", "::");            // returns "hello"
         * substringAfterOrElseItself(null, "::");               // returns null
         * substringAfterOrElseItself("hello::", "::");          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning of the substring (exclusive).
         * @return The substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the specified delimiter up to the exclusive end index if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * after (not including) that delimiter up to the specified exclusive end index. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterOrElseItself("hello.world.java", ".", 11);     // returns "world"
         * substringAfterOrElseItself("hello.world.java", ".", 20);     // returns "world.java"
         * substringAfterOrElseItself("hello", ".", 10);                // returns "hello"
         * substringAfterOrElseItself(null, ".", 10);                   // returns null
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter marking the beginning of the substring (exclusive).
         * @param exclusiveEndIndex The index marking the end of the substring (exclusive).
         * @return The substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified character delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLastOrElseItself("hello.world.java", '.');     // returns "java"
         * substringAfterLastOrElseItself("hello", '.');                // returns "hello"
         * substringAfterLastOrElseItself(null, '.');                   // returns null
         * substringAfterLastOrElseItself("hello.world.", '.');         // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The character delimiter marking the beginning of the substring (exclusive).
         * @return The substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final char delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified string delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLastOrElseItself("hello::world::java", "::");     // returns "java"
         * substringAfterLastOrElseItself("hello", "::");                  // returns "hello"
         * substringAfterLastOrElseItself(null, "::");                     // returns null
         * substringAfterLastOrElseItself("hello::world::", "::");         // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning of the substring (exclusive).
         * @return The substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified delimiter up to
         * the exclusive end index if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * after (not including) that delimiter up to the specified exclusive end index. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringAfterLastOrElseItself("hello.world.java", ".", 16);     // returns "java"
         * substringAfterLastOrElseItself("hello.world.java", ".", 14);     // returns "ja"
         * substringAfterLastOrElseItself("hello", ".", 10);                // returns "hello"
         * substringAfterLastOrElseItself(null, ".", 10);                   // returns null
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The delimiter marking the beginning of the substring (exclusive).
         * @param exclusiveEndIndex The index marking the end of the substring (exclusive).
         * @return The substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified character delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeOrElseItself("hello.world", '.');     // returns "hello"
         * substringBeforeOrElseItself("hello", '.');           // returns "hello"
         * substringBeforeOrElseItself(null, '.');              // returns null
         * substringBeforeOrElseItself(".world", '.');          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The character delimiter marking the end of the substring (exclusive).
         * @return The substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final char delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified string delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeOrElseItself("hello::world", "::");     // returns "hello"
         * substringBeforeOrElseItself("hello", "::");            // returns "hello"
         * substringBeforeOrElseItself(null, "::");               // returns null
         * substringBeforeOrElseItself("::world", "::");          // returns ""
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end of the substring (exclusive).
         * @return The substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified delimiter starting from the given index
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter starting from the
         * specified index and returns the substring from that index up to (but not including)
         * the delimiter. If the delimiter is not found or the input is null, the original string
         * is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeOrElseItself("hello.world.java", 0, ".");      // returns "hello"
         * substringBeforeOrElseItself("hello.world.java", 6, ".");      // returns "world"
         * substringBeforeOrElseItself("hello.world.java", 0, "::");     // returns "hello.world.java"
         * substringBeforeOrElseItself(null, 0, ".");                    // returns null
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param inclusiveBeginIndex The index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @return The substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified character delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLastOrElseItself("hello.world.java", '.');     // returns "hello.world"
         * substringBeforeLastOrElseItself("hello", '.');                // returns "hello"
         * substringBeforeLastOrElseItself(null, '.');                   // returns null
         * substringBeforeLastOrElseItself("hello.", '.');               // returns "hello"
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The character delimiter marking the end of the substring (exclusive).
         * @return The substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final char delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified string delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLastOrElseItself("hello::world::java", "::");     // returns "hello::world"
         * substringBeforeLastOrElseItself("hello", "::");                  // returns "hello"
         * substringBeforeLastOrElseItself(null, "::");                     // returns null
         * substringBeforeLastOrElseItself("hello::", "::");                // returns "hello"
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end of the substring (exclusive).
         * @return The substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified delimiter up to
         * the exclusive end index if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter before the specified
         * end index and returns the substring from the beginning up to (but not including) that
         * delimiter. If the delimiter is not found or the input is null, the original string is returned.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBeforeLastOrElseItself("hello.world.java", 16, ".");     // returns "hello.world"
         * substringBeforeLastOrElseItself("hello.world.java", 11, ".");     // returns "hello"
         * substringBeforeLastOrElseItself("hello", 5, ".");                 // returns "hello"
         * substringBeforeLastOrElseItself(null, 10, ".");                   // returns null
         * }</pre>
         *
         * @param str The string to search in. Can be {@code null}.
         * @param exclusiveEndIndex The index marking the end boundary for searching (exclusive).
         * @param delimiterOfExclusiveEndIndex The delimiter marking the end of the substring (exclusive).
         * @return The substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final int exclusiveEndIndex, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, exclusiveEndIndex, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin and end indices.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the exclusive end index. If the indices are invalid (negative, out of bounds,
         * or begin index >= end index), an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello world", 5, 11);     // returns Optional.of(" world")
         * substringBetween("hello", 0, 5);            // returns Optional.of("ello")
         * substringBetween("hello", 5, 10);           // returns Optional.empty() (indices out of bounds)
         * substringBetween("hello", 3, 3);            // returns Optional.empty() (begin >= end)
         * substringBetween(null, 0, 5);               // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param exclusiveBeginIndex The starting index (exclusive).
         * @param exclusiveEndIndex The ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin index and the first occurrence of the character delimiter.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the first occurrence of the delimiter character. If the delimiter is not
         * found after the begin index or indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello.world.java", 5, '.');     // returns Optional.of("world")
         * substringBetween("hello.world", 0, '.');          // returns Optional.of("ello")
         * substringBetween("hello", 0, '.');                // returns Optional.empty()
         * substringBetween(null, 0, '.');                   // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param exclusiveBeginIndex The starting index (exclusive).
         * @param delimiterOfExclusiveEndIndex The character delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, int, char)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin index and the first occurrence of the string delimiter.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the first occurrence of the delimiter string. If the delimiter is not
         * found after the begin index or indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiter.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello::world::java", 5, "::");     // returns Optional.of("world")
         * substringBetween("hello::world", 0, "::");           // returns Optional.of("ello")
         * substringBetween("hello", 0, "::");                  // returns Optional.empty()
         * substringBetween(null, 0, "::");                     // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param exclusiveBeginIndex The starting index (exclusive).
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, int, String)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the character delimiter and the specified exclusive end index.
         *
         * <p>This method extracts the substring starting after the first occurrence of the delimiter
         * character and ending before the exclusive end index. If the delimiter is not found or
         * indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello.world.java", '.', 11);     // returns Optional.of("world")
         * substringBetween("hello.world.java", '.', 20);     // returns Optional.of("world.java")
         * substringBetween("hello", '.', 10);                // returns Optional.empty()
         * substringBetween(null, '.', 10);                   // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The character delimiter marking the beginning (exclusive).
         * @param exclusiveEndIndex The ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, char, int)
         */
        public static Optional<String> substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the string delimiter and the specified exclusive end index.
         *
         * <p>This method extracts the substring starting after the first occurrence of the delimiter
         * string and ending before the exclusive end index. If the delimiter is not found or
         * indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiter.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello::world::java", "::", 13);     // returns Optional.of("world")
         * substringBetween("hello::world::java", "::", 20);     // returns Optional.of("world::java")
         * substringBetween("hello", "::", 10);                  // returns Optional.empty()
         * substringBetween(null, "::", 10);                     // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning (exclusive).
         * @param exclusiveEndIndex The ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, String, int)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrences
         * of the two specified character delimiters.
         *
         * <p>This method extracts the substring starting after the first occurrence of the begin
         * delimiter and ending before the first occurrence of the end delimiter (after the begin
         * delimiter). If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello[world]java", '[', ']');     // returns Optional.of("world")
         * substringBetween("hello.world.java", '.', '.');     // returns Optional.of("world")
         * substringBetween("hello[world", '[', ']');          // returns Optional.empty()
         * substringBetween(null, '[', ']');                   // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The character delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex The character delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, char, char)
         */
        public static Optional<String> substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between occurrences
         * of the same tag string.
         *
         * <p>This method extracts the substring between the first occurrence of the tag and
         * the next occurrence of the same tag. This is equivalent to calling
         * {@code substringBetween(str, tag, tag)}.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or tag.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("*hello*world*", "*");     // returns Optional.of("hello")
         * substringBetween("##value##", "##");        // returns Optional.of("value")
         * substringBetween("hello world", "*");       // returns Optional.empty()
         * substringBetween(null, "*");                // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param tag The tag string marking both the beginning and end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, String, String)
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final String tag) {
            return substringBetween(str, tag, tag);
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrences
         * of the two specified string delimiters.
         *
         * <p>This method extracts the substring starting after the first occurrence of the begin
         * delimiter and ending before the first occurrence of the end delimiter (after the begin
         * delimiter). If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiters.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello<start>world</end>java", "<start>", "</end>");     // returns Optional.of("world")
         * substringBetween("hello::world::java", "::", "::");                       // returns Optional.of("world")
         * substringBetween("hello<start>world", "<start>", "</end>");               // returns Optional.empty()
         * substringBetween(null, "<start>", "</end>");                              // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, String, String)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified delimiters,
         * starting the search from the given index.
         *
         * <p>This method searches for the begin delimiter starting from the specified index, then
         * extracts the substring between that delimiter and the first occurrence of the end delimiter
         * after it. If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or delimiters.</p>
         *
         * <p>Example:
         * <pre>{@code
         * substringBetween("hello<a>world</a><a>java</a>", 10, "<a>", "</a>");     // returns Optional.of("java")
         * substringBetween("hello::world::java", 0, "::", "::");                   // returns Optional.of("world")
         * substringBetween("hello::world::java", 10, "::", "::");                  // returns Optional.empty()
         * substringBetween(null, 0, "<a>", "</a>");                                // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param fromIndex The index from which to start searching.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, fromIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the exclusive begin index
         * and a dynamically calculated exclusive end index.
         *
         * <p>This method uses a function to calculate the exclusive end index based on the exclusive
         * begin index. The function receives the begin index and should return the corresponding end
         * index. If the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or function.</p>
         *
         * <p>Example:
         * <pre>{@code
         * // Extract 5 characters after the begin index
         * substringBetween("hello world", 5, beginIdx -> beginIdx + 6);     // returns Optional.of(" world")
         * 
         * // Extract until the end of the string
         * substringBetween("hello", 1, beginIdx -> 5);                      // returns Optional.of("ello")
         * 
         * substringBetween(null, 0, idx -> idx + 5);                        // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param exclusiveBeginIndex The starting index (exclusive).
         * @param funcOfExclusiveEndIndex Function to calculate the ending index based on begin index.
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, int, IntUnaryOperator)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between a dynamically calculated
         * exclusive begin index and the specified exclusive end index.
         *
         * <p>This method uses a function to calculate the exclusive begin index based on the exclusive
         * end index. The function receives the end index and should return the corresponding begin
         * index. If the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string or function.</p>
         *
         * <p>Example:
         * <pre>{@code
         * // Extract 5 characters before the end index
         * substringBetween("hello world", endIdx -> endIdx - 5, 11);     // returns Optional.of("world")
         * 
         * // Extract from the beginning
         * substringBetween("hello", endIdx -> 0, 4);                     // returns Optional.of("hell")
         * 
         * substringBetween(null, idx -> idx - 5, 10);                    // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param funcOfExclusiveBeginIndex Function to calculate the starting index based on end index.
         * @param exclusiveEndIndex The ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, IntUnaryOperator, int)
         */
        public static Optional<String> substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, funcOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the delimiter and a dynamically calculated exclusive end index.
         *
         * <p>This method finds the first occurrence of the delimiter, then uses a function to
         * calculate the exclusive end index based on the position after the delimiter. If the
         * delimiter is not found or the function returns an invalid index, an empty {@code Optional}
         * is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string, delimiter, or function.</p>
         *
         * <p>Example:
         * <pre>{@code
         * // Extract 5 characters after the delimiter
         * substringBetween("hello::world", "::", idx -> idx + 5);     // returns Optional.of("world")
         * 
         * // Extract to the end of string
         * substringBetween("key=value", "=", idx -> 10);              // returns Optional.of("value")
         * 
         * substringBetween(null, "::", idx -> idx + 5);               // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex The string delimiter marking the beginning (exclusive).
         * @param funcOfExclusiveEndIndex Function to calculate the ending index based on delimiter position.
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex,
                final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between a dynamically calculated
         * exclusive begin index and the last occurrence of the delimiter.
         *
         * <p>This method finds the last occurrence of the delimiter, then uses a function to
         * calculate the exclusive begin index based on the delimiter position. The function receives
         * the delimiter position and should return the begin index. If the delimiter is not found
         * or the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for null input string, delimiter, or function.</p>
         *
         * <p>Example:
         * <pre>{@code
         * // Extract from 5 characters before the last delimiter
         * substringBetween("hello.world.java", idx -> idx - 5, ".");     // returns Optional.of("world")
         * 
         * // Extract from the beginning
         * substringBetween("prefix::value", idx -> 0, "::");             // returns Optional.of("prefix")
         * 
         * substringBetween(null, idx -> idx - 5, ".");                   // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to extract from. Can be {@code null}.
         * @param funcOfExclusiveBeginIndex Function to calculate the starting index based on delimiter position.
         * @param delimiterOfExclusiveEndIndex The string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, funcOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Attempts to parse the given string as an integer and returns an {@code OptionalInt}.
         *
         * <p>This method handles various integer formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It returns an empty {@code OptionalInt} if the string
         * is blank, null, or cannot be parsed as a valid integer.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createInteger("123");        // returns OptionalInt.of(123)
         * createInteger("-456");       // returns OptionalInt.of(-456)
         * createInteger("0xFF");       // returns OptionalInt.of(255)
         * createInteger("077");        // returns OptionalInt.of(63) - octal
         * createInteger("abc");        // returns OptionalInt.empty()
         * createInteger("");           // returns OptionalInt.empty()
         * createInteger(null);         // returns OptionalInt.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code OptionalInt} containing the parsed integer value, or empty if parsing fails.
         * @see Numbers#createInteger(String)
         */
        @Beta
        public static u.OptionalInt createInteger(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalInt.empty();
            }

            try {
                return u.OptionalInt.of(Numbers.createInteger(str));
            } catch (final NumberFormatException e) {
                return u.OptionalInt.empty();
            }
        }

        /**
         * Attempts to parse the given string as a long and returns an {@code OptionalLong}.
         *
         * <p>This method handles various long formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It returns an empty {@code OptionalLong} if the string
         * is blank, null, or cannot be parsed as a valid long.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createLong("123456789");        // returns OptionalLong.of(123456789L)
         * createLong("-9876543210");      // returns OptionalLong.of(-9876543210L)
         * createLong("0xFFFFFFFF");       // returns OptionalLong.of(4294967295L)
         * createLong("0777");             // returns OptionalLong.of(511L) - octal
         * createLong("abc");              // returns OptionalLong.empty()
         * createLong("");                 // returns OptionalLong.empty()
         * createLong(null);               // returns OptionalLong.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code OptionalLong} containing the parsed long value, or empty if parsing fails.
         * @see Numbers#createLong(String)
         */
        @Beta
        public static u.OptionalLong createLong(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalLong.empty();
            }

            try {
                return u.OptionalLong.of(Numbers.createLong(str));
            } catch (final NumberFormatException e) {
                return u.OptionalLong.empty();
            }
        }

        /**
         * Attempts to parse the given string as a float and returns an {@code OptionalFloat}.
         *
         * <p>This method handles standard floating-point formats including decimal notation
         * and scientific notation. It returns an empty {@code OptionalFloat} if the string
         * is blank, null, or cannot be parsed as a valid float.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createFloat("123.45");          // returns OptionalFloat.of(123.45f)
         * createFloat("-67.89");          // returns OptionalFloat.of(-67.89f)
         * createFloat("1.23e4");          // returns OptionalFloat.of(12300.0f)
         * createFloat("NaN");             // returns OptionalFloat.of(Float.NaN)
         * createFloat("Infinity");        // returns OptionalFloat.of(Float.POSITIVE_INFINITY)
         * createFloat("abc");             // returns OptionalFloat.empty()
         * createFloat("");                // returns OptionalFloat.empty()
         * createFloat(null);              // returns OptionalFloat.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code OptionalFloat} containing the parsed float value, or empty if parsing fails.
         * @see Numbers#createFloat(String)
         */
        @Beta
        public static u.OptionalFloat createFloat(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalFloat.empty();
            }

            try {
                return u.OptionalFloat.of(Numbers.createFloat(str));
            } catch (final NumberFormatException e) {
                return u.OptionalFloat.empty();
            }
        }

        /**
         * Attempts to parse the given string as a double and returns an {@code OptionalDouble}.
         *
         * <p>This method handles standard floating-point formats including decimal notation
         * and scientific notation. It returns an empty {@code OptionalDouble} if the string
         * is blank, null, or cannot be parsed as a valid double.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createDouble("123.456789");      // returns OptionalDouble.of(123.456789)
         * createDouble("-67.89012");       // returns OptionalDouble.of(-67.89012)
         * createDouble("1.23456e10");      // returns OptionalDouble.of(1.23456E10)
         * createDouble("NaN");             // returns OptionalDouble.of(Double.NaN)
         * createDouble("Infinity");        // returns OptionalDouble.of(Double.POSITIVE_INFINITY)
         * createDouble("abc");             // returns OptionalDouble.empty()
         * createDouble("");                // returns OptionalDouble.empty()
         * createDouble(null);              // returns OptionalDouble.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code OptionalDouble} containing the parsed double value, or empty if parsing fails.
         * @see Numbers#createDouble(String)
         */
        @Beta
        public static u.OptionalDouble createDouble(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalDouble.empty();
            }

            try {
                return u.OptionalDouble.of(Numbers.createDouble(str));
            } catch (final NumberFormatException e) {
                return u.OptionalDouble.empty();
            }
        }

        /**
         * Attempts to parse the given string as a BigInteger and returns an {@code Optional<BigInteger>}.
         *
         * <p>This method handles various integer formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It can handle values larger than Long.MAX_VALUE. It returns
         * an empty {@code Optional} if the string is blank, null, or cannot be parsed as a valid BigInteger.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createBigInteger("123456789012345678901234567890");     // returns Optional of the BigInteger
         * createBigInteger("-999999999999999999999999999999");    // returns Optional of the BigInteger
         * createBigInteger("0xFF");                               // returns Optional.of(BigInteger.valueOf(255))
         * createBigInteger("077");                                // returns Optional.of(BigInteger.valueOf(63))
         * createBigInteger("abc");                                // returns Optional.empty()
         * createBigInteger("");                                   // returns Optional.empty()
         * createBigInteger(null);                                 // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code Optional<BigInteger>} containing the parsed BigInteger value, or empty if parsing fails.
         * @see Numbers#createBigInteger(String)
         */
        @Beta
        public static u.Optional<BigInteger> createBigInteger(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createBigInteger(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }

        /**
         * Attempts to parse the given string as a BigDecimal and returns an {@code Optional<BigDecimal>}.
         *
         * <p>This method handles standard decimal notation and scientific notation. It provides
         * arbitrary precision decimal arithmetic. It returns an empty {@code Optional} if the string
         * is blank, null, or cannot be parsed as a valid BigDecimal.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createBigDecimal("123.456789012345678901234567890");     // returns Optional of the BigDecimal
         * createBigDecimal("-999999999999999999999.999999999");    // returns Optional of the BigDecimal
         * createBigDecimal("1.23456E+10");                         // returns Optional of the BigDecimal
         * createBigDecimal("NaN");                                 // returns Optional.empty()
         * createBigDecimal("abc");                                 // returns Optional.empty()
         * createBigDecimal("");                                    // returns Optional.empty()
         * createBigDecimal(null);                                  // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code Optional<BigDecimal>} containing the parsed BigDecimal value, or empty if parsing fails.
         * @see Numbers#createBigDecimal(String)
         */
        @Beta
        public static u.Optional<BigDecimal> createBigDecimal(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createBigDecimal(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }

        /**
         * Attempts to parse the given string as a Number and returns an {@code Optional<Number>}.
         *
         * <p>This method automatically determines the most appropriate Number type based on the
         * string format and value. It handles integers, longs, floats, doubles, BigIntegers, and
         * BigDecimals, including hexadecimal and octal formats. It returns an empty {@code Optional}
         * if the string is blank, null, or cannot be parsed as a valid number.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p>Example:
         * <pre>{@code
         * createNumber("123");                    // returns Optional.of(Integer 123)
         * createNumber("1234567890123456789");    // returns Optional.of(Long or BigInteger)
         * createNumber("123.45");                 // returns Optional.of(Float 123.45)
         * createNumber("123.456789012345");       // returns Optional.of(Double)
         * createNumber("0xFF");                   // returns Optional.of(Integer 255)
         * createNumber("abc");                    // returns Optional.empty()
         * createNumber("");                       // returns Optional.empty()
         * createNumber(null);                     // returns Optional.empty()
         * }</pre>
         *
         * @param str The string to parse. Can be {@code null} or blank.
         * @return {@code Optional<Number>} containing the parsed Number value, or empty if parsing fails.
         * @see Numbers#createNumber(String)
         */
        @Beta
        public static u.Optional<Number> createNumber(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createNumber(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }
    }
}
