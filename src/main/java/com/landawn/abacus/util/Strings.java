/*
 * Copyright (c) 2015, Haiyang Li.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.landawn.abacus.util;

import static com.landawn.abacus.util.WD._BACKSLASH;
import static com.landawn.abacus.util.WD._QUOTATION_D;
import static com.landawn.abacus.util.WD._QUOTATION_S;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;
import java.util.Collection;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.RandomAccess;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.lang.model.SourceVersion;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.MayReturnNull;
import com.landawn.abacus.logging.Logger;
import com.landawn.abacus.logging.LoggerFactory;
import com.landawn.abacus.util.u.Optional;
import com.landawn.abacus.util.u.OptionalChar;
import com.landawn.abacus.util.stream.IntStream;
import com.landawn.abacus.util.stream.Stream;

/**
 * A comprehensive utility class providing an extensive collection of static methods for string operations,
 * manipulations, validations, and transformations. This class serves as the primary string utility facade
 * in the Abacus library, offering null-safe, performance-optimized operations for all common string
 * processing needs.
 *
 * <p>The {@code Strings} class is designed as an abstract sealed class that provides a comprehensive
 * string manipulation API covering validation, transformation, searching, parsing, encoding, and
 * formatting operations. All methods are static and thread-safe, with a focus on null-safety and
 * performance optimization.</p>
 *
 * <p><b>Key Features:</b>
 * <ul>
 *   <li><b>Null-Safe Operations:</b> All methods handle null inputs gracefully without throwing exceptions</li>
 *   <li><b>Comprehensive Coverage:</b> Complete set of string operations from basic to advanced</li>
 *   <li><b>Performance Optimized:</b> Efficient algorithms with minimal object allocation</li>
 *   <li><b>Unicode Support:</b> Full Unicode character support and normalization</li>
 *   <li><b>Encoding Support:</b> Base64, URL encoding, and character set conversions</li>
 *   <li><b>Pattern Matching:</b> Regular expression utilities and wildcard matching</li>
 *   <li><b>Validation Utilities:</b> Email, URL, identifier, and format validation</li>
 *   <li><b>Case Operations:</b> Comprehensive case conversion and comparison utilities</li>
 * </ul>
 *
 * <p><b>Core Functional Categories:</b>
 * <ul>
 *   <li><b>Validation:</b> isEmpty, isBlank, isEmail, isJavaIdentifier, isBase64</li>
 *   <li><b>Transformation:</b> reverse, abbreviate, capitalize, uncapitalize, swapCase</li>
 *   <li><b>Case Operations:</b> upperCase, lowerCase, toCamelCase, toSnakeCase, toPascalCase</li>
 *   <li><b>Padding:</b> leftPad, rightPad, center with character or string padding</li>
 *   <li><b>Trimming:</b> trim, strip, trimToNull, stripToNull with whitespace handling</li>
 *   <li><b>Searching:</b> indexOf, lastIndexOf, contains, startsWith, endsWith</li>
 *   <li><b>Replacement:</b> replace, replaceAll, replaceFirst with pattern support</li>
 *   <li><b>Comparison:</b> equals, equalsIgnoreCase, compare with locale support</li>
 *   <li><b>Parsing:</b> parseBoolean, parseInt, parseDouble with safe conversion</li>
 *   <li><b>Encoding:</b> base64Encode, base64Decode, urlEncode, urlDecode</li>
 *   <li><b>Joining/Splitting:</b> join, split with delimiter and pattern support</li>
 *   <li><b>Extraction:</b> extractNumbers, extractEmails, extractPatterns</li>
 * </ul>
 *
 * <p><b>Design Philosophy:</b>
 * <ul>
 *   <li><b>Null Safety:</b> Methods handle {@code null} inputs gracefully, typically returning
 *       {@code null}, empty strings, or sensible defaults rather than throwing exceptions</li>
 *   <li><b>Empty over Null:</b> Methods prefer returning empty strings over {@code null} when appropriate</li>
 *   <li><b>Exception Minimization:</b> Exceptions are thrown only when method contracts are violated
 *       (e.g., invalid parameters), not for edge cases like {@code null} inputs</li>
 *   <li><b>Performance First:</b> Optimized implementations with minimal object allocation</li>
 *   <li><b>Consistent API:</b> Uniform method naming and parameter conventions across all operations</li>
 * </ul>
 *
 * <p><b>Usage Examples:</b></p>
 * <pre>{@code
 * // Null-safe validation operations
 * boolean empty = Strings.isEmpty(null);                // Returns true
 * boolean blank = Strings.isBlank("   ");               // Returns true
 * boolean email = Strings.isEmail("user@domain.com");   // Returns true
 *
 * // Safe transformation operations
 * String reversed    = Strings.reverse(null);                  // Returns null
 * String abbrev      = Strings.abbreviate("Hello World", 8);   // Returns "Hello..."
 * String capitalized = Strings.capitalize("hello");            // Returns "Hello"
 * String camelCase   = Strings.toCamelCase("hello_world");     // Returns "helloWorld"
 *
 * // Padding and alignment operations
 * String padded   = Strings.leftPad("123", 5, '0');    // Returns "00123"
 * String centered = Strings.center("Hi", 6);           // Returns "  Hi  "
 * String trimmed  = Strings.trim("  text  ");          // Returns "text"
 *
 * // Search and replace operations
 * int index       = Strings.indexOf("Hello World", "World");           // Returns 6
 * String replaced = Strings.replace("Hello World", "World", "Java");   // Returns "Hello Java"
 * int count       = Strings.countMatches("abcabc", "abc");             // Returns 2
 *
 * // Encoding and decoding operations
 * String encoded    = Strings.base64Encode("Hello");      // Base64 encoding
 * String decoded    = Strings.base64Decode(encoded);      // Base64 decoding
 * String urlEncoded = Strings.urlEncode("Hello World");   // URL encoding
 *
 * // Pattern extraction and validation
 * String firstEmail      = Strings.findFirstEmailAddress("Contact: user@domain.com or admin@site.org");
 * List<String> allEmails = Strings.findAllEmailAddresses(text);
 * String firstNumber     = Strings.extractFirstInteger("Price: $123.45");
 * String firstDouble     = Strings.extractFirstDouble("Value: 123.45kg");
 *
 * // Advanced string building and manipulation
 * String joined     = Strings.join(Arrays.asList("a", "b", "c"), ", ");   // Returns "a, b, c"
 * String[] split    = Strings.split("a,b,c", ",");   // Returns ["a", "b", "c"]
 * String normalized = Strings.normalize("caf√©");     // Unicode normalization
 * }</pre>
 *
 * <p><b>Performance Characteristics:</b>
 * <ul>
 *   <li><b>Memory Efficient:</b> Minimal object allocation and string copying</li>
 *   <li><b>Cache Friendly:</b> Sequential character processing where possible</li>
 *   <li><b>Algorithm Selection:</b> Optimal algorithms chosen based on string length and operation type</li>
 *   <li><b>Pattern Compilation:</b> Efficient regex pattern handling and caching</li>
 *   <li><b>Buffer Management:</b> Smart buffer sizing for concatenation operations</li>
 * </ul>
 *
 * <p><b>Thread Safety:</b>
 * <ul>
 *   <li><b>Stateless Design:</b> All static methods are stateless and thread-safe</li>
 *   <li><b>Immutable Operations:</b> String immutability ensures thread safety</li>
 *   <li><b>No Shared State:</b> No static mutable fields that could cause race conditions</li>
 *   <li><b>Concurrent Access:</b> Safe for concurrent access from multiple threads</li>
 * </ul>
 *
 * <p><b>Validation Operations:</b>
 * <ul>
 *   <li><b>Empty/Blank Checking:</b> {@code Strings.isEmpty()}, {@code Strings.isBlank()}, {@code Strings.isNotEmpty()}, {@code Strings.isNotBlank()}</li>
 *   <li><b>Format Validation:</b> {@code Strings.isEmail()}, {@code Strings.isBase64()}</li>
 *   <li><b>Identifier Validation:</b> {@code Strings.isJavaIdentifier()}, {@code Strings.isValidIdentifier()}</li>
 *   <li><b>Pattern Matching:</b> {@code Strings.matches()}, {@code Strings.matchesIgnoreCase()}</li>
 * </ul>
 *
 * <p><b>Case Operations:</b>
 * <ul>
 *   <li><b>Basic Case:</b> {@code Strings.upperCase()}, {@code Strings.lowerCase()}, {@code Strings.swapCase()}</li>
 *   <li><b>Word Case:</b> {@code Strings.capitalize()}, {@code Strings.uncapitalize()}, {@code Strings.capitalizeWords()}</li>
 *   <li><b>Naming Conventions:</b> {@code Strings.toCamelCase()}, {@code Strings.toSnakeCase()}, {@code Strings.toPascalCase()}</li>
 *   <li><b>Locale Support:</b> Locale-aware case conversion operations</li>
 * </ul>
 *
 * <p><b>Encoding/Decoding Support:</b>
 * <ul>
 *   <li><b>Base64:</b> {@code Strings.base64Encode()}, {@code Strings.base64Decode()} with standard and URL-safe variants</li>
 *   <li><b>URL Encoding:</b> {@code Strings.urlEncode()}, {@code Strings.urlDecode()} with charset support</li>
 *   <li><b>Unicode:</b> {@code Strings.normalize()}, {@code Strings.toUnicode()}, {@code Strings.fromUnicode()}</li>
 *   <li><b>Character Sets:</b> Support for various character encodings</li>
 * </ul>
 *
 * <p><b>Pattern Extraction:</b>
 * <ul>
 *   <li><b>Email Extraction:</b> {@code Strings.findFirstEmailAddress()}, {@code Strings.findAllEmailAddresses()}</li>
 *   <li><b>Number Extraction:</b> {@code Strings.extractFirstInteger()}, {@code Strings.extractFirstDouble()}</li>
 *   <li><b>Custom Patterns:</b> Regular expression-based extraction utilities</li>
 *   <li><b>Replacement:</b> {@code Strings.replaceFirstInteger()}, {@code Strings.replaceFirstDouble()}</li>
 * </ul>
 *
 * <p><b>Error Handling Strategy:</b>
 * <ul>
 *   <li><b>Graceful Degradation:</b> Methods handle edge cases without throwing exceptions</li>
 *   <li><b>Null Tolerance:</b> Comprehensive null input handling throughout the API</li>
 *   <li><b>Sensible Defaults:</b> Return appropriate default values for invalid inputs</li>
 *   <li><b>Clear Contracts:</b> Method documentation clearly specifies behavior and exceptions</li>
 * </ul>
 *
 * <p><b>Integration with Java Ecosystem:</b>
 * <ul>
 *   <li><b>String Compatibility:</b> Seamless integration with java.lang.String</li>
 *   <li><b>Pattern Support:</b> Full java.util.regex.Pattern integration</li>
 *   <li><b>Locale Support:</b> Internationalization and localization features</li>
 *   <li><b>Stream Integration:</b> Works well with Java 8+ Stream operations</li>
 * </ul>
 *
 * <p><b>Best Practices:</b>
 * <ul>
 *   <li>Use {@code Strings} utilities instead of manual null checking and string manipulation</li>
 *   <li>Prefer the null-safe methods for robust code</li>
 *   <li>Use validation methods before string processing operations</li>
 *   <li>Leverage the encoding utilities for safe data transmission</li>
 *   <li>Take advantage of the pattern extraction methods for data parsing</li>
 *   <li>Use case conversion utilities for consistent data formatting</li>
 * </ul>
 *
 * <p><b>Performance Tips:</b>
 * <ul>
 *   <li>Use bulk operations for multiple string transformations</li>
 *   <li>Prefer {@code StringBuilder} for complex string building outside of utility methods</li>
 *   <li>Cache compiled regex patterns for repeated pattern matching</li>
 *   <li>Use appropriate buffer sizes for large string operations</li>
 *   <li>Consider locale-specific operations only when necessary</li>
 * </ul>
 *
 * <p><b>Common Patterns:</b>
 * <ul>
 *   <li><b>Validation:</b> {@code if (Strings.isNotBlank(input)) { ... }}</li>
 *   <li><b>Safe Conversion:</b> {@code String safe     = Strings.defaultIfNull(value, "");}</li>
 *   <li><b>Case Conversion:</b> {@code String camel    = Strings.toCamelCase(snakeCase);}</li>
 *   <li><b>Pattern Extraction:</b> {@code String email = Strings.findFirstEmailAddress(text);}</li>
 * </ul>
 *
 * <p><b>Related Utility Classes:</b>
 * <ul>
 *   <li><b>{@link Joiner}:</b> Specialized string joining operations</li>
 *   <li><b>{@link Splitter}:</b> Advanced string splitting utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.RegExUtil}:</b> Regular expression utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.URLEncodedUtil}:</b> URL encoding/decoding utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.N}:</b> General utility class with string operations</li>
 *   <li><b>{@link java.lang.String}:</b> Core Java string class</li>
 *   <li><b>{@link java.util.regex.Pattern}:</b> Regular expression patterns</li>
 * </ul>
 *
 * <p><b>Example: Text Processing Pipeline</b>
 * <pre>{@code
 * // Comprehensive text processing example
 * String rawInput = "  Contact: John.Doe@COMPANY.COM, Phone: 123-456-7890  ";
 *
 * // Validation and cleaning
 * if (Strings.isNotBlank(rawInput)) {
 *     String cleaned = Strings.trim(rawInput);
 *
 *     // Extract structured data
 *     String email = Strings.findFirstEmailAddress(cleaned);
 *     String phone = Strings.extractFirstInteger(cleaned);
 *
 *     // Format email properly
 *     if (Strings.isEmail(email)) {
 *         email = Strings.lowerCase(email);
 *         
 *         // Extract name from email
 *         String namePart = Strings.substringBefore(email, "@");
 *         String displayName = Strings.replace(namePart, ".", " ");
 *         displayName = Strings.capitalizeWords(displayName);
 *         
 *         // Build formatted result
 *         String result = Strings.join(Arrays.asList(
 *             "Name: " + displayName,
 *             "Email: " + email,
 *             "Phone: " + phone
 *         ), "\n");
 *         
 *         System.out.println(result);
 *         // Output:
 *         // Name: John Doe
 *         // Email: john.doe@company.com
 *         // Phone: 1234567890
 *     }
 * }
 *
 * // Base64 encoding example
 * String data    = "Sensitive data to encode";
 * String encoded = Strings.base64Encode(data);
 * String decoded = Strings.base64Decode(encoded);
 * }</pre>
 *
 * <p><b>Attribution:</b>
 * This class includes code adapted from Apache Commons Lang, Google Guava, and other
 * open source projects under the Apache License 2.0. Methods from these libraries may have been
 * modified for consistency, performance optimization, and null-safety enhancement.
 *
 * @see Joiner
 * @see Splitter
 * @see com.landawn.abacus.util.RegExUtil
 * @see com.landawn.abacus.util.N
 * @see com.landawn.abacus.util.Array
 * @see com.landawn.abacus.util.Iterables
 * @see com.landawn.abacus.util.Iterators
 * @see com.landawn.abacus.util.Maps
 * @see com.landawn.abacus.util.URLEncodedUtil
 * @see com.landawn.abacus.util.AppendableWriter
 * @see com.landawn.abacus.util.StringWriter
 * @see com.landawn.abacus.util.IEEE754rUtil
 */
@SuppressWarnings({ "java:S1694", "UnnecessaryUnicodeEscape" })
public final class Strings {

    private static final Logger LOGGER = LoggerFactory.getLogger(Strings.class);

    /**
     * String with value {@code "null"}.
     */
    @Beta
    public static final String NULL = "null";

    /**
     *
     * Char array with value {@code "['n', 'u', 'l', 'l']"}.
     */
    static final char[] NULL_CHAR_ARRAY = NULL.toCharArray();

    /**
     * The empty String {@code ""}.
     */
    public static final String EMPTY = "";

    //    /**
    //     * The empty String {@code ""}.
    //     * @deprecated Use {@link #EMPTY_STRING} instead
    //     */
    //    @Deprecated
    //    public static final String EMPTY = EMPTY_STRING;

    /**
     * A String for a space character: {@code " "}.
     */
    public static final String SPACE = WD.SPACE;

    /**
     * A String for linefeed LF ("\n").
     *
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences
     *      for Character and String Literals</a>
     */
    public static final String LF = "\n";

    /**
     * A String for carriage return CR ("\r").
     *
     * @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6">JLF: Escape Sequences
     *      for Character and String Literals</a>
     */
    public static final String CR = "\r";

    /**
     * Carriage return followed by line feed. This is the line ending used on Windows.
     */
    public static final String CR_LF = "\r\n";

    /**
     * The null character (character with value 0).
     */
    @Beta
    public static final char CHAR_ZERO = (char) 0;

    /**
     * The space character ' '.
     */
    @Beta
    public static final char CHAR_SPACE = WD._SPACE;

    /**
     * The line feed character '\n' (newline on Unix systems).
     */
    @Beta
    public static final char CHAR_LF = LF.charAt(0);

    /**
     * The carriage return character '\r' (part of line ending on Windows systems).
     */
    @Beta
    public static final char CHAR_CR = CR.charAt(0);

    /**
     * Field COMMA_SPACE (value is {@code ", "})
     */
    public static final String COMMA_SPACE = WD.COMMA_SPACE;

    /**
     * Value is {@code ", "}
     */
    public static final String ELEMENT_SEPARATOR = COMMA_SPACE;

    static final char[] ELEMENT_SEPARATOR_CHAR_ARRAY = ELEMENT_SEPARATOR.toCharArray();

    static final String TRUE = Boolean.TRUE.toString().intern();

    static final char[] TRUE_CHAR_ARRAY = TRUE.toCharArray();

    static final String FALSE = Boolean.FALSE.toString().intern();

    static final char[] FALSE_CHAR_ARRAY = FALSE.toCharArray();

    static final String BACKSLASH_ASTERISK = "*";

    static final String STR_FOR_EMPTY_ARRAY = "[]";

    // java.lang.ExceptionInInitializerError: Exception java.lang.NoClassDefFoundError: Could not initialize class com.landawn.abacus.util.WD [in thread "main"]
    //    static final Set<String> CASE_INSENSITIVE_KEYWORDS = Set.of(" ", ", ", ";", ":", ":", ":", "=", "|", "&", "@", "$", "*", "+", "-", "_", "#", "!", "<", ">",
    //            "~", "^", "%", "\"", "'", "`", "{", "}", "[", "]", "(", ")", "?", "/", "\\", ".", ",", ";", ":", "!", "@", "#", "$", "%", "^", "&", "*");

    /**
     * A regex pattern for recognizing blocks of whitespace characters.
     * The apparent convolutedness of the pattern serves the purpose of ignoring
     * "blocks" consisting of only a single space: the pattern is used only to
     * normalize whitespace, condensing "blocks" down to a single space, thus
     * matching the same would likely cause a great many noop replacements.
     */
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("(?: |\\u00A0|\\s|[\\s&&[^ ]])\\s*");//NOSONAR

    private static final Splitter lineSplitter = Splitter.forLines();
    private static final Splitter trimLineSplitter = Splitter.forLines().trimResults();
    private static final Splitter omitEmptyLinesLineSplitter = Splitter.forLines().omitEmptyStrings();
    private static final Splitter trimAndOmitEmptyLinesLineSplitter = Splitter.forLines().trimResults().omitEmptyStrings();

    private static final Encoder BASE64_ENCODER = java.util.Base64.getEncoder();

    private static final Decoder BASE64_DECODER = java.util.Base64.getDecoder();

    private static final Encoder BASE64_URL_ENCODER = java.util.Base64.getUrlEncoder().withoutPadding();

    private static final Decoder BASE64_URL_DECODER = java.util.Base64.getUrlDecoder();

    private Strings() {
        // Utility class.
    }

    /**
     * Generates a new universally unique identifier (UUID) string.
     *
     * <p>This method creates a standard UUID using {@link UUID#randomUUID()} and returns it
     * as a string in the canonical format with hyphens (8-4-4-4-12 format).</p>
     *
     * <p>The UUID is generated using a cryptographically strong pseudo random number generator.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String uuid = uuid();   // returns something like "550e8400-e29b-41d4-a716-446655440000"
     * 
     * // Common use cases
     * String id = uuid();                   // returns "123e4567-e89b-12d3-a456-426614174000"
     * String uniqueKey = "KEY_" + uuid();   // returns "KEY_123e4567-e89b-12d3-a456-426614174000"
     * }</pre>
     *
     * @return a new UUID string in the standard format (8-4-4-4-12).
     * @see #guid()
     * @see UUID#randomUUID()
     */
    public static String uuid() {
        return UUID.randomUUID().toString();
    }

    /**
     * Generates a new globally unique identifier (GUID) string without hyphens.
     *
     * <p>This method creates a UUID using {@link UUID#randomUUID()} and removes all hyphen characters
     * to produce a continuous string of 32 hexadecimal characters.</p>
     *
     * <p>The returned string is suitable for use cases where a unique identifier is needed without
     * the standard UUID hyphen separators.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String guid = guid();   // returns something like "550e8400e29b41d4a716446655440000"
     * 
     * // Common use cases
     * String sessionId = "SESSION_" + guid();        // returns "SESSION_550e8400e29b41d4a716446655440000"
     * String fileName = "temp_" + guid() + ".txt";   // returns "temp_550e8400e29b41d4a716446655440000.txt"
     * }</pre>
     *
     * @return a new UUID string without hyphens, consisting of 32 hexadecimal characters.
     * @see #uuid()
     * @see UUID#randomUUID()
     */
    public static String guid() {
        return uuid().replace("-", "");
    }

    /**
     * Converts the provided character array into a String.
     *
     * <p>This method provides a null-safe way to convert a character array to a String.
     * If the input array is {@code null}, the method returns {@code null} rather than
     * throwing a NullPointerException.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'h', 'e', 'l', 'l', 'o'};
     * Strings.valueOf(chars);                        // returns "hello"
     * Strings.valueOf(new char[] {'a', 'b', 'c'});   // returns "abc"
     * Strings.valueOf(new char[0]);                  // returns ""
     * Strings.valueOf(null);                         // returns null
     * }</pre>
     *
     * @param value the character array to be converted, may be {@code null}
     * @return a String representation of the character array. Returns {@code null} if <i>value</i> is {@code null}.
     * @see String#valueOf(char[])
     * @see N#toString(Object)
     */
    @MayReturnNull
    public static String valueOf(final char[] value) {
        return value == null ? null : String.valueOf(value);
    }

    /**
      * Checks if the given CharSequence is a valid Java identifier.
      *
      * <p>A valid Java identifier must start with a letter, a currency character ($), or a connecting character such as underscore (_).
      * Identifiers cannot start with a number, and they cannot be a Java keyword or boolean literal (true or false).
      * Subsequent characters may include letters, digits, currency characters, or connecting characters.</p>
      *
      * <p>The method returns {@code false} for {@code null} or empty input.</p>
      *
      * <p><b>Usage Examples:</b></p>
      * <pre>{@code
      * // Valid Java identifiers
      * Strings.isValidJavaIdentifier("myVariable");      // returns true
      * Strings.isValidJavaIdentifier("_privateField");   // returns true
      * Strings.isValidJavaIdentifier("$money");          // returns true
      * Strings.isValidJavaIdentifier("MAX_VALUE");       // returns true
      * Strings.isValidJavaIdentifier("userId123");       // returns true
      * 
      * // Invalid Java identifiers
      * Strings.isValidJavaIdentifier(null);              // returns false
      * Strings.isValidJavaIdentifier("");                // returns false
      * Strings.isValidJavaIdentifier("   ");             // returns false
      * Strings.isValidJavaIdentifier("123abc");          // returns false (starts with digit)
      * }</pre>
      *
      * @param cs the CharSequence to be checked, may be {@code null} or empty
      * @return {@code true} if the CharSequence is a valid Java identifier, {@code false} otherwise.
      * @see Character#isJavaIdentifierStart(char)
      * @see Character#isJavaIdentifierPart(char)
      * @see <a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-3.html#jls-3.8">Java Language Specification - Identifiers</a>
      */
    public static boolean isValidJavaIdentifier(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.JAVA_IDENTIFIER_MATCHER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a Java keyword.
     *
     * <p>This method verifies whether the provided CharSequence matches any of the reserved
     * keywords in the Java programming language, based on the latest source version supported
     * by the runtime environment. Java keywords include reserved words like
     * {@code class}, {@code public}, {@code if}, {@code else}, etc.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Java keywords
     * Strings.isKeyword("class");        // returns true
     * Strings.isKeyword("public");       // returns true
     * Strings.isKeyword("if");           // returns true
     * Strings.isKeyword("return");       // returns true
     * 
     * // Not Java keywords
     * Strings.isKeyword("Class");        // returns false (case sensitive)
     * Strings.isKeyword("myVariable");   // returns false
     * Strings.isKeyword(null);           // returns false
     * Strings.isKeyword("");             // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence is a Java keyword, {@code false} otherwise.
     * @see javax.lang.model.SourceVersion#isKeyword(CharSequence)
     */
    public static boolean isKeyword(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return SourceVersion.isKeyword(cs);
    }

    /**
     * Checks if the given CharSequence is a valid email address.
     *
     * <p>This method uses a regular expression (RFC 5322) to validate the email address. It checks for the general form of an email address
     * which is "local-part@domain". The local-part can contain alphanumeric characters and special characters like !, #, $, %, &amp;, ', *, +, -, /, =, ?, ^, _, `, {, |, } and ~.
     * The domain part contains at least one dot (.) and can contain alphanumeric characters as well as hyphens (-).</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid email addresses
     * Strings.isValidEmailAddress("user@example.com");         // returns true
     * Strings.isValidEmailAddress("john.doe@company.org");     // returns true
     * Strings.isValidEmailAddress("admin+tag@domain.co.uk");   // returns true
     * 
     * // Invalid email addresses
     * Strings.isValidEmailAddress("invalid.email");            // returns false (no @ symbol)
     * Strings.isValidEmailAddress("@example.com");             // returns false (no local part)
     * Strings.isValidEmailAddress("user@");                    // returns false (no domain)
     * Strings.isValidEmailAddress(null);                       // returns false
     * Strings.isValidEmailAddress("");                         // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence is a valid email address, {@code false} otherwise.
     * @see #findFirstEmailAddress(CharSequence)
     * @see #findAllEmailAddresses(CharSequence)
     */
    public static boolean isValidEmailAddress(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.EMAIL_ADDRESS_RFC_5322_MATCHER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a valid URL.
     *
     * <p>This method uses a regular expression to validate the URL. It checks for the general form of a URL
     * which includes protocol, domain, port, path, query parameters, and fragment identifier.
     * The URL can start with various protocols including http, https, ftp, file, etc.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid URLs
     * Strings.isValidUrl("http://www.example.com");            // returns true
     * Strings.isValidUrl("https://example.com:8080/path");     // returns true
     * Strings.isValidUrl("ftp://files.example.com/doc.pdf");   // returns true
     * Strings.isValidUrl("file://C:/Users/doc.txt");           // returns true
     * 
     * // Invalid URLs
     * Strings.isValidUrl("not a url");                         // returns false
     * Strings.isValidUrl("www.example.com");                   // returns false (no protocol)
     * Strings.isValidUrl(null);                                // returns false
     * Strings.isValidUrl("");                                  // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence is a valid URL, {@code false} otherwise.
     */
    public static boolean isValidUrl(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.URL_MATCHER.matcher(cs).matches();
    }

    /**
     * Checks if the given CharSequence is a valid HTTP URL.
     *
     * <p>This method uses a regular expression to validate the URL. It checks for the general form of a URL
     * which includes protocol, domain, port, path, query parameters, and fragment identifier.
     * The URL must start with http:// or https://.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid HTTP URLs
     * Strings.isValidHttpUrl("http://www.example.com");         // returns true
     * Strings.isValidHttpUrl("https://example.com/path");       // returns true
     * Strings.isValidHttpUrl("https://api.example.com:8443");   // returns true
     * 
     * // Invalid HTTP URLs
     * Strings.isValidHttpUrl("ftp://files.example.com");        // returns false (not HTTP)
     * Strings.isValidHttpUrl("www.example.com");                // returns false (no protocol)
     * Strings.isValidHttpUrl("file:///C:/doc.txt");             // returns false (not HTTP)
     * Strings.isValidHttpUrl(null);                             // returns false
     * Strings.isValidHttpUrl("");                               // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence is a valid HTTP URL, {@code false} otherwise.
     */
    public static boolean isValidHttpUrl(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        return RegExUtil.HTTP_URL_MATCHER.matcher(cs).matches();
    }

    /**
     * Checks if the specified {@code CharSequence} is {@code null} or empty.
     *
     * <p>A CharSequence is considered empty if it has zero length. This method provides
     * a null-safe way to check for empty strings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isEmpty(null);                  // returns true
     * Strings.isEmpty("");                    // returns true
     * Strings.isEmpty("   ");                 // returns false (contains spaces)
     * Strings.isEmpty("abc");                 // returns false
     * Strings.isEmpty(new StringBuilder());   // returns true
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null}
     * @return {@code true} if the CharSequence is {@code null} or has zero length, {@code false} otherwise.
     */
    public static boolean isEmpty(final CharSequence cs) {
        return (cs == null) || (cs.isEmpty());
    }

    /**
     * Checks if the given CharSequence is {@code null} or contains only whitespace characters.
     *
     * <p>A CharSequence is considered blank if it is {@code null}, empty, or contains only whitespace
     * characters as defined by {@link Character#isWhitespace(char)}. This includes spaces,
     * tabs, newlines, and other Unicode whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isBlank(null);        // returns true
     * Strings.isBlank("");          // returns true
     * Strings.isBlank("   ");       // returns true
     * Strings.isBlank("\t\n\r");    // returns true
     * Strings.isBlank("  abc  ");   // returns false
     * Strings.isBlank("abc");       // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence is {@code null} or contains only whitespace characters, {@code false} otherwise.
     */
    public static boolean isBlank(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        if (cs instanceof String) {
            return ((String) cs).isBlank();
        }

        for (int i = 0, len = cs.length(); i < len; i++) {
            if (!Character.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence is not {@code null} and not empty.
     *
     * <p>This method is the opposite of {@link #isEmpty(CharSequence)}. It returns {@code true}
     * when the CharSequence is not {@code null} and has at least one character.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isNotEmpty("abc");                       // returns true
     * Strings.isNotEmpty("   ");                       // returns true (contains spaces)
     * Strings.isNotEmpty(new StringBuilder("test"));   // returns true
     * Strings.isNotEmpty("");                          // returns false
     * Strings.isNotEmpty(null);                        // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null}
     * @return {@code true} if the CharSequence is not {@code null} and not empty, {@code false} otherwise.
     */
    public static boolean isNotEmpty(final CharSequence cs) {
        return (cs != null) && (!cs.isEmpty());
    }

    /**
     * Checks if the given CharSequence is not {@code null} and contains non-whitespace characters.
     *
     * <p>This method is the opposite of {@link #isBlank(CharSequence)}. It returns {@code true}
     * when the CharSequence is not {@code null} and contains at least one non-whitespace character.</p>
     *
     * <p>This method is marked as @Beta, indicating it may be subject to change in future versions.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isNotBlank("abc");       // returns true
     * Strings.isNotBlank("  abc  ");   // returns true
     * Strings.isNotBlank("   ");       // returns false (only whitespace)
     * Strings.isNotBlank("");          // returns false
     * Strings.isNotBlank(null);        // returns false
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null}
     * @return {@code true} if the CharSequence is not {@code null} and contains non-whitespace characters, {@code false} otherwise.
     */
    @Beta
    public static boolean isNotBlank(final CharSequence cs) {
        return !isBlank(cs);
    }

    /**
     * Checks if both of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when both CharSequences are either {@code null} or empty.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllEmpty(null, null);     // returns true
     * Strings.isAllEmpty("", "");         // returns true
     * Strings.isAllEmpty(null, "");       // returns true
     * Strings.isAllEmpty("", null);       // returns true
     * Strings.isAllEmpty("abc", "");      // returns false
     * Strings.isAllEmpty("", "xyz");      // returns false
     * Strings.isAllEmpty("abc", "xyz");   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @return {@code true} if both CharSequences are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAllEmpty(CharSequence, CharSequence, CharSequence)
     * @see #isAllEmpty(CharSequence...)
     * @see #isAnyEmpty(CharSequence, CharSequence)
     */
    public static boolean isAllEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when all three CharSequences are either {@code null} or empty.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllEmpty(null, null, null);   // returns true
     * Strings.isAllEmpty("", "", "");         // returns true
     * Strings.isAllEmpty(null, "", null);     // returns true
     * Strings.isAllEmpty("abc", "", "");      // returns false
     * Strings.isAllEmpty("", "xyz", "");      // returns false
     * Strings.isAllEmpty("", "", "123");      // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @param c the third CharSequence to be checked, may be {@code null}
     * @return {@code true} if all CharSequences are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAllEmpty(CharSequence, CharSequence)
     * @see #isAllEmpty(CharSequence...)
     * @see #isAnyEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static boolean isAllEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * Checks if all the CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when all provided CharSequences are either {@code null} or empty.
     * If the input array itself is {@code null} or empty, the method returns {@code true}.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllEmpty(null);              // returns true
     * Strings.isAllEmpty(null, "");          // returns true
     * Strings.isAllEmpty(new String[] {});   // returns true
     * Strings.isAllEmpty(null, "foo");       // returns false
     * Strings.isAllEmpty("", "bar");         // returns false
     * Strings.isAllEmpty("bob", "");         // returns false
     * Strings.isAllEmpty("  bob  ", null);   // returns false
     * Strings.isAllEmpty(" ", "bar");        // returns false
     * Strings.isAllEmpty("foo", "bar");      // returns false
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or null
     * @see #isEmpty(CharSequence)
     * @see #isAllEmpty(CharSequence, CharSequence)
     * @see #isAllEmpty(Iterable)
     * @see #isAnyEmpty(CharSequence...)
     */
    public static boolean isAllEmpty(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the provided CharSequences in the Iterable are empty or {@code null}.
     *
     * <p>This method returns {@code true} only when all CharSequences in the Iterable are either {@code null} or empty.
     * If the Iterable itself is {@code null} or empty, the method returns {@code true}.
     * If at least one CharSequence is not empty, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList(null, "", null);
     * Strings.isAllEmpty(list1);   // returns true
     * 
     * List<String> list2 = Arrays.asList("", "abc", "");
     * Strings.isAllEmpty(list2);               // returns false
     * 
     * Strings.isAllEmpty(null);                // returns true
     * Strings.isAllEmpty(new ArrayList<>());   // returns true
     * }</pre>
     *
     * @param css the Iterable of CharSequences to be checked, may be {@code null}
     * @return {@code true} if all CharSequences in the Iterable are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAllEmpty(CharSequence...)
     * @see #isAnyEmpty(Iterable)
     */
    public static boolean isAllEmpty(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if both of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when both CharSequences are either {@code null}, empty, or contain only whitespace.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllBlank(null, null);      // returns true
     * Strings.isAllBlank("", "");          // returns true
     * Strings.isAllBlank("   ", "\t\n");   // returns true
     * Strings.isAllBlank(null, "   ");     // returns true
     * Strings.isAllBlank("abc", "   ");    // returns false
     * Strings.isAllBlank("   ", "xyz");    // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @return {@code true} if both CharSequences are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAllBlank(CharSequence, CharSequence, CharSequence)
     * @see #isAllBlank(CharSequence...)
     * @see #isAnyBlank(CharSequence, CharSequence)
     */
    public static boolean isAllBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) && isBlank(b);
    }

    /**
     * Checks if all the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when all three CharSequences are either {@code null}, empty, or contain only whitespace.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllBlank(null, null, null);    // returns true
     * Strings.isAllBlank("", "", "");          // returns true
     * Strings.isAllBlank("   ", "\t", "\n");   // returns true
     * Strings.isAllBlank("abc", "   ", "");    // returns false
     * Strings.isAllBlank("", "xyz", "   ");    // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @param c the third CharSequence to be checked, may be {@code null}
     * @return {@code true} if all CharSequences are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAllBlank(CharSequence, CharSequence)
     * @see #isAllBlank(CharSequence...)
     * @see #isAnyBlank(CharSequence, CharSequence, CharSequence)
     */
    public static boolean isAllBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) && isBlank(b) && isBlank(c);
    }

    /**
     * Checks if all the CharSequences are blank or {@code null}.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>This method returns {@code true} only when all provided CharSequences are either {@code null}, empty, or contain only whitespace.
     * If the input array itself is {@code null} or empty, the method returns {@code true}.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllBlank(null);              // returns true
     * Strings.isAllBlank(null, "foo");       // returns false
     * Strings.isAllBlank(null, null);        // returns true
     * Strings.isAllBlank("", "bar");         // returns false
     * Strings.isAllBlank("bob", "");         // returns false
     * Strings.isAllBlank("  bob  ", null);   // returns false
     * Strings.isAllBlank(" ", "bar");        // returns false
     * Strings.isAllBlank("foo", "bar");      // returns false
     * Strings.isAllBlank(new String[] {});   // returns true
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or {@code null} or whitespace only
     * @see #isBlank(CharSequence)
     * @see #isAllBlank(CharSequence, CharSequence)
     * @see #isAllBlank(Iterable)
     * @see #isAnyBlank(CharSequence...)
     */
    public static boolean isAllBlank(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the provided CharSequences in the Iterable are blank or {@code null}.
     *
     * <p>This method returns {@code true} only when all CharSequences in the Iterable are either {@code null}, empty, or contain only whitespace.
     * If the Iterable itself is {@code null} or empty, the method returns {@code true}.
     * If at least one CharSequence contains non-whitespace characters, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList(null, "", "   ");
     * Strings.isAllBlank(list1);   // returns true
     * 
     * List<String> list2 = Arrays.asList("   ", "abc", "");
     * Strings.isAllBlank(list2);               // returns false
     * 
     * Strings.isAllBlank(null);                // returns true
     * Strings.isAllBlank(new ArrayList<>());   // returns true
     * }</pre>
     *
     * @param css the Iterable of CharSequences to be checked, may be {@code null}
     * @return {@code true} if all CharSequences in the Iterable are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAllBlank(CharSequence...)
     * @see #isAnyBlank(Iterable)
     */
    public static boolean isAllBlank(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (isNotBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if any of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the two CharSequences is either {@code null} or empty.
     * It returns {@code false} only when both CharSequences are not empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyEmpty(null, null);     // returns true
     * Strings.isAnyEmpty("", "");         // returns true
     * Strings.isAnyEmpty("abc", "");      // returns true
     * Strings.isAnyEmpty("", "xyz");      // returns true
     * Strings.isAnyEmpty(null, "xyz");    // returns true
     * Strings.isAnyEmpty("abc", "xyz");   // returns false
     * Strings.isAnyEmpty("   ", "xyz");   // returns false (spaces are not empty)
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @return {@code true} if any of the CharSequences are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAnyEmpty(CharSequence, CharSequence, CharSequence)
     * @see #isAnyEmpty(CharSequence...)
     * @see #isAllEmpty(CharSequence, CharSequence)
     */
    public static boolean isAnyEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) || isEmpty(b);
    }

    /**
     * Checks if any of the provided CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the three CharSequences is either {@code null} or empty.
     * It returns {@code false} only when all CharSequences are not empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyEmpty(null, null, null);      // returns true
     * Strings.isAnyEmpty("abc", "", "xyz");      // returns true
     * Strings.isAnyEmpty("", "def", "xyz");      // returns true
     * Strings.isAnyEmpty("abc", "def", null);    // returns true
     * Strings.isAnyEmpty("abc", "def", "xyz");   // returns false
     * Strings.isAnyEmpty("   ", "def", "xyz");   // returns false (spaces are not empty)
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @param c the third CharSequence to be checked, may be {@code null}
     * @return {@code true} if any of the CharSequences are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAnyEmpty(CharSequence, CharSequence)
     * @see #isAnyEmpty(CharSequence...)
     * @see #isAllEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static boolean isAnyEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) || isEmpty(b) || isEmpty(c);
    }

    /**
     * Checks if any of the CharSequences are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the provided CharSequences is either {@code null} or empty.
     * If the input array itself is {@code null} or has zero length, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the array are not empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyEmpty((String) null);       // returns true
     * Strings.isAnyEmpty((String[]) null);     // returns false
     * Strings.isAnyEmpty(null, "foo");         // returns true
     * Strings.isAnyEmpty("", "bar");           // returns true
     * Strings.isAnyEmpty("bob", "");           // returns true
     * Strings.isAnyEmpty("  bob  ", null);     // returns true
     * Strings.isAnyEmpty(" ", "bar");          // returns false
     * Strings.isAnyEmpty("foo", "bar");        // returns false
     * Strings.isAnyEmpty(new String[] {});     // returns false
     * Strings.isAnyEmpty(new String[] {""});   // returns true
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or null
     * @see #isEmpty(CharSequence)
     * @see #isAnyEmpty(CharSequence, CharSequence)
     * @see #isAnyEmpty(Iterable)
     * @see #isAllEmpty(CharSequence...)
     */
    public static boolean isAnyEmpty(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isEmpty(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences in the Iterable are empty or {@code null}.
     *
     * <p>This method returns {@code true} if at least one CharSequence in the Iterable is either {@code null} or empty.
     * If the Iterable itself is {@code null} or empty, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the Iterable are not empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList("abc", "", "xyz");
     * Strings.isAnyEmpty(list1);   // returns true
     * 
     * List<String> list2 = Arrays.asList("abc", "def", "xyz");
     * Strings.isAnyEmpty(list2);               // returns false
     * 
     * Strings.isAnyEmpty(null);                // returns false
     * Strings.isAnyEmpty(new ArrayList<>());   // returns false
     * }</pre>
     *
     * @param css the Iterable of CharSequences to be checked, may be {@code null}
     * @return {@code true} if any CharSequences in the Iterable are {@code null} or empty, {@code false} otherwise.
     * @see #isEmpty(CharSequence)
     * @see #isAnyEmpty(CharSequence...)
     * @see #isAllEmpty(Iterable)
     */
    public static boolean isAnyEmpty(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isEmpty(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the two CharSequences is either {@code null}, empty, or contains only whitespace.
     * It returns {@code false} only when both CharSequences contain non-whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyBlank(null, null);      // returns true
     * Strings.isAnyBlank("", "");          // returns true
     * Strings.isAnyBlank("   ", "xyz");    // returns true
     * Strings.isAnyBlank("abc", "\t\n");   // returns true
     * Strings.isAnyBlank(null, "xyz");     // returns true
     * Strings.isAnyBlank("abc", "xyz");    // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @return {@code true} if any of the CharSequences are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAnyBlank(CharSequence, CharSequence, CharSequence)
     * @see #isAnyBlank(CharSequence...)
     * @see #isAllBlank(CharSequence, CharSequence)
     */
    public static boolean isAnyBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) || isBlank(b);
    }

    /**
     * Checks if any of the provided CharSequences are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one of the three CharSequences is either {@code null}, empty, or contains only whitespace.
     * It returns {@code false} only when all CharSequences contain non-whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyBlank(null, null, null);      // returns true
     * Strings.isAnyBlank("abc", "   ", "xyz");   // returns true
     * Strings.isAnyBlank("", "def", "xyz");      // returns true
     * Strings.isAnyBlank("abc", "def", null);    // returns true
     * Strings.isAnyBlank("abc", "def", "xyz");   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to be checked, may be {@code null}
     * @param b the second CharSequence to be checked, may be {@code null}
     * @param c the third CharSequence to be checked, may be {@code null}
     * @return {@code true} if any of the CharSequences are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAnyBlank(CharSequence, CharSequence)
     * @see #isAnyBlank(CharSequence...)
     * @see #isAllBlank(CharSequence, CharSequence, CharSequence)
     */
    public static boolean isAnyBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) || isBlank(b) || isBlank(c);
    }

    /**
     * Checks if any of the CharSequences are blank or {@code null}.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>This method returns {@code true} if at least one of the provided CharSequences is either {@code null}, empty, or contains only whitespace.
     * If the input array itself is {@code null} or has zero length, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the array contain non-whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAnyBlank((String) null);       // returns true
     * Strings.isAnyBlank((String[]) null);     // returns false
     * Strings.isAnyBlank(null, "foo");         // returns true
     * Strings.isAnyBlank(null, null);          // returns true
     * Strings.isAnyBlank("", "bar");           // returns true
     * Strings.isAnyBlank("bob", "");           // returns true
     * Strings.isAnyBlank("  bob  ", null);     // returns true
     * Strings.isAnyBlank(" ", "bar");          // returns true
     * Strings.isAnyBlank(new String[] {});     // returns false
     * Strings.isAnyBlank(new String[] {""});   // returns true
     * Strings.isAnyBlank("foo", "bar");        // returns false
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or {@code null} or whitespace only
     * @see #isBlank(CharSequence)
     * @see #isAnyBlank(CharSequence, CharSequence)
     * @see #isAnyBlank(Iterable)
     * @see #isAllBlank(CharSequence...)
     */
    public static boolean isAnyBlank(final CharSequence... css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the provided CharSequences in the Iterable are blank or {@code null}.
     *
     * <p>This method returns {@code true} if at least one CharSequence in the Iterable is either {@code null}, empty, or contains only whitespace.
     * If the Iterable itself is {@code null} or empty, the method returns {@code false}.
     * It returns {@code false} only when all CharSequences in the Iterable contain non-whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList("abc", "   ", "xyz");
     * Strings.isAnyBlank(list1);   // returns true
     * 
     * List<String> list2 = Arrays.asList("abc", "def", "xyz");
     * Strings.isAnyBlank(list2);               // returns false
     * 
     * Strings.isAnyBlank(null);                // returns false
     * Strings.isAnyBlank(new ArrayList<>());   // returns false
     * }</pre>
     *
     * @param css the Iterable of CharSequences to be checked, may be {@code null}
     * @return {@code true} if any CharSequences in the Iterable are {@code null} or blank, {@code false} otherwise.
     * @see #isBlank(CharSequence)
     * @see #isAnyBlank(CharSequence...)
     * @see #isAllBlank(Iterable)
     */
    public static boolean isAnyBlank(final Iterable<? extends CharSequence> css) {
        if (N.isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the input string is wrapped with the specified prefix and suffix string.
     *
     * <p>This method verifies whether the string starts and ends with the same specified string.
     * The prefixSuffix parameter serves as both the prefix and suffix.
     * The check is case-sensitive.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isWrappedWith("'hello'", "'");        // returns true
     * Strings.isWrappedWith("\"text\"", "\"");      // returns true
     * Strings.isWrappedWith("--comment--", "--");   // returns true
     * Strings.isWrappedWith("hello", "'");          // returns false
     * Strings.isWrappedWith("'hello\"", "'");       // returns false
     * Strings.isWrappedWith(null, "'");             // returns false
     * }</pre>
     *
     * @param str the input string to be checked, may be {@code null} or empty
     * @param prefixSuffix the string that should be the prefix and suffix of the input string.
     * @return {@code true} if the input string starts and ends with the prefixSuffix string, {@code false} otherwise.
     * @throws IllegalArgumentException if prefixSuffix is empty.
     * @see #isWrappedWith(String, String, String)
     */
    public static boolean isWrappedWith(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return str != null && str.length() >= prefixSuffix.length() * 2 && str.startsWith(prefixSuffix) && str.endsWith(prefixSuffix);
    }

    /**
     * Checks if the input string is wrapped with the specified prefix and suffix string.
     *
     * <p>This method verifies whether the string starts with the specified prefix and ends with the specified suffix.
     * The check is case-sensitive.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isWrappedWith("<html>content</html>", "<html>", "</html>");   // returns true
     * Strings.isWrappedWith("{data}", "{", "}");                            // returns true
     * Strings.isWrappedWith("[array]", "[", "]");                           // returns true
     * Strings.isWrappedWith("hello", "<", ">");                             // returns false
     * Strings.isWrappedWith("<hello", "<", ">");                            // returns false
     * Strings.isWrappedWith(null, "<", ">");                                // returns false
     * }</pre>
     *
     * @param str the input string to be checked, may be {@code null} or empty
     * @param prefix the string that should be the prefix of the input string.
     * @param suffix the string that should be the suffix of the input string.
     * @return {@code true} if the input string starts with the prefix and ends with the suffix, {@code false} otherwise.
     * @throws IllegalArgumentException if prefix or suffix is empty.
     * @see #isWrappedWith(String, String)
     */
    public static boolean isWrappedWith(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        return str != null && str.length() >= prefix.length() + suffix.length() && str.startsWith(prefix) && str.endsWith(suffix);
    }

    /**
     * Returns the specified default value if the given {@code charSequence} is {@code null}, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method provides a null-safe way to ensure a CharSequence is never {@code null}.
     * The default value must not be {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfNull("hello", "default");   // returns "hello"
     * Strings.defaultIfNull(null, "default");      // returns "default"
     * Strings.defaultIfNull("", "default");        // returns ""
     * Strings.defaultIfNull("   ", "default");     // returns "   "
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for {@code null}
     * @param defaultForNull the default value to return if {@code str} is {@code null}
     * @return {@code str} if it is not {@code null}, otherwise {@code defaultForNull}
     * @throws IllegalArgumentException if the specified default value is {@code null}.
     * @see #defaultIfNull(CharSequence, Supplier)
     * @see #defaultIfEmpty(CharSequence, CharSequence)
     * @see #defaultIfBlank(CharSequence, CharSequence)
     * @see N#defaultIfNull(Object, Object)
     */
    public static <T extends CharSequence> T defaultIfNull(final T str, final T defaultForNull) throws IllegalArgumentException {
        N.checkArgNotNull(defaultForNull, cs.defaultValue);

        return str == null ? defaultForNull : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is {@code null}, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method provides a null-safe way to ensure a CharSequence is never {@code null}, with lazy evaluation of the default value.
     * The supplier is only invoked if the input CharSequence is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfNull("hello", () -> "default");        // returns "hello"
     * Strings.defaultIfNull(null, () -> "default");           // returns "default"
     * Strings.defaultIfNull("", () -> "default");             // returns ""
     * Strings.defaultIfNull(null, () -> generateDefault());   // calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for {@code null}
     * @param supplierForDefault the supplier that provides the default value if {@code str} is {@code null}
     * @return {@code str} if it is not {@code null}, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is {@code null} when the specified {@code charSequence} is {@code null}.
     * @see #defaultIfNull(CharSequence, CharSequence)
     * @see #defaultIfEmpty(CharSequence, Supplier)
     * @see #defaultIfBlank(CharSequence, Supplier)
     * @see N#defaultIfNull(Object, Supplier)
     */
    public static <T extends CharSequence> T defaultIfNull(final T str, final Supplier<? extends T> supplierForDefault) throws IllegalArgumentException {
        if (str == null) {
            return N.checkArgNotNull(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence empty if it is {@code null} or has zero length.
     * The default value must not be empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfEmpty("hello", "default");   // returns "hello"
     * Strings.defaultIfEmpty("", "default");        // returns "default"
     * Strings.defaultIfEmpty(null, "default");      // returns "default"
     * Strings.defaultIfEmpty("   ", "default");     // returns "   " (spaces are not empty)
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for emptiness
     * @param defaultForEmpty the default value to return if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise {@code defaultForEmpty}
     * @throws IllegalArgumentException if the specified default charSequence value is empty.
     * @see #defaultIfEmpty(CharSequence, Supplier)
     * @see #defaultIfNull(CharSequence, CharSequence)
     * @see #defaultIfBlank(CharSequence, CharSequence)
     * @see #firstNonEmpty(String, String)
     * @see N#defaultIfEmpty(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultForEmpty) throws IllegalArgumentException {
        N.checkArgNotEmpty(defaultForEmpty, cs.defaultValue);

        return isEmpty(str) ? defaultForEmpty : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence empty if it is {@code null} or has zero length.
     * The supplier is only invoked if the input CharSequence is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfEmpty("hello", () -> "default");      // returns "hello"
     * Strings.defaultIfEmpty("", () -> "default");           // returns "default"
     * Strings.defaultIfEmpty(null, () -> "default");         // returns "default"
     * Strings.defaultIfEmpty("", () -> generateDefault());   // calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for emptiness
     * @param supplierForDefault the supplier that provides the default value if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is empty when the specified {@code charSequence} is empty.
     * @see #defaultIfEmpty(CharSequence, CharSequence)
     * @see #defaultIfNull(CharSequence, Supplier)
     * @see #defaultIfBlank(CharSequence, Supplier)
     * @see #firstNonEmpty(String, String)
     * @see N#defaultIfEmpty(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isEmpty(str)) {
            return N.checkArgNotEmpty(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence blank if it is {@code null}, empty, or contains only whitespace characters.
     * The default value must not be blank.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfBlank("hello", "default");     // returns "hello"
     * Strings.defaultIfBlank("   ", "default");       // returns "default"
     * Strings.defaultIfBlank("", "default");          // returns "default"
     * Strings.defaultIfBlank(null, "default");        // returns "default"
     * Strings.defaultIfBlank("  abc  ", "default");   // returns "  abc  "
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for blankness
     * @param defaultForBlank the default value to return if {@code str} is blank
     * @return {@code str} if it is not blank, otherwise {@code defaultForBlank}
     * @throws IllegalArgumentException if the specified default charSequence value is blank.
     * @see #defaultIfBlank(CharSequence, Supplier)
     * @see #defaultIfNull(CharSequence, CharSequence)
     * @see #defaultIfEmpty(CharSequence, CharSequence)
     * @see #firstNonBlank(String, String)
     * @see N#defaultIfBlank(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultForBlank) throws IllegalArgumentException {
        N.checkArgNotBlank(defaultForBlank, cs.defaultValue);

        return isBlank(str) ? defaultForBlank : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p>This method considers a CharSequence blank if it is {@code null}, empty, or contains only whitespace characters.
     * The supplier is only invoked if the input CharSequence is blank.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.defaultIfBlank("hello", () -> "default");         // returns "hello"
     * Strings.defaultIfBlank("   ", () -> "default");           // returns "default"
     * Strings.defaultIfBlank(null, () -> "default");            // returns "default"
     * Strings.defaultIfBlank("   ", () -> generateDefault());   // calls generateDefault() and returns its result
     * }</pre>
     *
     * @param <T> the type of {@code CharSequence}
     * @param str the {@code charSequence} to check for blankness
     * @param supplierForDefault the supplier that provides the default value if {@code str} is blank
     * @return {@code str} if it is not blank, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is blank when the specified {@code charSequence} is blank.
     * @see #defaultIfBlank(CharSequence, CharSequence)
     * @see #defaultIfNull(CharSequence, Supplier)
     * @see #defaultIfEmpty(CharSequence, Supplier)
     * @see #firstNonBlank(String, String)
     * @see N#defaultIfBlank(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isBlank(str)) {
            return N.checkArgNotBlank(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the first non-empty String from the given two Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not empty.
     * A string is considered empty if it is {@code null} or has zero length.
     * If both strings are empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonEmpty("hello", "world");   // returns "hello"
     * Strings.firstNonEmpty("", "world");        // returns "world"
     * Strings.firstNonEmpty(null, "world");      // returns "world"
     * Strings.firstNonEmpty("", "");             // returns ""
     * Strings.firstNonEmpty(null, null);         // returns ""
     * }</pre>
     *
     * @param a the first String to be checked, may be {@code null} or empty
     * @param b the second String to be checked, may be {@code null} or empty
     * @return the first non-empty String from the given two Strings. If both are empty, returns an empty string {@code ""}.
     * @see #firstNonEmpty(String, String, String)
     * @see #firstNonEmpty(String...)
     * @see #firstNonBlank(String, String)
     * @see N#firstNonEmpty(CharSequence, CharSequence)
     */
    public static String firstNonEmpty(final String a, final String b) {
        return isEmpty(a) ? (isEmpty(b) ? EMPTY : b) : a;
    }

    /**
     * Returns the first non-empty String from the given three Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not empty.
     * A string is considered empty if it is {@code null} or has zero length.
     * If all strings are empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonEmpty("hello", "world", "!");   // returns "hello"
     * Strings.firstNonEmpty("", "world", "!");        // returns "world"
     * Strings.firstNonEmpty("", "", "!");             // returns "!"
     * Strings.firstNonEmpty(null, null, "!");         // returns "!"
     * Strings.firstNonEmpty("", "", "");              // returns ""
     * Strings.firstNonEmpty(null, null, null);        // returns ""
     * }</pre>
     *
     * @param a the first String to be checked, may be {@code null} or empty
     * @param b the second String to be checked, may be {@code null} or empty
     * @param c the third String to be checked, may be {@code null} or empty
     * @return the first non-empty String from the given three Strings. If all are empty, returns an empty string {@code ""}.
     * @see #firstNonEmpty(String, String)
     * @see #firstNonEmpty(String...)
     * @see #firstNonBlank(String, String, String)
     * @see N#firstNonEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static String firstNonEmpty(final String a, final String b, final String c) {
        return isEmpty(a) ? (isEmpty(b) ? (isEmpty(c) ? EMPTY : c) : b) : a;
    }

    /**
     * Returns the first non-empty String from the given array of Strings.
     *
     * <p>This method iterates through the strings and returns the first one that is not empty.
     * A string is considered empty if it is {@code null} or has zero length.
     * If all values are empty or the array is {@code null} or empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonEmpty(null, null, null);     // returns ""
     * Strings.firstNonEmpty(null, null, "");       // returns ""
     * Strings.firstNonEmpty(null, "", " ");        // returns " "
     * Strings.firstNonEmpty("abc");                // returns "abc"
     * Strings.firstNonEmpty(null, "xyz");          // returns "xyz"
     * Strings.firstNonEmpty("", "xyz");            // returns "xyz"
     * Strings.firstNonEmpty(null, "xyz", "abc");   // returns "xyz"
     * Strings.firstNonEmpty();                     // returns ""
     * }</pre>
     *
     * @param css the values to test, may be {@code null} or empty
     * @return the first non-empty String from the given array. If all Strings are empty or the array is {@code null}, returns an empty string {@code ""}.
     * @see #firstNonEmpty(String, String)
     * @see #firstNonEmpty(Iterable)
     * @see #firstNonBlank(String...)
     * @see N#firstNonEmpty(CharSequence...)
     */
    public static String firstNonEmpty(final String... css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotEmpty(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-empty String from the given Iterable of Strings.
     *
     * <p>This method iterates through the strings and returns the first one that is not empty.
     * A string is considered empty if it is {@code null} or has zero length.
     * If all strings are empty or the Iterable is {@code null} or empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList("", null, "hello");
     * Strings.firstNonEmpty(list1);   // returns "hello"
     * 
     * List<String> list2 = Arrays.asList("", null, "");
     * Strings.firstNonEmpty(list2);               // returns ""
     * 
     * Strings.firstNonEmpty(null);                // returns ""
     * Strings.firstNonEmpty(new ArrayList<>());   // returns ""
     * }</pre>
     *
     * @param css the Iterable of Strings to be checked, may be {@code null}
     * @return the first non-empty String from the given Iterable. If all Strings are empty or the Iterable is {@code null}, returns an empty string {@code ""}.
     * @see #firstNonEmpty(String...)
     * @see #firstNonBlank(Iterable)
     * @see N#firstNonEmpty(Iterable)
     */
    public static String firstNonEmpty(final Iterable<String> css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotEmpty(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-blank String from the given two Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * If both strings are blank, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonBlank("hello", "world");   // returns "hello"
     * Strings.firstNonBlank("   ", "world");     // returns "world"
     * Strings.firstNonBlank(null, "world");      // returns "world"
     * Strings.firstNonBlank("   ", "   ");       // returns ""
     * Strings.firstNonBlank(null, null);         // returns ""
     * }</pre>
     *
     * @param a the first String to be checked, may be {@code null} or empty
     * @param b the second String to be checked, may be {@code null} or empty
     * @return the first non-blank String from the given two Strings. If both are blank, returns an empty string {@code ""}.
     * @see #firstNonBlank(String, String, String)
     * @see #firstNonBlank(String...)
     * @see #firstNonEmpty(String, String)
     * @see N#firstNonBlank(CharSequence, CharSequence)
     */
    public static String firstNonBlank(final String a, final String b) {
        return isBlank(a) ? (isBlank(b) ? EMPTY : b) : a;
    }

    /**
     * Returns the first non-blank String from the given three Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * If all strings are blank, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonBlank("hello", "world", "!");   // returns "hello"
     * Strings.firstNonBlank("   ", "world", "!");     // returns "world"
     * Strings.firstNonBlank("   ", "   ", "!");       // returns "!"
     * Strings.firstNonBlank(null, null, "!");         // returns "!"
     * Strings.firstNonBlank("   ", "   ", "   ");     // returns ""
     * Strings.firstNonBlank(null, null, null);        // returns ""
     * }</pre>
     *
     * @param a the first String to be checked, may be {@code null} or empty
     * @param b the second String to be checked, may be {@code null} or empty
     * @param c the third String to be checked, may be {@code null} or empty
     * @return the first non-blank String from the given three Strings. If all are blank, returns an empty string {@code ""}.
     * @see #firstNonBlank(String, String)
     * @see #firstNonBlank(String...)
     * @see #firstNonEmpty(String, String, String)
     * @see N#firstNonBlank(CharSequence, CharSequence, CharSequence)
     */
    public static String firstNonBlank(final String a, final String b, final String c) {
        return isBlank(a) ? (isBlank(b) ? (isBlank(c) ? EMPTY : c) : b) : a;
    }

    /**
     * Returns the first non-blank String from the given Strings.
     *
     * <p>This method checks the strings in order and returns the first one that is not blank.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * If all strings are blank or the array is {@code null} or empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstNonBlank(null, "   ", "hello");   // returns "hello"
     * Strings.firstNonBlank("", "\t", "world");      // returns "world"
     * Strings.firstNonBlank("   ", "   ", "   ");    // returns ""
     * Strings.firstNonBlank(null, null, null);       // returns ""
     * Strings.firstNonBlank();                       // returns ""
     * Strings.firstNonBlank((String[]) null);        // returns ""
     * }</pre>
     *
     * @param css the Strings to be checked. They can be {@code null} or empty.
     * @return the first non-blank String from the given Strings. If all are blank, returns an empty string {@code ""}.
     * @see #firstNonBlank(String, String)
     * @see #firstNonBlank(Iterable)
     * @see #firstNonEmpty(String...)
     * @see N#firstNonBlank(CharSequence...)
     */
    public static String firstNonBlank(final String... css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotBlank(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Returns the first non-blank String from the given Iterable of Strings.
     *
     * <p>This method iterates through the strings and returns the first one that is not blank.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * If all strings are blank or the Iterable is {@code null} or empty, an empty string ("") is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList("   ", null, "hello");
     * Strings.firstNonBlank(list1);   // returns "hello"
     *
     * List<String> list2 = Arrays.asList("   ", null, "\t");
     * Strings.firstNonBlank(list2);   // returns ""
     *
     * Strings.firstNonBlank(null);                // returns ""
     * Strings.firstNonBlank(new ArrayList<>());   // returns ""
     * }</pre>
     *
     * @param css the Iterable of Strings to be checked, may be {@code null}
     * @return the first non-blank String from the given Iterable. If all Strings are blank or the Iterable is {@code null}, returns an empty string {@code ""}.
     * @see #firstNonBlank(String...)
     * @see #firstNonEmpty(Iterable)
     * @see N#firstNonBlank(Iterable)
     */
    public static String firstNonBlank(final Iterable<String> css) {
        if (N.isEmpty(css)) {
            return EMPTY;
        }

        for (final String val : css) {
            if (isNotBlank(val)) {
                return val;
            }
        }

        return EMPTY;
    }

    /**
     * Converts the specified String to an empty String {@code ""} if it's {@code null}, otherwise returns the original string.
     *
     * <p>This method provides a null-safe way to ensure a string is never {@code null}, converting {@code null} values to empty strings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.nullToEmpty(null);      // returns ""
     * Strings.nullToEmpty("");        // returns ""
     * Strings.nullToEmpty("   ");     // returns "   "
     * Strings.nullToEmpty("hello");   // returns "hello"
     * }</pre>
     *
     * @param str the input string to be checked, may be {@code null}
     * @return an empty string if the input string is {@code null}, otherwise the original string.
     * @see N#nullToEmpty(String)
     */
    public static String nullToEmpty(final String str) {
        return str == null ? EMPTY : str;
    }

    /**
     * Converts each {@code null} String element in the specified String array to an empty String {@code ""}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all {@code null} elements with empty strings.
     * Non-null elements remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {null, "hello", null, "world"};
     * Strings.nullToEmpty(arr);   // arr becomes {"", "hello", "", "world"}
     * 
     * String[] arr2 = {"a", "b", "c"};
     * Strings.nullToEmpty(arr2);            // arr2 remains {"a", "b", "c"}
     * 
     * Strings.nullToEmpty(null);            // does nothing
     * Strings.nullToEmpty(new String[0]);   // does nothing
     * }</pre>
     *
     * @param strs the input string array to be checked. Each {@code null} element in the array will be converted to an empty string, may be {@code null} or empty
     * @see N#nullToEmpty(String[])
     * @see N#nullToEmptyForEach(String[])
     */
    public static void nullToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strs[i] == null ? EMPTY : strs[i];
        }
    }

    /**
     * Converts the specified String to {@code null} if it's empty, otherwise returns the original string.
     *
     * <p>This method considers a string empty if it has zero length. Strings containing only whitespace
     * are not considered empty and will not be converted to {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.emptyToNull("");        // returns null
     * Strings.emptyToNull(null);      // returns null
     * Strings.emptyToNull("   ");     // returns "   " (spaces are not empty)
     * Strings.emptyToNull("hello");   // returns "hello"
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param str the input string to be checked, may be {@code null} or empty
     * @return {@code null} if the input string is empty, otherwise the original string.
     */
    public static <T extends CharSequence> T emptyToNull(final T str) {
        return str == null || str.isEmpty() ? null : str;
    }

    /**
     * Converts each empty String element in the specified String array to {@code null}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all empty string elements with {@code null}.
     * Non-empty elements and {@code null} elements remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"", "hello", "", "world"};
     * Strings.emptyToNull(arr);   // arr becomes {null, "hello", null, "world"}
     * 
     * String[] arr2 = {"a", "   ", "c"};
     * Strings.emptyToNull(arr2);            // arr2 remains {"a", "   ", "c"} (spaces are not empty)
     * 
     * Strings.emptyToNull(null);            // does nothing
     * Strings.emptyToNull(new String[0]);   // does nothing
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param strs the input string array to be checked. Each empty element in the array will be converted to {@code null}, may be {@code null} or empty
     */
    public static <T extends CharSequence> void emptyToNull(final T[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strs[i] == null || strs[i].isEmpty() ? null : strs[i];
        }
    }

    /**
     * Converts the specified String to an empty String {@code ""} if it's blank, otherwise returns the original string.
     *
     * <p>This method considers a string blank if it is {@code null}, empty, or contains only whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.blankToEmpty(null);          // returns ""
     * Strings.blankToEmpty("");            // returns ""
     * Strings.blankToEmpty("   ");         // returns ""
     * Strings.blankToEmpty("\t\n");        // returns ""
     * Strings.blankToEmpty("hello");       // returns "hello"
     * Strings.blankToEmpty("  hello  ");   // returns "  hello  "
     * }</pre>
     *
     * @param str the input string to be checked, may be {@code null} or empty
     * @return an empty string if the input string is blank, otherwise the original string.
     */
    public static String blankToEmpty(final String str) {
        return isBlank(str) ? EMPTY : str;
    }

    /**
     * Converts each blank String element in the specified String array to an empty String {@code ""}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all blank string elements with empty strings.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * Non-blank elements remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {null, "   ", "hello", "\t"};
     * Strings.blankToEmpty(arr);   // arr becomes {"", "", "hello", ""}
     * 
     * String[] arr2 = {"a", "  b  ", "c"};
     * Strings.blankToEmpty(arr2);            // arr2 remains {"a", "  b  ", "c"}
     * 
     * Strings.blankToEmpty(null);            // does nothing
     * Strings.blankToEmpty(new String[0]);   // does nothing
     * }</pre>
     *
     * @param strs the input string array to be checked. Each blank element in the array will be converted to an empty string, may be {@code null} or empty
     */
    public static void blankToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = isBlank(strs[i]) ? EMPTY : strs[i];
        }
    }

    /**
     * Converts the specified String to {@code null} if it's blank, otherwise returns the original string.
     *
     * <p>This method considers a string blank if it is {@code null}, empty, or contains only whitespace characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.blankToNull("");            // returns null
     * Strings.blankToNull("   ");         // returns null
     * Strings.blankToNull("\t\n");        // returns null
     * Strings.blankToNull(null);          // returns null
     * Strings.blankToNull("hello");       // returns "hello"
     * Strings.blankToNull("  hello  ");   // returns "  hello  "
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param str the input string to be checked, may be {@code null} or empty
     * @return {@code null} if the input string is blank, otherwise the original string.
     */
    public static <T extends CharSequence> T blankToNull(final T str) {
        return isBlank(str) ? null : str;
    }

    /**
     * Converts each blank String element in the specified String array to {@code null}.
     * Do nothing if the input array is {@code null} or empty.
     *
     * <p>This method modifies the array in-place, replacing all blank string elements with {@code null}.
     * A string is considered blank if it is {@code null}, empty, or contains only whitespace characters.
     * Non-blank elements remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"   ", "hello", "\t", "world"};
     * Strings.blankToNull(arr);   // arr becomes {null, "hello", null, "world"}
     * 
     * String[] arr2 = {"a", "  b  ", "c"};
     * Strings.blankToNull(arr2);            // arr2 remains {"a", "  b  ", "c"}
     * 
     * Strings.blankToNull(null);            // does nothing
     * Strings.blankToNull(new String[0]);   // does nothing
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param strs the input string array to be checked. Each blank element in the array will be converted to {@code null}, may be {@code null} or empty
     */
    public static <T extends CharSequence> void blankToNull(final T[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = isBlank(strs[i]) ? null : strs[i];
        }
    }

    /**
     * <p>Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "...is the time for..."</p>
     *
     * <p>Works like {@code Strings.abbreviate(String, int)}, but allows you to specify
     * a "left edge" offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * ellipses, but it will appear somewhere in the result.
     *
     * <p>In no case will it return a String of length greater than
     * {@code maxWidth}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.abbreviate(null, 0, 4)                  = null
     * Strings.abbreviate("", 0, 4)                    = ""
     * Strings.abbreviate("abcdefghijklmno", -1, 10)   = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 0, 10)    = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 1, 10)    = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 4, 10)    = "abcdefg..."
     * Strings.abbreviate("abcdefghijklmno", 5, 10)    = "...fghi..."
     * Strings.abbreviate("abcdefghijklmno", 6, 10)    = "...ghij..."
     * Strings.abbreviate("abcdefghijklmno", 8, 10)    = "...ijklmno"
     * Strings.abbreviate("abcdefghijklmno", 10, 10)   = "...ijklmno"
     * Strings.abbreviate("abcdefghijklmno", 12, 10)   = "...ijklmno"
     * Strings.abbreviate("abcdefghij", 0, 3)          = IllegalArgumentException
     * Strings.abbreviate("abcdefghij", 5, 6)          = IllegalArgumentException
     * }</pre>
     *
     * @param str the String to check, may be {@code null}
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException if the width is too small
     * @deprecated
     */
    @Deprecated
    static String abbreviate(final String str, final int offset, final int maxWidth) {
        return abbreviate(str, "...", offset, maxWidth);
    }

    // Abbreviating
    //-----------------------------------------------------------------------

    /**
     * <p>Abbreviates a String using a given replacement marker. This will turn
     * "Now is the time for all good men" into "...is the time for..." if "..." was defined
     * as the replacement marker.</p>
     *
     * <p>Works like {@code Strings.abbreviate(String, String, int)}, but allows you to specify
     * a "left edge" offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * replacement marker, but it will appear somewhere in the result.
     *
     * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.abbreviate(null, "...", 0, 4)                       = null
     * Strings.abbreviate("", "...", 0, 4)                         = ""
     * Strings.abbreviate("abcdefghijklmno", {@code null}, *, *)   = "abcdefghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "---", -1, 10)        = "abcdefg---"
     * Strings.abbreviate("abcdefghijklmno", ",", 0, 10)           = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", ",", 1, 10)           = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", ",", 2, 10)           = "abcdefghi,"
     * Strings.abbreviate("abcdefghijklmno", "::", 4, 10)          = "::efghij::"
     * Strings.abbreviate("abcdefghijklmno", "...", 6, 10)         = "...ghij..."
     * Strings.abbreviate("abcdefghijklmno", "*", 9, 10)           = "*ghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "'", 10, 10)          = "'ghijklmno"
     * Strings.abbreviate("abcdefghijklmno", "!", 12, 10)          = "!ghijklmno"
     * Strings.abbreviate("abcdefghij", "abra", 0, 4)              = IllegalArgumentException
     * Strings.abbreviate("abcdefghij", "...", 5, 6)               = IllegalArgumentException
     * }</pre>
     *
     * @param str the String to check, may be {@code null}
     * @param abbrevMarker the String used as replacement marker
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     * @deprecated
     */
    @Deprecated
    static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
        final int abbrevMarkerLength = N.len(abbrevMarker);
        final int minAbbrevWidth = abbrevMarkerLength + 1;
        final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;

        if (maxWidth < minAbbrevWidth) {
            throw new IllegalArgumentException(String.format("Minimum abbreviation width is %d", minAbbrevWidth));
        }

        if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
            return Strings.substring(str, 0, maxWidth);
        } else if (isAnyEmpty(str, abbrevMarker)) {
            return str;
        }

        final int strLen = str.length();

        if (strLen <= maxWidth) {
            return str;
        }

        if (offset > strLen) {
            offset = strLen;
        }

        if (strLen - offset < maxWidth - abbrevMarkerLength) {
            offset = strLen - (maxWidth - abbrevMarkerLength);
        }

        if (offset <= abbrevMarkerLength + 1) {
            return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;
        }

        if (maxWidth < minAbbrevWidthOffset) {
            throw new IllegalArgumentException(String.format("Minimum abbreviation width with offset is %d", minAbbrevWidthOffset));
        }

        if (offset + maxWidth - abbrevMarkerLength < strLen) {
            return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);
        }

        return abbrevMarker + str.substring(strLen - (maxWidth - abbrevMarkerLength));
    }

    /**
     * <p>Abbreviates a String using ellipses. This will turn
     * "Now is the time for all good men" into "Now is the time for..."</p>
     *
     * <p>Specifically:</p>
     * <ul>
     *   <li>If the number of characters in {@code str} is less than or equal to
     *       {@code maxWidth}, return {@code str}.</li>
     *   <li>Else abbreviate it to {@code (Strings.substring(str, 0, max - 3) + "...")}.</li>
     *   <li>If {@code maxWidth} is less than {@code 4}, throw an
     *       {@code IllegalArgumentException}.</li>
     *   <li>In no case will it return a String of length greater than
     *       {@code maxWidth}.</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.abbreviate(null, 4)        = null
     * Strings.abbreviate("", 4)          = ""
     * Strings.abbreviate("abcdefg", 6)   = "abc..."
     * Strings.abbreviate("abcdefg", 7)   = "abcdefg"
     * Strings.abbreviate("abcdefg", 8)   = "abcdefg"
     * Strings.abbreviate("abcdefg", 4)   = "a..."
     * Strings.abbreviate("abcdefg", 3)   = IllegalArgumentException
     * }</pre>
     *
     * @param str the String to check, may be {@code null}
     * @param maxWidth maximum length of result String, must be at least 4
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     */
    public static String abbreviate(final String str, final int maxWidth) {
        return abbreviate(str, "...", 0, maxWidth);
    }

    /**
     * <p>Abbreviates a String using another given String as replacement marker. This will turn
     * "Now is the time for all good men" into "Now is the time for..." if "..." was defined
     * as the replacement marker.</p>
     *
     * <p>Specifically:</p>
     * <ul>
     *   <li>If the number of characters in {@code str} is less than or equal to
     *       {@code maxWidth}, return {@code str}.</li>
     *   <li>Else abbreviate it to {@code (Strings.substring(str, 0, max - abbrevMarker.length) + abbrevMarker)}.</li>
     *   <li>If {@code maxWidth} is less than {@code abbrevMarker.length + 1}, throw an
     *       {@code IllegalArgumentException}.</li>
     *   <li>In no case will it return a String of length greater than
     *       {@code maxWidth}.</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.abbreviate(null, "...", 4)        = null
     * Strings.abbreviate("", "...", 4)          = ""
     * Strings.abbreviate("abcdefg", null, *)    = "abcdefg"
     * Strings.abbreviate("abcdefg", ".", 5)     = "abcd."
     * Strings.abbreviate("abcdefg", ".", 7)     = "abcdefg"
     * Strings.abbreviate("abcdefg", ".", 8)     = "abcdefg"
     * Strings.abbreviate("abcdefg", "..", 4)    = "ab.."
     * Strings.abbreviate("abcdefg", "..", 3)    = "a.."
     * Strings.abbreviate("abcdefg", "..", 2)    = IllegalArgumentException
     * Strings.abbreviate("abcdefg", "...", 3)   = IllegalArgumentException
     * }</pre>
     *
     * @param str the String to check, may be {@code null}
     * @param abbrevMarker the String used as replacement marker
     * @param maxWidth maximum length of result String, must be at least {@code abbrevMarker.length + 1}
     * @return abbreviated String
     * @throws IllegalArgumentException if the width is too small
     */
    public static String abbreviate(final String str, final String abbrevMarker, final int maxWidth) {
        return abbreviate(str, abbrevMarker, 0, maxWidth);
    }

    /**
     * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
     * replacement String.</p>
     *
     * <p>This abbreviation only occurs if the following criteria is met:</p>
     * <ul>
     * <li>Neither the String for abbreviation nor the replacement String are {@code null} or empty </li>
     * <li>The length to truncate to is less than the length of the supplied String</li>
     * <li>The length to truncate to is greater than 0</li>
     * <li>The abbreviated String will have enough room for the length supplied replacement String
     * and the first and last characters of the supplied String for abbreviation</li>
     * </ul>
     * <p>Otherwise, the returned String will be the same as the supplied String for abbreviation.
     * </p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.abbreviateMiddle(null, null, 0)      = null
     * Strings.abbreviateMiddle("abc", null, 0)     = "abc"
     * Strings.abbreviateMiddle("abc", ".", 0)      = "abc"
     * Strings.abbreviateMiddle("abc", ".", 3)      = "abc"
     * Strings.abbreviateMiddle("abcdef", ".", 4)   = "ab.f"
     * }</pre>
     *
     * @param str the String to abbreviate, may be {@code null}
     * @param middle the String to replace the middle characters with, may be {@code null}
     * @param length the length to abbreviate {@code str} to.
     * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
     */
    public static String abbreviateMiddle(final String str, final String middle, final int length) {
        if (isAnyEmpty(str, middle) || length >= str.length() || length < middle.length() + 2) {
            return str;
        }

        final int targetSting = length - middle.length();
        final int startOffset = targetSting / 2 + targetSting % 2;
        final int endOffset = str.length() - targetSting / 2;

        return str.substring(0, startOffset) + middle + str.substring(endOffset);
    }

    /**
     * <p>Centers a String in a larger String of size {@code size}
     * using the space character (' ').</p>
     *
     * <p>If the size is less than the String length, the original String is returned.
     * This method is equivalent to {@code Strings.center(str, size, " ")}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.center(null, 3)     = "   "
     * Strings.center("", 3)       = "   "
     * Strings.center("ab", 4)     = " ab "
     * Strings.center("abcd", 2)   = "abcd"
     * Strings.center("a", 4)      = " a  "
     * }</pre>
     *
     * @param str the String to center, may be {@code null}
     * @param size the int size of new String
     * @return centered String
     */
    public static String center(final String str, final int size) {
        return center(str, size, ' ');
    }

    /**
     * <p>Centers a String in a larger String of size {@code size}.
     * Uses a supplied character as the value to pad the String with.</p>
     *
     * <p>If the size is less than the String length, the String is returned.
     * Padding is distributed evenly on both sides. If the padding cannot be evenly distributed,
     * the extra padding character is added to the right side.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.center(null, 4, ' ')     = "    "
     * Strings.center("", 4, ' ')       = "    "
     * Strings.center("ab", 4, ' ')     = " ab "
     * Strings.center("abcd", 2, ' ')   = "abcd"
     * Strings.center("a", 4, ' ')      = " a  "
     * Strings.center("a", 4, 'y')      = "yayy"
     * }</pre>
     *
     * @param str the String to center, may be {@code null}
     * @param size the int size of new String.
     * @param padChar the character to pad the new String with
     * @return centered String
     * @throws IllegalArgumentException if size is negative
     */
    public static String center(String str, final int size, final char padChar) throws IllegalArgumentException {
        N.checkArgNotNegative(size, cs.size);

        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= size) {
            return str;
        }

        final int strLen = str.length();
        final int pads = size - strLen;

        str = padStart(str, strLen + pads / 2, padChar);
        return padEnd(str, size, padChar);
    }

    /**
     * <p>Centers a String in a larger String of size {@code minLength}.
     * Uses a supplied String as the value to pad the String with.</p>
     *
     * <p>If the size is less than the String length, the String is returned.
     * Padding is distributed evenly on both sides. If the padding cannot be evenly distributed,
     * the extra padding is added to the right side.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.center(null, 4, " ")     = "    "
     * Strings.center("", 4, " ")       = "    "
     * Strings.center("ab", 4, " ")     = " ab "
     * Strings.center("abcd", 2, " ")   = "abcd"
     * Strings.center("a", 4, " ")      = " a  "
     * Strings.center("a", 4, "yz")     = "yzayz"
     * Strings.center("abc", 7, "")     = "  abc  "
     * }</pre>
     *
     * @param str the String to center, may be {@code null}
     * @param minLength the minimum size of new String.
     * @param padStr the String to pad the new String with, must not be {@code null} or empty
     * @return centered String
     * @throws IllegalArgumentException if minLength is negative
     */
    public static String center(String str, final int minLength, String padStr) throws IllegalArgumentException {
        N.checkArgNotNegative(minLength, cs.minLength);
        // N.checkArgNotEmpty(padStr, "padStr");

        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        if (isEmpty(padStr)) {
            padStr = " ";
        }

        final int strLen = str.length();
        final int pads = minLength - strLen;

        str = padStart(str, strLen + pads / 2, padStr);
        return padEnd(str, minLength, padStr);
    }

    /**
     * Pads the given string from the start (left) with spaces until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padStart("abc", 5);   // returns "  abc"
     * Strings.padStart("abc", 3);   // returns "abc"
     * Strings.padStart("abc", 1);   // returns "abc"
     * Strings.padStart("", 3);      // returns "   "
     * Strings.padStart(null, 3);    // returns "   "
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @return a new string that is a copy of the original string padded with leading spaces so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(final String str, final int minLength) {
        return padStart(str, minLength, WD._SPACE);
    }

    /**
     * Pads the given string from the start (left) with the specified character until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padStart("abc", 5, '*');   // returns "**abc"
     * Strings.padStart("abc", 3, '*');   // returns "abc"
     * Strings.padStart("abc", 6, '0');   // returns "000abc"
     * Strings.padStart("", 3, 'x');      // returns "xxx"
     * Strings.padStart(null, 3, '-');    // returns "---"
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @param padChar the character to be used for padding.
     * @return a new string that is a copy of the original string padded with the padChar so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(String str, final int minLength, final char padChar) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        final String padStr = Strings.repeat(padChar, minLength - str.length());

        return concat(padStr, str);
    }

    /**
     * Pads the given string from the start (left) with the specified string until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>If the padding string is longer than the remaining space, only the necessary portion of the padding string is used.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padStart("abc", 7, "xy");    // returns "xyxyabc"
     * Strings.padStart("abc", 6, "123");   // returns "123abc"
     * Strings.padStart("abc", 8, "xy");    // returns "xyxyxabc"
     * Strings.padStart("", 4, "ab");       // returns "abab"
     * Strings.padStart(null, 3, "0");      // returns "000"
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @param padStr the string to be used for padding.
     * @return a new string that is a copy of the original string padded with the padStr so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padStart(String str, final int minLength, final String padStr) {
        N.checkArgNotEmpty(padStr, "padStr");

        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        @SuppressWarnings("DuplicateExpressions")
        final int delta = ((minLength - str.length()) % padStr.length() == 0) ? ((minLength - str.length()) / padStr.length())
                : ((minLength - str.length()) / padStr.length() + 1);
        switch (delta) {
            case 1:
                return padStr + str;

            case 2:
                return padStr + padStr + str;

            case 3:
                return padStr + padStr + padStr + str;

            default: {
                final StringBuilder sb = Objectory.createStringBuilder(str.length() + (padStr.length() * delta));

                try {
                    //noinspection StringRepeatCanBeUsed
                    for (int i = 0; i < delta; i++) {
                        sb.append(padStr);
                    }

                    sb.append(str);

                    return sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }
            }
        }
    }

    /**
     * Pads the given string from the end (right) with spaces until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padEnd("abc", 5);   // returns "abc  "
     * Strings.padEnd("abc", 3);   // returns "abc"
     * Strings.padEnd("abc", 1);   // returns "abc"
     * Strings.padEnd("", 3);      // returns "   "
     * Strings.padEnd(null, 3);    // returns "   "
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @return a new string that is a copy of the original string padded with trailing spaces so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padEnd(final String str, final int minLength) {
        return padEnd(str, minLength, WD._SPACE);
    }

    /**
     * Pads the given string from the end (right) with the specified character until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padEnd("abc", 5, '*');   // returns "abc**"
     * Strings.padEnd("abc", 3, '*');   // returns "abc"
     * Strings.padEnd("abc", 6, '0');   // returns "abc000"
     * Strings.padEnd("", 3, 'x');      // returns "xxx"
     * Strings.padEnd(null, 3, '-');    // returns "---"
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @param padChar the character to be used for padding.
     * @return a new string that is a copy of the original string padded with the padChar so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     */
    public static String padEnd(String str, final int minLength, final char padChar) {
        if (str == null) {
            str = EMPTY;
        }

        if (str.length() >= minLength) {
            return str;
        }

        final String padStr = Strings.repeat(padChar, minLength - str.length());

        return concat(str, padStr);
    }

    /**
     * Pads the given string from the end (right) with the specified string until the string reaches the specified minimum length.
     * If the length of the given string is already greater than or equal to the specified minimum length, the original string is returned.
     *
     * <p>If the padding string is longer than the remaining space, only the necessary portion of the padding string is used.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.padEnd("abc", 7, "xy");    // returns "abcxyxy"
     * Strings.padEnd("abc", 6, "123");   // returns "abc123"
     * Strings.padEnd("abc", 8, "xy");    // returns "abcxyxyx"
     * Strings.padEnd("", 4, "ab");       // returns "abab"
     * Strings.padEnd(null, 3, "0");      // returns "000"
     * }</pre>
     *
     * @param str the string to be padded, may be {@code null} or empty
     * @param minLength the minimum length the string should have after padding. Must be non-negative.
     * @param padStr the string to be used for padding. Must not be {@code null} or empty.
     * @return a new string that is a copy of the original string padded with the padStr so that it reaches the specified minimum length.
     *         If the original string is already greater than or equal to the specified minimum length, the original string is returned.
     * @throws IllegalArgumentException if padStr is {@code null} or empty
     */
    public static String padEnd(String str, final int minLength, final String padStr) {
        if (str == null) {
            str = EMPTY;
        }

        if (padStr == null || padStr.isEmpty()) {
            throw new IllegalArgumentException("padStr cannot be null or empty");
        }

        if (str.length() >= minLength) {
            return str;
        }

        @SuppressWarnings("DuplicateExpressions")
        final int delta = ((minLength - str.length()) % padStr.length() == 0) ? ((minLength - str.length()) / padStr.length())
                : ((minLength - str.length()) / padStr.length() + 1);

        switch (delta) {
            case 1:
                return str + padStr;

            case 2:
                return str + padStr + padStr;

            case 3:
                return str + padStr + padStr + padStr;

            default: {
                final StringBuilder sb = Objectory.createStringBuilder(str.length() + (padStr.length() * delta));

                try {
                    sb.append(str);

                    //noinspection StringRepeatCanBeUsed
                    for (int i = 0; i < delta; i++) {
                        sb.append(padStr);
                    }

                    return sb.toString();
                } finally {
                    Objectory.recycle(sb);
                }
            }
        }
    }

    /**
     * Repeats the given character a specified number of times and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified character repeated n times.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.repeat('a', 0);   // returns ""
     * Strings.repeat('a', 3);   // returns "aaa"
     * Strings.repeat('*', 5);   // returns "*****"
     * Strings.repeat(' ', 4);   // returns "    "
     * }</pre>
     *
     * @param ch the character to be repeated.
     * @param n the number of times the character should be repeated. Must be non-negative.
     * @return a string consisting of the given character repeated n times.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(final char ch, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY;
        } else if (n == 1) {
            return N.stringOf(ch);
        }

        return N.stringOf(ch).repeat(n);
    }

    /**
     * Repeats the given character a specified number of times, separated by a specified delimiter, and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified character repeated n times,
     * with each occurrence separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.repeat('a', 0, ',');   // returns ""
     * Strings.repeat('a', 1, ',');   // returns "a"
     * Strings.repeat('a', 3, ',');   // returns "a,a,a"
     * Strings.repeat('*', 4, '-');   // returns "*-*-*-*"
     * }</pre>
     *
     * @param ch the character to be repeated.
     * @param n the number of times the character should be repeated. Must be non-negative.
     * @param delimiter the character used to separate the repeated characters.
     * @return a string consisting of the given character repeated n times, separated by the delimiter.
     * @throws IllegalArgumentException if n is negative.
     * @see #repeat(char, int, char)
     * @see #repeat(String, int, String)
     */
    public static String repeat(final char ch, final int n, final char delimiter) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        return repeat(N.stringOf(ch), n, N.stringOf(delimiter));
    }

    /**
     * Repeats the given string a specified number of times and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified string repeated n times.
     * If the input string is {@code null} or empty, or n is 0, empty string {@code ""} is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.repeat("ab", 0);      // returns ""
     * Strings.repeat("ab", 1);      // returns "ab"
     * Strings.repeat("ab", 3);      // returns "ababab"
     * Strings.repeat("Hello", 2);   // returns "HelloHello"
     * Strings.repeat(null, 3);      // returns ""
     * Strings.repeat("", 3);        // returns ""
     * }</pre>
     *
     * @param str the string to be repeated, may be {@code null} or empty
     * @param n the number of times the string should be repeated. Must be non-negative.
     * @return a string consisting of the given string repeated n times, an empty string {@code ""} if the input string is {@code null} or empty, or n is 0.
     * @throws IllegalArgumentException if n is negative.
     * @see #repeat(char, int, char)
     * @see #repeat(String, int, String)
     */
    public static String repeat(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (N.isEmpty(str) || n == 0) {
            return EMPTY;
        } else if (n == 1) {
            return str;
        }

        return str.repeat(n);
    }

    /**
     * Repeats the given string a specified number of times, separated by a specified delimiter, and returns the resulting string.
     *
     * <p>This method creates a string consisting of the specified string repeated n times,
     * with each occurrence separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.repeat("ab", 0, ",");      // returns ""
     * Strings.repeat("ab", 1, ",");      // returns "ab"
     * Strings.repeat("ab", 3, ",");      // returns "ab,ab,ab"
     * Strings.repeat("Hello", 2, " ");   // returns "Hello Hello"
     * Strings.repeat("X", 4, "-");       // returns "X-X-X-X"
     * }</pre>
     *
     * @param str the string to be repeated, may be {@code null} or empty
     * @param n the number of times the string should be repeated. Must be non-negative.
     * @param delimiter the string used to separate the repeated strings.
     * @return a string consisting of the given string repeated n times, separated by the delimiter.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(final String str, final int n, final String delimiter) throws IllegalArgumentException {
        if (N.isEmpty(delimiter)) {
            return repeat(str, n);
        }

        return repeat(str, n, delimiter, EMPTY, EMPTY);
    }

    /**
     * Repeats the given string a specified number of times, separated by a specified delimiter, and returns the resulting string.
     * The resulting string is also prefixed and suffixed with the provided strings.
     *
     * <p>This method creates a string consisting of the prefix, followed by the specified string repeated n times
     * (with each occurrence separated by the delimiter), and ending with the suffix.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.repeat("ab", 0, ",", "[", "]");          // returns "[]"
     * Strings.repeat("ab", 1, ",", "[", "]");          // returns "[ab]"
     * Strings.repeat("ab", 3, ",", "[", "]");          // returns "[ab,ab,ab]"
     * Strings.repeat("X", 4, "-", "Start:", ":End");   // returns "Start:X-X-X-X:End"
     * }</pre>
     *
     * @param str the string to be repeated, may be {@code null} or empty
     * @param n the number of times the string should be repeated. Must be non-negative.
     * @param delimiter the string used to separate the repeated strings.
     * @param prefix the string to be added at the start of the resulting string.
     * @param suffix the string to be added at the end of the resulting string.
     * @return a string consisting of the prefix, the given string repeated n times separated by the delimiter, and the suffix.
     * @throws IllegalArgumentException if n is negative.
     */
    public static String repeat(String str, final int n, String delimiter, String prefix, String suffix) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        str = str == null ? EMPTY : str;
        delimiter = delimiter == null ? EMPTY : delimiter;
        prefix = prefix == null ? EMPTY : prefix;
        suffix = suffix == null ? EMPTY : suffix;

        if (n == 0 || (isEmpty(str) && isEmpty(delimiter))) {
            return concat(prefix + suffix);
        } else if (n == 1) {
            return concat(prefix, str, suffix);
        }

        return join(Array.repeat(str, n), delimiter, prefix, suffix);
    }

    /**
     * Returns the byte array returned by {@code String.getBytes()}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a byte array using the platform's default charset.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.getBytes("hello");   // returns byte array of "hello"
     * Strings.getBytes("");        // returns empty byte array
     * Strings.getBytes(null);      // returns null
     * }</pre>
     *
     * @param string the input string to be converted, may be {@code null}
     * @return a byte array representation of the input string using the default charset, or {@code null} if the input string is {@code null}.
     */
    @MayReturnNull
    public static byte[] getBytes(final String string) {
        return string == null ? null : string.getBytes();
    }

    /**
     * Returns the byte array returned by {@code String#getBytes(Charset)}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a byte array using the specified charset.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.getBytes("hello", StandardCharsets.UTF_8);      // returns UTF-8 encoded bytes
     * Strings.getBytes("hello", StandardCharsets.US_ASCII);   // returns ASCII encoded bytes
     * Strings.getBytes("", StandardCharsets.UTF_8);           // returns empty byte array
     * Strings.getBytes(null, StandardCharsets.UTF_8);         // returns null
     * }</pre>
     *
     * @param string the input string to be converted, may be {@code null}
     * @param charset the charset to be used for encoding.
     * @return the encoded bytes
     */
    @MayReturnNull
    public static byte[] getBytes(final String string, final Charset charset) {
        return string == null ? null : string.getBytes(charset);
    }

    /**
     * Returns the byte array returned by {@code String#getBytes(Charsets.UTF_8)}, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a String to a UTF-8 encoded byte array.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.getBytesUtf8("hello");   // returns UTF-8 encoded bytes
     * Strings.getBytesUtf8("‰∏ñÁïå");      // returns UTF-8 encoded bytes
     * Strings.getBytesUtf8("");        // returns empty byte array
     * Strings.getBytesUtf8(null);      // returns null
     * }</pre>
     *
     * @param string the input string to be converted, may be {@code null}
     * @return a byte array representation of the input string using UTF-8 encoding, or {@code null} if the input string is {@code null}.
     */
    @MayReturnNull
    public static byte[] getBytesUtf8(final String string) {
        return getBytes(string, Charsets.UTF_8);
    }

    /**
     * Returns the char array of the specified CharSequence, or {@code null} if the specified String is {@code null}.
     *
     * <p>This method provides a null-safe way to convert a CharSequence to a char array.
     * It handles String instances efficiently by using the native toCharArray() method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toCharArray("hello");                    // returns ['h','e','l','l','o']
     * Strings.toCharArray("");                         // returns []
     * Strings.toCharArray(null);                       // returns null
     * Strings.toCharArray(new StringBuilder("abc"));   // returns ['a','b','c']
     * }</pre>
     *
     * @param source the input CharSequence to be converted, may be {@code null}
     * @return a char array representation of the input CharSequence. Returns {@code null} if the input CharSequence is {@code null}.
     */
    @MayReturnNull
    public static char[] toCharArray(final CharSequence source) {
        if (source == null) {
            return null; // NOSONAR
        } else if (source.isEmpty()) {
            return N.EMPTY_CHAR_ARRAY;
        } else if (source instanceof String) {
            return ((String) source).toCharArray();
        }

        final int len = N.len(source);

        final char[] array = new char[len];

        for (int i = 0; i < len; i++) {
            array[i] = source.charAt(i);
        }

        return array;
    }

    /**
     * <p>Converts a {@code CharSequence} into an array of code points.</p>
     *
     * <p>Valid pairs of surrogate code units will be converted into a single supplementary
     * code point. Isolated surrogate code units (i.e., a high surrogate not followed by a low surrogate or
     * a low surrogate not preceded by a high surrogate) will be returned as-is.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toCodePoints(null)    = null
     * Strings.toCodePoints("")      = []  // empty array
     * Strings.toCodePoints("ABC")   = [65, 66, 67]
     * Strings.toCodePoints("üëç")    = [128077]  // emoji as single code point
     * }</pre>
     *
     * @param str the character sequence to convert
     * @return an array of code points representing the input CharSequence, or {@code null} if the input is {@code null}.
     */
    @MayReturnNull
    public static int[] toCodePoints(final CharSequence str) {
        if (str == null) {
            return null; // NOSONAR
        } else if (str.isEmpty()) {
            return N.EMPTY_INT_ARRAY;
        }

        final String s = str.toString();

        return s.codePoints().toArray();
    }

    /**
     * Converts a character to lowercase.
     *
     * <p>This method converts the specified character to its lowercase equivalent
     * according to the Unicode standard.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toLowerCase('A');   // returns 'a'
     * Strings.toLowerCase('Z');   // returns 'z'
     * Strings.toLowerCase('a');   // returns 'a'
     * Strings.toLowerCase('1');   // returns '1'
     * Strings.toLowerCase('Œ©');   // returns 'œâ'
     * }</pre>
     *
     * @param ch the character to convert to lowercase.
     * @return the lowercase equivalent of the character.
     * @see Character#toLowerCase(char)
     */
    public static char toLowerCase(final char ch) {
        return Character.toLowerCase(ch);
    }

    /**
     * <p>
     * Converts a String to lower case as per {@link String#toLowerCase()}.
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>
     * <strong>Note:</strong> As described in the documentation for
     * {@link String#toLowerCase()}, the result of this method is affected by
     * the current locale. For platform-independent case transformations, the
     * method {@link #toLowerCase(String, Locale)} should be used with a specific
     * locale (e.g., {@link Locale#ENGLISH}).
     * </p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toLowerCase(null)    = null
     * Strings.toLowerCase("")      = ""
     * Strings.toLowerCase("aBc")   = "abc"
     * }</pre>
     *
     * @param str the String to lower case, may be {@code null}
     * @return the lower case String, or the specified String if it's {@code null} or empty.
     */
    public static String toLowerCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toLowerCase();
    }

    /**
     * <p>
     * Converts a String to lower case as per {@link String#toLowerCase(Locale)}
     * .
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>This method allows locale-specific case transformations, which is important
     * for certain languages where case conversion rules differ from the default.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toLowerCase(null, Locale.ENGLISH)    = null
     * Strings.toLowerCase("", Locale.ENGLISH)      = ""
     * Strings.toLowerCase("aBc", Locale.ENGLISH)   = "abc"
     * }</pre>
     *
     * @param str the String to lower case, may be {@code null}
     * @param locale the locale that defines the case transformation rules, must not be null
     * @return the lower case String, or the specified String if it's {@code null} or empty.
     */
    public static String toLowerCase(final String str, final Locale locale) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toLowerCase(locale);
    }

    /**
     * Converts the given string to lower case with underscores.
     * If the input string is {@code null} or empty, it returns the input string.
     *
     * <p>This method converts uppercase letters to lowercase and inserts underscores
     * before uppercase letters that are preceded by lowercase letters or followed by lowercase letters.
     * This is useful for converting camelCase or PascalCase strings to snake_case.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toLowerCaseWithUnderscore("helloWorld");      // returns "hello_world"
     * Strings.toLowerCaseWithUnderscore("HelloWorld");      // returns "hello_world"
     * Strings.toLowerCaseWithUnderscore("helloWorldAPI");   // returns "hello_world_api"
     * Strings.toLowerCaseWithUnderscore("IOError");         // returns "io_error"
     * Strings.toLowerCaseWithUnderscore(null);              // returns null
     * Strings.toLowerCaseWithUnderscore("");                // returns ""
     * }</pre>
     *
     * @param str the input string to be converted
     * @return the converted string in lower case with underscores
     * @see #toUpperCaseWithUnderscore(String)
     * @see #toCamelCase(String)
     * @see #toPascalCase(String)
     */
    public static String toLowerCaseWithUnderscore(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);
        char ch = 0;

        try {
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (Character.isUpperCase(ch)) {
                    if (i > 0 && (Character.isLowerCase(str.charAt(i - 1)) || (i < len - 1 && Character.isLowerCase(str.charAt(i + 1))))) {
                        if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {//NOSONAR
                            sb.append(WD._UNDERSCORE);
                        }
                    }

                    sb.append(Character.toLowerCase(ch));
                } else {
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Converts a character to uppercase.
     *
     * <p>This method converts the specified character to its uppercase equivalent
     * according to the Unicode standard.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toUpperCase('a');   // returns 'A'
     * Strings.toUpperCase('z');   // returns 'Z'
     * Strings.toUpperCase('A');   // returns 'A'
     * Strings.toUpperCase('1');   // returns '1'
     * Strings.toUpperCase('œâ');   // returns 'Œ©'
     * }</pre>
     *
     * @param ch the character to convert to uppercase.
     * @return the uppercase equivalent of the character.
     * @see Character#toUpperCase(char)
     */
    public static char toUpperCase(final char ch) {
        return Character.toUpperCase(ch);
    }

    /**
     * <p>
     * Converts a String to upper case as per {@link String#toUpperCase()}.
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>
     * <strong>Note:</strong> As described in the documentation for
     * {@link String#toUpperCase()}, the result of this method is affected by
     * the current locale. For platform-independent case transformations, the
     * method {@link #toUpperCase(String, Locale)} should be used with a specific
     * locale (e.g., {@link Locale#ENGLISH}).
     * </p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toUpperCase(null)    = null
     * Strings.toUpperCase("")      = ""
     * Strings.toUpperCase("aBc")   = "ABC"
     * }</pre>
     *
     * @param str the String to upper case, may be {@code null}
     * @return the upper case String, or the specified String if it's {@code null} or empty.
     */
    public static String toUpperCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toUpperCase();
    }

    /**
     * <p>
     * Converts a String to upper case as per {@link String#toUpperCase(Locale)}
     * </p>
     *
     * <p>
     * A {@code null} input String returns {@code null}.
     * </p>
     *
     * <p>This method allows locale-specific case transformations, which is important
     * for certain languages where case conversion rules differ from the default.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toUpperCase(null, Locale.ENGLISH)    = null
     * Strings.toUpperCase("", Locale.ENGLISH)      = ""
     * Strings.toUpperCase("aBc", Locale.ENGLISH)   = "ABC"
     * }</pre>
     *
     * @param str the String to upper case, may be {@code null}
     * @param locale the locale that defines the case transformation rules, must not be null
     * @return the upper case String, or the specified String if it's {@code null} or empty.
     */
    public static String toUpperCase(final String str, final Locale locale) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return str.toUpperCase(locale);
    }
    // Case conversion
    // -----------------------------------------------------------------------

    /**
     * Converts the given string to upper case with underscores.
     *
     * <p>This method converts the input string to uppercase and inserts underscores before uppercase letters 
     * that are preceded by lowercase letters or followed by lowercase letters. This is useful for converting 
     * camelCase or PascalCase strings to UPPER_CASE_WITH_UNDERSCORES format.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toUpperCaseWithUnderscore(null);              // returns null
     * Strings.toUpperCaseWithUnderscore("");                // returns ""
     * Strings.toUpperCaseWithUnderscore("helloWorld");      // returns "HELLO_WORLD"
     * Strings.toUpperCaseWithUnderscore("HelloWorld");      // returns "HELLO_WORLD"
     * Strings.toUpperCaseWithUnderscore("helloWorldAPI");   // returns "HELLO_WORLD_API"
     * Strings.toUpperCaseWithUnderscore("XMLParser");       // returns "XML_PARSER"
     * Strings.toUpperCaseWithUnderscore("IOError");         // returns "IO_ERROR"
     * }</pre>
     *
     * @param str the input string to be converted, may be {@code null} or empty
     * @return the converted string in upper case with underscores, or the original string if it is {@code null} or empty.
     * @see #toLowerCaseWithUnderscore(String)
     * @see #toCamelCase(String)
     * @see #toPascalCase(String)
     */
    public static String toUpperCaseWithUnderscore(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);
        char ch = 0;

        try {
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (Character.isUpperCase(ch)) {
                    if (i > 0 && (Character.isLowerCase(str.charAt(i - 1)) || (i < len - 1 && Character.isLowerCase(str.charAt(i + 1))))) {
                        if (!sb.isEmpty() && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {//NOSONAR
                            sb.append(WD._UNDERSCORE);
                        }
                    }

                    sb.append(ch);
                } else {
                    //    if (i > 0 && ((isAsciiNumeric(ch) && !isAsciiNumeric(str.charAt(i - 1))) || (isAsciiNumeric(str.charAt(i - 1)) && !isAsciiNumeric(ch)))) {
                    //        if (sb.length() > 0 && sb.charAt(sb.length() - 1) != WD._UNDERSCORE) {
                    //            sb.append(WD._UNDERSCORE);
                    //        }
                    //    }

                    sb.append(Character.toUpperCase(ch));
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Converts the specified string to camel case.
     *
     * <p>This method converts a string with underscores or hyphens to camel case format. 
     * The first word starts with a lowercase letter, and each subsequent word starts with an uppercase letter.
     * All other letters are lowercase. The delimiters (underscores or hyphens) are removed.</p>
     *
     * <p>If the input string contains no delimiters but has uppercase letters, it intelligently converts 
     * from PascalCase or UPPER_CASE to camelCase.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toCamelCase(null);           // returns null
     * Strings.toCamelCase("");             // returns ""
     * Strings.toCamelCase("first_name");   // returns "firstName"
     * Strings.toCamelCase("FIRST_NAME");   // returns "firstName"
     * Strings.toCamelCase("first-name");   // returns "firstName"
     * Strings.toCamelCase("FirstName");    // returns "firstName"
     * Strings.toCamelCase("FIRSTNAME");    // returns "firstname"
     * Strings.toCamelCase("firstName");    // returns "firstName"
     * }</pre>
     *
     * @param str the input string to be converted, may be {@code null} or empty
     * @return a camel case representation of the input string. Returns the original string if it's {@code null} or empty.
     * @see #toCamelCase(String, char)
     * @see #toPascalCase(String)
     * @see #toLowerCaseWithUnderscore(String)
     */
    public static String toCamelCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return toCamelCase(str, RegExUtil.split(str, RegExUtil.CAMEL_CASE_SEPARATOR));
    }

    /**
     * Converts the specified string to camel case using a custom split character.
     *
     * <p>This method converts a string with a specified delimiter character to camel case format. 
     * The first word starts with a lowercase letter, and each subsequent word starts with an uppercase letter.
     * All other letters are lowercase. The delimiter characters are removed.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toCamelCase(null, '.');           // returns null
     * Strings.toCamelCase("", '.');             // returns ""
     * Strings.toCamelCase("first.name", '.');   // returns "firstName"
     * Strings.toCamelCase("FIRST.NAME", '.');   // returns "firstName"
     * Strings.toCamelCase("first#name", '#');   // returns "firstName"
     * Strings.toCamelCase("firstName", '.');    // returns "firstName"
     * }</pre>
     *
     * @param str the input string to be converted, may be {@code null} or empty
     * @param splitChar the character used to split the input string.
     * @return a camel case representation of the input string. Returns the original string if it's {@code null} or empty.
     * @see #toCamelCase(String)
     * @see #toPascalCase(String, char)
     * @see #toLowerCaseWithUnderscore(String)
     */
    public static String toCamelCase(final String str, final char splitChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return toCamelCase(str, Strings.split(str, splitChar));
    }

    private static String toCamelCase(final String str, final String[] substrs) {
        final int firstSplitorIndex = N.len(substrs) == 1 ? -1 : substrs[0].length() + 1;

        if (firstSplitorIndex >= 0) {
            final StringBuilder sb = Objectory.createStringBuilder(str.length());

            try {
                boolean first = true;

                for (final String substr : substrs) {
                    if (isNotEmpty(substr)) {
                        sb.append(substr.toLowerCase());

                        if (!first) {
                            sb.setCharAt(sb.length() - substr.length(), Character.toUpperCase(substr.charAt(0)));
                        } else {
                            first = false;
                        }
                    }
                }

                return sb.toString();
            } finally {
                Objectory.recycle(sb);
            }
        } else {
            for (int i = 0, len = str.length(); i < len; i++) {
                if (Character.isLowerCase(str.charAt(i))) {
                    if (i == 1) {
                        return str.substring(0, 1).toLowerCase() + str.substring(1);
                    } else if (i > 1) {
                        return str.substring(0, i - 1).toLowerCase() + str.substring(i - 1);
                    }

                    break;
                } else if ((i + 1) == str.length()) {
                    return str.toLowerCase();
                }
            }

            return str;
        }
    }

    /**
     * Converts the specified string to Pascal case.
     *
     * <p>This method converts a string with underscores to Pascal case format (also known as UpperCamelCase). 
     * Each word starts with an uppercase letter, and all other letters are lowercase. 
     * The underscores are removed.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toPascalCase(null);           // returns null
     * Strings.toPascalCase("");             // returns ""
     * Strings.toPascalCase("first_name");   // returns "FirstName"
     * Strings.toPascalCase("FIRST_NAME");   // returns "FirstName"
     * Strings.toPascalCase("firstName");    // returns "FirstName"
     * Strings.toPascalCase("FirstName");    // returns "FirstName"
     * Strings.toPascalCase("first");        // returns "First"
     * }</pre>
     *
     * @param str the input string to be converted, may be {@code null} or empty
     * @return a Pascal case representation of the input string. Returns the original string if it's {@code null} or empty.
     * @see #toPascalCase(String, char)
     * @see #toCamelCase(String)
     * @see #toUpperCaseWithUnderscore(String)
     */
    public static String toPascalCase(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return toPascalCase(str, RegExUtil.split(str, RegExUtil.CAMEL_CASE_SEPARATOR));
    }

    /**
     * Converts the specified string to Pascal case using a custom split character.
     *
     * <p>This method converts a string with a specified delimiter character to Pascal case format (also known as UpperCamelCase). 
     * Each word starts with an uppercase letter, and all other letters are lowercase. 
     * The delimiter characters are removed.</p>
     *
     * <p>If the string contains no delimiter characters, only the first character is converted to uppercase.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.toPascalCase(null, '.');           // returns null
     * Strings.toPascalCase("", '.');             // returns ""
     * Strings.toPascalCase("first.name", '.');   // returns "FirstName"
     * Strings.toPascalCase("FIRST.NAME", '.');   // returns "FirstName"
     * Strings.toPascalCase("first-name", '-');   // returns "FirstName"
     * Strings.toPascalCase("firstName", '.');    // returns "FirstName"
     * Strings.toPascalCase("firstname", '.');    // returns "Firstname"
     * }</pre>
     *
     * @param str the input string to be converted, may be {@code null} or empty
     * @param splitChar the character used to split the input string.
     * @return a Pascal case representation of the input string. Returns the original string if it's {@code null} or empty.
     * @see #toPascalCase(String)
     * @see #toCamelCase(String, char)
     * @see #toUpperCaseWithUnderscore(String)
     */
    public static String toPascalCase(final String str, final char splitChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return toPascalCase(str, Strings.split(str, splitChar));
    }

    private static String toPascalCase(final String str, final String[] substrs) {
        final int firstSplitorIndex = N.len(substrs) == 1 ? -1 : substrs[0].length() + 1;

        if (firstSplitorIndex >= 0) {
            final StringBuilder sb = Objectory.createStringBuilder(str.length());

            try {
                for (final String substr : substrs) {
                    if (isNotEmpty(substr)) {
                        sb.append(substr.toLowerCase());

                        sb.setCharAt(sb.length() - substr.length(), Character.toUpperCase(substr.charAt(0)));
                    }
                }

                return sb.toString();
            } finally {
                Objectory.recycle(sb);
            }
        } else {
            return Character.isLowerCase(str.charAt(0)) ? str.substring(0, 1).toUpperCase() + str.substring(1) : str;
        }
    }

    /**
     * Swaps the case of a character changing upper and title case to lower case, and lower case to upper case.
     *
     * <p>This method converts uppercase and title case characters to lowercase, and lowercase characters to uppercase.
     * Characters that are neither uppercase, title case, nor lowercase remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.swapCase('A');   // returns 'a'
     * Strings.swapCase('a');   // returns 'A'
     * Strings.swapCase('1');   // returns '1'
     * Strings.swapCase(' ');   // returns ' '
     * }</pre>
     *
     * @param ch the input character to be case-swapped.
     * @return the case-swapped representation of the input character.
     * @see #swapCase(String)
     * @see Character#toLowerCase(char)
     * @see Character#toUpperCase(char)
     */
    public static char swapCase(final char ch) {
        return Character.isUpperCase(ch) || Character.isTitleCase(ch) ? Character.toLowerCase(ch)
                : (Character.isLowerCase(ch) ? Character.toUpperCase(ch) : ch);
    }

    /**
     * Swaps the case of a String changing upper and title case to lower case, and lower case to upper case.
     *
     * <p>This method processes each character in the string, converting uppercase and title case characters to lowercase, 
     * and lowercase characters to uppercase. Characters that are neither uppercase, title case, nor lowercase remain unchanged.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}.</p>
     *
     * <p>Note: This method performs character-by-character case swapping, not word-based swapping. 
     * For word-based algorithms, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.swapCase(null);                   // returns null
     * Strings.swapCase("");                     // returns ""
     * Strings.swapCase("The dog has a BONE");   // returns "tHE DOG HAS A bone"
     * Strings.swapCase("Hello World");          // returns "hELLO wORLD"
     * Strings.swapCase("ABC123xyz");            // returns "abc123XYZ"
     * }</pre>
     *
     * @param str the String to swap case, may be {@code null}
     * @return the case-swapped String, {@code null} if the input is {@code null}
     * @see #swapCase(char)
     */
    public static String swapCase(final String str) {
        if (isEmpty(str)) {
            return str;
        }

        final int strLen = str.length();
        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        int oldCodepoint, newCodePoint;

        for (int i = 0; i < strLen; i += Character.charCount(newCodePoint)) {
            oldCodepoint = str.codePointAt(i);

            if (Character.isUpperCase(oldCodepoint) || Character.isTitleCase(oldCodepoint)) {
                newCodePoint = Character.toLowerCase(oldCodepoint);
            } else if (Character.isLowerCase(oldCodepoint)) {
                newCodePoint = Character.toUpperCase(oldCodepoint);
            } else {
                newCodePoint = oldCodepoint;
            }

            newCodePoints[outOffset++] = newCodePoint;
        }

        return new String(newCodePoints, 0, outOffset);
    }

    // Copied from Apache commons Lang under Apache License v2.

    /**
     * Converts the first character of the given string to lower case.
     *
     * <p>This method converts only the first character to lowercase while leaving the rest of the string unchanged.
     * It properly handles Unicode characters including supplementary characters.</p>
     *
     * <p>The method returns the original string if it is {@code null}, empty, or already starts with a lowercase character.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.uncapitalize(null);    // returns null
     * Strings.uncapitalize("");      // returns ""
     * Strings.uncapitalize("Cat");   // returns "cat"
     * Strings.uncapitalize("CAT");   // returns "cAT"
     * Strings.uncapitalize("cat");   // returns "cat"
     * Strings.uncapitalize("C");     // returns "c"
     * }</pre>
     *
     * @param str the string to be uncapitalized, may be {@code null} or empty
     * @return a string with its first character converted to lower case, or the original string if it's {@code null}, empty, or already starts with a lowercase character.
     * @see #capitalize(String)
     * @see #capitalizeFully(String)
     */
    public static String uncapitalize(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int firstCodePoint = str.codePointAt(0);
        final int newCodePoint = Character.toLowerCase(firstCodePoint);

        if (firstCodePoint == newCodePoint) {
            // already uncapitalize
            return str;
        }

        final int strLen = str.length();

        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        newCodePoints[outOffset++] = newCodePoint; // copy the first code point

        for (int inOffset = Character.charCount(firstCodePoint); inOffset < strLen;) {
            final int codePoint = str.codePointAt(inOffset);
            newCodePoints[outOffset++] = codePoint; // copy the remaining ones
            inOffset += Character.charCount(codePoint);
        }

        return new String(newCodePoints, 0, outOffset);
    }

    // Copied from Apache commons Lang under Apache License v2.

    /**
     * Converts the first character of the given string to upper case.
     *
     * <p>This method converts only the first character to uppercase (title case) while leaving the rest of the string unchanged.
     * It properly handles Unicode characters including supplementary characters.</p>
     *
     * <p>The method returns the original string if it is {@code null}, empty, or already starts with an uppercase character.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.capitalize(null);      // returns null
     * Strings.capitalize("");        // returns ""
     * Strings.capitalize("cat");     // returns "Cat"
     * Strings.capitalize("cAT");     // returns "CAT"
     * Strings.capitalize("Cat");     // returns "Cat"
     * Strings.capitalize("c");       // returns "C"
     * Strings.capitalize("'cat'");   // returns "'cat'"
     * }</pre>
     *
     * @param str the string to be capitalized, may be {@code null} or empty
     * @return a string with its first character converted to upper case, or the original string if it's {@code null}, empty, or already starts with an uppercase character.
     * @see #uncapitalize(String)
     * @see #capitalizeFully(String)
     */
    public static String capitalize(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int firstCodepoint = str.codePointAt(0);
        final int newCodePoint = Character.toTitleCase(firstCodepoint);

        if (firstCodepoint == newCodePoint) {
            // already capitalized
            return str;
        }

        final int strLen = str.length();
        final int[] newCodePoints = new int[strLen]; // cannot be longer than the char array
        int outOffset = 0;
        newCodePoints[outOffset++] = newCodePoint; // copy the first code point

        for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen;) {
            final int codePoint = str.codePointAt(inOffset);
            newCodePoints[outOffset++] = codePoint; // copy the remaining ones
            inOffset += Character.charCount(codePoint);
        }

        return new String(newCodePoints, 0, outOffset);
    }

    /**
     * Capitalizes all the words in the specified string split by space (' ').
     *
     * <p>This method splits the input string by spaces and capitalizes the first letter of each word.
     * The rest of each word is left unchanged. Empty tokens between consecutive spaces are preserved.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.capitalizeFully(null);             // returns null
     * Strings.capitalizeFully("");               // returns ""
     * Strings.capitalizeFully("hello world");    // returns "Hello World"
     * Strings.capitalizeFully("HELLO WORLD");    // returns "HELLO WORLD"
     * Strings.capitalizeFully("hello  world");   // returns "Hello  World"
     * Strings.capitalizeFully("hELLO wORLD");    // returns "HELLO WORLD"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @return the processed string with all words capitalized, or the original string if it's {@code null} or empty.
     * @see #capitalizeFully(String, String)
     * @see #capitalize(String)
     */
    public static String capitalizeFully(final String str) {
        return capitalizeFully(str, " ");
    }

    /**
     * Capitalizes all the words in the specified string split by the provided delimiter.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word.
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.capitalizeFully(null, "-");                 // returns null
     * Strings.capitalizeFully("", "-");                   // returns ""
     * Strings.capitalizeFully("hello-world", "-");        // returns "Hello-World"
     * Strings.capitalizeFully("HELLO_WORLD", "_");        // returns "HELLO_WORLD"
     * Strings.capitalizeFully("hello.world.java", ".");   // returns "Hello.World.Java"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @param delimiter the delimiter used to split the string into words. It must not be empty.
     * @return the processed string with all words capitalized, or the original string if it's {@code null} or empty.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #capitalizeFully(String)
     * @see #capitalizeFully(String, String, String...)
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String capitalizeFully(final String str, final String delimiter) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter);   // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);

        for (int i = 0; i < words.length; i++) {
            words[i] = capitalize(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Capitalizes all the words in the given string, split by the provided delimiter, excluding the specified words except the first word.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word,
     * except for words that appear in the excludedWords array (unless they are the first word).
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The first word is always capitalized regardless of whether it appears in the excluded words list.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.capitalizeFully("the quick brown fox", " ", "the", "of");   // returns "The Quick Brown Fox"
     * Strings.capitalizeFully("the end of story", " ", "the", "of");      // returns "The End of Story"
     * Strings.capitalizeFully("of mice and men", " ", "of", "and");       // returns "Of Mice and Men"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty If it's {@code null} or empty, the method will return the input string.
     * @param delimiter the delimiter used to split the string into words. It must not be empty.
     * @param excludedWords an array of words to be excluded from capitalization. If it's {@code null} or empty, all words will be capitalized.
     * @return the processed string with all non-excluded words capitalized.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #capitalizeFully(String, String)
     * @see #capitalizeFully(String, String, Collection)
     */
    public static String capitalizeFully(final String str, final String delimiter, final String... excludedWords) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter);   // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return capitalizeFully(str, delimiter);
        }

        return capitalizeFully(str, delimiter, N.toSet(excludedWords));
    }

    /**
     * Capitalizes all the words in the given string, split by the provided delimiter, excluding the words in the excludedWords collection except the first word.
     *
     * <p>This method splits the input string by the specified delimiter and capitalizes the first letter of each word,
     * except for words that appear in the excludedWords collection (unless they are the first word).
     * The rest of each word is left unchanged. Empty tokens between consecutive delimiters are preserved.</p>
     *
     * <p>The first word is always capitalized regardless of whether it appears in the excluded words collection.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> excluded = Set.of("the", "of", "and");
     * Strings.capitalizeFully("the lord of the rings", " ", excluded);      // returns "The Lord of the Rings"
     * Strings.capitalizeFully("and then there were none", " ", excluded);   // returns "And Then There Were None"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty If it's {@code null} or empty, the method will return the input string.
     * @param delimiter the delimiter used to split the string into words. It must not be empty.
     * @param excludedWords a collection of words to be excluded from capitalization. If it's {@code null} or empty, all words will be capitalized.
     * @return the processed string with all non-excluded words capitalized.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #capitalizeFully(String, String)
     * @see #capitalizeFully(String, String, String...)
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String capitalizeFully(final String str, final String delimiter, final Collection<String> excludedWords) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter);   // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return capitalizeFully(str, delimiter);
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);
        final Collection<String> excludedWordSet = excludedWords instanceof Set || (excludedWords.size() <= 3 && words.length <= 3) ? excludedWords
                : N.newHashSet(excludedWords);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = i != 0 && excludedWordSet.contains(words[i]) ? words[i] : capitalize(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Converts all the words in the given string using the provided converter function.
     *
     * <p>This method splits the input string by spaces and applies the converter function to each word.
     * Empty tokens between consecutive spaces are preserved. The words are then joined back together with spaces.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.convertWords("hello world", String::toUpperCase);    // returns "HELLO WORLD"
     * Strings.convertWords("hello world", s -> s + "!");           // returns "hello! world!"
     * Strings.convertWords("hello  world", String::toUpperCase);   // returns "HELLO  WORLD"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty If it's {@code null} or empty, the method will return the input string.
     * @param converter the function used to convert each word. This function should accept a string and return a string.
     * @return the processed string with all words converted using the provided converter function.
     * @see #convertWords(String, String, Function)
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String convertWords(final String str, final Function<? super String, String> converter) {
        return convertWords(str, " ", converter);
    }

    /**
     * Converts all the words from the specified string, split by the provided delimiter, using the provided converter function.
     *
     * <p>This method splits the input string by the specified delimiter and applies the converter function to each word.
     * Empty tokens between consecutive delimiters are preserved. The words are then joined back together with the delimiter.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.convertWords("hello-world", "-", String::toUpperCase);       // returns "HELLO-WORLD"
     * Strings.convertWords("hello.world.java", ".", s -> "[" + s + "]");   // returns "[hello].[world].[java]"
     * Strings.convertWords("hello--world", "-", String::toUpperCase);      // returns "HELLO--WORLD"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty If it's {@code null} or empty, the method will return the input string.
     * @param delimiter the delimiter used to split the string into words. It must not be empty.
     * @param converter the function used to convert each word.
     * @return the processed string with all words converted using the provided converter function.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #convertWords(String, Function)
     * @see #convertWords(String, String, Collection, Function)
     */
    public static String convertWords(final String str, final String delimiter, final Function<? super String, String> converter)
            throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter);   // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = converter.apply(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Converts all the words from the specified string, split by the provided delimiter, using the provided converter function.
     * Words that are present in the excludedWords collection are not converted.
     *
     * <p>This method splits the input string by the specified delimiter and applies the converter function to each word,
     * except for words that appear in the excludedWords collection. Empty tokens between consecutive delimiters are preserved.
     * The words are then joined back together with the delimiter.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> excluded = Set.of("and", "or");
     * Strings.convertWords("jack and jill", " ", excluded, String::toUpperCase);   // returns "JACK and JILL"
     * Strings.convertWords("true or false", " ", excluded, s -> "*" + s + "*");    // returns "*true* or *false*"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty If it's {@code null} or empty, the method will return the input string.
     * @param delimiter the delimiter used to split the string into words. It must not be empty.
     * @param excludedWords a collection of words to be excluded from conversion. If it's {@code null} or empty, all words will be converted.
     * @param converter the function used to convert each word. If a word is in the excludedWords collection, it will not be converted.
     * @return the processed string with all non-excluded words converted using the provided converter function.
     * @throws IllegalArgumentException if the provided delimiter is empty.
     * @see #convertWords(String, Function)
     * @see #convertWords(String, String, Function)
     */
    public static String convertWords(final String str, final String delimiter, final Collection<String> excludedWords,
            final Function<? super String, String> converter) throws IllegalArgumentException {
        N.checkArgNotEmpty(delimiter, cs.delimiter);   // NOSONAR

        if (str == null || str.isEmpty()) {
            return str;
        }

        if (N.isEmpty(excludedWords)) {
            return convertWords(str, delimiter, converter);
        }

        final String[] words = splitPreserveAllTokens(str, delimiter);
        final Collection<String> excludedWordSet = excludedWords instanceof Set || (excludedWords.size() <= 3 && words.length <= 3) ? excludedWords
                : N.newHashSet(excludedWords);

        for (int i = 0, len = words.length; i < len; i++) {
            words[i] = excludedWordSet.contains(words[i]) ? words[i] : converter.apply(words[i]);
        }

        return join(words, delimiter);
    }

    /**
     * Replaces single quotes (') and double quotes (") with escaped versions (\' and \") if they are not already escaped.
     *
     * <p>This method scans through the string and adds a backslash before any unescaped single or double quote character.
     * If a quote is already preceded by a backslash, it will not be escaped again.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.quoteEscaped(null);                      // returns null
     * Strings.quoteEscaped("");                        // returns ""
     * Strings.quoteEscaped("Hello World");             // returns "Hello World"
     * Strings.quoteEscaped("She said \"Hi\"");         // returns "She said \"Hi\""
     * Strings.quoteEscaped("It's a test");             // returns "It\'s a test"
     * Strings.quoteEscaped("Already \\'escaped\\'");   // returns "Already \\'escaped\\'"
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @return the string with all unescaped single and double quotes escaped, or the original string if it's {@code null} or empty.
     * @see #quoteEscaped(String, char)
     */
    public static String quoteEscaped(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);

        try {
            char ch = 0;
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if ((ch == _BACKSLASH) && (i < (len - 1))) {
                    sb.append(ch);
                    sb.append(str.charAt(++i));
                } else {
                    if ((ch == _QUOTATION_S) || (ch == _QUOTATION_D)) {
                        sb.append(_BACKSLASH);
                    }
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Escapes the specified quotation character in the given string if it is not already escaped.
     *
     * <p>This method scans through the string and adds a backslash before any unescaped occurrence of the specified quote character.
     * If the quote character is already preceded by a backslash, it will not be escaped again.</p>
     *
     * <p>The method returns the original string if it is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.quoteEscaped(null, '"');                        // returns null
     * Strings.quoteEscaped("", '"');                          // returns ""
     * Strings.quoteEscaped("She said \"Hi\"", '"');           // returns "She said \"Hi\""
     * Strings.quoteEscaped("It's a test", '\'');              // returns "It\'s a test"
     * Strings.quoteEscaped("No quotes here", '"');            // returns "No quotes here"
     * Strings.quoteEscaped("Already \\\"escaped\\\"", '"');   // returns "Already \\\"escaped\\\""
     * }</pre>
     *
     * @param str the input string to be processed, may be {@code null} or empty
     * @param quoteChar the quotation character to be escaped, should be either {@code "} or {@code '}
     * @return the processed string with the specified quotation character escaped, or the original string if it is {@code null} or empty
     * @see #quoteEscaped(String)
     */
    public static String quoteEscaped(final String str, final char quoteChar) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + 16);

        try {
            char ch = 0;
            for (int i = 0, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if ((ch == _BACKSLASH) && (i < (len - 1))) {
                    sb.append(ch);
                    sb.append(str.charAt(++i));
                } else {
                    if (ch == quoteChar) {
                        sb.append(_BACKSLASH);
                    }
                    sb.append(ch);
                }
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    // --------------------------------------------------------------------------

    /**
     * Converts the char to the unicode format '\u0020'.
     *
     * <p>This method converts a character to its Unicode escape sequence representation.
     * The format is the Java source code format: a backslash followed by 'u' and exactly four hexadecimal digits.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.unicodeEscaped(' ');    // returns "\u0020"
     * Strings.unicodeEscaped('A');    // returns "\u0041"
     * Strings.unicodeEscaped('‚Ç¨');    // returns "\u20ac"
     * Strings.unicodeEscaped('\n');   // returns "\u000a"
     * }</pre>
     *
     * @param ch the character to convert
     * @return the Unicode escape sequence representation of the character
     */
    public static String unicodeEscaped(final char ch) {
        if (ch < 0x10) {
            return "\\u000" + Integer.toHexString(ch);
        } else if (ch < 0x100) {
            return "\\u00" + Integer.toHexString(ch);
        } else if (ch < 0x1000) {
            return "\\u0" + Integer.toHexString(ch);
        }

        return "\\u" + Integer.toHexString(ch);
    }

    /**
     * Normalizes whitespace in a string by trimming leading and trailing whitespace and replacing sequences of whitespace characters with a single space.
     *
     * <p>This method is similar to the XPath normalize-space function. It first trims the string using {@link #trim(String)} 
     * to remove leading and trailing whitespace, then replaces any sequence of whitespace characters (including space, tab, 
     * newline, carriage return, form feed, and vertical tab) with a single space character.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}, and an empty string if the input is empty or contains only whitespace.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.normalizeSpace(null);                      // returns null
     * Strings.normalizeSpace("");                        // returns ""
     * Strings.normalizeSpace("  ");                      // returns ""
     * Strings.normalizeSpace("abc");                     // returns "abc"
     * Strings.normalizeSpace("  abc  ");                 // returns "abc"
     * Strings.normalizeSpace("  abc    def  ");          // returns "abc def"
     * Strings.normalizeSpace("abc\n\tdef");              // returns "abc def"
     * Strings.normalizeSpace("  multiple   spaces  ");   // returns "multiple spaces"
     * }</pre>
     *
     * @param str the source String to normalize whitespaces from, may be {@code null}
     * @return the normalized String, {@code null} if the input is {@code null}
     * @see Pattern
     * @see #trim(String)
     * @see <a href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize-space</a>
     */
    public static String normalizeSpace(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return WHITESPACE_PATTERN.matcher(str.trim()).replaceAll(WD.SPACE);
    }

    /**
     * Replaces all occurrences of a String within another String.
     *
     * <p>This method searches for all occurrences of the target string and replaces them with the replacement string.
     * A {@code null} reference passed to this method is a no-op.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceAll(null, *, *);             // returns null
     * Strings.replaceAll("", *, *);               // returns ""
     * Strings.replaceAll("any", null, *);         // returns "any"
     * Strings.replaceAll("any", *, null);         // returns "any"
     * Strings.replaceAll("any", "", *);           // returns "any"
     * Strings.replaceAll("aba", "a", null);       // returns "b"
     * Strings.replaceAll("aba", "a", "");         // returns "b"
     * Strings.replaceAll("aba", "a", "z");        // returns "zbz"
     * Strings.replaceAll("abaaaba", "aa", "z");   // returns "abzaba"
     * }</pre>
     *
     * @param str text to search and replace in, may be {@code null}
     * @param target the String to search for, may be {@code null}
     * @param replacement the String to replace it with, may be {@code null}
     * @return the text with all occurrences of the target string replaced, {@code null} if the input is {@code null}
     */
    public static String replaceAll(final String str, final String target, final String replacement) {
        return replaceAll(str, 0, target, replacement);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the target string starting from the given index and replaces them with the replacement string.
     * Occurrences before the specified index are not replaced.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceAll("abacadae", 0, "a", "z");      // returns "zbzczde"
     * Strings.replaceAll("abacadae", 3, "a", "z");      // returns "abzczde"
     * Strings.replaceAll("abacadae", 5, "a", "z");      // returns "abacadze"
     * Strings.replaceAll("hello world", 0, "o", "0");   // returns "hell0 w0rld"
     * Strings.replaceAll("hello world", 6, "o", "0");   // returns "hello w0rld"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return the text with all occurrences of the target string replaced starting from the specified index, {@code null} if the input is {@code null}
     */
    public static String replaceAll(final String str, final int fromIndex, final String target, final String replacement) {
        return replace(str, fromIndex, target, replacement, -1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method searches for the first occurrence of the target string and replaces it with the replacement string.
     * Subsequent occurrences are not replaced.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceFirst(null, *, *);             // returns null
     * Strings.replaceFirst("", *, *);               // returns ""
     * Strings.replaceFirst("any", null, *);         // returns "any"
     * Strings.replaceFirst("any", *, null);         // returns "ny"
     * Strings.replaceFirst("any", "", *);           // returns "any"
     * Strings.replaceFirst("aba", "a", null);       // returns "ba"
     * Strings.replaceFirst("aba", "a", "");         // returns "ba"
     * Strings.replaceFirst("aba", "a", "z");        // returns "zba"
     * Strings.replaceFirst("abaaaba", "aa", "z");   // returns "abzaba"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return the text with the first occurrence of the target string replaced, {@code null} if the input is {@code null}
     */
    public static String replaceFirst(final String str, final String target, final String replacement) {
        return replaceFirst(str, 0, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method searches for the first occurrence of the target string starting from the given index and replaces it with the replacement string.
     * Occurrences before the specified index are not replaced.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceFirst("abacadae", 0, "a", "z");      // returns "zbacadae"
     * Strings.replaceFirst("abacadae", 3, "a", "z");      // returns "abzcadae"
     * Strings.replaceFirst("abacadae", 5, "a", "z");      // returns "abacadze"
     * Strings.replaceFirst("hello world", 0, "o", "0");   // returns "hell0 world"
     * Strings.replaceFirst("hello world", 6, "o", "0");   // returns "hello w0rld"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return the text with the first occurrence of the target string replaced starting from the specified index, {@code null} if the input is {@code null}
     */
    public static String replaceFirst(final String str, final int fromIndex, final String target, final String replacement) {
        return replace(str, fromIndex, target, replacement, 1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method is equivalent to {@link #replaceFirst(String, String, String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceOnce(null, *, *);         // returns null
     * Strings.replaceOnce("", *, *);           // returns ""
     * Strings.replaceOnce("any", null, *);     // returns "any"
     * Strings.replaceOnce("any", *, null);     // returns "any"
     * Strings.replaceOnce("any", "", *);       // returns "any"
     * Strings.replaceOnce("aba", "a", null);   // returns "ba"
     * Strings.replaceOnce("aba", "a", "");     // returns "ba"
     * Strings.replaceOnce("aba", "a", "z");    // returns "zba"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null}
     * @param target the string to be replaced, may be {@code null}
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with the first occurrence of the target string replaced with the replacement string.
     *         If the input string or target string is {@code null}, the method returns the original string.
     * @deprecated Use {@link #replaceFirst(String, String, String)} instead
     */
    @Deprecated
    public static String replaceOnce(final String str, final String target, final String replacement) {
        return replaceFirst(str, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, starting from a specified index.
     *
     * <p>This method is equivalent to {@link #replaceFirst(String, int, String, String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceOnce("aba", 1, "a", "z");    // returns "abz"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with the first occurrence of the target string replaced with the replacement string, starting from the specified index.
     * @deprecated Use {@link #replaceFirst(String, int, String, String)} instead
     */
    @Deprecated
    public static String replaceOnce(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceFirst(str, fromIndex, target, replacement);
    }

    /**
     * Replaces the last occurrence of a target string in the input string with a replacement string.
     *
     * <p>This method searches for the last occurrence of the target string and replaces it with the replacement string.
     * All other occurrences remain unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceLast(null, *, *);             // returns null
     * Strings.replaceLast("", *, *);               // returns ""
     * Strings.replaceLast("any", null, *);         // returns "any"
     * Strings.replaceLast("any", "a", null);       // returns "ny"
     * Strings.replaceLast("any", "", *);           // returns "any"
     * Strings.replaceLast("aba", "a", null);       // returns "ab"
     * Strings.replaceLast("aba", "a", "");         // returns "ab"
     * Strings.replaceLast("aba", "a", "z");        // returns "abz"
     * Strings.replaceLast("abaaaba", "aa", "z");   // returns "abaazba"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the String to replace with, may be {@code null}
     * @return a new string with the last occurrence of the target string replaced with the replacement string.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceLast(final String str, final String target, final String replacement) {
        return replaceLast(str, N.len(str), target, replacement);
    }

    /**
     * Replaces the last occurrence of a target string in the input string with a replacement string, searching backward from a specified index.
     *
     * <p>This method searches backward from the specified index for the last occurrence of the target string and replaces it with the replacement string.
     * The search starts from the given index and proceeds toward the beginning of the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceLast("abacadae", 8, "a", "z");       // returns "abacadze"
     * Strings.replaceLast("abacadae", 5, "a", "z");       // returns "abzcadae"
     * Strings.replaceLast("abacadae", 2, "a", "z");       // returns "zbacadae"
     * Strings.replaceLast("hello world", 11, "o", "0");   // returns "hello w0rld"
     * Strings.replaceLast("hello world", 5, "o", "0");    // returns "hell0 world"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param startIndexFromBack the index to start the search from, searching backward.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with the last occurrence of the target string replaced with the replacement string, starting from the specified index backward.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceLast(final String str, final int startIndexFromBack, final String target, final String replacement) {
        if (isEmpty(str) || isEmpty(target) || startIndexFromBack < 0) {
            return str;
        }

        final int lastIndex = lastIndexOf(str, target, startIndexFromBack);

        if (lastIndex < 0) {
            return str;
        }

        return Strings.replaceRange(str, lastIndex, lastIndex + N.len(target), replacement);
    }

    /**
     * Replaces occurrences of a target string in the input string with a replacement string, starting from a specified index and up to a maximum number of replacements.
     *
     * <p>This method provides fine-grained control over string replacement operations. You can specify where to start searching,
     * what to replace, what to replace it with, and how many replacements to make.</p>
     *
     * <p>A {@code null} reference passed to this method is a no-op.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replace(null, *, *, *, *);           // returns null
     * Strings.replace("", *, *, *, *);             // returns ""
     * Strings.replace("any", *, null, *, *);       // returns "any"
     * Strings.replace("any", *, "", *, *);         // returns "any"
     * Strings.replace("any", *, *, *, 0);          // returns "any"
     * Strings.replace("abaa", 0, "a", null, -1);   // returns "b"
     * Strings.replace("abaa", 0, "a", "", -1);     // returns "b"
     * Strings.replace("abaa", 0, "a", "z", 0);     // returns "abaa"
     * Strings.replace("abaa", 0, "a", "z", 1);     // returns "zbaa"
     * Strings.replace("abaa", 0, "a", "z", 2);     // returns "zbza"
     * Strings.replace("abaa", 0, "a", "z", -1);    // returns "zbzz"
     * Strings.replace("abaa", 1, "a", "z", -1);    // returns "abzz"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null}
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null}
     * @param replacement the string to replace the target string. If it's {@code null}, it will be treated as an empty string.
     * @param max the maximum number of replacements. If it's -1, all occurrences will be replaced.
     * @return a new string with occurrences of the target string replaced with the replacement string, starting from the specified index and up to the maximum number of replacements.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replace(final String str, final int fromIndex, final String target, final String replacement, final int max) {
        return replace(str, fromIndex, target, replacement, max, false);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for all occurrences of the target string and replaces them with the replacement string.
     * The case of the original text is preserved except for the replaced portions.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceAllIgnoreCase(null, *, *);         // returns null
     * Strings.replaceAllIgnoreCase("", *, *);           // returns ""
     * Strings.replaceAllIgnoreCase("any", null, *);     // returns "any"
     * Strings.replaceAllIgnoreCase("any", *, null);     // returns "any"
     * Strings.replaceAllIgnoreCase("any", "", *);       // returns "any"
     * Strings.replaceAllIgnoreCase("aba", "A", null);   // returns "b"
     * Strings.replaceAllIgnoreCase("aba", "A", "");     // returns "b"
     * Strings.replaceAllIgnoreCase("aba", "A", "z");    // returns "zbz"
     * Strings.replaceAllIgnoreCase("ABa", "a", "z");    // returns "zBz"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with all occurrences of the target string replaced with the replacement string, ignoring case considerations.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceAllIgnoreCase(final String str, final String target, final String replacement) {
        return replaceAllIgnoreCase(str, 0, target, replacement);
    }

    /**
     * Replaces all occurrences of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index.
     *
     * <p>This method performs a case-insensitive search for all occurrences of the target string starting from the given index 
     * and replaces them with the replacement string. The case of the original text is preserved except for the replaced portions.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceAllIgnoreCase("aBaCaDaE", 0, "A", "z");      // returns "zBzCzDzE"
     * Strings.replaceAllIgnoreCase("aBaCaDaE", 3, "A", "z");      // returns "aBzCzDzE"
     * Strings.replaceAllIgnoreCase("aBaCaDaE", 5, "A", "z");      // returns "aBaCzDzE"
     * Strings.replaceAllIgnoreCase("HELLO world", 0, "o", "0");   // returns "HELL0 w0rld"
     * Strings.replaceAllIgnoreCase("HELLO world", 6, "o", "0");   // returns "HELLO w0rld"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with all occurrences of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceAllIgnoreCase(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceIgnoreCase(str, fromIndex, target, replacement, -1);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, ignoring case considerations.
     *
     * <p>This method searches for the first occurrence of the target string in the input string without considering case differences,
     * and replaces it with the specified replacement string. The search starts from the beginning of the input string.</p>
     *
     * <p>The method returns the original string if the target is not found or if the input/target is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceFirstIgnoreCase("Hello World", "hello", "Hi");      // returns "Hi World"
     * Strings.replaceFirstIgnoreCase("JAVA java Java", "java", "C++");   // returns "C++ java Java"
     * Strings.replaceFirstIgnoreCase("Programming", "GRAM", "");         // returns "Proming"
     * Strings.replaceFirstIgnoreCase("Test", "xyz", "abc");              // returns "Test"
     * Strings.replaceFirstIgnoreCase(null, "test", "new");               // returns null
     * Strings.replaceFirstIgnoreCase("Test", null, "new");               // returns "Test"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with the first occurrence of the target string replaced with the replacement string, ignoring case considerations.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceFirstIgnoreCase(final String str, final String target, final String replacement) {
        return replaceFirstIgnoreCase(str, 0, target, replacement);
    }

    /**
     * Replaces the first occurrence of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index.
     *
     * <p>This method searches for the first occurrence of the target string in the input string starting from the specified index,
     * without considering case differences, and replaces it with the specified replacement string.</p>
     *
     * <p>The method returns the original string if the target is not found after the specified index or if the input/target is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceFirstIgnoreCase("Hello HELLO hello", 0, "hello", "Hi");    // returns "Hi HELLO hello"
     * Strings.replaceFirstIgnoreCase("Hello HELLO hello", 6, "hello", "Hi");    // returns "Hello Hi hello"
     * Strings.replaceFirstIgnoreCase("Hello HELLO hello", 12, "hello", "Hi");   // returns "Hello HELLO Hi"
     * Strings.replaceFirstIgnoreCase("Test String", 5, "test", "Best");         // returns "Test String"
     * Strings.replaceFirstIgnoreCase("Test", 10, "test", "Best");               // returns "Test"
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @return a new string with the first occurrence of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceFirstIgnoreCase(final String str, final int fromIndex, final String target, final String replacement) {
        return replaceIgnoreCase(str, fromIndex, target, replacement, 1);
    }

    /**
     * Replaces occurrences of a target string in the input string with a replacement string, ignoring case considerations, starting from a specified index and up to a maximum number of replacements.
     *
     * <p>This method searches for occurrences of the target string in the input string starting from the specified index,
     * without considering case differences, and replaces them with the specified replacement string up to the maximum number specified.</p>
     *
     * <p>If max is -1, all occurrences will be replaced. If max is 0, no replacements will be made.
     * If the replacement is {@code null}, it will be treated as an empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceIgnoreCase("Java JAVA java", 0, "java", "C++", -1);   // returns "C++ C++ C++"
     * Strings.replaceIgnoreCase("Java JAVA java", 0, "java", "C++", 2);    // returns "C++ C++ java"
     * Strings.replaceIgnoreCase("Java JAVA java", 5, "java", "C++", -1);   // returns "Java C++ C++"
     * Strings.replaceIgnoreCase("Test String", 0, "xyz", "abc", -1);       // returns "Test String"
     * Strings.replaceIgnoreCase("Test", 0, "test", null, 1);               // returns ""
     * }</pre>
     *
     * @param str the input string where the replacement should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the search for the target string. It should be a non-negative integer.
     * @param target the string to be replaced, may be {@code null} or empty
     * @param replacement the string to replace the target string, may be {@code null}
     * @param max the maximum number of replacements. If it's -1, all occurrences will be replaced.
     * @return a new string with occurrences of the target string replaced with the replacement string, ignoring case considerations, starting from the specified index and up to the maximum number of replacements.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the target string is not found, the input string is returned unchanged.
     */
    public static String replaceIgnoreCase(final String str, final int fromIndex, final String target, final String replacement, final int max) {
        return replace(str, fromIndex, target, replacement, max, true);
    }

    private static String replace(final String str, final int fromIndex, final String target, String replacement, int max, final boolean ignoreCase) {
        N.checkPositionIndex(fromIndex, N.len(str));

        if (isEmpty(str) || isEmpty(target) || max == 0) {
            return str;
        }

        if (replacement == null) {
            replacement = "";
        }

        final String searchText = ignoreCase ? str.toLowerCase() : str;
        final String searchTarget = ignoreCase ? target.toLowerCase() : target;

        int end = searchText.indexOf(searchTarget, fromIndex);

        if (end == N.INDEX_NOT_FOUND) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length() + (N.len(replacement) - N.len(target)) * (N.min(16, max)));
        final int substrLength = target.length();
        sb.append(str, 0, fromIndex);
        int start = fromIndex;

        try {
            while (end != N.INDEX_NOT_FOUND) {
                sb.append(str, start, end).append(replacement);
                start = end + substrLength;

                if (--max == 0) {
                    break;
                }

                end = searchText.indexOf(searchTarget, start);
            }

            sb.append(str, start, str.length());

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Replaces the substring specified by the start and end indices with the specified replacement string.
     *
     * <p>This method replaces the characters in the input string from the start index (inclusive) to the end index (exclusive)
     * with the specified replacement string. The original string is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceRange("Hello World", 6, 11, "Java");   // returns "Hello Java"
     * Strings.replaceRange("Programming", 0, 7, "Test");    // returns "Testming"
     * Strings.replaceRange("ABCDEF", 2, 4, "XYZ");          // returns "ABXYZEF"
     * Strings.replaceRange("Test", 1, 3, "");               // returns "Tt"
     * }</pre>
     *
     * @param str the input string where the replacement should occur. It cannot be {@code null}.
     * @param fromIndex the start index of the substring to be replaced. It should be a non-negative integer and less than the length of the input string.
     * @param toIndex the end index of the substring to be replaced. It should be a non-negative integer, greater than the start index and less than or equal to the length of the input string.
     * @param replacement the string to replace the substring. It cannot be {@code null}.
     * @return a new string with the specified substring replaced with the replacement string.
     * @throws IndexOutOfBoundsException if the start or end index is out of the string bounds.
     * @deprecated Use {@link #replaceRange(String, int, int, String)} instead of this method.
     * @see #replaceRange(String, int, int, String)
     */
    @Deprecated
    public static String replace(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        return replaceRange(str, fromIndex, toIndex, replacement);
    }

    /**
     * Replaces the substring between two specified delimiters in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the start delimiter and then finds the first occurrence of the end delimiter
     * after the start delimiter. The substring between these delimiters (excluding the delimiters themselves) is replaced
     * with the replacement string.</p>
     *
     * <p>The delimiters themselves are not included in the replaced substring and remain in the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceBetween("Hello [World]!", "[", "]", "Java");   // returns "Hello [Java]!"
     * Strings.replaceBetween("Start<old>End", "<", ">", "new");     // returns "Start<new>End"
     * Strings.replaceBetween("A{B{C}D}E", "{", "}", "X");           // returns "A{X}D}E"
     * Strings.replaceBetween("No delimiters", "[", "]", "test");    // returns "No delimiters"
     * Strings.replaceBetween("Only[Start", "[", "]", "test");       // returns "Only[Start"
     * Strings.replaceBetween(null, "[", "]", "test");               // returns null
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @param delimiterOfExclusiveBeginIndex the delimiter after which the replacement should start.
     * @param delimiterOfExclusiveEndIndex the delimiter before which the replacement should end.
     * @param replacement the string to replace the substring between the delimiters. If it's {@code null}, the substring between the delimiters will be removed.
     * @return the processed string with the substring between the delimiters replaced with the replacement string.
     *         If the input string is {@code null} or either of the delimiters is {@code null}, the original string is returned.
     * @see #substringBetween(String, String, String)
     */
    public static String replaceBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final String replacement) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null) {
            return str;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return str;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return str;
        }

        return replace(str, startIndex, endIndex, replacement);
    }

    /**
     * Replaces the substring after a specified delimiter in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the delimiter and replaces everything after it
     * (excluding the delimiter itself) with the replacement string. The delimiter remains in the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceAfter("Hello, World!", ",", " Java!");     // returns "Hello, Java!"
     * Strings.replaceAfter("prefix:suffix", ":", "new");        // returns "prefix:new"
     * Strings.replaceAfter("NoDelimiter", ":", "test");         // returns "NoDelimiter"
     * Strings.replaceAfter("EndsWith:", ":", "");               // returns "EndsWith:"
     * Strings.replaceAfter("Multiple:colons:here", ":", "X");   // returns "Multiple:X"
     * Strings.replaceAfter(null, ":", "test");                  // returns null
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @param delimiterOfExclusiveBeginIndex the delimiter after which the replacement should start.
     * @param replacement the string to replace the substring after the delimiter. If it's {@code null}, the substring after the delimiter will be removed.
     * @return the processed string with the substring after the delimiter replaced with the replacement string.
     *         If the input string is {@code null} or the delimiter is {@code null}, the original string is returned.
     */
    public static String replaceAfter(final String str, final String delimiterOfExclusiveBeginIndex, final String replacement) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return str;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return str;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        return replace(str, startIndex, str.length(), replacement);
    }

    /**
     * Replaces the substring before a specified delimiter in the given string with a replacement string.
     *
     * <p>This method finds the first occurrence of the delimiter and replaces everything before it
     * (excluding the delimiter itself) with the replacement string. The delimiter remains in the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.replaceBefore("Hello, World!", ",", "Hi");         // returns "Hi, World!"
     * Strings.replaceBefore("prefix:suffix", ":", "new");        // returns "new:suffix"
     * Strings.replaceBefore("NoDelimiter", ":", "test");         // returns "NoDelimiter"
     * Strings.replaceBefore(":StartsWith", ":", "");             // returns ":StartsWith"
     * Strings.replaceBefore("Multiple:colons:here", ":", "X");   // returns "X:colons:here"
     * Strings.replaceBefore(null, ":", "test");                  // returns null
     * }</pre>
     *
     * @param str the string to be processed, may be {@code null} or empty
     * @param delimiterOfExclusiveEndIndex the delimiter before which the replacement should end.
     * @param replacement the string to replace the substring before the delimiter. If it's {@code null}, the substring before the delimiter will be removed.
     * @return the processed string with the substring before the delimiter replaced with the replacement string.
     *         If the input string is {@code null} or the delimiter is {@code null}, the original string is returned.
     */
    public static String replaceBefore(final String str, final String delimiterOfExclusiveEndIndex, final String replacement) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return str;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return str;
        }

        return replace(str, 0, endIndex, replacement);
    }

    // Remove
    // -----------------------------------------------------------------------

    /**
     * Removes a substring only if it is at the beginning of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeStart(null, "*");                    // returns null
     * Strings.removeStart("", "*");                      // returns ""
     * Strings.removeStart("abc", null);                  // returns "abc"
     * Strings.removeStart("www.domain.com", "www.");     // returns "domain.com"
     * Strings.removeStart("domain.com", "www.");         // returns "domain.com"
     * Strings.removeStart("www.domain.com", "domain");   // returns "www.domain.com"
     * Strings.removeStart("abc", "");                    // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, may be {@code null}
     * @param removeStr the String to search for and remove, may be {@code null}
     * @return the string with the prefix removed if found, or the original string. Returns {@code null} if the input is {@code null}.
     */
    public static String removeStart(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (str.startsWith(removeStr)) {
            return str.substring(removeStr.length());
        }

        return str;
    }

    /**
     * Case-insensitive removal of a substring if it is at the beginning of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeStartIgnoreCase(null, "*");                    // returns null
     * Strings.removeStartIgnoreCase("", "*");                      // returns ""
     * Strings.removeStartIgnoreCase("abc", null);                  // returns "abc"
     * Strings.removeStartIgnoreCase("www.domain.com", "www.");     // returns "domain.com"
     * Strings.removeStartIgnoreCase("www.domain.com", "WWW.");     // returns "domain.com"
     * Strings.removeStartIgnoreCase("domain.com", "www.");         // returns "domain.com"
     * Strings.removeStartIgnoreCase("www.domain.com", "domain");   // returns "www.domain.com"
     * Strings.removeStartIgnoreCase("abc", "");                    // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, may be {@code null}
     * @param removeStr the String to search for (case insensitive) and remove, may be {@code null}
     * @return the string with the prefix removed if found (ignoring case), or the original string. Returns {@code null} if the input is {@code null}.
     */
    public static String removeStartIgnoreCase(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (startsWithIgnoreCase(str, removeStr)) {
            return str.substring(removeStr.length());
        }

        return str;
    }

    /**
     * Removes a substring only if it is at the end of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeEnd(null, "*");                    // returns null
     * Strings.removeEnd("", "*");                      // returns ""
     * Strings.removeEnd("abc", null);                  // returns "abc"
     * Strings.removeEnd("www.domain.com", ".com.");    // returns "www.domain.com"
     * Strings.removeEnd("www.domain.com", ".com");     // returns "www.domain"
     * Strings.removeEnd("www.domain.com", "domain");   // returns "www.domain.com"
     * Strings.removeEnd("abc", "");                    // returns "abc"
     * }</pre>
     *
     * @param str the source String to search, may be {@code null}
     * @param removeStr the String to search for and remove, may be {@code null}
     * @return the string with the suffix removed if found, or the original string. Returns {@code null} if the input is {@code null}.
     */
    public static String removeEnd(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (str.endsWith(removeStr)) {
            return str.substring(0, str.length() - removeStr.length());
        }

        return str;
    }

    /**
     * Case-insensitive removal of a substring if it is at the end of a source string, otherwise returns the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} search string will return the source string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeEndIgnoreCase(null, "*");                    // returns null
     * Strings.removeEndIgnoreCase("", "*");                      // returns ""
     * Strings.removeEndIgnoreCase("abc", null);                  // returns "abc"
     * Strings.removeEndIgnoreCase("www.domain.com", ".com.");    // returns "www.domain.com"
     * Strings.removeEndIgnoreCase("www.domain.com", ".com");     // returns "www.domain"
     * Strings.removeEndIgnoreCase("www.domain.com", "domain");   // returns "www.domain.com"
     * Strings.removeEndIgnoreCase("abc", "");                    // returns "abc"
     * Strings.removeEndIgnoreCase("www.domain.com", ".COM");     // returns "www.domain"
     * Strings.removeEndIgnoreCase("www.domain.COM", ".com");     // returns "www.domain"
     * }</pre>
     *
     * @param str the source String to search, may be {@code null}
     * @param removeStr the String to search for (case insensitive) and remove, may be {@code null}
     * @return the string with the suffix removed if found (ignoring case), or the original string. Returns {@code null} if the input is {@code null}.
     */
    public static String removeEndIgnoreCase(final String str, final String removeStr) {
        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        if (endsWithIgnoreCase(str, removeStr)) {
            return str.substring(0, str.length() - removeStr.length());
        }

        return str;
    }

    /**
     * Removes all occurrences of a specified character from the input string.
     *
     * <p>This method searches for all occurrences of the specified character in the input string
     * and removes them. If the character is not found, the original string is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeAll("abcabc", 'a');   // returns "bcbc"
     * Strings.removeAll("hello", 'l');    // returns "heo"
     * Strings.removeAll("test", 'x');     // returns "test" (character not found)
     * Strings.removeAll(null, 'a');       // returns null
     * Strings.removeAll("", 'a');         // returns ""
     * }</pre>
     *
     * @param str the input string from which the character should be removed, may be {@code null} or empty
     * @param removeChar the character to be removed.
     * @return a new string with all occurrences of the specified character removed.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the character is not found, the input string is returned unchanged.
     */
    public static String removeAll(final String str, final char removeChar) {
        return removeAll(str, 0, removeChar);
    }

    /**
     * Removes all occurrences of a specified character from the input string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the specified character starting from the given index
     * and removes them from the string. Characters before the specified index are preserved.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeAll("abcabc", 0, 'a');   // returns "bcbc"
     * Strings.removeAll("abcabc", 3, 'a');   // returns "abcbc"
     * Strings.removeAll("abcabc", 3, 'b');   // returns "abcac"
     * Strings.removeAll("hello", 0, 'l');    // returns "heo"
     * Strings.removeAll("test", 10, 't');    // returns "test" (index out of bounds)
     * Strings.removeAll(null, 0, 'a');       // returns null
     * }</pre>
     *
     * @param str the input string where the removal should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the removal. It should be a non-negative integer.
     * @param removeChar the character to be removed.
     * @return a new string with all occurrences of the specified character removed, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the character is not found, the input string is returned unchanged.
     */
    public static String removeAll(final String str, final int fromIndex, final char removeChar) {
        // N.checkIndex(fromIndex, N.len(str));

        if (str == null || str.isEmpty()) {
            return str;
        }

        final int index = str.indexOf(removeChar, fromIndex);
        if (index == N.INDEX_NOT_FOUND) {
            return str;
        } else {
            final char[] cbuf = new char[str.length()];

            if (index > 0) {
                str.getChars(0, index, cbuf, 0);
            }

            int count = index;
            char ch = 0;

            for (int i = index + 1, len = str.length(); i < len; i++) {
                ch = str.charAt(i);

                if (ch != removeChar) {
                    cbuf[count++] = ch;
                }
            }

            return count == cbuf.length ? str : new String(cbuf, 0, count);
        }
    }

    /**
     * Removes all occurrences of a substring from within the source string.
     *
     * <p>A {@code null} source string will return {@code null}. An empty ("") source string will return the empty string.
     * A {@code null} remove string will return the source string. An empty ("") remove string will return the source string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeAll(null, "*");         // returns null
     * Strings.removeAll("", "*");           // returns ""
     * Strings.removeAll("abc", null);       // returns "abc"
     * Strings.removeAll("abc", "");         // returns "abc"
     * Strings.removeAll("queued", "ue");    // returns "qd"
     * Strings.removeAll("queued", "zz");    // returns "queued"
     * Strings.removeAll("abcabc", "abc");   // returns ""
     * }</pre>
     *
     * @param str the source String to search, may be {@code null}
     * @param removeStr the String to search for and remove, may be {@code null}
     * @return the specified String if it's {@code null} or empty.
     */
    public static String removeAll(final String str, final String removeStr) {
        return removeAll(str, 0, removeStr);
    }

    /**
     * Removes all occurrences of a specified string from the input string, starting from a specified index.
     *
     * <p>This method searches for all occurrences of the specified string starting from the given index
     * and removes them from the input string. The part of the string before the specified index is preserved.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.removeAll("abcabcabc", 0, "abc");   // returns ""
     * Strings.removeAll("abcabcabc", 3, "abc");   // returns "abc"
     * Strings.removeAll("abcabcabc", 6, "abc");   // returns "abcabc"
     * Strings.removeAll("hello world", 0, "o");   // returns "hell wrld"
     * Strings.removeAll("test", 10, "es");        // returns "test" (index out of bounds)
     * Strings.removeAll(null, 0, "abc");          // returns null
     * }</pre>
     *
     * @param str the input string where the removal should occur, may be {@code null} or empty
     * @param fromIndex the index from which to start the removal. It should be a non-negative integer.
     * @param removeStr the string to be removed, may be {@code null} or empty
     * @return a new string with all occurrences of the specified string removed, starting from the specified index.
     *         If the input string is {@code null}, the method returns {@code null}. If the input string is empty, or the string to be removed is not found, the input string is returned unchanged.
     */
    public static String removeAll(final String str, final int fromIndex, final String removeStr) {
        //  N.checkIndex(fromIndex, N.len(str));

        if (isEmpty(str) || isEmpty(removeStr)) {
            return str;
        }

        return replace(str, fromIndex, removeStr, EMPTY, -1);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter character.
     *
     * <p>This method splits the string at each occurrence of the delimiter character. Empty strings between
     * consecutive delimiters are omitted from the result. Leading and trailing delimiters are also ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split("a,b,c", ',');     // returns ["a", "b", "c"]
     * Strings.split("a,,b,c", ',');    // returns ["a", "b", "c"]
     * Strings.split(",a,b,c,", ',');   // returns ["a", "b", "c"]
     * Strings.split("abc", ',');       // returns ["abc"]
     * Strings.split("", ',');          // returns []
     * Strings.split(null, ',');        // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the character used as the delimiter for splitting the string
     * @return an array of substrings derived from the input string, split based on the delimiter character.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final char delimiter) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    final Splitter splitter = splitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings() : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter character.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter character. Empty strings between
     * consecutive delimiters are omitted from the result. Leading and trailing delimiters are also ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split(" a , b , c ", ',', true);    // returns ["a", "b", "c"]
     * Strings.split(" a , b , c ", ',', false);   // returns [" a ", " b ", " c "]
     * Strings.split("a,,b", ',', true);           // returns ["a", "b"]
     * Strings.split("", ',', true);               // returns []
     * Strings.split(null, ',', true);             // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the character used as the delimiter for splitting the string
     * @param trim a boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return an array of substrings derived from the input string, split based on the delimiter character and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final char delimiter, final boolean trim) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    if (trim) {
        //        final Splitter splitter = trimSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings().trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return split(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     *
     * <p>This method splits the string at each occurrence of the delimiter string. Empty strings between
     * consecutive delimiters are omitted from the result. If delimiter is {@code null}, the string is split on whitespace.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split("a::b::c", "::");       // returns ["a", "b", "c"]
     * Strings.split("a::::b::c", "::");     // returns ["a", "b", "c"]
     * Strings.split("::a::b::c::", "::");   // returns ["a", "b", "c"]
     * Strings.split("abc", "::");           // returns ["abc"]
     * Strings.split("a b  c", null);        // returns ["a", "b", "c"]
     * Strings.split("", "::");              // returns []
     * Strings.split(null, "::");            // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @return an array of substrings derived from the input string, split based on the delimiter string.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final String delimiter) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    final Splitter splitter = splitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings() : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter string. Empty strings between
     * consecutive delimiters are omitted from the result. If delimiter is {@code null}, the string is split on whitespace.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split(" a :: b :: c ", "::", true);    // returns ["a", "b", "c"]
     * Strings.split(" a :: b :: c ", "::", false);   // returns [" a ", " b ", " c "]
     * Strings.split("a::::b", "::", true);           // returns ["a", "b"]
     * Strings.split(" a  b  c ", null, true);        // returns ["a", "b", "c"]
     * Strings.split("", "::", true);                 // returns []
     * Strings.split(null, "::", true);               // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param trim a boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return an array of substrings derived from the input string, split based on the delimiter string and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     */
    public static String[] split(final String str, final String delimiter, final boolean trim) {
        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        //    if (trim) {
        //        final Splitter splitter = trimSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).omitEmptyStrings().trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return split(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * The split operation will stop after reaching the specified maximum limit of substrings.
     *
     * <p>This method splits the string at each occurrence of the delimiter string up to the maximum limit.
     * If the string contains more delimiters than max-1, the last substring will contain all remaining text including delimiters.
     * Empty strings between consecutive delimiters are omitted from the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split("a:b:c:d:e", ":", 3);    // returns ["a", "b", "c:d:e"]
     * Strings.split("a:b:c:d:e", ":", 5);    // returns ["a", "b", "c", "d", "e"]
     * Strings.split("a:b:c:d:e", ":", 10);   // returns ["a", "b", "c", "d", "e"]
     * Strings.split("a:b:c", ":", 1);        // returns ["a:b:c"]
     * Strings.split("", ":", 3);             // returns []
     * Strings.split(null, ":", 3);           // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max the maximum number of substrings to be included in the resulting array.
     *            If the string contains more delimiters, the last substring will contain all remaining text.
     * @return an array of substrings derived from the input string, split based on the delimiter string.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] split(final String str, final String delimiter, final int max) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        if (max == 1) {
            return new String[] { str };
        }

        //    return Splitter.with(delimiter).omitEmptyStrings().limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, false, false);
    }

    /**
     * Splits the given string into an array of substrings, using the specified delimiter string.
     * The split operation will stop after reaching the specified maximum limit of substrings.
     * If the trim parameter is {@code true}, it trims leading and trailing whitespace from each substring.
     *
     * <p>This method splits the string at each occurrence of the delimiter string up to the maximum limit.
     * If the string contains more delimiters than max-1, the last substring will contain all remaining text including delimiters.
     * Empty strings between consecutive delimiters are omitted from the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.split(" a : b : c : d ", ":", 3, true);    // returns ["a", "b", "c : d"]
     * Strings.split(" a : b : c : d ", ":", 3, false);   // returns [" a ", " b ", " c : d "]
     * Strings.split("a:b:c", ":", 1, true);              // returns ["a:b:c"]
     * Strings.split("a:b:c", ":", 1, false);             // returns ["a:b:c"]
     * Strings.split("", ":", 3, true);                   // returns []
     * Strings.split(null, ":", 3, true);                 // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max the maximum number of substrings to be included in the resulting array.
     *            If the string contains more delimiters, the last substring will contain all remaining text.
     * @param trim a boolean that determines whether to trim leading and trailing whitespace from each substring.
     * @return an array of substrings derived from the input string, split based on the delimiter string, limited by the max parameter and optionally trimmed.
     *         If the input string is {@code null} or empty, the method will return an empty String array.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] split(final String str, final String delimiter, final int max, final boolean trim) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (isEmpty(str)) {
            return N.EMPTY_STRING_ARRAY;
        }

        if (max == 1) {
            return new String[] { trim ? str.trim() : str };
        }

        //    return Splitter.with(delimiter).omitEmptyStrings().trim(trim).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, trim, false);
    }

    /**
     * Splits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * This is an alternative to using StringTokenizer.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens(null, '*');       // returns []
     * Strings.splitPreserveAllTokens("", '*');         // returns [""]
     * Strings.splitPreserveAllTokens("a.b.c", '.');    // returns ["a", "b", "c"]
     * Strings.splitPreserveAllTokens("a..b.c", '.');   // returns ["a", "", "b", "c"]
     * Strings.splitPreserveAllTokens("a:b:c", '.');    // returns ["a:b:c"]
     * Strings.splitPreserveAllTokens("a b c", ' ');    // returns ["a", "b", "c"]
     * Strings.splitPreserveAllTokens("a b c ", ' ');   // returns ["a", "b", "c", ""]
     * Strings.splitPreserveAllTokens(" a b c", ' ');   // returns ["", "a", "b", "c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the character used as the delimiter
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final char delimiter) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    final Splitter splitter = preserveSplitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter) : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, true);
    }

    /**
     * Splits the provided text into an array, separator specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens(" a . b . c ", '.', true);    // returns ["a", "b", "c"]
     * Strings.splitPreserveAllTokens(" a . b . c ", '.', false);   // returns [" a ", " b ", " c "]
     * Strings.splitPreserveAllTokens("a..b", '.', true);           // returns ["a", "", "b"]
     * Strings.splitPreserveAllTokens(" .. ", '.', true);           // returns ["", "", ""]
     * Strings.splitPreserveAllTokens("", '.', true);               // returns [""]
     * Strings.splitPreserveAllTokens(null, '.', true);             // returns []
     * }</pre>
     *
     * @param str the String to parse, may be {@code null}
     * @param delimiter the character used as the delimiter
     * @param trim if {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final char delimiter, final boolean trim) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    if (trim) {
        //        final Splitter splitter = trimPreserveSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return splitPreserveAllTokens(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, true);
    }

    /**
     * Splits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens(null, "*");          // returns []
     * Strings.splitPreserveAllTokens("", "*");            // returns [""]
     * Strings.splitPreserveAllTokens("abc def", null);    // returns ["abc", "def"]
     * Strings.splitPreserveAllTokens("abc def", " ");     // returns ["abc", "def"]
     * Strings.splitPreserveAllTokens("abc  def", " ");    // returns ["abc", "", "def"]
     * Strings.splitPreserveAllTokens("ab:cd:ef", ":");    // returns ["ab", "cd", "ef"]
     * Strings.splitPreserveAllTokens("ab:cd:ef:", ":");   // returns ["ab", "cd", "ef", ""]
     * Strings.splitPreserveAllTokens(":cd:ef", ":");      // returns ["", "cd", "ef"]
     * Strings.splitPreserveAllTokens("a::b::c", "::");    // returns ["a", "b", "c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    final Splitter splitter = preserveSplitterPool.get(delimiter);
        //
        //    return (splitter == null ? Splitter.with(delimiter) : splitter).splitToArray(str);

        return splitWorker(str, delimiter, Integer.MAX_VALUE, false, true);
    }

    /**
     * Splits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * A {@code null} separatorChars splits on whitespace. If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens(" a : b : c ", ":", true);    // returns ["a", "b", "c"]
     * Strings.splitPreserveAllTokens(" a : b : c ", ":", false);   // returns [" a ", " b ", " c "]
     * Strings.splitPreserveAllTokens("a::b", ":", true);           // returns ["a", "", "b"]
     * Strings.splitPreserveAllTokens(" :: ", ":", true);           // returns ["", "", ""]
     * Strings.splitPreserveAllTokens("", ":", true);               // returns [""]
     * Strings.splitPreserveAllTokens(null, ":", true);             // returns []
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param trim if {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final boolean trim) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        //    if (trim) {
        //        final Splitter splitter = trimPreserveSplitterPool.get(delimiter);
        //        return (splitter == null ? Splitter.with(delimiter).trim(trim) : splitter).splitToArray(str);
        //    } else {
        //        return splitPreserveAllTokens(str, delimiter);
        //    }

        return splitWorker(str, delimiter, Integer.MAX_VALUE, trim, true);
    }

    /**
     * Splits the provided text into an array with a maximum length, separators specified, preserving all tokens.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If more than {@code max} delimited substrings are found, the last returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters).</p>
     *
     * <p>A {@code null} input String returns {@code null}. A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens("a:b:c:d", ":", 3);   // returns ["a", "b", "c:d"]
     * Strings.splitPreserveAllTokens("a:b:::d", ":", 3);   // returns ["a", "b", "::d"]
     * Strings.splitPreserveAllTokens("a:b:c:d", ":", 5);   // returns ["a", "b", "c", "d"]
     * Strings.splitPreserveAllTokens(":a:b:c", ":", 4);    // returns ["", "a", "b", "c"]
     * Strings.splitPreserveAllTokens("a:b:c:", ":", 4);    // returns ["a", "b", "c", ""]
     * Strings.splitPreserveAllTokens("a:b:c", ":", 1);     // returns ["a:b:c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max the maximum number of substrings to be included in the resulting array.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final int max) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        if (max == 1) {
            return new String[] { str };
        }

        // return Splitter.with(delimiter).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, false, true);
    }

    /**
     * Splits the provided text into an array with a maximum length, separators specified, preserving all tokens.
     *
     * <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens.
     * If more than {@code max} delimited substrings are found, the last returned string includes all characters after the first {@code max - 1}
     * returned strings (including separator characters). If the trim parameter is {@code true}, leading and trailing whitespace is removed from each substring.</p>
     *
     * <p>A {@code null} input String returns {@code null}. A {@code null} separatorChars splits on whitespace.</p>
     *
     * <p>An empty String array {@code []} will be returned if the input string {@code null}.
     * A String array with single empty String: {@code [""]} will be returned if the input string is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitPreserveAllTokens(" a : b : c : d ", ":", 3, true);    // returns ["a", "b", "c : d"]
     * Strings.splitPreserveAllTokens(" a : b : c : d ", ":", 3, false);   // returns [" a ", " b ", " c : d "]
     * Strings.splitPreserveAllTokens("a::b:c", ":", 4, true);             // returns ["a", "", "b", "c"]
     * Strings.splitPreserveAllTokens(" : : ", ":", 3, true);              // returns ["", "", ""]
     * Strings.splitPreserveAllTokens("a:b:c", ":", 1, true);              // returns ["a:b:c"]
     * Strings.splitPreserveAllTokens("a:b:c", ":", 1, false);             // returns ["a:b:c"]
     * }</pre>
     *
     * @param str  the String to parse, may be {@code null}
     * @param delimiter the string used as the delimiter for splitting the string. {@code null} for splitting on whitespace.
     * @param max the maximum number of substrings to be included in the resulting array.
     * @param trim if {@code true}, leading and trailing whitespace is removed from each substring.
     * @return an array of parsed Strings. An empty String array {@code []} will be returned if the input string {@code null},
     *         or a String array with single empty String: {@code [""]} will be returned if the input string is empty.
     * @throws IllegalArgumentException if the max parameter is not a positive integer.
     */
    public static String[] splitPreserveAllTokens(final String str, final String delimiter, final int max, final boolean trim) throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { EMPTY };
        }

        if (max == 1) {
            return new String[] { trim ? str.trim() : str };
        }

        // return Splitter.with(delimiter).trim(trim).limit(max).splitToArray(str);

        return splitWorker(str, delimiter, max, trim, true);
    }

    // Copied from Apache Commons Lang 3.17.0 under Apache License 2.0
    private static String[] splitWorker(final String str, final char delimiter, final int max, final boolean trim, final boolean preserveAllTokens)
            throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return preserveAllTokens ? new String[] { EMPTY } : N.EMPTY_STRING_ARRAY;
        }

        final int len = str.length();
        final List<String> substrs = new ArrayList<>();

        int sizePlus1 = 1;
        int i = 0;
        int start = 0;
        boolean match = false;
        boolean lastMatch = false;

        while (i < len) {
            if (str.charAt(i) == delimiter) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    substrs.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }

        if (match || preserveAllTokens && lastMatch) {
            substrs.add(str.substring(start, i));
        }

        final String[] ret = substrs.toArray(N.EMPTY_STRING_ARRAY);

        if (trim) {
            trim(ret);
        }

        return ret;
    }

    // Copied from Apache Commons Lang 3.17.0 under Apache License 2.0
    private static String[] splitWorker(final String str, final String delimiter, final int max, final boolean trim, final boolean preserveAllTokens)
            throws IllegalArgumentException {
        N.checkArgPositive(max, cs.max);

        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return preserveAllTokens ? new String[] { EMPTY } : N.EMPTY_STRING_ARRAY;
        } else if (max == 1) {
            final String[] result = { str };

            if (trim) {
                trim(result);
            }

            return result;
        }

        final int delimiterLength = N.len(delimiter);

        if (delimiterLength == 1) {
            return splitWorker(str, delimiter.charAt(0), max, trim, preserveAllTokens);
        }

        final int len = str.length();
        final List<String> substrs = new ArrayList<>();

        int i = 0;

        if (delimiterLength == 0) {
            int start = 0;
            boolean match = false;
            boolean lastMatch = false;
            int sizePlus1 = 1;
            // Null separator means use whitespace
            while (i < len) {
                if (Character.isWhitespace(str.charAt(i))) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        substrs.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }

            if (match || (preserveAllTokens && lastMatch)) {
                substrs.add(str.substring(start, i));
            }
        } else {
            // standard case
            int idx = -1;

            while (i <= len - delimiterLength) {
                if ((idx = str.indexOf(delimiter, i)) < 0) {
                    break;
                }

                if (idx > i) {
                    substrs.add(str.substring(i, idx));
                } else if (preserveAllTokens) {
                    substrs.add(EMPTY);
                }

                if (substrs.size() == max - 1) {
                    if (preserveAllTokens || idx + delimiterLength < len) {
                        substrs.add(str.substring(idx + delimiterLength));
                    }

                    i = len; // end the loop
                    idx = -1; // reset idx to avoid adding another substring

                    break;
                }

                i = idx + delimiterLength;
            }

            if (idx < 0 || i < len) {
                if (i < len) {
                    substrs.add(str.substring(i, len));
                } else if (preserveAllTokens) {
                    substrs.add(EMPTY);
                }
            }
        }

        final String[] ret = substrs.toArray(N.EMPTY_STRING_ARRAY);

        if (trim) {
            trim(ret);
        }

        return ret;
    }

    /**
     * Splits the given string into an array of substrings, each of which is a line of text from the original string.
     *
     * <p>The string is split at line terminators, which can be the carriage return character ('\r'), 
     * the newline character ('\n'), or the carriage return followed immediately by the newline character ('\r\n').
     * Empty lines are preserved in the result.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitToLines("Line1\nLine2\nLine3");       // returns ["Line1", "Line2", "Line3"]
     * Strings.splitToLines("Line1\r\nLine2\r\nLine3");   // returns ["Line1", "Line2", "Line3"]
     * Strings.splitToLines("Line1\rLine2\rLine3");       // returns ["Line1", "Line2", "Line3"]
     * Strings.splitToLines("\n\n");                      // returns ["", "", ""]
     * Strings.splitToLines("");                          // returns [""]
     * Strings.splitToLines(null);                        // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty If it's {@code null}, the method will return an empty String array.
     * @return an array of substrings derived from the input string, each of which is a line of text.
     *         If the input string is {@code null}, return an empty String array. If the input string is empty, return an String array with one empty String inside.
     */
    public static String[] splitToLines(final String str) {
        if (str == null) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { Strings.EMPTY };
        }

        return lineSplitter.splitToArray(str);
    }

    /**
     * Splits the given string into an array of substrings, each of which is a line of text from the original string.
     *
     * <p>The string is split at line terminators, which can be the carriage return character ('\r'), 
     * the newline character ('\n'), or the carriage return followed immediately by the newline character ('\r\n').
     * If the trim parameter is {@code true}, leading and trailing whitespace is removed from each line of text.
     * If the omitEmptyLines parameter is {@code true}, empty lines (after trimming, if the trim parameter is true) are not included in the resulting array.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.splitToLines(" Line1 \n Line2 \n Line3 ", true, false);   // returns ["Line1", "Line2", "Line3"]
     * Strings.splitToLines(" Line1 \n \n Line3 ", true, true);          // returns ["Line1", "Line3"]
     * Strings.splitToLines("Line1\n\nLine3", false, true);              // returns ["Line1", "Line3"]
     * Strings.splitToLines("\n\n", false, false);                       // returns ["", "", ""]
     * Strings.splitToLines("\n\n", true, true);                         // returns []
     * Strings.splitToLines("", true, true);                             // returns []
     * Strings.splitToLines(null, true, true);                           // returns []
     * }</pre>
     *
     * @param str the string to be split, may be {@code null} or empty
     * @param trim a boolean that determines whether to trim leading and trailing whitespace from each line of text.
     * @param omitEmptyLines a boolean that determines whether to omit empty lines from the resulting array.
     * @return an array of substrings derived from the input string, each of which is a line of text, optionally trimmed and with empty lines optionally omitted.
     *         If the input string is {@code null} or {@code str.length() == 0 && omitEmptyLines}, return an empty String array. If the input string is empty, return an String array with one empty String inside.
     */
    public static String[] splitToLines(final String str, final boolean trim, final boolean omitEmptyLines) {
        if (str == null || (str.isEmpty() && omitEmptyLines)) {
            return N.EMPTY_STRING_ARRAY;
        } else if (str.isEmpty()) {
            return new String[] { Strings.EMPTY };
        }

        if (trim) {
            if (omitEmptyLines) {
                return trimAndOmitEmptyLinesLineSplitter.splitToArray(str);
            } else {
                return trimLineSplitter.splitToArray(str);
            }
        } else if (omitEmptyLines) {
            return omitEmptyLinesLineSplitter.splitToArray(str);
        } else {
            return lineSplitter.splitToArray(str);
        }
    }

    // -----------------------------------------------------------------------

    /**
     * Removes space characters (char &lt;= 32) from both ends of this String, handling {@code null} by returning {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #strip(String)}.</p>
     *
     * <p>To trim your choice of characters, use the {@link #strip(String, String)} methods.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.trim(null);            // returns null
     * Strings.trim("");              // returns ""
     * Strings.trim("     ");         // returns ""
     * Strings.trim("abc");           // returns "abc"
     * Strings.trim("    abc    ");   // returns "abc"
     * Strings.trim(" \t\r\n ");      // returns ""
     * }</pre>
     *
     * @param str the String to be trimmed, may be {@code null}
     * @return the trimmed string, {@code null} if {@code null} String input
     */
    public static String trim(final String str) {
        return isEmpty(str) || (!Character.isWhitespace(str.charAt(0)) && !Character.isWhitespace(str.charAt(str.length() - 1))) ? str : str.trim();
    }

    /**
     * Trims leading and trailing space characters from each string in the provided array.
     *
     * <p>This method uses {@link String#trim()} to remove space characters (char &lt;= 32) from both ends of each string.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", " def ", "ghi"};
     * Strings.trim(arr);   // arr becomes ["abc", "def", "ghi"]
     * 
     * String[] arr2 = {null, "  test  ", ""};
     * Strings.trim(arr2);   // arr2 becomes [null, "test", ""]
     * }</pre>
     *
     * @param strs the array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trim(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trim(strs[i]);
        }
    }

    /**
     * Removes space characters (char &lt;= 32) from both ends of this String returning {@code null} if the String is empty ("") after the trim or if it is {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #stripToNull(String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.trimToNull(null);            // returns null
     * Strings.trimToNull("");              // returns null
     * Strings.trimToNull("     ");         // returns null
     * Strings.trimToNull("abc");           // returns "abc"
     * Strings.trimToNull("    abc    ");   // returns "abc"
     * Strings.trimToNull(" \t\r\n ");      // returns null
     * }</pre>
     *
     * @param str the String to be trimmed, may be {@code null}
     * @return the trimmed String, {@code null} if only spaces, empty or {@code null} String input
     */
    @MayReturnNull
    public static String trimToNull(String str) {
        str = trim(str);

        return isEmpty(str) ? null : str;
    }

    /**
     * Trims leading and trailing whitespace from each string in the provided array and sets the string to {@code null} if it is empty after trimming.
     *
     * <p>This method uses {@link String#trim()} to remove whitespace. If a string becomes empty after trimming, it is set to {@code null}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", "   ", "def", ""};
     * Strings.trimToNull(arr);   // arr becomes ["abc", null, "def", null]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * Strings.trimToNull(arr2);   // arr2 becomes [null, "test", null]
     * }</pre>
     *
     * @param strs the array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trimToNull(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trimToNull(strs[i]);
        }
    }

    /**
     * Removes control characters (char &lt;= 32) from both ends of this String returning an empty String ("") if the String is empty ("") after the trim or if it is {@code null}.
     *
     * <p>The String is trimmed using {@link String#trim()}. Trim removes start and end characters &lt;= 32.
     * To strip whitespace use {@link #stripToEmpty(String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.trimToEmpty(null);            // returns ""
     * Strings.trimToEmpty("");              // returns ""
     * Strings.trimToEmpty("     ");         // returns ""
     * Strings.trimToEmpty("abc");           // returns "abc"
     * Strings.trimToEmpty("    abc    ");   // returns "abc"
     * Strings.trimToEmpty(" \t\r\n ");      // returns ""
     * }</pre>
     *
     * @param str the String to be trimmed, may be {@code null}
     * @return the trimmed String, or an empty String if {@code null} input
     */
    public static String trimToEmpty(final String str) {
        return isEmpty(str) ? EMPTY : str.trim();
    }

    /**
     * Trims leading and trailing whitespace from each string in the provided array.
     *
     * <p>If a string becomes {@code null} after trimming, it is set to empty string.
     * This method uses {@link String#trim()} to remove whitespace.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", null, "def", "   "};
     * Strings.trimToEmpty(arr);   // arr becomes ["abc", "", "def", ""]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * Strings.trimToEmpty(arr2);   // arr2 becomes ["", "test", ""]
     * }</pre>
     *
     * @param strs the array of strings to be trimmed. Each string in the array will be updated in-place.
     */
    public static void trimToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = trimToEmpty(strs[i]);
        }
    }

    // Stripping
    // -----------------------------------------------------------------------

    /**
     * Strips whitespace from the start and end of a String.
     *
     * <p>This is similar to {@link #trim(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>A {@code null} input String returns {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.strip(null);       // returns null
     * Strings.strip("");         // returns ""
     * Strings.strip("   ");      // returns ""
     * Strings.strip("abc");      // returns "abc"
     * Strings.strip("  abc");    // returns "abc"
     * Strings.strip("abc  ");    // returns "abc"
     * Strings.strip(" abc ");    // returns "abc"
     * Strings.strip(" ab c ");   // returns "ab c"
     * }</pre>
     *
     * @param str the String to remove whitespace from, may be {@code null}
     * @return the stripped String, {@code null} if {@code null} String input
     */
    public static String strip(final String str) {
        return strip(str, null);
    }

    /**
     * Strips whitespace from the start and end of each string in the provided array.
     *
     * <p>This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", " def ", "ghi"};
     * Strings.strip(arr);   // arr becomes ["abc", "def", "ghi"]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * Strings.strip(arr2);   // arr2 becomes [null, "test", ""]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void strip(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strip(strs[i]);
        }
    }

    /**
     * Strips whitespace from the start and end of a String returning {@code null} if the String is empty ("") after the strip.
     *
     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripToNull(null);       // returns null
     * Strings.stripToNull("");         // returns null
     * Strings.stripToNull("   ");      // returns null
     * Strings.stripToNull("abc");      // returns "abc"
     * Strings.stripToNull("  abc");    // returns "abc"
     * Strings.stripToNull("abc  ");    // returns "abc"
     * Strings.stripToNull(" abc ");    // returns "abc"
     * Strings.stripToNull(" ab c ");   // returns "ab c"
     * }</pre>
     *
     * @param str the String to be stripped, may be {@code null}
     * @return the stripped String, {@code null} if whitespace, empty or {@code null} String input
     */
    @MayReturnNull
    public static String stripToNull(String str) {
        str = strip(str, null);

        return isEmpty(str) ? null : str;
    }

    /**
     * Strips whitespace from the start and end of each string in the provided array and sets the string to {@code null} if it is empty after stripping.
     *
     * <p>This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", "   ", "def", ""};
     * Strings.stripToNull(arr);   // arr becomes ["abc", null, "def", null]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * Strings.stripToNull(arr2);   // arr2 becomes [null, "test", null]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripToNull(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripToNull(strs[i]);
        }
    }

    /**
     * Strips whitespace from the start and end of a String returning an empty String if {@code null} input.
     *
     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripToEmpty(null);       // returns ""
     * Strings.stripToEmpty("");         // returns ""
     * Strings.stripToEmpty("   ");      // returns ""
     * Strings.stripToEmpty("abc");      // returns "abc"
     * Strings.stripToEmpty("  abc");    // returns "abc"
     * Strings.stripToEmpty("abc  ");    // returns "abc"
     * Strings.stripToEmpty(" abc ");    // returns "abc"
     * Strings.stripToEmpty(" ab c ");   // returns "ab c"
     * }</pre>
     *
     * @param str the String to be stripped, may be {@code null}
     * @return the trimmed String, or an empty String if {@code null} input
     */
    public static String stripToEmpty(final String str) {
        return isEmpty(str) ? EMPTY : strip(str, null);
    }

    /**
     * Strips leading and trailing whitespace from each string in the provided array.
     *
     * <p>If a string becomes {@code null} after stripping, it is set to an empty string.
     * This method uses {@link #strip(String)} to remove whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"  abc  ", null, "def", "   "};
     * Strings.stripToEmpty(arr);   // arr becomes ["abc", "", "def", ""]
     * 
     * String[] arr2 = {null, "  test  ", " \t\n "};
     * Strings.stripToEmpty(arr2);   // arr2 becomes ["", "test", ""]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripToEmpty(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripToEmpty(strs[i]);
        }
    }

    /**
     * Strips any of a set of characters from the start and end of a String.
     *
     * <p>This is similar to {@link String#trim()} but allows the characters to be stripped to be controlled.</p>
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * Alternatively use {@link #strip(String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.strip(null, "*");           // returns null
     * Strings.strip("", "*");             // returns ""
     * Strings.strip("abc", null);         // returns "abc"
     * Strings.strip("  abc", null);       // returns "abc"
     * Strings.strip("abc  ", null);       // returns "abc"
     * Strings.strip(" abc ", null);       // returns "abc"
     * Strings.strip("  abcyx", "xyz");    // returns "  abc"
     * Strings.strip("yxabcxyz", "xyz");   // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, may be {@code null}
     * @param stripChars the characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String strip(final String str, final String stripChars) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        return stripEnd(stripStart(str, stripChars), stripChars);
    }

    /**
     * Strips the specified characters from the start and end of each string in the provided array.
     *
     * <p>This method uses {@link #strip(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"xxabcyy", "xydefyx", "xyz"};
     * Strings.strip(arr, "xyz");   // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"  test  ", null, " \tabc\n "};
     * Strings.strip(arr2, null);   // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars the set of characters to be stripped from the strings. If {@code null}, the method behaves as {@link #strip(String)}.
     */
    public static void strip(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = strip(strs[i], stripChars);
        }
    }

    /**
     * Strips whitespace from the start of a String.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.
     * A {@code null} input String returns {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripStart(null);      // returns null
     * Strings.stripStart("");        // returns ""
     * Strings.stripStart("abc");     // returns "abc"
     * Strings.stripStart("  abc");   // returns "abc"
     * Strings.stripStart("abc  ");   // returns "abc  "
     * Strings.stripStart(" abc ");   // returns "abc "
     * }</pre>
     *
     * @param str the String to remove whitespace from, may be {@code null}
     * @return the stripped String, {@code null} if {@code null} String input
     */
    public static String stripStart(final String str) {
        return stripStart(str, null);
    }

    /**
     * Strips any of a set of characters from the start of a String.
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripStart(null, "*");          // returns null
     * Strings.stripStart("", "*");            // returns ""
     * Strings.stripStart("abc", "");          // returns "abc"
     * Strings.stripStart("abc", null);        // returns "abc"
     * Strings.stripStart("  abc", null);      // returns "abc"
     * Strings.stripStart("abc  ", null);      // returns "abc  "
     * Strings.stripStart(" abc ", null);      // returns "abc "
     * Strings.stripStart("yxabc  ", "xyz");   // returns "abc  "
     * Strings.stripStart("xyzabc", "xyz");    // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, may be {@code null}
     * @param stripChars the characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String stripStart(final String str, final String stripChars) {
        if (isEmpty(str) || (stripChars != null && stripChars.isEmpty())) {
            return str;
        }

        final int strLen = str.length();
        int start = 0;
        if (stripChars == null) {
            while (start != strLen && Character.isWhitespace(str.charAt(start))) {
                start++;
            }
        } else {
            while (start != strLen && stripChars.indexOf(str.charAt(start)) != N.INDEX_NOT_FOUND) {
                start++;
            }
        }

        return start == 0 ? str : str.substring(start);
    }

    /**
     * Strips the specified characters from the start of each string in the provided array.
     *
     * <p>This method uses {@link #stripStart(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"xxabc", "xydef", "xyz"};
     * Strings.stripStart(arr, "xyz");   // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"  test", null, " \tabc"};
     * Strings.stripStart(arr2, null);   // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars the set of characters to be stripped from the start of the strings. If {@code null}, the method behaves as {@link #stripStart(String, String)}.
     * @see #stripStart(String, String)
     */
    public static void stripStart(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripStart(strs[i], stripChars);
        }
    }

    /**
     * Strips whitespace from the end of a String.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.
     * A {@code null} input String returns {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripEnd(null);      // returns null
     * Strings.stripEnd("");        // returns ""
     * Strings.stripEnd("abc");     // returns "abc"
     * Strings.stripEnd("  abc");   // returns "  abc"
     * Strings.stripEnd("abc  ");   // returns "abc"
     * Strings.stripEnd(" abc ");   // returns " abc"
     * }</pre>
     *
     * @param str the String to remove whitespace from, may be {@code null}
     * @return the stripped String, {@code null} if {@code null} String input
     */
    public static String stripEnd(final String str) {
        return stripEnd(str, null);
    }

    /**
     * Strips any of a set of characters from the end of a String.
     *
     * <p>A {@code null} input String returns {@code null}. An empty string ("") input returns the empty string.</p>
     *
     * <p>If the stripChars String is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripEnd(null, "*");          // returns null
     * Strings.stripEnd("", "*");            // returns ""
     * Strings.stripEnd("abc", "");          // returns "abc"
     * Strings.stripEnd("abc", null);        // returns "abc"
     * Strings.stripEnd("  abc", null);      // returns "  abc"
     * Strings.stripEnd("abc  ", null);      // returns "abc"
     * Strings.stripEnd(" abc ", null);      // returns " abc"
     * Strings.stripEnd("  abcyx", "xyz");   // returns "  abc"
     * Strings.stripEnd("120.00", ".0");     // returns "12"
     * Strings.stripEnd("abcxyz", "xyz");    // returns "abc"
     * }</pre>
     *
     * @param str the String to remove characters from, may be {@code null}
     * @param stripChars the set of characters to remove, {@code null} treated as whitespace
     * @return the specified String if it's {@code null} or empty.
     */
    public static String stripEnd(final String str, final String stripChars) {
        if (isEmpty(str) || (stripChars != null && stripChars.isEmpty())) {
            return str;
        }

        int end = str.length();

        if (stripChars == null) {
            while (end > 0 && Character.isWhitespace(str.charAt(end - 1))) {
                end--;
            }
        } else {
            while (end > 0 && stripChars.indexOf(str.charAt(end - 1)) != N.INDEX_NOT_FOUND) {
                end--;
            }
        }

        return end == str.length() ? str : str.substring(0, end);
    }

    /**
     * Strips the specified characters from the end of each string in the provided array.
     *
     * <p>This method uses {@link #stripEnd(String, String)} to remove the specified characters.
     * If the stripChars is {@code null}, whitespace is stripped as defined by {@link Character#isWhitespace(char)}.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"abcxx", "defxy", "xyz"};
     * Strings.stripEnd(arr, "xyz");   // arr becomes ["abc", "def", ""]
     * 
     * String[] arr2 = {"test  ", null, "abc \t"};
     * Strings.stripEnd(arr2, null);   // arr2 becomes ["test", null, "abc"]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     * @param stripChars the set of characters to be stripped from the end of the strings. If {@code null}, the method behaves as {@link #stripEnd(String, String)}.
     * @see #stripEnd(String, String)
     */
    public static void stripEnd(final String[] strs, final String stripChars) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripEnd(strs[i], stripChars);
        }
    }

    /**
     * Removes diacritics (~ = accents) from a string. The case will not be altered.
     *
     * <p>For instance, '√†' will be replaced by 'a'.
     * Note that ligatures will be left as is.</p>
     *
     * <p>This method uses Java's Normalizer to decompose accented characters and then removes the combining diacritical marks.
     * Some special characters like ≈Å and ≈Ç are handled separately.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.stripAccents(null);           // returns null
     * Strings.stripAccents("");             // returns ""
     * Strings.stripAccents("control");      // returns "control"
     * Strings.stripAccents("√©clair");       // returns "eclair"
     * Strings.stripAccents("√† la carte");   // returns "a la carte"
     * Strings.stripAccents("≈Å√≥d≈∫");         // returns "Lodz"
     * }</pre>
     *
     * @param str the String to strip accents from, may be {@code null}
     * @return the stripped String, {@code null} if {@code null} String input
     */
    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented
    // characters by their unaccented equivalent (and uncommitted bug fix:
    // https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).
    @MayReturnNull
    public static String stripAccents(final String str) {
        if (str == null) {
            return null;
        }
        final StringBuilder decomposed = new StringBuilder(Normalizer.normalize(str, Normalizer.Form.NFD));
        convertRemainingAccentCharacters(decomposed);
        // Note that this doesn't correctly remove ligatures...
        return STRIP_ACCENTS_PATTERN.matcher(decomposed).replaceAll(EMPTY);
    }

    /**
     * Pattern used in {@link #stripAccents(String)}.
     */
    private static final Pattern STRIP_ACCENTS_PATTERN = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");   //$NON-NLS-1$

    private static void convertRemainingAccentCharacters(final StringBuilder decomposed) {
        char ch = 0;

        for (int i = 0; i < decomposed.length(); i++) {
            ch = decomposed.charAt(i);

            if (ch == '\u0141') {
                decomposed.setCharAt(i, 'L');
            } else if (ch == '\u0142') {
                decomposed.setCharAt(i, 'l');
            }
        }
    }

    /**
     * Strips accents from each string in the provided array.
     *
     * <p>This method uses {@link #stripAccents(String)} to remove accents from each string.
     * If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"√©clair", "caf√©", "na√Øve"};
     * Strings.stripAccents(arr);   // arr becomes ["eclair", "cafe", "naive"]
     * 
     * String[] arr2 = {null, "≈Å√≥d≈∫", "r√©sum√©"};
     * Strings.stripAccents(arr2);   // arr2 becomes [null, "Lodz", "resume"]
     * }</pre>
     *
     * @param strs the array of strings to be stripped. Each string in the array will be updated in-place.
     */
    public static void stripAccents(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = stripAccents(strs[i]);
        }
    }
    // Chomping
    // -----------------------------------------------------------------------

    /**
     * Removes one newline from end of a String if it's there, otherwise leave it alone.
     * 
     * <p>A newline is defined as "\n", "\r", or "\r\n". This method removes exactly one occurrence
     * of any of these sequences from the end of the string. If the string ends with multiple newlines,
     * only the last one is removed.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.chomp(null)            = null
     * Strings.chomp("")              = ""
     * Strings.chomp("a")             = "a"
     * Strings.chomp("abc \r")        = "abc "
     * Strings.chomp("abc\n")         = "abc"
     * Strings.chomp("abc\r\n")       = "abc"
     * Strings.chomp("abc\r\n\r\n")   = "abc\r\n"
     * Strings.chomp("abc\n\r")       = "abc\n"
     * Strings.chomp("abc\n\rabc")    = "abc\n\rabc"
     * Strings.chomp("\r")            = ""
     * Strings.chomp("\n")            = ""
     * Strings.chomp("\r\n")          = ""
     * }</pre>
     *
     * @param str the String to chomp a newline from, may be {@code null}
     * @return string without newline at the end, {@code null} if {@code null} String input
     * @see #chop(String)
     */
    public static String chomp(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        if (str.length() == 1) {
            final char ch = str.charAt(0);

            if (ch == CHAR_CR || ch == CHAR_LF) {
                return EMPTY;
            }

            return str;
        }

        int lastIdx = str.length() - 1;
        final char last = str.charAt(lastIdx);

        if (last == CHAR_LF) {
            if (lastIdx > 0 && str.charAt(lastIdx - 1) == CHAR_CR) {
                lastIdx--;
            }
        } else if (last != CHAR_CR) {
            lastIdx++;
        }

        return lastIdx == str.length() ? str : str.substring(0, lastIdx);
    }

    /**
     * Removes one newline from end of each string in the provided array if it's there, otherwise leaves it alone.
     * 
     * <p>A newline is defined as "\n", "\r", or "\r\n". This method processes each string in the array
     * independently, removing exactly one occurrence of any of these sequences from the end of each string.
     * The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strs = {"abc\n", "def\r", "ghi"};
     * Strings.chomp(strs);
     * // strs is now {"abc", "def", "ghi"}
     * }</pre>
     *
     * @param strs the array of strings to be chomped. Each string in the array will be updated in-place.
     */
    public static void chomp(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = chomp(strs[i]);
        }
    }

    // Chopping
    // -----------------------------------------------------------------------

    /**
     * Remove the last character from a String.
     *
     * <p>If the String ends in "\r\n", then both characters are removed. Otherwise, only the last
     * character is removed. This differs from {@link #chomp(String)} which only removes newline sequences.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null}, and an empty string if the input
     * has only one character or is already empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.chop(null)         = null
     * Strings.chop("")           = ""
     * Strings.chop("abc \r")     = "abc "
     * Strings.chop("abc\n")      = "abc"
     * Strings.chop("abc\r\n")    = "abc"
     * Strings.chop("abc")        = "ab"
     * Strings.chop("abc\nabc")   = "abc\nab"
     * Strings.chop("a")          = ""
     * Strings.chop("\r")         = ""
     * Strings.chop("\n")         = ""
     * Strings.chop("\r\n")       = ""
     * }</pre>
     *
     * @param str the String to chop last character from, may be {@code null}
     * @return string without last character, {@code null} if {@code null} String input
     * @see #chomp(String)
     */
    public static String chop(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int strLen = str.length();

        if (strLen < 2) {
            return EMPTY;
        }

        final int lastIdx = strLen - 1;

        if (str.charAt(lastIdx) == CHAR_LF && str.charAt(lastIdx - 1) == CHAR_CR) {
            return str.substring(0, lastIdx - 1);
        } else {
            return str.substring(0, lastIdx);
        }
    }

    /**
     * Removes the last character from each string in the provided array.
     *
     * <p>If a string in the array ends in "\r\n", both characters are removed. Otherwise, only the last
     * character is removed. The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strs = {"abc", "def\r\n", "g"};
     * Strings.chop(strs);
     * // strs is now {"ab", "def", ""}
     * }</pre>
     *
     * @param strs the array of strings to be chopped. Each string in the array will be updated in-place.
     */
    public static void chop(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = chop(strs[i]);
        }
    }

    /**
     * Truncates a String to a specified maximum width.
     *
     * <p>This method will return the original string if it is shorter than or equal to the specified
     * maximum width. If the string is longer, it will be truncated to exactly the maximum width.
     * The method handles {@code null} input by returning {@code null}.</p>
     *
     * <p>If {@code maxWidth} is less than 0, an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.truncate(null, 0)         = null
     * Strings.truncate(null, 2)         = null
     * Strings.truncate("", 4)           = ""
     * Strings.truncate("abcdefg", 4)    = "abcd"
     * Strings.truncate("abcdefg", 6)    = "abcdef"
     * Strings.truncate("abcdefg", 7)    = "abcdefg"
     * Strings.truncate("abcdefg", 8)    = "abcdefg"
     * Strings.truncate("abcdefg", -1)   = throws an IllegalArgumentException
     * }</pre>
     *
     * @param str the String to truncate, may be {@code null}
     * @param maxWidth maximum length of result String, must be positive
     * @return truncated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException if {@code maxWidth} is less than 0
     * @see #truncate(String, int, int)
     * @see #truncate(String[], int)
     */
    public static String truncate(final String str, final int maxWidth) {
        return truncate(str, 0, maxWidth);
    }

    /**
     * Truncates a String to a specified maximum width starting from a given offset.
     *
     * <p>This method allows you to specify a "left edge" offset from where the truncation should begin.
     * The resulting string will contain at most {@code maxWidth} characters starting from the offset position.
     * If the string is shorter than {@code offset + maxWidth}, the entire substring from offset is returned.</p>
     *
     * <p>If {@code offset} or {@code maxWidth} is less than 0, an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.truncate(null, 0, 0)                  = null
     * Strings.truncate(null, 2, 4)                  = null
     * Strings.truncate("", 0, 10)                   = ""
     * Strings.truncate("", 2, 10)                   = ""
     * Strings.truncate("abcdefghij", 0, 3)          = "abc"
     * Strings.truncate("abcdefghij", 5, 6)          = "fghij"
     * Strings.truncate("raspberry peach", 10, 15)   = "peach"
     * Strings.truncate("abcdefghijklmno", 0, 10)    = "abcdefghij"
     * Strings.truncate("abcdefghijklmno", -1, 10)   = throws an IllegalArgumentException
     * Strings.truncate("abcdefghij", 3, -1)         = throws an IllegalArgumentException
     * }</pre>
     *
     * @param str the String to truncate, may be {@code null}
     * @param offset left edge of source String
     * @param maxWidth maximum length of result String, must be positive
     * @return truncated String, {@code null} if {@code null} String input
     * @throws IllegalArgumentException if {@code offset} or {@code maxWidth} is less than 0
     * @see #truncate(String, int)
     * @see #truncate(String[], int, int)
     */
    @MayReturnNull
    public static String truncate(final String str, final int offset, final int maxWidth) throws IllegalArgumentException {
        N.checkArgNotNegative(offset, cs.offset);
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (str == null) {
            return null;
        } else if (str.length() <= offset || maxWidth == 0) {
            return EMPTY;
        } else if (str.length() - offset <= maxWidth) {
            return offset == 0 ? str : str.substring(offset);
        } else {
            return str.substring(offset, offset + maxWidth);
        }
    }

    /**
     * Truncates each string in the provided array to the specified maximum width.
     *
     * <p>If a string in the array has a length less than or equal to the maxWidth, it remains unchanged.
     * If a string in the array has a length greater than the maxWidth, it is truncated to the maxWidth.
     * The strings in the array are updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strs = {"hello", "world123", "hi"};
     * Strings.truncate(strs, 5);
     * // strs is now {"hello", "world", "hi"}
     * }</pre>
     *
     * @param strs the array of strings to be truncated. Each string in the array will be updated in-place.
     * @param maxWidth the maximum length for each string. Must be non-negative.
     * @throws IllegalArgumentException if maxWidth is less than 0.
     * @see #truncate(String, int)
     * @see #truncate(String[], int, int)
     */
    public static void truncate(final String[] strs, final int maxWidth) {
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = truncate(strs[i], maxWidth);
        }
    }

    /**
     * Truncates each string in the provided array to the specified maximum width starting from the given offset.
     *
     * <p>This method processes each string in the array independently. For each string, if it has a length
     * less than or equal to the offset, it becomes an empty string. Otherwise, it is truncated to contain
     * at most {@code maxWidth} characters starting from the offset position. The strings in the array are
     * updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strs = {"hello", "world123", "hi"};
     * Strings.truncate(strs, 2, 3);
     * // strs is now {"llo", "rld", ""}
     * }</pre>
     *
     * @param strs the array of strings to be truncated. Each string in the array will be updated in-place.
     * @param offset the starting index from where the string needs to be truncated.
     * @param maxWidth the maximum length for each string starting from the offset. Must be non-negative.
     * @throws IllegalArgumentException if maxWidth or offset is less than 0.
     * @see #truncate(String, int, int)
     * @see #truncate(String[], int)
     */
    public static void truncate(final String[] strs, final int offset, final int maxWidth) {
        N.checkArgNotNegative(offset, cs.offset);
        N.checkArgNotNegative(maxWidth, cs.maxWidth);

        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = truncate(strs[i], offset, maxWidth);
        }
    }

    // Delete
    // -----------------------------------------------------------------------

    /**
     * Deletes all whitespace from a String as defined by {@link Character#isWhitespace(char)}.
     *
     * <p>This method removes all characters for which {@link Character#isWhitespace(char)} returns {@code true}.
     * This includes spaces, tabs, newlines, and other Unicode whitespace characters. The method returns
     * {@code null} if the input is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.deleteWhitespace(null)           = null
     * Strings.deleteWhitespace("")             = ""
     * Strings.deleteWhitespace("abc")          = "abc"
     * Strings.deleteWhitespace("   ab  c  ")   = "abc"
     * Strings.deleteWhitespace("a\tb\nc")      = "abc"
     * Strings.deleteWhitespace("a b\tc\r\n")   = "abc"
     * }</pre>
     *
     * @param str the String to delete whitespace from, may be {@code null}
     * @return the String without whitespaces, {@code null} if {@code null} String input
     * @see #deleteWhitespace(String[])
     */
    public static String deleteWhitespace(final String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        final int len = str.length();
        final char[] cbuf = new char[len];
        int count = 0;
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = str.charAt(i);

            if (!Character.isWhitespace(ch)) {
                cbuf[count++] = ch;
            }
        }

        return count == cbuf.length ? str : new String(cbuf, 0, count);
    }

    /**
     * Deletes all whitespace from each string in the provided array.
     *
     * <p>Whitespace is determined by {@link Character#isWhitespace(char)}. This includes spaces,
     * tabs, newlines, and other Unicode whitespace characters. Each string in the array is processed
     * independently and updated in-place.</p>
     *
     * <p>If the input array is {@code null} or empty, the method does nothing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strs = {"  hello  ", "world\t123", " h i "};
     * Strings.deleteWhitespace(strs);
     * // strs is now {"hello", "world123", "hi"}
     * }</pre>
     *
     * @param strs the array of strings to be processed. Each string in the array will be updated in-place.
     * @see #deleteWhitespace(String)
     */
    public static void deleteWhitespace(final String[] strs) {
        if (N.isEmpty(strs)) {
            return;
        }

        for (int i = 0, len = strs.length; i < len; i++) {
            strs[i] = deleteWhitespace(strs[i]);
        }
    }

    /**
     * Appends the specified suffix to the input string if it is not already present at the end of the string.
     *
     * <p>This method checks if the string already ends with the specified suffix. If it does, the original
     * string is returned unchanged. If not, the suffix is appended to the string. If the input string is
     * {@code null} or empty, the suffix is returned as is.</p>
     *
     * <p>The suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.appendIfMissing(null, ".txt")         = ".txt"
     * Strings.appendIfMissing("", ".txt")           = ".txt"
     * Strings.appendIfMissing("file", ".txt")       = "file.txt"
     * Strings.appendIfMissing("file.txt", ".txt")   = "file.txt"
     * Strings.appendIfMissing("file.doc", ".txt")   = "file.doc.txt"
     * Strings.appendIfMissing("file", "")           = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to which the suffix should be appended, may be {@code null} or empty
     * @param suffix the suffix to append to the string. Must not be empty.
     * @return the input string with the suffix appended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the suffix is empty.
     * @see #appendIfMissingIgnoreCase(String, String)
     * @see #prependIfMissing(String, String)
     */
    public static String appendIfMissing(final String str, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return suffix;
        } else if (str.endsWith(suffix)) {
            return str;
        } else {
            return str + suffix;
        }
    }

    /**
     * Appends the specified suffix to the input string if it is not already present at the end of the string,
     * ignoring case considerations.
     *
     * <p>This method performs a case-insensitive check to determine if the string already ends with the
     * specified suffix. If it does, the original string is returned unchanged. If not, the suffix is
     * appended to the string. If the input string is {@code null} or empty, the suffix is returned as is.</p>
     *
     * <p>The suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.appendIfMissingIgnoreCase(null, ".TXT")         = ".TXT"
     * Strings.appendIfMissingIgnoreCase("", ".TXT")           = ".TXT"
     * Strings.appendIfMissingIgnoreCase("file", ".TXT")       = "file.TXT"
     * Strings.appendIfMissingIgnoreCase("file.txt", ".TXT")   = "file.txt"
     * Strings.appendIfMissingIgnoreCase("file.TXT", ".txt")   = "file.TXT"
     * Strings.appendIfMissingIgnoreCase("file", "")           = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to which the suffix should be appended, may be {@code null} or empty
     * @param suffix the suffix to append to the string. Must not be empty.
     * @return the input string with the suffix appended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the suffix is empty.
     * @see #appendIfMissing(String, String)
     * @see #prependIfMissingIgnoreCase(String, String)
     */
    public static String appendIfMissingIgnoreCase(final String str, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return suffix;
        } else if (Strings.endsWithIgnoreCase(str, suffix)) {
            return str;
        } else {
            return str + suffix;
        }
    }

    /**
     * Prepends the specified prefix to the input string if it is not already present at the start of the string.
     *
     * <p>This method checks if the string already starts with the specified prefix. If it does, the original
     * string is returned unchanged. If not, the prefix is prepended to the string. If the input string is
     * {@code null} or empty, the prefix is returned as is.</p>
     *
     * <p>The prefix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.prependIfMissing(null, "http://")                   = "http://"
     * Strings.prependIfMissing("", "http://")                     = "http://"
     * Strings.prependIfMissing("example.com", "http://")          = "http://example.com"
     * Strings.prependIfMissing("http://example.com", "http://")   = "http://example.com"
     * Strings.prependIfMissing("ftp://example.com", "http://")    = "http://ftp://example.com"
     * Strings.prependIfMissing("example.com", "")                 = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to which the prefix should be prepended, may be {@code null} or empty
     * @param prefix the prefix to prepend to the string. Must not be empty.
     * @return the input string with the prefix prepended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefix is empty.
     * @see #prependIfMissingIgnoreCase(String, String)
     * @see #appendIfMissing(String, String)
     */
    public static String prependIfMissing(final String str, final String prefix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);

        if (str == null || str.isEmpty()) {
            return prefix;
        } else if (str.startsWith(prefix)) {
            return str;
        } else {
            return concat(prefix, str);
        }
    }

    /**
     * Prepends the specified prefix to the input string if it is not already present at the start of the string,
     * ignoring case considerations.
     *
     * <p>This method performs a case-insensitive check to determine if the string already starts with the
     * specified prefix. If it does, the original string is returned unchanged. If not, the prefix is
     * prepended to the string. If the input string is {@code null} or empty, the prefix is returned as is.</p>
     *
     * <p>The prefix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.prependIfMissingIgnoreCase(null, "HTTP://")                   = "HTTP://"
     * Strings.prependIfMissingIgnoreCase("", "HTTP://")                     = "HTTP://"
     * Strings.prependIfMissingIgnoreCase("example.com", "HTTP://")          = "HTTP://example.com"
     * Strings.prependIfMissingIgnoreCase("http://example.com", "HTTP://")   = "http://example.com"
     * Strings.prependIfMissingIgnoreCase("HTTP://example.com", "http://")   = "HTTP://example.com"
     * Strings.prependIfMissingIgnoreCase("example.com", "")                 = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to which the prefix should be prepended, may be {@code null} or empty
     * @param prefix the prefix to prepend to the string. Must not be empty.
     * @return the input string with the prefix prepended if it was not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefix is empty.
     * @see #prependIfMissing(String, String)
     * @see #appendIfMissingIgnoreCase(String, String)
     */
    public static String prependIfMissingIgnoreCase(final String str, final String prefix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);

        if (str == null || str.isEmpty()) {
            return prefix;
        } else if (Strings.startsWithIgnoreCase(str, prefix)) {
            return str;
        } else {
            return concat(prefix, str);
        }
    }

    /**
     * Wraps the input string with the specified prefix and suffix if they are not already present.
     *
     * <p>This method uses the same string as both prefix and suffix. The method follows these rules:</p>
     * <ul>
     * <li>If the input string is {@code null} or empty, the prefix and suffix are concatenated and returned.</li>
     * <li>If the input string already starts with the prefix and ends with the suffix, the original string is returned.</li>
     * <li>If the input string already starts with the prefix but not ends with the suffix, then {@code str + prefixSuffix} is returned.</li>
     * <li>If the input string ends with the suffix but not starts with the prefix, then {@code prefixSuffix + str} is returned.</li>
     * <li>Otherwise, the prefix and suffix are added to the start and end of the string respectively.</li>
     * </ul>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.wrapIfMissing(null, "\"")        = "\"\""
     * Strings.wrapIfMissing("", "\"")          = "\"\""
     * Strings.wrapIfMissing("abc", "\"")       = "\"abc\""
     * Strings.wrapIfMissing("\"abc", "\"")     = "\"abc\""
     * Strings.wrapIfMissing("abc\"", "\"")     = "\"abc\""
     * Strings.wrapIfMissing("\"abc\"", "\"")   = "\"abc\""
     * Strings.wrapIfMissing("abc", "")         = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to be wrapped. May be {@code null} or empty.
     * @param prefixSuffix the string to be used as both the prefix and suffix for wrapping. Must not be empty.
     * @return the input string wrapped with the prefixSuffix at both ends if they were not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefixSuffix is empty.
     * @see #wrapIfMissing(String, String, String)
     * @see #wrap(String, String)
     */
    public static String wrapIfMissing(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return wrapIfMissing(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Wraps the input string with the specified prefix and suffix if they are not already present.
     *
     * <p>The method follows these rules:</p>
     * <ul>
     * <li>If the input string is {@code null} or empty, the prefix and suffix are concatenated and returned.</li>
     * <li>If the input string already starts with the prefix and ends with the suffix, the original string is returned.</li>
     * <li>If the input string already starts with the prefix but not ends with the suffix, then {@code str + suffix} is returned.</li>
     * <li>If the input string ends with the suffix but not starts with the prefix, then {@code prefix + str} is returned.</li>
     * <li>Otherwise, the prefix and suffix are added to the start and end of the string respectively.</li>
     * </ul>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.wrapIfMissing(null, "[", "]")       = "[]"
     * Strings.wrapIfMissing("", "[", "]")         = "[]"
     * Strings.wrapIfMissing("[", "[", "]")        = "[]"
     * Strings.wrapIfMissing("]", "[", "]")        = "[]"
     * Strings.wrapIfMissing("abc", "[", "]")      = "[abc]"
     * Strings.wrapIfMissing("[abc", "[", "]")     = "[abc]"
     * Strings.wrapIfMissing("abc]", "[", "]")     = "[abc]"
     * Strings.wrapIfMissing("[abc]", "[", "]")    = "[abc]"
     * Strings.wrapIfMissing("a", "aa", "aa")      = "aaaaa"
     * Strings.wrapIfMissing("aa", "aa", "aa")     = "aaaa"
     * Strings.wrapIfMissing("aaa", "aa", "aa")    = "aaaaa"
     * Strings.wrapIfMissing("aaaa", "aa", "aa")   = "aaaa"
     * }</pre>
     *
     * @param str the string to be wrapped. May be {@code null} or empty.
     * @param prefix the string to be used as the prefix for wrapping. Must not be empty.
     * @param suffix the string to be used as the suffix for wrapping. Must not be empty.
     * @return the input string wrapped with the prefix and suffix at both ends if they were not already present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefix or suffix is empty.
     * @see #wrapIfMissing(String, String)
     * @see #wrap(String, String, String)
     */
    public static String wrapIfMissing(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (isEmpty(str)) {
            return concat(prefix, suffix);
        } else if (str.startsWith(prefix)) {
            return (str.length() - prefix.length() >= suffix.length() && str.endsWith(suffix)) ? str : concat(str + suffix);
        } else if (str.endsWith(suffix)) {
            return concat(prefix, str);
        } else {
            return concat(prefix, str, suffix);
        }
    }

    /**
     * Wraps the input string with the specified prefix and suffix.
     *
     * <p>This method unconditionally adds the prefix and suffix to the string, regardless of whether
     * they are already present. If the input string is {@code null}, it will be treated as an empty string.
     * This method uses the same string as both prefix and suffix.</p>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.wrap(null, "\"")        = "\"\""
     * Strings.wrap("", "\"")          = "\"\""
     * Strings.wrap("abc", "\"")       = "\"abc\""
     * Strings.wrap("\"abc", "\"")     = "\"\"abc\""
     * Strings.wrap("abc\"", "\"")     = "\"abc\"\""
     * Strings.wrap("\"abc\"", "\"")   = "\"\"abc\"\""
     * Strings.wrap("abc", "")         = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to be wrapped. May be {@code null}.
     * @param prefixSuffix the string to be used as both the prefix and suffix for wrapping. Must not be empty.
     * @return the input string wrapped with the prefixSuffix at both ends.
     * @throws IllegalArgumentException if the prefixSuffix is empty.
     * @see #wrap(String, String, String)
     * @see #wrapIfMissing(String, String)
     */
    public static String wrap(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return wrap(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Wraps the input string with the specified prefix and suffix.
     *
     * <p>This method unconditionally adds the prefix and suffix to the string, regardless of whether
     * they are already present. If the input string is {@code null}, it will be treated as an empty string.</p>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.wrap(null, "[", "]")      = "[]"
     * Strings.wrap("", "[", "]")        = "[]"
     * Strings.wrap("[", "[", "]")       = "[[]"
     * Strings.wrap("]", "[", "]")       = "[]]"
     * Strings.wrap("abc", "[", "]")     = "[abc]"
     * Strings.wrap("[abc]", "[", "]")   = "[[abc]]"
     * Strings.wrap("a", "aa", "aa")     = "aaaaa"
     * Strings.wrap("aa", "aa", "aa")    = "aaaaaa"
     * Strings.wrap("aaa", "aa", "aa")   = "aaaaaaa"
     * }</pre>
     *
     * @param str the string to be wrapped. May be {@code null}.
     * @param prefix the string to be used as the prefix for wrapping. Must not be empty.
     * @param suffix the string to be used as the suffix for wrapping. Must not be empty.
     * @return the input string wrapped with the prefix and suffix at both ends.
     * @throws IllegalArgumentException if the prefix or suffix is empty.
     * @see #wrap(String, String)
     * @see #wrapIfMissing(String, String, String)
     */
    public static String wrap(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (isEmpty(str)) {
            return concat(prefix, suffix);
        } else {
            return concat(prefix, str, suffix);
        }
    }

    /**
     * Unwraps the input string if it is wrapped by the specified prefixSuffix at both ends.
     *
     * <p>This method removes the prefixSuffix from both the start and end of the string if and only if
     * the string starts and ends with the prefixSuffix. If the input string is {@code null} or empty,
     * the original string is returned. If the input string is not wrapped by the prefixSuffix, the
     * original string is returned unchanged.</p>
     *
     * <p>The prefixSuffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.unwrap(null, "\"")            = null
     * Strings.unwrap("", "\"")              = ""
     * Strings.unwrap("abc", "\"")           = "abc"
     * Strings.unwrap("\"abc", "\"")         = "\"abc"
     * Strings.unwrap("abc\"", "\"")         = "abc\""
     * Strings.unwrap("\"abc\"", "\"")       = "abc"
     * Strings.unwrap("\"\"abc\"\"", "\"")   = "\"abc\""
     * Strings.unwrap("abc", "")             = throws IllegalArgumentException
     * }</pre>
     *
     * @param str the string to be unwrapped. May be {@code null} or empty.
     * @param prefixSuffix the string used as both the prefix and suffix for unwrapping. Must not be empty.
     * @return the input string with the prefixSuffix removed from both ends if they were present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefixSuffix is empty.
     * @see #unwrap(String, String, String)
     */
    public static String unwrap(final String str, final String prefixSuffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefixSuffix, cs.prefixSuffix);

        return unwrap(str, prefixSuffix, prefixSuffix);
    }

    /**
     * Unwraps the input string if it is wrapped by the specified prefix and suffix.
     *
     * <p>This method removes the prefix from the start and the suffix from the end of the string if and
     * only if the string starts with the prefix and ends with the suffix. If the input string is {@code null}
     * or empty, the original string is returned. If the input string is not wrapped by the prefix and suffix,
     * the original string is returned unchanged.</p>
     *
     * <p>The prefix and suffix must not be empty, otherwise an {@code IllegalArgumentException} is thrown.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.unwrap(null, "[", "]")        = null
     * Strings.unwrap("", "[", "]")          = ""
     * Strings.unwrap("[", "[", "]")         = "["
     * Strings.unwrap("]", "[", "]")         = "]"
     * Strings.unwrap("[abc]", "[", "]")     = "abc"
     * Strings.unwrap("[[abc]]", "[", "]")   = "[abc]"
     * Strings.unwrap("[abc", "[", "]")      = "[abc"
     * Strings.unwrap("abc]", "[", "]")      = "abc]"
     * Strings.unwrap("aaaaa", "aa", "aa")   = "a"
     * Strings.unwrap("aa", "aa", "aa")      = "aa"
     * Strings.unwrap("aaa", "aa", "aa")     = "aaa"
     * Strings.unwrap("aaaa", "aa", "aa")    = ""
     * }</pre>
     *
     * @param str the string to be unwrapped. May be {@code null} or empty.
     * @param prefix the string used as the prefix for unwrapping. Must not be empty.
     * @param suffix the string used as the suffix for unwrapping. Must not be empty.
     * @return the input string with the prefix and suffix removed from both ends if they were present; otherwise, the original string.
     * @throws IllegalArgumentException if the prefix or suffix is empty.
     * @see #unwrap(String, String)
     */
    public static String unwrap(final String str, final String prefix, final String suffix) throws IllegalArgumentException {
        N.checkArgNotEmpty(prefix, cs.prefix);
        N.checkArgNotEmpty(suffix, cs.suffix);

        if (str == null || str.isEmpty()) {
            return str;
        } else if (str.length() - prefix.length() >= suffix.length() && str.startsWith(prefix) && str.endsWith(suffix)) {
            return str.substring(prefix.length(), str.length() - suffix.length());
        } else {
            return str;
        }
    }

    /**
     * Checks if the specified character is a lowercase character.
     *
     * <p>This method delegates to {@link Character#isLowerCase(char)} to determine if the character
     * is a lowercase letter according to Unicode standards.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isLowerCase('a')   = true
     * Strings.isLowerCase('A')   = false
     * Strings.isLowerCase('1')   = false
     * Strings.isLowerCase('√±')   = true
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is lowercase, {@code false} otherwise
     * @see Character#isLowerCase(char)
     * @see #isUpperCase(char)
     * @see #isAsciiLowerCase(char)
     */
    public static boolean isLowerCase(final char ch) {
        return Character.isLowerCase(ch);
    }

    /**
     * Checks if the specified character is an ASCII lowercase character.
     *
     * <p>This method checks if the character is in the range 'a' to 'z' (ASCII values 97 to 122).
     * Unlike {@link #isLowerCase(char)}, this method only considers ASCII lowercase letters and
     * does not include lowercase letters from other Unicode ranges.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiLowerCase('a')   = true
     * Strings.isAsciiLowerCase('z')   = true
     * Strings.isAsciiLowerCase('A')   = false
     * Strings.isAsciiLowerCase('1')   = false
     * Strings.isAsciiLowerCase('√±')   = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is an ASCII lowercase letter, {@code false} otherwise
     * @see #isLowerCase(char)
     * @see #isAsciiAlphaLower(char)
     * @see #isAsciiUpperCase(char)
     */
    public static boolean isAsciiLowerCase(final char ch) {
        return (ch >= 'a') && (ch <= 'z');
    }

    /**
     * Checks if the specified character is an uppercase character.
     *
     * <p>This method delegates to {@link Character#isUpperCase(char)} to determine if the character
     * is an uppercase letter according to Unicode standards.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isUpperCase('A')   = true
     * Strings.isUpperCase('a')   = false
     * Strings.isUpperCase('1')   = false
     * Strings.isUpperCase('√ë')   = true
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is uppercase, {@code false} otherwise
     * @see Character#isUpperCase(char)
     * @see #isLowerCase(char)
     * @see #isAsciiUpperCase(char)
     */
    public static boolean isUpperCase(final char ch) {
        return Character.isUpperCase(ch);
    }

    /**
     * Checks if the specified character is an ASCII uppercase character.
     *
     * <p>This method checks if the character is in the range 'A' to 'Z' (ASCII values 65 to 90).
     * Unlike {@link #isUpperCase(char)}, this method only considers ASCII uppercase letters and
     * does not include uppercase letters from other Unicode ranges.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiUpperCase('A')   = true
     * Strings.isAsciiUpperCase('Z')   = true
     * Strings.isAsciiUpperCase('a')   = false
     * Strings.isAsciiUpperCase('1')   = false
     * Strings.isAsciiUpperCase('√ë')   = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is an ASCII uppercase letter, {@code false} otherwise
     * @see #isUpperCase(char)
     * @see #isAsciiAlphaUpper(char)
     * @see #isAsciiLowerCase(char)
     */
    public static boolean isAsciiUpperCase(final char ch) {
        return (ch >= 'A') && (ch <= 'Z');
    }

    /**
     * Checks if all characters in the given CharSequence are lowercase.
     *
     * <p>This method returns {@code true} if all characters in the CharSequence are lowercase letters
     * according to {@link Character#isLowerCase(char)}. An empty CharSequence or {@code null} returns
     * {@code true}. Note that non-letter characters will cause this method to return {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllLowerCase(null)    = true
     * Strings.isAllLowerCase("")      = true
     * Strings.isAllLowerCase("abc")   = true
     * Strings.isAllLowerCase("abC")   = false
     * Strings.isAllLowerCase("ab c") = false (space is not a lowercase letter)
     * Strings.isAllLowerCase("ab1")  = false (digit is not a lowercase letter)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if all characters are lowercase or the CharSequence is empty or {@code null}; {@code false} otherwise
     * @see #isLowerCase(char)
     * @see #isAllUpperCase(CharSequence)
     * @see #isMixedCase(CharSequence)
     */
    public static boolean isAllLowerCase(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLowerCase(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all characters in the given CharSequence are uppercase.
     *
     * <p>This method returns {@code true} if all characters in the CharSequence are uppercase letters
     * according to {@link Character#isUpperCase(char)}. An empty CharSequence or {@code null} returns
     * {@code true}. Note that non-letter characters will cause this method to return {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAllUpperCase(null)    = true
     * Strings.isAllUpperCase("")      = true
     * Strings.isAllUpperCase("ABC")   = true
     * Strings.isAllUpperCase("ABc")   = false
     * Strings.isAllUpperCase("AB C") = false (space is not an uppercase letter)
     * Strings.isAllUpperCase("AB1")  = false (digit is not an uppercase letter)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if all characters are uppercase or the CharSequence is empty; {@code false} otherwise
     * @see #isUpperCase(char)
     * @see #isAllLowerCase(CharSequence)
     * @see #isMixedCase(CharSequence)
     */
    public static boolean isAllUpperCase(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isUpperCase(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains mixed case characters.
     *
     * <p>A CharSequence is considered mixed case if it contains both uppercase and lowercase characters.
     * If the CharSequence is empty, {@code null}, or contains only a single character, it is not considered
     * mixed case and the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isMixedCase(null)      = false
     * Strings.isMixedCase("")        = false
     * Strings.isMixedCase("a")       = false
     * Strings.isMixedCase("A")       = false
     * Strings.isMixedCase("abc")     = false
     * Strings.isMixedCase("ABC")     = false
     * Strings.isMixedCase("aBc")     = true
     * Strings.isMixedCase("Hello")   = true
     * Strings.isMixedCase("123")     = false (no letters)
     * Strings.isMixedCase("a1B2")    = true
     * }</pre>
     *
     * @param cs the CharSequence to check. It may be {@code null}.
     * @return {@code true} if the CharSequence is mixed case, {@code false} otherwise.
     * @see #isAllLowerCase(CharSequence)
     * @see #isAllUpperCase(CharSequence)
     */
    public static boolean isMixedCase(final CharSequence cs) {
        if (isEmpty(cs) || cs.length() == 1) {
            return false;
        }

        boolean containsUppercase = false;
        boolean containsLowercase = false;
        final int len = cs.length();

        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (Character.isUpperCase(ch)) {
                containsUppercase = true;
            } else if (Character.isLowerCase(ch)) {
                containsLowercase = true;
            }

            if (containsUppercase && containsLowercase) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified character is a digit.
     *
     * <p>This method delegates to {@link Character#isDigit(char)} to determine if the character
     * is a digit (0-9) according to Unicode standards. This includes not only ASCII digits but
     * also digits from other Unicode scripts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isDigit('0')   = true
     * Strings.isDigit('9')   = true
     * Strings.isDigit('a')   = false
     * Strings.isDigit('A')   = false
     * Strings.isDigit('Ÿ†')   = true (Arabic-Indic digit zero)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a digit, {@code false} otherwise
     * @see Character#isDigit(char)
     * @see #isLetter(char)
     * @see #isLetterOrDigit(char)
     * @see #isAsciiNumeric(char)
     */
    public static boolean isDigit(final char ch) {
        return Character.isDigit(ch);
    }

    /**
     * Checks if the specified character is a letter.
     *
     * <p>This method delegates to {@link Character#isLetter(char)} to determine if the character
     * is a letter according to Unicode standards. This includes letters from all Unicode scripts,
     * not just ASCII letters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isLetter('a')   = true
     * Strings.isLetter('A')   = true
     * Strings.isLetter('√±')   = true
     * Strings.isLetter('‰∏≠')   = true
     * Strings.isLetter('1')   = false
     * Strings.isLetter(' ')   = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a letter, {@code false} otherwise
     * @see Character#isLetter(char)
     * @see #isDigit(char)
     * @see #isLetterOrDigit(char)
     * @see #isAsciiAlpha(char)
     */
    public static boolean isLetter(final char ch) {
        return Character.isLetter(ch);
    }

    /**
     * Checks if the specified character is a letter or digit.
     *
     * <p>This method delegates to {@link Character#isLetterOrDigit(char)} to determine if the character
     * is either a letter or a digit according to Unicode standards. This includes letters and digits
     * from all Unicode scripts, not just ASCII.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isLetterOrDigit('a')   = true
     * Strings.isLetterOrDigit('A')   = true
     * Strings.isLetterOrDigit('1')   = true
     * Strings.isLetterOrDigit('√±')   = true
     * Strings.isLetterOrDigit('‰∏≠')   = true
     * Strings.isLetterOrDigit(' ')   = false
     * Strings.isLetterOrDigit('!')   = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character is a letter or digit, {@code false} otherwise
     * @see Character#isLetterOrDigit(char)
     * @see #isLetter(char)
     * @see #isDigit(char)
     * @see #isAsciiAlphanumeric(char)
     */
    public static boolean isLetterOrDigit(final char ch) {
        return Character.isLetterOrDigit(ch);
    }

    // --------------------------------------------------------------------------

    /**
     * Checks whether the character is ASCII 7 bit.
     *
     * <p>This method checks if the character value is less than 128, which means it belongs to the
     * standard ASCII character set (0-127). ASCII 7-bit includes control characters, printable
     * characters, letters, digits, and special symbols.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAscii('a')    = true
     * Strings.isAscii('A')    = true
     * Strings.isAscii('3')    = true
     * Strings.isAscii('-')    = true
     * Strings.isAscii('\n')   = true
     * Strings.isAscii('¬©')    = false (value 169)
     * Strings.isAscii('√±')    = false (value 241)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if the character value is less than 128, {@code false} otherwise
     * @see #isAsciiPrintable(char)
     * @see #isAsciiControl(char)
     * @see #isAsciiAlpha(char)
     * @see #isAsciiNumeric(char)
     */
    public static boolean isAscii(final char ch) {
        return ch < 128;
    }

    /**
     * Checks whether the character is ASCII 7 bit printable.
     *
     * <p>This method checks if the character is in the range of printable ASCII characters,
     * which are characters with values from 32 to 126 inclusive. This range includes space,
     * letters, digits, punctuation, and symbols, but excludes control characters.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiPrintable('a')   = true
     * Strings.isAsciiPrintable('A')   = true
     * Strings.isAsciiPrintable('3')   = true
     * Strings.isAsciiPrintable('-')   = true
     * Strings.isAsciiPrintable(' ')   = true (space, value 32)
     * Strings.isAsciiPrintable('~')   = true (tilde, value 126)
     * Strings.isAsciiPrintable('\n')  = false (newline, value 10)
     * Strings.isAsciiPrintable('\t')  = false (tab, value 9)
     * Strings.isAsciiPrintable('¬©')   = false (value 169)
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 32 and 126 inclusive, {@code false} otherwise
     * @see #isAscii(char)
     * @see #isAsciiControl(char)
     * @see #isAsciiPrintable(CharSequence)
     */
    public static boolean isAsciiPrintable(final char ch) {
        return ch > 31 && ch < 127;
    }

    /**
     * Checks whether the character is ASCII 7 bit control.
     *
     * <p>This method checks if the character is an ASCII control character. Control characters
     * are those with values less than 32 or equal to 127 (DEL). These include characters like
     * newline, carriage return, tab, and other non-printable control codes.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiControl('\n')     = true (newline, value 10)
     * Strings.isAsciiControl('\r')     = true (carriage return, value 13)
     * Strings.isAsciiControl('\t')     = true (tab, value 9)
     * Strings.isAsciiControl('\0')     = true (null, value 0)
     * Strings.isAsciiControl('\u007F') = true (DEL, value 127)
     * Strings.isAsciiControl('a')   = false
     * Strings.isAsciiControl('A')   = false
     * Strings.isAsciiControl(' ')      = false (space, value 32)
     * Strings.isAsciiControl('¬©')      = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if less than 32 or equals 127, {@code false} otherwise
     * @see #isAscii(char)
     * @see #isAsciiPrintable(char)
     */
    public static boolean isAsciiControl(final char ch) {
        return ch < 32 || ch == 127;
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic.
     *
     * <p>This method checks if the character is an ASCII letter, either uppercase (A-Z) or
     * lowercase (a-z). It does not include letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiAlpha('a')    = true
     * Strings.isAsciiAlpha('A')    = true
     * Strings.isAsciiAlpha('z')    = true
     * Strings.isAsciiAlpha('Z')    = true
     * Strings.isAsciiAlpha('3')    = false
     * Strings.isAsciiAlpha('-')    = false
     * Strings.isAsciiAlpha('\n')   = false
     * Strings.isAsciiAlpha('√±')    = false
     * Strings.isAsciiAlpha('¬©')    = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 65 and 90 or 97 and 122 inclusive, {@code false} otherwise
     * @see #isAsciiAlphaUpper(char)
     * @see #isAsciiAlphaLower(char)
     * @see #isAsciiAlphanumeric(char)
     * @see #isLetter(char)
     */
    public static boolean isAsciiAlpha(final char ch) {
        return isAsciiAlphaUpper(ch) || isAsciiAlphaLower(ch);
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic upper case.
     *
     * <p>This method checks if the character is an ASCII uppercase letter (A-Z).
     * It does not include uppercase letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiAlphaUpper('A')    = true
     * Strings.isAsciiAlphaUpper('Z')    = true
     * Strings.isAsciiAlphaUpper('a')    = false
     * Strings.isAsciiAlphaUpper('3')    = false
     * Strings.isAsciiAlphaUpper('-')    = false
     * Strings.isAsciiAlphaUpper('\n')   = false
     * Strings.isAsciiAlphaUpper('√ë')    = false
     * Strings.isAsciiAlphaUpper('¬©')    = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 65 and 90 inclusive, {@code false} otherwise
     * @see #isUpperCase(char)
     * @see #isAsciiLowerCase(char)
     */
    public static boolean isAsciiAlphaUpper(final char ch) {
        return ch >= 'A' && ch <= 'Z';
    }

    /**
     * Checks whether the character is ASCII 7 bit alphabetic lower case.
     *
     * <p>This method checks if the character is an ASCII lowercase letter (a-z).
     * It does not include lowercase letters from extended character sets or other
     * Unicode scripts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiAlphaLower('a')    = true
     * Strings.isAsciiAlphaLower('z')    = true
     * Strings.isAsciiAlphaLower('A')    = false
     * Strings.isAsciiAlphaLower('3')    = false
     * Strings.isAsciiAlphaLower('-')    = false
     * Strings.isAsciiAlphaLower('\n')   = false
     * Strings.isAsciiAlphaLower('√±')    = false
     * Strings.isAsciiAlphaLower('¬©')    = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 97 and 122 inclusive, {@code false} otherwise
     * @see #isAsciiAlpha(char)
     * @see #isAsciiAlphaUpper(char)
     * @see #isLowerCase(char)
     */
    public static boolean isAsciiAlphaLower(final char ch) {
        return ch >= 'a' && ch <= 'z';
    }

    /**
     * Checks whether the character is ASCII 7 bit numeric.
     *
     * <p>This method checks if the character is an ASCII digit (0-9). It does not include
     * digits from extended character sets or other Unicode scripts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiNumeric('0')    = true
     * Strings.isAsciiNumeric('9')    = true
     * Strings.isAsciiNumeric('5')    = true
     * Strings.isAsciiNumeric('a')    = false
     * Strings.isAsciiNumeric('A')    = false
     * Strings.isAsciiNumeric('-')    = false
     * Strings.isAsciiNumeric('\n')   = false
     * Strings.isAsciiNumeric('Ÿ†')    = false (Arabic-Indic digit)
     * Strings.isAsciiNumeric('¬©')    = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 48 and 57 inclusive, {@code false} otherwise
     * @see #isDigit(char)
     * @see #isAsciiAlphanumeric(char)
     */
    public static boolean isAsciiNumeric(final char ch) {
        return ch >= '0' && ch <= '9';
    }

    /**
     * Checks whether the character is ASCII 7 bit alphanumeric.
     *
     * <p>This method checks if the character is either an ASCII letter (A-Z, a-z) or an
     * ASCII digit (0-9). It combines the checks from {@link #isAsciiAlpha(char)} and
     * {@link #isAsciiNumeric(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiAlphanumeric('a')    = true
     * Strings.isAsciiAlphanumeric('A')    = true
     * Strings.isAsciiAlphanumeric('3')    = true
     * Strings.isAsciiAlphanumeric('z')    = true
     * Strings.isAsciiAlphanumeric('Z')    = true
     * Strings.isAsciiAlphanumeric('0')    = true
     * Strings.isAsciiAlphanumeric('-')    = false
     * Strings.isAsciiAlphanumeric(' ')    = false
     * Strings.isAsciiAlphanumeric('\n')   = false
     * Strings.isAsciiAlphanumeric('√±')    = false
     * Strings.isAsciiAlphanumeric('¬©')    = false
     * }</pre>
     *
     * @param ch the character to check
     * @return {@code true} if between 48 and 57 or 65 and 90 or 97 and 122 inclusive, {@code false} otherwise
     * @see #isLetterOrDigit(char)
     * @see #isAsciiAlpha(char)
     * @see #isAsciiNumeric(char)
     */
    public static boolean isAsciiAlphanumeric(final char ch) {
        return isAsciiAlpha(ch) || isAsciiNumeric(ch);
    }

    /**
     * Checks if the CharSequence contains only ASCII printable characters.
     *
     * <p>This method checks if all characters in the CharSequence are ASCII printable characters
     * (values 32-126). An empty CharSequence returns {@code true}, while {@code null} returns
     * {@code false}. The method will return {@code false} if any character is outside the
     * printable ASCII range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isAsciiPrintable(null)       = false
     * Strings.isAsciiPrintable("")         = true
     * Strings.isAsciiPrintable(" ")        = true
     * Strings.isAsciiPrintable("Ceki")     = true
     * Strings.isAsciiPrintable("ab2c")     = true
     * Strings.isAsciiPrintable("!ab-c~")   = true
     * Strings.isAsciiPrintable("\u0020")     = true (space)
     * Strings.isAsciiPrintable("\u0021")     = true (!)
     * Strings.isAsciiPrintable("\u007e")     = true (~)
     * Strings.isAsciiPrintable("\u007f")     = false (DEL)
     * Strings.isAsciiPrintable("Ceki G√ºlc√º") = false (contains non-ASCII)
     * Strings.isAsciiPrintable("abc\n")      = false (contains newline)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be null
     * @return {@code true} if every character is ASCII printable, {@code false} if the CharSequence is {@code null} or contains non-printable characters
     * @see #isAsciiPrintable(char)
     */
    public static boolean isAsciiPrintable(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiPrintable(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphabetic characters (a-z, A-Z).
     *
     * <p>ASCII alphabetic characters are those in the ranges 'a' through 'z' (lowercase) and 'A' through 'Z' (uppercase).
     * The method does not consider non-ASCII Unicode letters as alphabetic.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // ASCII alphabetic strings
     * Strings.isAsciiAlpha("abcDEF");        // returns true
     * Strings.isAsciiAlpha("HelloWorld");    // returns true
     * 
     * // Non-ASCII alphabetic strings
     * Strings.isAsciiAlpha(null);            // returns false
     * Strings.isAsciiAlpha("");              // returns false
     * Strings.isAsciiAlpha("abc123");        // returns {@code false} (contains digits)
     * Strings.isAsciiAlpha("hello world");   // returns {@code false} (contains space)
     * Strings.isAsciiAlpha("caf√©");          // returns {@code false} (contains non-ASCII character)
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence contains only ASCII alphabetic characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isAsciiAlpha(char)
     * @see #isAlpha(CharSequence)
     * @see #isAsciiAlphaSpace(CharSequence)
     */
    public static boolean isAsciiAlpha(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiAlpha(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphabetic characters (a-z, A-Z) and spaces.
     *
     * <p>ASCII alphabetic characters are those in the ranges 'a' through 'z' (lowercase) and 'A' through 'Z' (uppercase).
     * Space character (' ') is also allowed. The method does not consider non-ASCII Unicode letters or other whitespace characters.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // ASCII alphabetic strings with spaces
     * Strings.isAsciiAlphaSpace("Hello World");       // returns true
     * Strings.isAsciiAlphaSpace("The Quick Brown");   // returns true
     * Strings.isAsciiAlphaSpace("");                  // returns true
     * 
     * // Invalid strings
     * Strings.isAsciiAlphaSpace(null);                // returns false
     * Strings.isAsciiAlphaSpace("Hello123");          // returns {@code false} (contains digits)
     * Strings.isAsciiAlphaSpace("Hello\tWorld");      // returns {@code false} (contains tab)
     * Strings.isAsciiAlphaSpace("caf√©");              // returns {@code false} (contains non-ASCII character)
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence contains only ASCII alphabetic characters and spaces and is {@code non-null}, {@code false} otherwise.
     * @see #isAsciiAlpha(CharSequence)
     * @see #isAlphaSpace(CharSequence)
     */
    public static boolean isAsciiAlphaSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!isAsciiAlpha(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphanumeric characters (a-z, A-Z, 0-9).
     *
     * <p>ASCII alphanumeric characters include letters in the ranges 'a' through 'z' (lowercase),
     * 'A' through 'Z' (uppercase), and digits '0' through '9'. The method does not consider
     * non-ASCII Unicode letters or digits as alphanumeric.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // ASCII alphanumeric strings
     * Strings.isAsciiAlphanumeric("abc123");           // returns true
     * Strings.isAsciiAlphanumeric("HelloWorld2023");   // returns true
     * Strings.isAsciiAlphanumeric("ABC");              // returns true
     * Strings.isAsciiAlphanumeric("123");              // returns true
     * 
     * // Non-ASCII alphanumeric strings
     * Strings.isAsciiAlphanumeric(null);               // returns false
     * Strings.isAsciiAlphanumeric("");                 // returns false
     * Strings.isAsciiAlphanumeric("hello world");      // returns {@code false} (contains space)
     * Strings.isAsciiAlphanumeric("user@email");       // returns {@code false} (contains special character)
     * Strings.isAsciiAlphanumeric("caf√©123");          // returns {@code false} (contains non-ASCII character)
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence contains only ASCII alphanumeric characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isAlphanumeric(CharSequence)
     * @see #isAsciiAlpha(CharSequence)
     * @see #isAsciiNumeric(CharSequence)
     */
    public static boolean isAsciiAlphanumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiAlphanumeric(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII alphanumeric characters (a-z, A-Z, 0-9) and spaces.
     *
     * <p>ASCII alphanumeric characters include letters in the ranges 'a' through 'z' (lowercase),
     * 'A' through 'Z' (uppercase), and digits '0' through '9'. Space character (' ') is also allowed.
     * The method does not consider non-ASCII Unicode letters, digits, or other whitespace characters.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // ASCII alphanumeric strings with spaces
     * Strings.isAsciiAlphanumericSpace("Hello World 123");   // returns true
     * Strings.isAsciiAlphanumericSpace("Test 2023");         // returns true
     * Strings.isAsciiAlphanumericSpace("");                  // returns true
     * 
     * // Invalid strings
     * Strings.isAsciiAlphanumericSpace(null);                // returns false
     * Strings.isAsciiAlphanumericSpace("Hello@World");       // returns {@code false} (contains special character)
     * Strings.isAsciiAlphanumericSpace("Test\t123");         // returns {@code false} (contains tab)
     * Strings.isAsciiAlphanumericSpace("caf√© 2023");         // returns {@code false} (contains non-ASCII character)
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence contains only ASCII alphanumeric characters and spaces and is {@code non-null}, {@code false} otherwise.
     * @see #isAsciiAlphanumeric(CharSequence)
     * @see #isAlphanumericSpace(CharSequence)
     */
    public static boolean isAsciiAlphanumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!isAsciiAlphanumeric(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the given CharSequence contains only ASCII numeric characters (0-9).
     *
     * <p>ASCII numeric characters are those in the range '0' through '9'. The method does not
     * consider decimal points, signs (+ or -), or non-ASCII Unicode digits as numeric.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // ASCII numeric strings
     * Strings.isAsciiNumeric("123");          // returns true
     * Strings.isAsciiNumeric("0");            // returns true
     * Strings.isAsciiNumeric("9876543210");   // returns true
     * 
     * // Non-ASCII numeric strings
     * Strings.isAsciiNumeric(null);           // returns false
     * Strings.isAsciiNumeric("");             // returns false
     * Strings.isAsciiNumeric("12.3");         // returns {@code false} (contains decimal point)
     * Strings.isAsciiNumeric("-123");         // returns {@code false} (contains minus sign)
     * Strings.isAsciiNumeric("12 34");        // returns {@code false} (contains space)
     * Strings.isAsciiNumeric("12a");          // returns {@code false} (contains letter)
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null} or empty
     * @return {@code true} if the CharSequence contains only ASCII numeric characters and is non-null/non-empty, {@code false} otherwise.
     * @see #isNumeric(CharSequence)
     * @see #isAsciiDigitalNumber(String)
     */
    public static boolean isAsciiNumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!isAsciiNumeric(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    // Character Tests
    // -----------------------------------------------------------------------

    /**
     * Checks if the CharSequence contains only Unicode letters.
     *
     * <p>This method uses {@link Character#isLetter(char)} to check each character, which includes
     * all Unicode letters from any language, not just ASCII letters. This is broader than
     * {@link #isAsciiAlpha(CharSequence)} which only checks for ASCII letters.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode letter strings
     * Strings.isAlpha("abc");    // returns true
     * Strings.isAlpha("ABC");    // returns true
     * Strings.isAlpha("Œ±Œ≤Œ≥");    // returns {@code true} (Greek letters)
     * Strings.isAlpha("‰Ω†Â•Ω");     // returns {@code true} (Chinese characters)
     * Strings.isAlpha("caf√©");   // returns {@code true} (includes accented letter)
     * 
     * // Non-letter strings
     * Strings.isAlpha(null);     // returns false
     * Strings.isAlpha("");       // returns false
     * Strings.isAlpha("  ");     // returns {@code false} (contains spaces)
     * Strings.isAlpha("ab2c");   // returns {@code false} (contains digit)
     * Strings.isAlpha("ab-c");   // returns {@code false} (contains hyphen)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains letters and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isLetter(char)
     * @see #isAsciiAlpha(CharSequence)
     */
    public static boolean isAlpha(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLetter(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters and space (' ').
     *
     * <p>This method uses {@link Character#isLetter(char)} to check each character (except spaces),
     * which includes all Unicode letters from any language. Only the space character (' ') is
     * allowed as whitespace; tabs, newlines, and other whitespace characters are not allowed.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode letter strings with spaces
     * Strings.isAlphaSpace("Hello World");    // returns true
     * Strings.isAlphaSpace("caf√© au lait");   // returns true
     * Strings.isAlphaSpace("‰Ω†Â•Ω ‰∏ñÁïå");          // returns {@code true} (Chinese with space)
     * Strings.isAlphaSpace("");               // returns {@code true} (empty string)
     * Strings.isAlphaSpace("  ");             // returns {@code true} (only spaces)
     * 
     * // Invalid strings
     * Strings.isAlphaSpace(null);             // returns false
     * Strings.isAlphaSpace("ab c");           // returns true
     * Strings.isAlphaSpace("ab2c");           // returns {@code false} (contains digit)
     * Strings.isAlphaSpace("ab-c");           // returns {@code false} (contains hyphen)
     * Strings.isAlphaSpace("ab\tc");          // returns {@code false} (contains tab)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains letters and spaces and is {@code non-null}, {@code false} otherwise.
     * @see #isAlpha(CharSequence)
     * @see #isAsciiAlphaSpace(CharSequence)
     */
    public static boolean isAlphaSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isLetter(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters or digits.
     *
     * <p>This method uses {@link Character#isLetterOrDigit(char)} to check each character,
     * which includes all Unicode letters and digits from any language, not just ASCII.
     * This is broader than {@link #isAsciiAlphanumeric(CharSequence)}.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode alphanumeric strings
     * Strings.isAlphanumeric("abc");        // returns true
     * Strings.isAlphanumeric("abc123");     // returns true
     * Strings.isAlphanumeric("Œ±Œ≤Œ≥123");     // returns {@code true} (Greek letters with digits)
     * Strings.isAlphanumeric("‰Ω†Â•Ω123");      // returns {@code true} (Chinese with digits)
     * Strings.isAlphanumeric("caf√©2023");   // returns true
     * 
     * // Invalid strings
     * Strings.isAlphanumeric(null);         // returns false
     * Strings.isAlphanumeric("");           // returns false
     * Strings.isAlphanumeric("  ");         // returns {@code false} (contains spaces)
     * Strings.isAlphanumeric("ab c");       // returns {@code false} (contains space)
     * Strings.isAlphanumeric("ab2c");       // returns true
     * Strings.isAlphanumeric("ab-c");       // returns {@code false} (contains hyphen)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains letters or digits and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isLetterOrDigit(char)
     * @see #isAsciiAlphanumeric(CharSequence)
     */
    public static boolean isAlphanumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isLetterOrDigit(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode letters, digits or space (' ').
     *
     * <p>This method uses {@link Character#isLetterOrDigit(char)} to check each character (except spaces),
     * which includes all Unicode letters and digits from any language. Only the space character (' ')
     * is allowed as whitespace; tabs, newlines, and other whitespace characters are not allowed.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode alphanumeric strings with spaces
     * Strings.isAlphanumericSpace("Hello World 123");     // returns true
     * Strings.isAlphanumericSpace("caf√© au lait 2023");   // returns true
     * Strings.isAlphanumericSpace("‰Ω†Â•Ω 123");              // returns true
     * Strings.isAlphanumericSpace("");                    // returns {@code true} (empty string)
     * Strings.isAlphanumericSpace("  ");                  // returns {@code true} (only spaces)
     * 
     * // Invalid strings
     * Strings.isAlphanumericSpace(null);                  // returns false
     * Strings.isAlphanumericSpace("ab c");                // returns true
     * Strings.isAlphanumericSpace("ab2c");                // returns true
     * Strings.isAlphanumericSpace("ab-c");                // returns {@code false} (contains hyphen)
     * Strings.isAlphanumericSpace("ab\tc");               // returns {@code false} (contains tab)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains letters, digits or spaces and is {@code non-null}, {@code false} otherwise.
     * @see #isAlphanumeric(CharSequence)
     * @see #isAsciiAlphanumericSpace(CharSequence)
     */
    public static boolean isAlphanumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isLetterOrDigit(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode digits.
     *
     * <p>This method uses {@link Character#isDigit(char)} to check each character, which includes
     * all Unicode digit characters from any language, not just ASCII digits 0-9. A decimal point
     * is not a Unicode digit and returns {@code false}.</p>
     *
     * <p>The method returns {@code false} for {@code null} or empty input.</p>
     *
     * <p>Note that the method does not allow for a leading sign, either positive or negative.
     * Also, if a String passes the numeric test, it may still generate a NumberFormatException
     * when parsed by Integer.parseInt or Long.parseLong, e.g., if the value is outside the
     * range for int or long respectively.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode numeric strings
     * Strings.isNumeric("123");    // returns true
     * Strings.isNumeric("‡•ß‡•®‡•©");    // returns {@code true} (Devanagari digits)
     * Strings.isNumeric("Ÿ§Ÿ•Ÿ¶");    // returns {@code true} (Arabic-Indic digits)
     * 
     * // Invalid strings
     * Strings.isNumeric(null);     // returns false
     * Strings.isNumeric("");       // returns false
     * Strings.isNumeric("  ");     // returns {@code false} (contains spaces)
     * Strings.isNumeric("12 3");   // returns {@code false} (contains space)
     * Strings.isNumeric("ab2c");   // returns {@code false} (contains letters)
     * Strings.isNumeric("12-3");   // returns {@code false} (contains hyphen)
     * Strings.isNumeric("12.3");   // returns {@code false} (contains decimal point)
     * Strings.isNumeric("-123");   // returns {@code false} (contains minus sign)
     * Strings.isNumeric("+123");   // returns {@code false} (contains plus sign)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains digits and is non-null/non-empty, {@code false} otherwise.
     * @see Character#isDigit(char)
     * @see #isAsciiNumeric(CharSequence)
     * @see #isNumber(String)
     */
    public static boolean isNumeric(final CharSequence cs) {
        if (isEmpty(cs)) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isDigit(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only Unicode digits or space (' ').
     *
     * <p>This method uses {@link Character#isDigit(char)} to check each character (except spaces),
     * which includes all Unicode digit characters from any language. A decimal point is not a
     * Unicode digit and returns {@code false}. Only the space character (' ') is allowed as
     * whitespace.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Unicode numeric strings with spaces
     * Strings.isNumericSpace("123 456");               // returns true
     * Strings.isNumericSpace("‡•ß‡•®‡•© ‡•™‡•´‡•¨");               // returns {@code true} (Devanagari digits with space)
     * Strings.isNumericSpace("");                      // returns {@code true} (empty string)
     * Strings.isNumericSpace("  ");                    // returns {@code true} (only spaces)
     * Strings.isNumericSpace("\u0967\u0968\u0969");    // returns true
     * Strings.isNumericSpace("\u0967\u0968 \u0969");   // returns true
     * 
     * // Invalid strings
     * Strings.isNumericSpace(null);                    // returns false
     * Strings.isNumericSpace("ab2c");                  // returns {@code false} (contains letters)
     * Strings.isNumericSpace("12-3");                  // returns {@code false} (contains hyphen)
     * Strings.isNumericSpace("12.3");                  // returns {@code false} (contains decimal point)
     * Strings.isNumericSpace("12\t3");                 // returns {@code false} (contains tab)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains digits or spaces and is {@code non-null}, {@code false} otherwise.
     * @see #isNumeric(CharSequence)
     * @see Character#isDigit(char)
     */
    public static boolean isNumericSpace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();
        char ch = 0;

        for (int i = 0; i < len; i++) {
            ch = cs.charAt(i);

            if (!Character.isDigit(ch) && ch != ' ') {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the CharSequence contains only whitespace.
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}, which includes space,
     * tab, newline, carriage return, form feed, and other Unicode whitespace characters.</p>
     *
     * <p>The method returns {@code false} for {@code null} input, but {@code true} for empty string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Whitespace strings
     * Strings.isWhitespace("");         // returns {@code true} (empty string)
     * Strings.isWhitespace("  ");       // returns {@code true} (spaces)
     * Strings.isWhitespace("\t\n\r");   // returns {@code true} (tab, newline, carriage return)
     * Strings.isWhitespace("  \t  ");   // returns {@code true} (mixed whitespace)
     * 
     * // Non-whitespace strings
     * Strings.isWhitespace(null);       // returns false
     * Strings.isWhitespace("abc");      // returns {@code false} (contains letters)
     * Strings.isWhitespace("ab2c");     // returns {@code false} (contains letters and digit)
     * Strings.isWhitespace("ab-c");     // returns {@code false} (contains letters and hyphen)
     * Strings.isWhitespace(" a ");      // returns {@code false} (contains letter)
     * }</pre>
     *
     * @param cs the CharSequence to check, may be {@code null}
     * @return {@code true} if only contains whitespace and is {@code non-null}, {@code false} otherwise.
     * @see Character#isWhitespace(char)
     */
    public static boolean isWhitespace(final CharSequence cs) {
        if (cs == null) {
            return false;
        }

        final int len = cs.length();

        for (int i = 0; i < len; i++) {
            if (!Character.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Note: It's copied from NumberUtils in Apache Commons Lang under Apache
     * License 2.0
     *
     * <p>
     * Checks whether the String a valid Java number. {@code true} is
     * returned if there is a number which can be initialized by
     * {@code createNumber} with specified String.
     * </p>
     *
     * <p>
     * {@code Null} and empty String will return {@code false}.
     * </p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.isNumber("123");    // returns true
     * Strings.isNumber("12.3");   // returns true
     * Strings.isNumber("-123");   // returns true
     * Strings.isNumber(null);     // returns false
     * Strings.isNumber("abc");    // returns false
     * }</pre>
     *
     * @param str the {@code String} to check
     * @return {@code true} if the string is a correctly formatted number
     * @see Numbers#isNumber(String)
     * @see Numbers#isCreatable(String)
     * @see Numbers#isParsable(String)
     *        validation
     * @deprecated use {@link Numbers#isNumber(String)} instead
     */
    @Deprecated
    public static boolean isNumber(final String str) {
        return Numbers.isNumber(str);
    }

    /**
     * Checks if the given string contains only valid ASCII number characters.
     *
     * <p>This method checks if the string is a valid number representation using only ASCII characters.
     * It supports digits (0-9), decimal point (.), signs (+ or -), and exponential notation (e or E).
     * The method validates proper number format including optional sign, integer part,
     * optional decimal part, and optional exponential part.</p>
     *
     * <p>The method returns {@code false} for {@code null}, empty strings, or strings containing spaces.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid ASCII digital numbers
     * Strings.isAsciiDigitalNumber("0");          // returns true
     * Strings.isAsciiDigitalNumber("123");        // returns true
     * Strings.isAsciiDigitalNumber("-456");       // returns true
     * Strings.isAsciiDigitalNumber("+789");       // returns true
     * Strings.isAsciiDigitalNumber("12.34");      // returns true
     * Strings.isAsciiDigitalNumber("2e10");       // returns true
     * Strings.isAsciiDigitalNumber("2E-10");      // returns true
     * Strings.isAsciiDigitalNumber("-3.14e+5");   // returns true
     * 
     * // Invalid strings
     * Strings.isAsciiDigitalNumber(null);         // returns false
     * Strings.isAsciiDigitalNumber("");           // returns false
     * Strings.isAsciiDigitalNumber(" 0.1 ");      // returns {@code false} (contains spaces)
     * Strings.isAsciiDigitalNumber("abc");        // returns {@code false} (contains letters)
     * Strings.isAsciiDigitalNumber("1 a");        // returns {@code false} (contains space and letter)
     * Strings.isAsciiDigitalNumber("1.2.3");      // returns {@code false} (multiple decimal points)
     * Strings.isAsciiDigitalNumber("e10");        // returns {@code false} (no digits before 'e')
     * }</pre>
     *
     * @param str the string to check, may be {@code null}
     * @return {@code true} if the string represents a valid ASCII digital number, {@code false} otherwise.
     * @see #isAsciiDigitalInteger(String)
     * @see #isNumber(String)
     */
    public static boolean isAsciiDigitalNumber(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        int count = 0;
        final int len = str.length();
        char ch = str.charAt(0);
        int i = 0;

        if (ch == '+' || ch == '-') {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (i < len && str.charAt(i) == '.') {
            if (count == 0) {
                return false;
            } else {
                count = 0;
            }

            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (count == 0) {
            return false;
        }

        if (i == len) {
            return true;
        }

        ch = str.charAt(i);

        if (ch != 'e' && ch != 'E') {
            return false;
        } else {
            i++;
        }

        count = 0;

        if (i < len && (str.charAt(i) == '+' || str.charAt(i) == '-')) {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        //NOSONAR
        return (count != 0) && (i == len);
    }

    /**
     * Checks if the given string contains only valid ASCII integer characters.
     *
     * <p>This method checks if the string is a valid integer representation using only ASCII characters.
     * It supports digits (0-9) and an optional leading sign (+ or -).
     * The method does not allow decimal points, exponential notation, or any other characters.
     * Empty strings and strings containing only a sign are considered invalid.</p>
     *
     * <p>The method returns {@code false} for {@code null}, empty strings, or strings containing spaces.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid ASCII digital integers
     * Strings.isAsciiDigitalInteger("0");       // returns true
     * Strings.isAsciiDigitalInteger("123");     // returns true
     * Strings.isAsciiDigitalInteger("-123");    // returns true
     * Strings.isAsciiDigitalInteger("+123");    // returns true
     * Strings.isAsciiDigitalInteger("+0");      // returns true
     * Strings.isAsciiDigitalInteger("-0");      // returns true
     * 
     * // Invalid strings
     * Strings.isAsciiDigitalInteger(null);      // returns false
     * Strings.isAsciiDigitalInteger("");        // returns false
     * Strings.isAsciiDigitalInteger(" 0.1 ");   // returns {@code false} (contains spaces and decimal)
     * Strings.isAsciiDigitalInteger("12.34");   // returns {@code false} (contains decimal point)
     * Strings.isAsciiDigitalInteger("abc");     // returns {@code false} (contains letters)
     * Strings.isAsciiDigitalInteger("1 a");     // returns {@code false} (contains space and letter)
     * Strings.isAsciiDigitalInteger("2e10");    // returns {@code false} (contains exponential notation)
     * Strings.isAsciiDigitalInteger("+");       // returns {@code false} (only sign, no digits)
     * }</pre>
     *
     * @param str the string to check, may be {@code null}
     * @return {@code true} if the string represents a valid ASCII digital integer, {@code false} otherwise.
     * @see #isAsciiDigitalNumber(String)
     * @see #isAsciiNumeric(CharSequence)
     */
    public static boolean isAsciiDigitalInteger(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        int count = 0;

        final int len = str.length();
        char ch = str.charAt(0);
        int i = 0;

        if (ch == '+' || ch == '-') {
            i++;
        }

        for (; i < len; i++) {
            ch = str.charAt(i);

            if (ch >= '0' && ch <= '9') {
                count++;
            } else {
                break;
            }
        }

        if (count == 0) {
            return false;
        }

        return i == len;
    }

    /**
     * Returns the index within this string of the first occurrence of the specified character.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence
     * represented by this {@code String} object, then the index of the first such occurrence
     * is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} for {@code null} or empty input strings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Character found
     * Strings.indexOf("hello", 'h');         // returns 0
     * Strings.indexOf("hello", 'e');         // returns 1
     * Strings.indexOf("hello", 'o');         // returns 4
     * Strings.indexOf("hello world", ' ');   // returns 5
     * 
     * // Character not found
     * Strings.indexOf("hello", 'x');         // returns -1
     * Strings.indexOf(null, 'a');            // returns -1
     * Strings.indexOf("", 'a');              // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param charValueToFind the Unicode code of the character to be found.
     * @return the index of the first occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur.
     * @see String#indexOf(int)
     */
    public static int indexOf(final String str, final int charValueToFind) {
        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(charValueToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified character, starting the search at the specified index.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first such occurrence is returned. If {@code fromIndex} is negative,
     * it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} for {@code null} or empty input strings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Character found
     * Strings.indexOf("hello", 'l', 0);   // returns 2
     * Strings.indexOf("hello", 'l', 3);   // returns 3
     * Strings.indexOf("hello", 'o', 0);   // returns 4
     * 
     * // Character not found
     * Strings.indexOf("hello", 'h', 1);   // returns -1
     * Strings.indexOf("hello", 'x', 0);   // returns -1
     * Strings.indexOf(null, 'a', 0);      // returns -1
     * Strings.indexOf("", 'a', 0);        // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param charValueToFind the Unicode code of the character to be found.
     * @param fromIndex the index to start the search from.
     * @return the index of the first occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur.
     * @see String#indexOf(int, int)
     */
    public static int indexOf(final String str, final int charValueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(charValueToFind, fromIndex);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first character
     * of the first such substring is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if the substring is not found, or if either parameter is {@code null},
     * or if the substring is longer than the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Substring found
     * Strings.indexOf("hello world", "world");   // returns 6
     * Strings.indexOf("hello world", "hello");   // returns 0
     * Strings.indexOf("hello world", "o");       // returns 4
     * Strings.indexOf("hello world", "");        // returns 0 (empty string always found at index 0)
     * 
     * // Substring not found
     * Strings.indexOf("hello", "world");         // returns -1
     * Strings.indexOf(null, "test");             // returns -1
     * Strings.indexOf("test", null);             // returns -1
     * Strings.indexOf("", "test");               // returns -1 (substring longer than string)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see String#indexOf(String)
     */
    public static int indexOf(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(valueToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, starting the search at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first character of the first such substring is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if the substring is not found, or if either parameter is {@code null},
     * or if the substring cannot fit in the remaining portion of the string from {@code fromIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Substring found
     * Strings.indexOf("hello world", "o", 0);       // returns 4
     * Strings.indexOf("hello world", "o", 5);       // returns 7
     * Strings.indexOf("hello world", "world", 0);   // returns 6
     * 
     * // Substring not found
     * Strings.indexOf("hello", "o", 5);             // returns -1 (fromIndex beyond string)
     * Strings.indexOf("hello", "world", 0);         // returns -1
     * Strings.indexOf(null, "test", 0);             // returns -1
     * Strings.indexOf("test", null, 0);             // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found.
     * @param fromIndex the index to start the search from.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see String#indexOf(String, int)
     */
    public static int indexOf(final String str, final String valueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || valueToFind == null || valueToFind.length() > str.length() - fromIndex) {
            return N.INDEX_NOT_FOUND;
        }

        return str.indexOf(valueToFind, fromIndex);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified character.
     *
     * <p>If any character within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first such occurrence
     * is returned. The search starts from the beginning of the string. Note that the returned index may not be
     * the smallest or largest index among all matching characters - it returns the index of the first match found.</p>
     *
     * <p>The method returns {@code -1} if none of the characters are found, or if the input string
     * is {@code null} or empty, or if the character array is {@code null} or empty.</p>
     * 
     * <p>Note: Use the {@code Strings.indexOf(String, int)} method when searching for a single character to avoid ambiguous compilation errors.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Characters found
     * Strings.indexOfAny("hello", 'e', 'o');        // returns 1 (first 'e')
     * Strings.indexOfAny("hello", 'o', 'l');        // returns 2 (first 'l')
     * Strings.indexOfAny("hello", 'x', 'y', 'h');   // returns 0 (first 'h')
     * 
     * // Characters not found
     * Strings.indexOfAny("hello", 'x', 'y', 'z');   // returns -1
     * Strings.indexOfAny(null, 'a');                // returns -1
     * Strings.indexOfAny("", 'a');                  // returns -1
     * Strings.indexOfAny("hello");                  // returns -1 (empty array)
     * 
     * Strings.indexOfAny("abc", '\uDC00', 'a');     // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.indexOfAny("abc", '\uDFFF', 'a');     // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of characters to be found.
     * @return the index of the first occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur.
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit. 
     * @see #indexOfAny(String, int, char...)
     * @see #indexOf(String, int)
     */
    public static int indexOfAny(final String str, final char... valuesToFind) throws IllegalArgumentException {
        return indexOfAny(str, 0, valuesToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified character, starting the search at the specified index.
     *
     * <p>If any character within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first such occurrence is returned. If {@code fromIndex} is negative,
     * it is treated as zero. Note that the returned index may not be
     * the smallest or largest index among all matching characters - it returns the index of the first match found.</p>
     *
     * <p>The method returns {@code -1} if none of the characters are found, or if the input string
     * is {@code null} or empty, or if the character array is {@code null} or empty.</p>
     * 
     * <p>Note: Use the {@code Strings.indexOf(String, int, int)} method when searching for a single character to avoid ambiguous compilation errors.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Characters found
     * Strings.indexOfAny("hello", 0, 'e', 'o');      // returns 1 (first 'e')
     * Strings.indexOfAny("hello", 2, 'e', 'o');      // returns 4 (first 'o' after index 2)
     * Strings.indexOfAny("hello", 0, 'l');           // returns 2 (first 'l')
     * 
     * // Characters not found
     * Strings.indexOfAny("hello", 5, 'h', 'e');      // returns -1 (no match after index 5)
     * Strings.indexOfAny("hello", 0, 'x', 'y');      // returns -1
     * Strings.indexOfAny(null, 0, 'a');              // returns -1
     * 
     * Strings.indexOfAny("abc", 0, '\uDC00', 'a');   // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.indexOfAny("abc", 0, '\uDFFF', 'a');   // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param fromIndex the index to start the search from.
     * @param valuesToFind the array of characters to be found.
     * @return the index of the first occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur.
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit.
     * @see #indexOfAny(String, char...)
     * @see #indexOf(String, int, int)
     */
    public static int indexOfAny(final String str, int fromIndex, final char... valuesToFind) throws IllegalArgumentException {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        fromIndex = Math.max(0, fromIndex);

        if (valuesToFind.length < 3 || (str.length() < 9 && valuesToFind.length < 9)) {
            int idx = 0;

            for (final char ch : valuesToFind) {
                idx = str.indexOf(ch, fromIndex);

                if (idx != N.INDEX_NOT_FOUND) {
                    return idx;
                }
            }
        } else {
            final int strLen = str.length();
            char ch = 0;

            for (int i = fromIndex; i < strLen; i++) {
                ch = str.charAt(i);

                for (final char c : valuesToFind) {
                    if (c == ch) {
                        return i;
                    }
                }
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified substring.
     *
     * <p>If any substring within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object, then the index of the first character of
     * the first such substring is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if none of the substrings are found, or if the input string
     * is {@code null}, or if the substring array is {@code null} or empty. Empty substrings in the array are ignored.</p>
     * 
     * <p>Note: Use the {@code Strings.indexOf(String, String)} method when searching for a single string to avoid ambiguous compilation errors.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Substrings found
     * Strings.indexOfAny("hello world", "world", "hello");   // returns 0 ("hello" comes first)
     * Strings.indexOfAny("hello world", "xyz", "world");     // returns 6 ("world" found)
     * Strings.indexOfAny("hello world", "o", "e");           // returns 1 ("e" comes first)
     * 
     * // Substrings not found
     * Strings.indexOfAny("hello", "xyz", "abc");             // returns -1
     * Strings.indexOfAny(null, "test");                      // returns -1
     * Strings.indexOfAny("test", (String[]) null);           // returns -1
     * Strings.indexOfAny("test", new String[0]);             // returns -1 (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of substrings to be found.
     * @return the index of the first occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur.
     * @see #indexOfAny(String, int, String...)
     * @see #indexOf(String, String)
     */
    public static int indexOfAny(final String str, final String... valuesToFind) {
        return indexOfAny(str, 0, valuesToFind);
    }

    /**
     * Returns the index within the input string of the first occurrence of any specified substring, starting the search at the specified index.
     *
     * <p>If any substring within the array {@code valuesToFind} occurs in the character sequence
     * represented by the input {@code String} object at an index no smaller than {@code fromIndex},
     * then the index of the first character of the first such substring is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if none of the substrings are found, or if the input string
     * is {@code null}, or if the substring array is {@code null} or empty. Empty substrings in the array are ignored.</p>
     * 
     * <p>Note: Use the {@code Strings.indexOf(String, String, int)} method when searching for a single string to avoid ambiguous compilation errors.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Substrings found
     * Strings.indexOfAny("hello world", 0, "world", "hello");   // returns 0 ("hello" at index 0)
     * Strings.indexOfAny("hello world", 6, "world", "hello");   // returns 6 ("world" at index 6)
     * Strings.indexOfAny("hello world", 7, "world", "o");       // returns 7 ("o" at index 7)
     * 
     * // Substrings not found
     * Strings.indexOfAny("hello", 0, "xyz", "abc");             // returns -1
     * Strings.indexOfAny("hello", 10, "h", "e");                // returns -1 (fromIndex beyond string)
     * Strings.indexOfAny(null, 0, "test");                      // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param fromIndex the index to start the search from.
     * @param valuesToFind the array of substrings to be found.
     * @return the index of the first occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String...)
     * @see #indexOf(String, String, int)
     */
    public static int indexOfAny(final String str, int fromIndex, final String... valuesToFind) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        int idx = 0;

        for (final String element : valuesToFind) {
            if (isEmpty(element)) {
                continue;
            }

            idx = indexOf(str, element, fromIndex);

            if (idx != N.INDEX_NOT_FOUND) {
                return idx;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of any character
     * that is not in the specified array of characters to exclude.
     *
     * <p>If a character not within the array {@code valuesToExclude} occurs in the character
     * sequence represented by the input {@code String} object, then the index of the first
     * such occurrence is returned. The search starts from the beginning of the string.</p>
     *
     * <p>The method returns {@code -1} if all characters in the string are in the exclusion array,
     * or if the string is {@code null} or empty. If the exclusion array is {@code null} or empty, returns 0
     * (the first character is not excluded).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Characters not in exclusion array found
     * Strings.indexOfAnyBut("hello", 'h', 'e');   // returns 2 (first 'l')
     * Strings.indexOfAnyBut("hello", 'x', 'y');   // returns 0 (first 'h')
     * Strings.indexOfAnyBut("aaabbb", 'a');       // returns 3 (first 'b')
     * 
     * // All characters excluded or special cases
     * Strings.indexOfAnyBut("aaa", 'a');          // returns -1 (all excluded)
     * Strings.indexOfAnyBut(null, 'a');           // returns -1
     * Strings.indexOfAnyBut("", 'a');             // returns -1
     * Strings.indexOfAnyBut("hello");             // returns 0 (empty exclusion array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToExclude the array of characters to exclude from the search.
     * @return the index of the first occurrence of any character not in the array of characters
     *         to exclude, or -1 if all characters are in the array or the string is {@code null} or empty.
     * @see #indexOfAnyBut(String, int, char...)
     */
    public static int indexOfAnyBut(final String str, final char... valuesToExclude) {
        return indexOfAnyBut(str, 0, valuesToExclude);
    }

    /**
     * Returns the index within the input string of the first occurrence of any character
     * that is not in the specified array of characters to exclude, starting the search at the specified index.
     *
     * <p>If a character not within the array {@code valuesToExclude} occurs in the character
     * sequence represented by the input {@code String} object at an index no smaller than
     * {@code fromIndex}, then the index of the first such occurrence is returned.
     * If {@code fromIndex} is negative, it is treated as zero.</p>
     *
     * <p>The method returns {@code -1} if all characters from {@code fromIndex} onwards are
     * in the exclusion array, or if the string is {@code null} or empty. If the exclusion array is
     * {@code null} or empty, returns {@code fromIndex} (if valid).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Characters not in exclusion array found
     * Strings.indexOfAnyBut("hello", 0, 'h', 'e');   // returns 2 (first 'l')
     * Strings.indexOfAnyBut("hello", 3, 'h', 'e');   // returns 3 (first 'l' from index 3)
     * Strings.indexOfAnyBut("aaabbb", 0, 'a');       // returns 3 (first 'b')
     * Strings.indexOfAnyBut("aaabbb", 3, 'a');       // returns 3 (first 'b' from index 3)
     * 
     * // All characters excluded or special cases
     * Strings.indexOfAnyBut("aaa", 0, 'a');          // returns -1 (all excluded)
     * Strings.indexOfAnyBut("hello", 10, 'x');       // returns -1 (fromIndex beyond string)
     * Strings.indexOfAnyBut(null, 0, 'a');           // returns -1
     * 
     * Strings.indexOfAnyBut("abc", '\uDC00', 'a');   // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.indexOfAnyBut("abc", '\uDFFF', 'a');   // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param fromIndex the index to start the search from.
     * @param valuesToExclude the array of characters to exclude from the search.
     * @return the index of the first occurrence of any character not in the array of characters
     *         to exclude, or -1 if all characters are in the array or the string is {@code null} or empty.
     * @throws IllegalArgumentException if any char in {@code valuesToExclude} contains low-surrogate or high-surrogate code unit.
     * @see #indexOfAnyBut(String, char...)
     */
    public static int indexOfAnyBut(final String str, int fromIndex, final char... valuesToExclude) {
        checkInputChars(valuesToExclude, cs.valuesToExclude, true);

        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        if (N.isEmpty(valuesToExclude)) {
            return 0;
        }

        fromIndex = Math.max(0, fromIndex);

        final int strLen = str.length();
        char ch = 0;

        outer: for (int i = fromIndex; i < strLen; i++) {//NOSONAR
            ch = str.charAt(i);

            for (final char c : valuesToExclude) {
                if (c == ch) {
                    // checked by checkInputChars

                    continue outer;
                }
            }

            return i;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring,
     * using the specified delimiter to separate the search.
     *
     * <p>The method searches for {@code valueToFind} as a whole word/token delimited by {@code delimiter}.
     * A match is valid only if the substring is preceded by the delimiter (or is at the start of the string)
     * and followed by the delimiter (or is at the end of the string).</p>
     *
     * <p>If the delimiter is empty, this method behaves the same as {@link #indexOf(String, String)}.
     * The method returns {@code -1} if the substring is not found as a delimited token.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Delimited substring found
     * Strings.indexOf("apple,banana,cherry", "banana", ",");   // returns 6
     * Strings.indexOf("apple banana cherry", "banana", " ");   // returns 6
     * Strings.indexOf(",banana,", "banana", ",");              // returns 1
     * Strings.indexOf("banana", "banana", ",");                // returns 0 (whole string matches)
     * 
     * // Delimited substring not found
     * Strings.indexOf("applesauce", "apple", ",");             // returns -1 (not delimited)
     * Strings.indexOf("apple,ban,cherry", "banana", ",");      // returns -1 (partial match)
     * Strings.indexOf(null, "test", ",");                      // returns -1
     * Strings.indexOf("test", null, ",");                      // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found.
     * @param delimiter the delimiter to separate the search.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see #indexOf(String, String, String, int)
     */
    public static int indexOf(final String str, final String valueToFind, final String delimiter) {
        return indexOf(str, valueToFind, delimiter, 0);
    }

    // Character Tests
    // -----------------------------------------------------------------------

    /**
     * Returns the index within the input string of the first occurrence of the specified substring,
     * using the specified delimiter to separate the search, starting the search at the specified index.
     *
     * <p>The method searches for {@code valueToFind} as a whole word/token delimited by {@code delimiter}.
     * A match is valid only if the substring is preceded by the delimiter (or is at the start of the search)
     * and followed by the delimiter (or is at the end of the string). If {@code fromIndex} is negative,
     * it is treated as zero.</p>
     *
     * <p>If the delimiter is empty, this method behaves the same as {@link #indexOf(String, String, int)}.
     * The method returns {@code -1} if the substring is not found as a delimited token.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Delimited substring found
     * Strings.indexOf("apple,banana,cherry", "banana", ",", 0);   // returns 6
     * Strings.indexOf("apple,banana,banana", "banana", ",", 7);   // returns 13 (second occurrence)
     * Strings.indexOf("apple banana cherry", "banana", " ", 0);   // returns 6
     * 
     * // Delimited substring not found
     * Strings.indexOf("applesauce", "apple", ",", 0);             // returns -1 (not delimited)
     * Strings.indexOf("apple,ban,cherry", "banana", ",", 0);      // returns -1 (partial match)
     * Strings.indexOf("test", "test", ",", 5);                    // returns -1 (fromIndex beyond match)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found.
     * @param delimiter the delimiter to separate the search.
     * @param fromIndex the index to start the search from.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur.
     * @see #indexOf(String, String, String)
     */
    public static int indexOf(final String str, final String valueToFind, final String delimiter, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (isEmpty(delimiter)) {
            return indexOf(str, valueToFind, fromIndex);
        }

        if (str == null || valueToFind == null) {
            return N.INDEX_NOT_FOUND;
        }

        final int len = str.length();
        final int targetLen = fromIndex > 0 ? len - fromIndex : len;
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (targetLen < substrLen || (targetLen > substrLen && targetLen - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        final int index = str.indexOf(valueToFind, fromIndex);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        if ((index == fromIndex || (index - fromIndex >= delimiterLen && delimiter.equals(str.substring(index - delimiterLen, index))))
                && (index + substrLen == len
                        || (len >= index + substrLen + delimiterLen && delimiter.equals(str.substring(index + substrLen, index + substrLen + delimiterLen))))) {
            return index;
        }

        int idx = str.indexOf(delimiter + valueToFind + delimiter, index);

        if (idx >= 0) {
            return idx + delimiterLen;
        } else {
            idx = str.indexOf(delimiter + valueToFind, index);

            if (idx >= 0 && idx + delimiterLen + substrLen == len) {
                return idx + delimiterLen;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object,
     * then the index of the first such occurrence is returned. The search is case-insensitive, meaning that uppercase and lowercase
     * characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indexOfIgnoreCase("Hello World", "WORLD");   // returns 6
     * Strings.indexOfIgnoreCase("Hello World", "world");   // returns 6
     * Strings.indexOfIgnoreCase("Hello World", "xyz");     // returns -1
     * Strings.indexOfIgnoreCase(null, "test");             // returns -1
     * Strings.indexOfIgnoreCase("test", null);             // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind) {
        return indexOfIgnoreCase(str, valueToFind, 0);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * starting the search at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object
     * at or after the specified {@code fromIndex}, then the index of the first such occurrence is returned. The search is case-insensitive,
     * meaning that uppercase and lowercase characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null}.
     * If {@code fromIndex} is negative, it is treated as 0. If {@code fromIndex} is greater than the string length, -1 is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indexOfIgnoreCase("Hello World Hello", "hello", 0);   // returns 0
     * Strings.indexOfIgnoreCase("Hello World Hello", "hello", 7);   // returns 13
     * Strings.indexOfIgnoreCase("Hello World", "WORLD", 10);        // returns -1
     * Strings.indexOfIgnoreCase("test", "TEST", -5);                // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param fromIndex the index to start the search from. Negative values are treated as 0.
     * @return the index of the first occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either string parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (str == null || valueToFind == null || valueToFind.length() > str.length() - fromIndex) {
            return N.INDEX_NOT_FOUND;
        }

        // performance optimization
        if (valueToFind.length() <= 3 && valueToFind.toUpperCase().equals(valueToFind.toLowerCase())) {
            return str.indexOf(valueToFind, fromIndex);
        }

        for (int i = fromIndex, len = str.length(), substrLen = valueToFind.length(), end = len - substrLen + 1; i < end; i++) {
            if (str.regionMatches(true, i, valueToFind, 0, substrLen)) {
                return i;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * where the substring is bounded by the specified delimiter.
     *
     * <p>This method searches for the substring within the input string, but only considers it a match if it is preceded and/or followed
     * by the specified delimiter (or at the beginning/end of the string). The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries, or if any parameter is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indexOfIgnoreCase("apple,APPLE,banana", "apple", ",");   // returns 0
     * Strings.indexOfIgnoreCase("apple,APPLE,banana", "APPLE", ",");   // returns 0
     * Strings.indexOfIgnoreCase("pineapple,apple", "apple", ",");      // returns 10
     * Strings.indexOfIgnoreCase("test", "test", ",");                  // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to be used for the search, may be {@code null} or empty.
     * @return the index of the first occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if any parameter is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, final String delimiter) {
        return indexOfIgnoreCase(str, valueToFind, delimiter, 0);
    }

    /**
     * Returns the index within the input string of the first occurrence of the specified substring, ignoring case considerations,
     * where the substring is bounded by the specified delimiter, starting the search at the specified index.
     *
     * <p>This method searches for the substring within the input string starting from {@code fromIndex}, but only considers it a match
     * if it is preceded and/or followed by the specified delimiter (or at the beginning/end of the string). The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries, or if the input string or
     * substring to find is {@code null}. If the delimiter is empty or {@code null}, the method behaves the same as
     * {@link #indexOfIgnoreCase(String, String, int)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indexOfIgnoreCase("apple,APPLE,banana", "apple", ",", 0);   // returns 0
     * Strings.indexOfIgnoreCase("apple,APPLE,banana", "apple", ",", 7);   // returns 6
     * Strings.indexOfIgnoreCase("pineapple,apple", "apple", ",", 0);      // returns 10
     * Strings.indexOfIgnoreCase("test value test", "test", " ", 5);       // returns 11
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to be used for the search, may be {@code null} or empty.
     * @param fromIndex the index to start the search from. Negative values are treated as 0.
     * @return the index of the first occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if the input string or substring to find is {@code null}.
     */
    public static int indexOfIgnoreCase(final String str, final String valueToFind, final String delimiter, int fromIndex) {
        fromIndex = Math.max(0, fromIndex);

        if (isEmpty(delimiter)) {
            return indexOfIgnoreCase(str, valueToFind, fromIndex);
        }

        if (str == null || valueToFind == null) {
            return N.INDEX_NOT_FOUND;
        }

        final int len = str.length();
        final int targetLen = fromIndex > 0 ? len - fromIndex : len;
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (targetLen < substrLen || (targetLen > substrLen && targetLen - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        final int index = indexOfIgnoreCase(str, valueToFind, fromIndex);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        if ((index == fromIndex || (index - fromIndex >= delimiterLen && delimiter.equalsIgnoreCase(str.substring(index - delimiterLen, index))))
                && (index + substrLen == len || (len >= index + substrLen + delimiterLen
                        && delimiter.equalsIgnoreCase(str.substring(index + substrLen, index + substrLen + delimiterLen))))) {
            return index;
        }

        int idx = indexOfIgnoreCase(str, delimiter + valueToFind + delimiter, index);

        if (idx >= 0) {
            return idx + delimiterLen;
        } else {
            idx = indexOfIgnoreCase(str, delimiter + valueToFind, index);

            if (idx >= 0 && idx + delimiterLen + substrLen == len) {
                return idx + delimiterLen;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within this string of the last occurrence of the specified character.
     *
     * <p>If a character with value {@code charValueToFind} occurs in the character sequence represented by
     * this {@code String} object, then the index of the last such occurrence is returned. The search proceeds
     * from the end of the string towards the beginning.</p>
     *
     * <p>The method returns -1 if the character is not found, or if the input string is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("Hello World", 'o');   // returns 7
     * Strings.lastIndexOf("Hello World", 'x');   // returns -1
     * Strings.lastIndexOf("", 'a');              // returns -1
     * Strings.lastIndexOf(null, 'a');            // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param charValueToFind the character to be found.
     * @return the index of the last occurrence of the character in the character sequence represented by this object,
     *         or -1 if the character does not occur or if the string is {@code null} or empty.
     */
    public static int lastIndexOf(final String str, final int charValueToFind) {
        if (str == null || str.isEmpty()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.lastIndexOf(charValueToFind);
    }

    /**
     * Returns the index within this string of the last occurrence of the specified character,
     * searching backward starting at the specified index.
     *
     * <p>For values of {@code charValueToFind} in the range from 0 to 0xFFFF (inclusive),
     * the index returned is the largest value <i>k</i> such that:
     * {@code (this.charAt(k) == charValueToFind) && (k <= startIndexFromBack)} is {@code true}.
     * For other values of {@code charValueToFind}, it is the largest value <i>k</i> such that:
     * {@code (this.codePointAt(k) == charValueToFind) && (k <= startIndexFromBack)} is {@code true}.</p>
     *
     * <p>If no such character occurs in this string at or before position {@code startIndexFromBack},
     * then -1 is returned. All indices are specified in {@code char} values (Unicode code units).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("Hello World", 'o', 10);   // returns 7
     * Strings.lastIndexOf("Hello World", 'o', 5);    // returns 4
     * Strings.lastIndexOf("Hello World", 'o', 3);    // returns -1
     * Strings.lastIndexOf("Hello", 'l', -1);         // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param charValueToFind a character (Unicode code point).
     * @param startIndexFromBack the index to start the search from. There is no restriction on
     *            the value of {@code startIndexFromBack}. If it is greater than or
     *            equal to the length of this string, it has the same effect as
     *            if it were equal to one less than the length of this string:
     *            this entire string may be searched. If it is negative, -1 is returned.
     * @return the index of the last occurrence of the character in the
     *         character sequence represented by this object that is less than
     *         or equal to {@code startIndexFromBack}, or {@code -1} if the
     *         character does not occur before that point.
     */
    public static int lastIndexOf(final String str, final int charValueToFind, int startIndexFromBack) {
        if (str == null || str.isEmpty() || startIndexFromBack < 0) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        return str.lastIndexOf(charValueToFind, startIndexFromBack);
    }

    /**
     * Returns the index within this string of the last occurrence of the specified substring.
     *
     * <p>The returned index is the index of the beginning of the last occurrence of the substring.
     * If the substring does not occur, -1 is returned. The search proceeds from the end of the string
     * towards the beginning.</p>
     *
     * <p>The method returns -1 if either the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("Hello World Hello", "Hello");   // returns 13
     * Strings.lastIndexOf("Hello World", "World");         // returns 6
     * Strings.lastIndexOf("Hello World", "xyz");           // returns -1
     * Strings.lastIndexOf(null, "test");                   // returns -1
     * Strings.lastIndexOf("test", null);                   // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @return the index of the last occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return str.lastIndexOf(valueToFind);
    }

    /**
     * Returns the index within {@code str} of the last occurrence of the specified {@code valueToFind},
     * searching backward starting at the specified index.
     *
     * <p>The returned index is the largest value <i>k</i> for which:
     * {@code k <= startIndexFromBack && str.startsWith(valueToFind, k)} is {@code true}.
     * If no such value of <i>k</i> exists, then {@code -1} is returned.</p>
     *
     * <p>The method returns -1 if either the input string or the substring to find is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("Hello World Hello", "Hello", 15);   // returns 13
     * Strings.lastIndexOf("Hello World Hello", "Hello", 10);   // returns 0
     * Strings.lastIndexOf("Hello World", "World", 5);          // returns -1
     * Strings.lastIndexOf("test", "test", -1);                 // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return the index of the last occurrence of the substring at or before the specified index,
     *         or -1 if the substring does not occur or if any parameter is invalid.
     */
    public static int lastIndexOf(final String str, final String valueToFind, int startIndexFromBack) {
        if (str == null || valueToFind == null || startIndexFromBack < 0 || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        return str.lastIndexOf(valueToFind, startIndexFromBack);
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * where the substring is bounded by the specified delimiter.
     *
     * <p>This method searches for the substring within the input string from the end, but only considers it a match
     * if it is preceded and/or followed by the specified delimiter (or at the beginning/end of the string).</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if any parameter is {@code null}. If the delimiter is empty or {@code null}, the method behaves
     * the same as {@link #lastIndexOf(String, String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("apple,banana,apple", "apple", ",");   // returns 13
     * Strings.lastIndexOf("pineapple,apple", "apple", ",");      // returns 10
     * Strings.lastIndexOf("apple test", "apple", " ");           // returns 0
     * Strings.lastIndexOf("test", "test", ",");                  // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to separate the search, may be {@code null} or empty.
     * @return the index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if any parameter is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind, final String delimiter) {
        return lastIndexOf(str, valueToFind, delimiter, str.length());
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * where the substring is bounded by the specified delimiter, starting the search at the specified index.
     *
     * <p>This method searches for the substring within the input string from {@code startIndexFromBack} backwards,
     * but only considers it a match if it is preceded and/or followed by the specified delimiter
     * (or at the beginning/end of the string).</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if the input string or substring to find is {@code null}. If the delimiter is empty or {@code null},
     * the method behaves the same as {@link #lastIndexOf(String, String, int)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOf("apple,banana,apple", "apple", ",", 20);   // returns 13
     * Strings.lastIndexOf("apple,banana,apple", "apple", ",", 10);   // returns 0
     * Strings.lastIndexOf("pineapple,apple", "apple", ",", 20);      // returns 10
     * Strings.lastIndexOf("test value test", "test", " ", 10);       // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to separate the search, may be {@code null} or empty.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return the index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if the input string or substring to find is {@code null}.
     */
    public static int lastIndexOf(final String str, final String valueToFind, final String delimiter, int startIndexFromBack) {
        if (isEmpty(delimiter)) {
            return lastIndexOf(str, valueToFind, startIndexFromBack);
        } else if (str == null || valueToFind == null || startIndexFromBack < 0) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (len < substrLen || (len > substrLen && len - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        int index = str.lastIndexOf(delimiter + valueToFind, startIndexFromBack);

        if (index >= 0 && index + delimiter.length() + valueToFind.length() == len) {
            return index + delimiter.length();
        }

        index = str.lastIndexOf(delimiter + valueToFind + delimiter, startIndexFromBack);

        if (index >= 0) {
            return index + delimiter.length();
        }

        index = str.lastIndexOf(valueToFind, startIndexFromBack);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        //noinspection DuplicateExpressions
        if (index == 0 && (index + valueToFind.length() == len || (len >= index + valueToFind.length() + delimiter.length()
                && delimiter.equals(str.substring(index + valueToFind.length(), index + valueToFind.length() + delimiter.length()))))) {
            return index;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring, ignoring case considerations.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object,
     * then the index of the last such occurrence is returned. The search is case-insensitive, meaning that uppercase and lowercase
     * characters are treated as equivalent during the search.</p>
     *
     * <p>The method returns -1 if the substring is not found, or if either the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfIgnoreCase("Hello World HELLO", "hello");   // returns 13
     * Strings.lastIndexOfIgnoreCase("Hello World", "WORLD");         // returns 6
     * Strings.lastIndexOfIgnoreCase("Hello World", "xyz");           // returns -1
     * Strings.lastIndexOfIgnoreCase(null, "test");                   // returns -1
     * Strings.lastIndexOfIgnoreCase("test", null);                   // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @return the index of the last occurrence of the substring in the character sequence represented by this object,
     *         or -1 if the substring does not occur or if either parameter is {@code null}.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        return lastIndexOfIgnoreCase(str, valueToFind, str.length());
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring, ignoring case considerations,
     * searching backward starting at the specified index.
     *
     * <p>If a substring with value {@code valueToFind} occurs in the character sequence represented by the input {@code String} object
     * at or before the specified {@code startIndexFromBack}, then the index of the last such occurrence is returned.
     * The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found at or before the specified index, or if either the input string
     * or the substring to find is {@code null}, if {@code startIndexFromBack} is negative, or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfIgnoreCase("Hello World HELLO", "hello", 15);   // returns 13
     * Strings.lastIndexOfIgnoreCase("Hello World HELLO", "hello", 10);   // returns 0
     * Strings.lastIndexOfIgnoreCase("Hello World", "WORLD", 5);          // returns -1
     * Strings.lastIndexOfIgnoreCase("test", "TEST", -1);                 // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return the index of the last occurrence of the substring at or before the specified index,
     *         or -1 if the substring does not occur or if any parameter is invalid.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind, int startIndexFromBack) {
        if (str == null || valueToFind == null || startIndexFromBack < 0 || valueToFind.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        for (int i = N.min(startIndexFromBack, str.length() - valueToFind.length()), substrLen = valueToFind.length(); i >= 0; i--) {
            if (str.regionMatches(true, i, valueToFind, 0, substrLen)) {
                return i;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * ignoring case considerations, where the substring is bounded by the specified delimiter.
     *
     * <p>This method searches for the substring within the input string from the end, but only considers it a match
     * if it is preceded and/or followed by the specified delimiter (or at the beginning/end of the string).
     * The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if any parameter is {@code null}. If the delimiter is empty or {@code null}, the method behaves
     * the same as {@link #lastIndexOfIgnoreCase(String, String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfIgnoreCase("apple,BANANA,apple", "apple", ",");   // returns 13
     * Strings.lastIndexOfIgnoreCase("pineapple,APPLE", "apple", ",");      // returns 10
     * Strings.lastIndexOfIgnoreCase("APPLE test", "apple", " ");           // returns 0
     * Strings.lastIndexOfIgnoreCase("test", "test", ",");                  // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to separate the search, may be {@code null} or empty.
     * @return the index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if any parameter is {@code null}.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind, final String delimiter) {
        return lastIndexOfIgnoreCase(str, valueToFind, delimiter, str.length());
    }

    /**
     * Returns the index within the input string of the last occurrence of the specified substring,
     * ignoring case considerations, where the substring is bounded by the specified delimiter,
     * starting the search at the specified index.
     *
     * <p>This method searches for the substring within the input string from {@code startIndexFromBack} backwards,
     * but only considers it a match if it is preceded and/or followed by the specified delimiter
     * (or at the beginning/end of the string). The search is case-insensitive.</p>
     *
     * <p>The method returns -1 if the substring is not found with the required delimiter boundaries,
     * or if the input string or substring to find is {@code null}. If the delimiter is empty or {@code null},
     * the method behaves the same as {@link #lastIndexOfIgnoreCase(String, String, int)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfIgnoreCase("apple,BANANA,apple", "apple", ",", 20);   // returns 13
     * Strings.lastIndexOfIgnoreCase("apple,BANANA,apple", "apple", ",", 10);   // returns 0
     * Strings.lastIndexOfIgnoreCase("pineapple,APPLE", "apple", ",", 20);      // returns 10
     * Strings.lastIndexOfIgnoreCase("test value TEST", "test", " ", 10);       // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the substring to be found, may be {@code null}.
     * @param delimiter the delimiter to separate the search, may be {@code null} or empty.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @return the index of the last occurrence of the substring bounded by the delimiter in the character sequence represented by this object,
     *         or -1 if the substring does not occur with proper boundaries or if the input string or substring to find is {@code null}.
     */
    public static int lastIndexOfIgnoreCase(final String str, final String valueToFind, final String delimiter, int startIndexFromBack) {
        if (isEmpty(delimiter)) {
            return lastIndexOfIgnoreCase(str, valueToFind, startIndexFromBack);
        } else if (str == null || valueToFind == null || startIndexFromBack < 0) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        final int substrLen = valueToFind.length();
        final int delimiterLen = delimiter.length();

        if (len < substrLen || (len > substrLen && len - substrLen < delimiterLen)) {
            return N.INDEX_NOT_FOUND;
        }

        int index = lastIndexOfIgnoreCase(str, delimiter + valueToFind, startIndexFromBack);

        if (index >= 0 && index + delimiter.length() + valueToFind.length() == len) {
            return index + delimiter.length();
        }

        index = lastIndexOfIgnoreCase(str, delimiter + valueToFind + delimiter, startIndexFromBack);

        if (index >= 0) {
            return index + delimiter.length();
        }

        index = lastIndexOfIgnoreCase(str, valueToFind, startIndexFromBack);

        if (index < 0) {
            return N.INDEX_NOT_FOUND;
        }

        //noinspection DuplicateExpressions
        if (index == 0 && (index + valueToFind.length() == len || (len >= index + valueToFind.length() + delimiter.length()
                && delimiter.equals(str.substring(index + valueToFind.length(), index + valueToFind.length() + delimiter.length()))))) {
            return index;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of any specified character.
     *
     * <p>This method searches the string from the end and returns the index of the first character found
     * that matches any character in the {@code valuesToFind} array. Note that the returned index may not be
     * the largest or smallest last index among all matching characters - it returns the index of the first match found
     * during the backward search.</p>
     *
     * <p>The method returns -1 if none of the characters are found, or if the input string is {@code null} or empty,
     * or if the character array is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfAny("Hello World", 'o', 'l');        // returns 9 or 7 (implementation dependent)
     * Strings.lastIndexOfAny("Hello World", 'x', 'y', 'z');   // returns -1
     * Strings.lastIndexOfAny("", 'a', 'b');                   // returns -1
     * Strings.lastIndexOfAny(null, 'a');                      // returns -1
     * 
     * Strings.lastIndexOfAny("abc", '\uDC00', 'a');           // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.lastIndexOfAny("abc", '\uDFFF', 'a');           // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of characters to be found, may be {@code null} or empty.
     * @return the index of the last occurrence of any character in the character sequence represented by this object,
     *         or -1 if none of the characters occur or if the string or character array is {@code null} or empty.
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit.
     * @see #smallestLastIndexOfAll(String, String[])
     * @see #smallestLastIndexOfAll(String, int, String[])
     * @see #largestLastIndexOfAll(String, String[])
     * @see #largestLastIndexOfAll(String, int, String[])
     */
    public static int lastIndexOfAny(final String str, final char... valuesToFind) throws IllegalArgumentException {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        return lastIndexOfAny(str, str.length(), valuesToFind);
    }

    /**
     * Returns the index within the input string of the last occurrence of any specified character,
     * searching backward starting at the specified index.
     *
     * <p>This method searches for any of the characters in the {@code valuesToFind} array within the input string,
     * starting from {@code startIndexFromBack} and moving backwards. The returned index corresponds to the position
     * of the first matching character found during this backward search. Note that the returned index may not be
     * the largest or smallest last index among all matching characters - it returns the index of the first match found
     * during the backward search.</p>
     *
     * <p>The method returns -1 if none of the characters are found at or before the specified index,
     * or if the input string is {@code null} or empty, or if the character array is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfAny("Hello World", 'o', 'l', 8);         // returns 7 or 3 (implementation dependent)
     * Strings.lastIndexOfAny("Hello World", 'o', 'l', 5);         // returns 4 or 3 (implementation dependent)
     * Strings.lastIndexOfAny("Hello World", 'x', 'y', 'z', 10);   // returns -1
     * Strings.lastIndexOfAny("", 'a', 'b', 0);                    // returns -1
     * Strings.lastIndexOfAny(null, 'a', 0);                       // returns -1
     * 
     * Strings.lastIndexOfAny("abc", 0, '\uDC00', 'a');            // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.lastIndexOfAny("abc", 0, '\uDFFF', 'a');            // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind the array of characters to be found, may be {@code null} or empty.
     * @return the index of the last occurrence of any character in the character sequence represented by this object
     *         that is less than or equal to {@code startIndexFromBack},
     *         or -1 if none of the characters occur before that point or if the string or character array is {@code null} or empty.
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit.
     */
    public static int lastIndexOfAny(final String str, int startIndexFromBack, final char... valuesToFind) throws IllegalArgumentException {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        if (valuesToFind.length < 3 || (str.length() < 9 && valuesToFind.length < 9)) {
            int idx = 0;

            for (final char ch : valuesToFind) {
                idx = str.lastIndexOf(ch, startIndexFromBack);

                if (idx != N.INDEX_NOT_FOUND) {
                    return idx;
                }
            }
        } else {
            char ch = 0;

            for (int i = startIndexFromBack; i >= 0; i--) {
                ch = str.charAt(i);

                for (final char c : valuesToFind) {
                    if (c == ch) {
                        return i;
                    }
                }
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Returns the index within the input string of the last occurrence of any specified substring.
     *
     * <p>This method searches for any of the substrings in the {@code valuesToFind} array within the input string.
     * The returned index corresponds to the beginning of the matched substring. Note that the returned index may not be
     * the largest last index among all matching substrings - it returns the index of the first match found during the search.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfAny("Hello World", "World", "Hello");   // returns 6 or 0 (implementation dependent)
     * Strings.lastIndexOfAny("Hello World", "xyz", "abc");       // returns -1
     * Strings.lastIndexOfAny("test", null, "test");              // returns 0
     * Strings.lastIndexOfAny(null, "test");                      // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the index of the last occurrence of any substring in the character sequence represented by this object,
     *         or -1 if none of the substrings occur or if the string or substring array is {@code null} or empty.
     * @see #smallestLastIndexOfAll(String, String[])
     * @see #smallestLastIndexOfAll(String, int, String[])
     * @see #largestLastIndexOfAll(String, String[])
     * @see #largestLastIndexOfAll(String, int, String[])
     */
    public static int lastIndexOfAny(final String str, final String... valuesToFind) {
        if (str == null || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        return lastIndexOfAny(str, str.length(), valuesToFind);
    }

    /**
     * Returns the index within the input string of the last occurrence of any specified substring,
     * searching backward starting at the specified index.
     *
     * <p>This method searches for any of the substrings in the {@code valuesToFind} array within the input string,
     * starting from {@code startIndexFromBack} and moving backwards. The returned index corresponds to the beginning
     * of the matched substring found during this backward search. Note that the returned index may not be
     * the largest last index among all matching substrings - it returns the index of the first match found
     * during the backward search.</p>
     *
     * <p>The method returns -1 if none of the substrings are found at or before the specified index,
     * or if the input string is {@code null}, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastIndexOfAny("Hello World", "World", "Hello", 10);   // returns 6 or 0 (implementation dependent)
     * Strings.lastIndexOfAny("Hello World", "World", "Hello", 5);    // returns 0
     * Strings.lastIndexOfAny("Hello World", "xyz", "abc", 10);       // returns -1
     * Strings.lastIndexOfAny(null, "test");                          // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the index of the last occurrence of any substring in the character sequence represented by this object
     *         that is less than or equal to {@code startIndexFromBack},
     *         or -1 if none of the substrings occur before that point or if the string or substring array is {@code null} or empty.
     */
    public static int lastIndexOfAny(final String str, int startIndexFromBack, final String... valuesToFind) {
        if (str == null || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        int idx = 0;

        for (final String element : valuesToFind) {
            if (isEmpty(element)) {
                continue;
            }

            idx = lastIndexOf(str, element, startIndexFromBack);

            if (idx != N.INDEX_NOT_FOUND) {
                return idx;
            }
        }

        return N.INDEX_NOT_FOUND;
    }

    // Shared code between ordinalIndexOf(String,String,int) and

    // lastOrdinalIndexOf(String,String,int)
    private static int ordinalIndexOf(final String str, final String substr, final int ordinal, final boolean isLastIndex) {
        if (ordinal < 1) {
            throw new IllegalArgumentException("ordinal(" + ordinal + ") must be >= 1");
        }

        if (str == null || substr == null || substr.length() > str.length()) {
            return N.INDEX_NOT_FOUND;
        }

        int fromIndex = isLastIndex ? str.length() : 0;

        for (int found = 0; fromIndex >= 0;) {
            fromIndex = isLastIndex ? str.lastIndexOf(substr, fromIndex) : str.indexOf(substr, fromIndex);

            if (fromIndex < 0) {
                return N.INDEX_NOT_FOUND;
            }

            if (++found >= ordinal) {
                return fromIndex;
            }

            fromIndex = isLastIndex ? (fromIndex - substr.length()) : (fromIndex + substr.length());
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Finds the smallest index of all specified substrings within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string,
     * and returns the smallest (leftmost) index among all found substrings. Each substring in the array
     * is searched at most once from the beginning of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.smallestIndexOfAll("Hello World", "World", "o");       // returns 4
     * Strings.smallestIndexOfAll("Hello World", "xyz", "abc");       // returns -1
     * Strings.smallestIndexOfAll("test string", "string", "test");   // returns 0
     * Strings.smallestIndexOfAll(null, "test");                      // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the smallest index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int smallestIndexOfAll(final String str, final String... valuesToFind) {
        return smallestIndexOfAll(str, 0, valuesToFind);
    }

    /**
     * Finds the smallest index of all substrings in {@code valuesToFind} within the input string from {@code fromIndex}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * starting from the specified {@code fromIndex}, and returns the smallest (leftmost) index among all found substrings.
     * Each substring in the array is searched at most once from the specified {@code fromIndex}.</p>
     *
     * <p>The method returns -1 if none of the substrings are found from the specified index, or if the input string is {@code null},
     * if {@code fromIndex} is greater than the string length, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored. If {@code fromIndex} is negative, it is treated as 0.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.smallestIndexOfAll("Hello World", 0, "World", "o");   // returns 4
     * Strings.smallestIndexOfAll("Hello World", 5, "World", "o");   // returns 6
     * Strings.smallestIndexOfAll("Hello World", 8, "World", "o");   // returns -1
     * Strings.smallestIndexOfAll("test", -5, "test");               // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param fromIndex the index to start the search from. Negative values are treated as 0.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the smallest index of all substrings within the input string from {@code fromIndex} or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int smallestIndexOfAll(final String str, int fromIndex, final String... valuesToFind) {
        if (str == null || fromIndex > str.length() || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        fromIndex = Math.max(0, fromIndex);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || (substr.length() > len - fromIndex)) {
                continue;
            }

            final int tmp = indexOf(str, substr, fromIndex);

            result = tmp >= 0 && (result == N.INDEX_NOT_FOUND || tmp < result) ? tmp : result;

            if (result == fromIndex) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the largest index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string,
     * and returns the largest (rightmost) index among all found substrings. Each substring in the array
     * is searched at most once from the beginning of the string. The search is optimized by prioritizing
     * longer substrings when they might affect the result.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.largestIndexOfAll("Hello World", "o", "World");   // returns 6
     * Strings.largestIndexOfAll("Hello World", "H", "d");       // returns 10
     * Strings.largestIndexOfAll("Hello World", "xyz", "abc");   // returns -1
     * Strings.largestIndexOfAll(null, "test");                  // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the largest index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int largestIndexOfAll(final String str, final String... valuesToFind) {
        return largestIndexOfAll(str, 0, valuesToFind);
    }

    /**
     * Finds the largest index of all substrings in {@code valuesToFind} within the input string from {@code fromIndex}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * starting from the specified {@code fromIndex}, and returns the largest (rightmost) index among all found substrings.
     * Each substring in the array is searched at most once from the specified {@code fromIndex}.
     * The search is optimized by prioritizing longer substrings when they might affect the result.</p>
     *
     * <p>The method returns -1 if none of the substrings are found from the specified index, or if the input string is {@code null},
     * if {@code fromIndex} is greater than the string length, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored. If {@code fromIndex} is negative, it is treated as 0.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.largestIndexOfAll("Hello World", 0, "o", "World");   // returns 6
     * Strings.largestIndexOfAll("Hello World", 5, "o", "H");       // returns 7
     * Strings.largestIndexOfAll("Hello World", 8, "o", "World");   // returns -1
     * Strings.largestIndexOfAll("test", -5, "test", "t");          // returns 3
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param fromIndex the index to start the search from. Negative values are treated as 0.
     * @param valuesToFind the array of substrings to be found, may be {@code null} or empty.
     * @return the largest index of all substrings within the input string from {@code fromIndex} or -1 if none of the substrings occur.
     * @see #indexOfAny(String, String[])
     * @see #indexOfAny(String, int, String[])
     */
    public static int largestIndexOfAll(final String str, final int fromIndex, final String... valuesToFind) {
        if (str == null || fromIndex > str.length() || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        final int fromIndexToUse = Math.max(0, fromIndex);

        final int len = str.length();
        final List<String> subStringsSortedByLen = Stream.of(valuesToFind) //
                .filter(it -> !(it == null || (fromIndexToUse + it.length() > len)))
                .sortedByInt(N::len)
                .toList();

        int result = N.INDEX_NOT_FOUND;

        for (final String substr : subStringsSortedByLen) {
            if (result >= 0 && substr.length() >= len - result) {
                continue;
            }

            result = N.max(result, indexOf(str, substr, fromIndex));

            if (result == len - substr.length()) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the smallest last index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from the end, and returns the smallest (leftmost) last index among all found substrings.
     * Each substring in the array is searched at most once from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.smallestLastIndexOfAll("Hello World", "o", "World");   // returns 6
     * Strings.smallestLastIndexOfAll("Hello Hello", "Hello", "o");   // returns 7
     * Strings.smallestLastIndexOfAll("test", "xyz", "abc");          // returns -1
     * Strings.smallestLastIndexOfAll(null, "test");                  // returns -1
     * }</pre>
     *
     * @param str the string to search within, may be {@code null}.
     * @param valuesToFind the substrings to find within the string, may be empty or {@code null}.
     * @return the smallest last index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int smallestLastIndexOfAll(final String str, final String... valuesToFind) {
        return smallestLastIndexOfAll(str, N.len(str), valuesToFind);
    }

    /**
     * Finds the smallest last index of all substrings in {@code valuesToFind} within the input string from {@code startIndexFromBack}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from {@code startIndexFromBack} backwards, and returns the smallest (leftmost) last index among all found substrings.
     * Each substring in the array is searched at most once from {@code startIndexFromBack} from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found at or before the specified index, or if the input string is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.smallestLastIndexOfAll("Hello World", 10, "o", "World");   // returns 6
     * Strings.smallestLastIndexOfAll("Hello World", 5, "o", "World");    // returns 4
     * Strings.smallestLastIndexOfAll("Hello World", 3, "o", "World");    // returns -1
     * Strings.smallestLastIndexOfAll("test", -1, "test");                // returns -1
     * }</pre>
     *
     * @param str the string to search within, may be {@code null}.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind the substrings to find within the string, may be empty or {@code null}.
     * @return the smallest index of all substrings within the input string from {@code startIndexFromBack} or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int smallestLastIndexOfAll(final String str, int startIndexFromBack, final String... valuesToFind) {
        if (str == null || startIndexFromBack < 0 || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || substr.length() > len) {
                continue;
            }

            final int tmp = lastIndexOf(str, substr, startIndexFromBack);

            result = tmp >= 0 && (result == N.INDEX_NOT_FOUND || tmp < result) ? tmp : result;

            if (result == 0) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the largest last index of all substrings in {@code valuesToFind} within the input string.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from the end, and returns the largest (rightmost) last index among all found substrings.
     * Each substring in the array is searched at most once from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found, or if the input string is {@code null},
     * or if the substring array is {@code null} or empty. {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.largestLastIndexOfAll("Hello World", "o", "World");   // returns 7
     * Strings.largestLastIndexOfAll("Hello Hello", "Hello", "e");   // returns 8
     * Strings.largestLastIndexOfAll("test", "xyz", "abc");          // returns -1
     * Strings.largestLastIndexOfAll(null, "test");                  // returns -1
     * }</pre>
     *
     * @param str the string to search within, may be {@code null}.
     * @param valuesToFind the substrings to find within the string, may be empty or {@code null}.
     * @return the largest last index of all substrings within the input string or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int largestLastIndexOfAll(final String str, final String... valuesToFind) {
        return largestLastIndexOfAll(str, N.len(str), valuesToFind);
    }

    /**
     * Finds the largest last index of all substrings in {@code valuesToFind} within the input string from {@code startIndexFromBack}.
     *
     * <p>This method searches for all substrings in the {@code valuesToFind} array within the input string
     * from {@code startIndexFromBack} backwards, and returns the largest (rightmost) last index among all found substrings.
     * Each substring in the array is searched at most once from {@code startIndexFromBack} from the back of the string.</p>
     *
     * <p>The method returns -1 if none of the substrings are found at or before the specified index, or if the input string is {@code null},
     * if {@code startIndexFromBack} is negative, or if the substring array is {@code null} or empty.
     * {@code null} elements in the array are ignored.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.largestLastIndexOfAll("Hello World", 10, "o", "World");   // returns 7
     * Strings.largestLastIndexOfAll("Hello World", 6, "o", "World");    // returns 6
     * Strings.largestLastIndexOfAll("Hello World", 3, "o", "H");        // returns 0
     * Strings.largestLastIndexOfAll("test", -1, "test");                // returns -1
     * }</pre>
     *
     * @param str the string to search within, may be {@code null}.
     * @param startIndexFromBack the index to start the search from, searching backward.
     *                          If greater than or equal to the string length, the entire string is searched.
     * @param valuesToFind the substrings to find within the string, may be empty or {@code null}.
     * @return the largest index of all substrings within the input string from {@code startIndexFromBack} or -1 if none of the substrings occur.
     * @see #lastIndexOfAny(String, String[])
     * @see #lastIndexOfAny(String, char[])
     */
    public static int largestLastIndexOfAll(final String str, int startIndexFromBack, final String... valuesToFind) {
        if (str == null || startIndexFromBack < 0 || N.isEmpty(valuesToFind)) {
            return N.INDEX_NOT_FOUND;
        }

        startIndexFromBack = Math.min(startIndexFromBack, str.length() - 1);

        final int len = str.length();
        int result = N.INDEX_NOT_FOUND;

        for (final String substr : valuesToFind) {
            if (substr == null || substr.length() > len) {
                continue;
            }

            result = N.max(result, str.lastIndexOf(substr, startIndexFromBack));

            if (result == startIndexFromBack) {
                break;
            }
        }

        return result;
    }

    /**
     * Finds the n-th occurrence of the specified value within the input string.
     *
     * <p>This method searches for the {@code ordinal}-th occurrence of {@code valueToFind} within the input string,
     * searching from the beginning of the string. The ordinal parameter must be greater than or equal to 1.</p>
     *
     * <p>The method returns -1 if the value does not occur as many times as requested, or if either the input string
     * or the value to find is {@code null}, or if the value is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.ordinalIndexOf("aabaabaa", "a", 1);    // returns 0
     * Strings.ordinalIndexOf("aabaabaa", "a", 3);    // returns 3
     * Strings.ordinalIndexOf("aabaabaa", "b", 2);    // returns 5
     * Strings.ordinalIndexOf("aabaabaa", "ab", 2);   // returns 4
     * Strings.ordinalIndexOf("aabaabaa", "c", 1);    // returns -1
     * Strings.ordinalIndexOf("", "", 1);             // returns 0
     * Strings.ordinalIndexOf("", null, 1);           // returns -1
     * Strings.ordinalIndexOf(null, "", 1);           // returns -1
     * Strings.ordinalIndexOf(null, null, 1);         // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the value to be found, may be {@code null}.
     * @param ordinal the n-th occurrence to find. Must be greater than or equal to 1.
     * @return the index of the n-th occurrence of the specified value within the input string,
     *         or -1 if the value does not occur as many times as requested.
     * @throws IllegalArgumentException if ordinal is less than 1
     */
    public static int ordinalIndexOf(final String str, final String valueToFind, final int ordinal) {
        return ordinalIndexOf(str, valueToFind, ordinal, false);
    }

    /**
     * Finds the n-th last occurrence of the specified value within the input string.
     *
     * <p>This method searches for the {@code ordinal}-th occurrence of {@code valueToFind} within the input string,
     * searching from the end of the string backwards. The ordinal parameter must be greater than or equal to 1.</p>
     *
     * <p>The method returns -1 if the value does not occur as many times as requested, or if either the input string
     * or the value to find is {@code null}, or if the value is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastOrdinalIndexOf("aabaabaa", "a", 1);    // returns 7
     * Strings.lastOrdinalIndexOf("aabaabaa", "a", 3);    // returns 4
     * Strings.lastOrdinalIndexOf("aabaabaa", "b", 2);    // returns 2
     * Strings.lastOrdinalIndexOf("aabaabaa", "ab", 2);   // returns 1
     * Strings.lastOrdinalIndexOf("aabaabaa", "c", 1);    // returns -1
     * Strings.lastOrdinalIndexOf("", "", 1);             // returns 0
     * Strings.lastOrdinalIndexOf("", null, 1);           // returns -1
     * Strings.lastOrdinalIndexOf(null, "", 1);           // returns -1
     * Strings.lastOrdinalIndexOf(null, null, 1);         // returns -1
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty.
     * @param valueToFind the value to be found, may be {@code null}.
     * @param ordinal the n-th last occurrence to find. Must be greater than or equal to 1.
     * @return the index of the n-th last occurrence of the specified value within the input string,
     *         or -1 if the value does not occur as many times as requested.
     * @throws IllegalArgumentException if ordinal is less than 1
     */
    public static int lastOrdinalIndexOf(final String str, final String valueToFind, final int ordinal) {
        return ordinalIndexOf(str, valueToFind, ordinal, true);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string and returns
     * a stream of their indices. The search is case-sensitive. If the substring is empty, it returns
     * indices of all positions in the string (0 through string length).</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indicesOf("abca", "a").join(", ");    // returns "0, 3"
     * Strings.indicesOf("abcA", "a").join(", ");    // returns "0"
     * Strings.indicesOf("abcA", null).join(", ");   // returns ""
     * Strings.indicesOf(null, "").join(", ");       // returns ""
     * Strings.indicesOf("", null).join(", ");       // returns ""
     * Strings.indicesOf("abcA", "").join(", ");     // returns "0, 1, 2, 3"
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOf(final String str, final String valueToFind) {
        return indicesOf(str, valueToFind, 0);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, starting the search at the specified index.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string starting from {@code fromIndex}
     * and returns a stream of their indices. The search is case-sensitive. If the substring is empty, it returns
     * indices of all positions in the string from {@code fromIndex} to string length.</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the remaining part of the input string from {@code fromIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indicesOf("abcabc", "a", 0).join(", ");   // returns "0, 3"
     * Strings.indicesOf("abcabc", "a", 2).join(", ");   // returns "3"
     * Strings.indicesOf("abcabc", "a", 4).join(", ");   // returns ""
     * Strings.indicesOf("abcA", "", 2).join(", ");      // returns "2, 3, 4"
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param fromIndex the index to start the search from
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOf(final String str, final String valueToFind, final int fromIndex) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return IntStream.empty();
        }

        final int increment = Math.max(valueToFind.length(), 1);

        return IntStream.ofIndices(str, fromIndex, increment, (s, from) -> s.indexOf(valueToFind, from));
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, ignoring case considerations.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string and returns
     * a stream of their indices. The search is case-insensitive. If the substring is empty, it returns
     * indices of all positions in the string (0 through string length).</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the input string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indicesOfIgnoreCase("abcA", "a").join(", ");    // returns "0, 3"
     * Strings.indicesOfIgnoreCase("HeLLo", "l").join(", ");   // returns "2, 3"
     * Strings.indicesOfIgnoreCase("test", "X").join(", ");    // returns ""
     * Strings.indicesOfIgnoreCase("abcA", null).join(", ");   // returns ""
     * Strings.indicesOfIgnoreCase(null, "a").join(", ");      // returns ""
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see #indicesOf(String, String)
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOfIgnoreCase(final String str, final String valueToFind) {
        return indicesOfIgnoreCase(str, valueToFind, 0);
    }

    /**
     * Returns a stream of indices of all occurrences of the specified substring, starting the search at the specified index, ignoring case considerations.
     *
     * <p>This method finds all occurrences of {@code valueToFind} within the input string starting from {@code fromIndex}
     * and returns a stream of their indices. The search is case-insensitive. If the substring is empty, it returns
     * indices of all positions in the string from {@code fromIndex} to string length.</p>
     *
     * <p>The method returns an empty stream if the input string or the substring to find is {@code null},
     * or if the substring is longer than the remaining part of the input string from {@code fromIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.indicesOfIgnoreCase("abcAbc", "a", 0).join(", ");   // returns "0, 3"
     * Strings.indicesOfIgnoreCase("abcAbc", "a", 2).join(", ");   // returns "3"
     * Strings.indicesOfIgnoreCase("HeLLo", "L", 1).join(", ");    // returns "2, 3"
     * Strings.indicesOfIgnoreCase("test", "X", 0).join(", ");     // returns ""
     * Strings.indicesOfIgnoreCase("abcA", null, 0).join(", ");    // returns ""
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param fromIndex the index to start the search from
     * @return a stream of indices of all occurrences of the specified substring, or an empty stream if the substring is not found
     * @see #indicesOf(String, String, int)
     * @see RegExUtil#matchIndices(String, String)
     * @see RegExUtil#matchIndices(String, Pattern)
     * @see IntStream#ofIndices(Object, int, int, com.landawn.abacus.util.function.ObjIntFunction)
     */
    public static IntStream indicesOfIgnoreCase(final String str, final String valueToFind, final int fromIndex) {
        if (str == null || valueToFind == null || valueToFind.length() > str.length()) {
            return IntStream.empty();
        }

        final int strLen = str.length();
        final int increment = Math.max(valueToFind.length(), 1);
        final int end = strLen - increment + 1;

        return IntStream.ofIndices(str, fromIndex, increment, (s, from) -> {
            for (int idx = from; idx < end; idx++) {
                if (str.regionMatches(true, idx, valueToFind, 0, increment)) {
                    return idx;
                }
            }

            return N.INDEX_NOT_FOUND;
        });
    }

    /**
     * Counts the number of occurrences of the specified character in the given string.
     *
     * <p>This method counts how many times a specific character appears in the input string.
     * If the input string is {@code null} or empty, the method returns 0.</p>
     *
     * <p>The method performs a simple character-by-character comparison to count occurrences.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Count character occurrences
     * Strings.countMatches("hello world", 'l');   // returns 3
     * Strings.countMatches("programming", 'm');   // returns 2
     * Strings.countMatches("test", 'x');          // returns 0
     * Strings.countMatches("", 'a');              // returns 0
     * Strings.countMatches(null, 'a');            // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param charValueToFind the character to be counted
     * @return the number of occurrences of the specified character in the string, or 0 if the string is {@code null} or empty
     * @see N#occurrencesOf(String, char)
     */
    @SuppressWarnings("deprecation")
    public static int countMatches(final String str, final char charValueToFind) {
        if (isEmpty(str)) {
            return 0;
        }

        int occurrences = 0;

        for (final char e : InternalUtil.getCharsForReadOnly(str)) {
            if (e == charValueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the number of occurrences of the specified substring in the given string.
     *
     * <p>This method counts how many times a specific substring appears in the input string.
     * The search is case-sensitive and does not count overlapping occurrences.
     * If either the input string or the substring to find is {@code null} or empty, the method returns 0.</p>
     *
     * <p>The method performs a sequential search through the string, advancing past each found occurrence.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Count substring occurrences
     * Strings.countMatches("abcabcabc", "abc");    // returns 3
     * Strings.countMatches("hello world", "o");    // returns 2
     * Strings.countMatches("programming", "mm");   // returns 1
     * Strings.countMatches("test", "xyz");         // returns 0
     * Strings.countMatches("aaa", "aa");           // returns 1 (non-overlapping)
     * Strings.countMatches(null, "test");          // returns 0
     * Strings.countMatches("test", null);          // returns 0
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be counted
     * @return the number of occurrences of the specified substring in the string, or 0 if either parameter is {@code null} or empty
     * @see N#occurrencesOf(String, String)
     */
    public static int countMatches(final String str, final String valueToFind) {
        if (isEmpty(str) || isEmpty(valueToFind)) {
            return 0;
        }

        int occurrences = 0;

        for (int len = N.len(str), substrLen = N.len(valueToFind), index = 0, fromIndex = 0, toIndex = len - substrLen; fromIndex <= toIndex;) {
            index = str.indexOf(valueToFind, fromIndex);

            if (index < 0) {
                break;
            } else {
                fromIndex = index + substrLen;
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Checks if the specified character is present in the given string.
     *
     * <p>This method determines whether a specific character appears at least once in the input string.
     * If the input string is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method uses the indexOf method internally for efficient searching.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check character presence
     * Strings.contains("hello", 'e');   // returns true
     * Strings.contains("world", 'x');   // returns false
     * Strings.contains("", 'a');        // returns false
     * Strings.contains(null, 'a');      // returns false
     * Strings.contains("test", 't');    // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param charValueToFind the character to be found
     * @return {@code true} if the character is found in the string, {@code false} otherwise
     */
    public static boolean contains(final String str, final char charValueToFind) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        return indexOf(str, charValueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string.
     *
     * <p>This method determines whether a specific substring appears at least once in the input string.
     * The search is case-sensitive. If either the input string or the substring is {@code null}, 
     * the method returns {@code false}.</p>
     *
     * <p>The method uses the indexOf method internally for efficient searching.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check substring presence
     * Strings.contains("hello world", "world");   // returns true
     * Strings.contains("hello world", "World");   // returns {@code false} (case-sensitive)
     * Strings.contains("programming", "gram");    // returns true
     * Strings.contains("test", "xyz");            // returns false
     * Strings.contains(null, "test");             // returns false
     * Strings.contains("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return {@code true} if the substring is found in the string, {@code false} otherwise
     */
    public static boolean contains(final String str, final String valueToFind) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOf(str, valueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, considering the specified delimiter.
     *
     * <p>This method determines whether a specific substring appears as a complete token in the input string,
     * where tokens are separated by the specified delimiter. The method only returns {@code true} if the
     * substring appears as a complete token, not as part of another token.</p>
     *
     * <p>If either the input string or the substring is {@code null}, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check token presence with delimiter
     * Strings.contains("apple,banana,orange", "banana", ",");   // returns true
     * Strings.contains("apple,banana,orange", "ban", ",");      // returns {@code false} (partial match)
     * Strings.contains("one two three", "two", " ");            // returns true
     * Strings.contains("one-two-three", "two", "-");            // returns true
     * Strings.contains("testing", "test", ",");                 // returns {@code false} (no delimiter)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param delimiter the delimiter to be considered, may be {@code null}
     * @return {@code true} if the substring is found as a complete token in the string considering the delimiter, {@code false} otherwise
     */
    public static boolean contains(final String str, final String valueToFind, final String delimiter) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOf(str, valueToFind, delimiter) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether a specific substring appears at least once in the input string,
     * performing a case-insensitive comparison. If either the input string or the substring is {@code null},
     * the method returns {@code false}.</p>
     *
     * <p>The method converts both strings to lowercase internally for comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check substring presence ignoring case
     * Strings.containsIgnoreCase("Hello World", "world");   // returns true
     * Strings.containsIgnoreCase("Hello World", "HELLO");   // returns true
     * Strings.containsIgnoreCase("Programming", "GRAM");    // returns true
     * Strings.containsIgnoreCase("test", "XYZ");            // returns false
     * Strings.containsIgnoreCase(null, "test");             // returns false
     * Strings.containsIgnoreCase("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @return {@code true} if the substring is found in the string ignoring case considerations, {@code false} otherwise
     */
    public static boolean containsIgnoreCase(final String str, final String valueToFind) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOfIgnoreCase(str, valueToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified substring is present in the given string, considering the specified delimiter and ignoring case considerations.
     *
     * <p>This method determines whether a specific substring appears as a complete token in the input string,
     * where tokens are separated by the specified delimiter. The comparison is case-insensitive.
     * The method only returns {@code true} if the substring appears as a complete token, not as part of another token.</p>
     *
     * <p>If either the input string or the substring is {@code null}, the method returns {@code false}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check token presence with delimiter ignoring case
     * Strings.containsIgnoreCase("Apple,Banana,Orange", "banana", ",");   // returns true
     * Strings.containsIgnoreCase("Apple,Banana,Orange", "BAN", ",");      // returns {@code false} (partial)
     * Strings.containsIgnoreCase("ONE TWO THREE", "two", " ");            // returns true
     * Strings.containsIgnoreCase("One-Two-Three", "TWO", "-");            // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valueToFind the substring to be found, may be {@code null}
     * @param delimiter the delimiter to be considered, may be {@code null}
     * @return {@code true} if the substring is found as a complete token in the string considering the delimiter and ignoring case considerations, {@code false} otherwise
     */
    public static boolean containsIgnoreCase(final String str, final String valueToFind, final String delimiter) {
        if (str == null || valueToFind == null) {
            return false;
        }

        return indexOfIgnoreCase(str, valueToFind, delimiter) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if all the specified characters are present in the given string.
     *
     * <p>This method determines whether every character in the specified array appears at least once
     * in the input string. The method returns {@code true} if the specified character array is empty
     * or {@code null}. If the input string is {@code null} or empty but the character array is not empty,
     * the method returns {@code false}.</p>
     *
     * <p>The method checks each character independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if all characters are present
     * Strings.containsAll("hello world", 'h', 'e', 'l');   // returns true
     * Strings.containsAll("hello world", 'h', 'x');        // returns {@code false} ('x' not present)
     * Strings.containsAll("test", 't', 'e', 's');          // returns true
     * Strings.containsAll("test");                         // returns {@code true} (empty array)
     * Strings.containsAll(null, 'a');                      // returns false
     * Strings.containsAll("", 'a');                        // returns false
     * Strings.containsAll("abc", '\uDC00', 'a');           // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.containsAll("abc", '\uDFFF', 'a');           // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be found
     * @return {@code true} if all the characters are found in the given string, or if the {@code valuesToFind} array is {@code null} or empty. Returns {@code false} otherwise.
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit.
     */
    public static boolean containsAll(final String str, final char... valuesToFind) throws IllegalArgumentException {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final char ch : valuesToFind) {
            if (str.indexOf(ch) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the specified substrings are present in the given string.
     *
     * <p>This method determines whether every substring in the specified array appears at least once
     * in the input string. The search is case-sensitive. The method returns {@code true} if the 
     * specified substring array is empty or {@code null}. If the input string is {@code null} or empty 
     * but the substring array is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks each substring independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if all substrings are present
     * Strings.containsAll("hello world", "hello", "world");   // returns true
     * Strings.containsAll("hello world", "hello", "xyz");     // returns false
     * Strings.containsAll("programming", "gram", "pro");      // returns true
     * Strings.containsAll("test");                            // returns {@code true} (empty array)
     * Strings.containsAll(null, "test");                      // returns false
     * Strings.containsAll("", "test");                        // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if all the substrings are found in the given string, or if the substring array is {@code null} or empty. Returns {@code false} otherwise.
     */
    public static boolean containsAll(final String str, final String... valuesToFind) {
        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final String searchStr : valuesToFind) {
            if (!Strings.contains(str, searchStr)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether every substring in the specified array appears at least once
     * in the input string, performing case-insensitive comparisons. The method returns {@code true} if 
     * the specified substring array is empty or {@code null}. If the input string is {@code null} or empty 
     * but the substring array is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks each substring independently; duplicates in the array do not require multiple occurrences in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if all substrings are present ignoring case
     * Strings.containsAllIgnoreCase("Hello World", "HELLO", "world");   // returns true
     * Strings.containsAllIgnoreCase("Hello World", "HELLO", "XYZ");     // returns false
     * Strings.containsAllIgnoreCase("Programming", "GRAM", "PRO");      // returns true
     * Strings.containsAllIgnoreCase("test");                            // returns {@code true} (empty array)
     * Strings.containsAllIgnoreCase(null, "test");                      // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if all the substrings are found in the given string (ignoring case), or if the substring array is {@code null} or empty. Returns {@code false} otherwise.
     */
    public static boolean containsAllIgnoreCase(final String str, final String... valuesToFind) {
        if (N.isEmpty(valuesToFind)) {
            return true;
        }

        if (str == null || str.isEmpty()) {
            return false;
        }

        for (final String searchStr : valuesToFind) {
            if (!Strings.containsIgnoreCase(str, searchStr)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if any of the specified characters are present in the given string.
     *
     * <p>This method determines whether at least one character from the specified array appears
     * in the input string. If either the input string or the character array is {@code null} or empty,
     * the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any character is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if any character is present
     * Strings.containsAny("hello", 'a', 'e', 'i');   // returns {@code true} ('e' is present)
     * Strings.containsAny("hello", 'x', 'y', 'z');   // returns false
     * Strings.containsAny("test", 't');              // returns true
     * Strings.containsAny("", 'a');                  // returns false
     * Strings.containsAny(null, 'a');                // returns false
     * Strings.containsAny("test");                   // returns {@code false} (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be found
     * @return {@code true} if any of the characters are found in the given string. Returns {@code false} if no characters are found, or if the string or {@code valuesToFind} array is {@code null} or empty.
     * @see #containsNone(String, char[])
     */
    public static boolean containsAny(final String str, final char... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAny(str, valuesToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if any of the specified substrings are present in the given string.
     *
     * <p>This method determines whether at least one substring from the specified array appears
     * in the input string. The search is case-sensitive. If either the input string or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any substring is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if any substring is present
     * Strings.containsAny("hello world", "xyz", "world");   // returns {@code true} ("world" is present)
     * Strings.containsAny("hello world", "xyz", "abc");     // returns false
     * Strings.containsAny("programming", "gram", "xyz");    // returns true
     * Strings.containsAny("", "test");                      // returns false
     * Strings.containsAny(null, "test");                    // returns false
     * Strings.containsAny(null, "");                        // returns false
     * Strings.containsAny(null, null);                      // returns false
     * Strings.containsAny("", "");                          // returns false
     * Strings.containsAny("", null);                        // returns false
     * Strings.containsAny("test");                          // returns {@code false} (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if any of the substrings are found in the given string. Returns {@code false} if no substrings are found, or if the string or substrings array is {@code null} or empty.
     * @see #containsNone(String, String[])
     */
    public static boolean containsAny(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAny(str, valuesToFind) != N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if any of the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether at least one substring from the specified array appears
     * in the input string, performing case-insensitive comparisons. If either the input string 
     * or the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops searching as soon as any substring is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if any substring is present ignoring case
     * Strings.containsAnyIgnoreCase("Hello World", "xyz", "WORLD");   // returns true
     * Strings.containsAnyIgnoreCase("Hello World", "XYZ", "ABC");     // returns false
     * Strings.containsAnyIgnoreCase("Programming", "GRAM", "xyz");    // returns true
     * Strings.containsAnyIgnoreCase("", "test");                      // returns false
     * Strings.containsAnyIgnoreCase(null, "test");                    // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be found
     * @return {@code true} if any of the substrings are found in the given string (ignoring case). Returns {@code false} if no substrings are found, or if the string or substrings array is {@code null} or empty.
     * @see #containsNoneIgnoreCase(String, String[])
     */
    public static boolean containsAnyIgnoreCase(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return false;
        }

        if (valuesToFind.length == 1) {
            return containsIgnoreCase(str, valuesToFind[0]);
        } else if (valuesToFind.length == 2) {
            if (containsIgnoreCase(str, valuesToFind[0])) {
                return true;
            }

            return containsIgnoreCase(str, valuesToFind[1]);
        }

        final String sourceText = str.toLowerCase();

        for (final String searchStr : valuesToFind) {
            if (isNotEmpty(searchStr) && indexOf(sourceText, searchStr.toLowerCase()) != N.INDEX_NOT_FOUND) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if none of the specified characters are present in the given string.
     *
     * <p>This method determines whether none of the characters in the specified array appear
     * in the input string. The method returns {@code true} if the string is {@code null} or empty, 
     * or if the specified character array is empty or {@code null}.</p>
     *
     * <p>The method stops checking and returns {@code false} as soon as any character is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if none of the characters are present
     * Strings.containsNone("hello", 'x', 'y', 'z');   // returns true
     * Strings.containsNone("hello", 'h', 'x');        // returns false ('h' is present)
     * Strings.containsNone("test", 'a', 'b', 'c');    // returns true
     * Strings.containsNone("", 'a');                  // returns true
     * Strings.containsNone(null, 'a');                // returns true
     * Strings.containsNone("test");                   // returns true (empty array)
     * Strings.containsNone("abc", '\uDC00', 'a');     // throws IllegalArgumentException (Character.isLowSurrogate('\uDC00') is true)
     * Strings.containsNone("abc", '\uD800', 'a');     // throws IllegalArgumentException (Character.isHighSurrogate('\uD800') is true)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of characters to be checked
     * @return {@code true} if none of the characters are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, {@code false} otherwise
     * @throws IllegalArgumentException if any char in {@code valuesToFind} contains low-surrogate or high-surrogate code unit.
     * @see #containsAny(String, char[])
     */
    public static boolean containsNone(final String str, final char... valuesToFind) throws IllegalArgumentException {
        checkInputChars(valuesToFind, cs.valuesToFind, true);

        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        final int strLen = str.length();
        char ch = 0;

        for (int i = 0; i < strLen; i++) {
            ch = str.charAt(i);

            for (final char c : valuesToFind) {
                if (c == ch) {
                    // checked by checkInputChars

                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if none of the specified substrings are present in the given string.
     *
     * <p>This method determines whether none of the substrings in the specified array appear
     * in the input string. The search is case-sensitive. If either the input string or the 
     * substring array is {@code null} or empty, the method returns {@code true}.</p>
     *
     * <p>This method is equivalent to {@code !Strings.containsAny(str, valuesToFind)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if none of the substrings are present
     * Strings.containsNone("hello world", "xyz", "abc");     // returns true
     * Strings.containsNone("hello world", "hello", "xyz");   // returns false ("hello" is present)
     * Strings.containsNone("test", "abc", "xyz");            // returns true
     * Strings.containsNone("", "test");                      // returns true
     * Strings.containsNone(null, "test");                    // returns true
     * Strings.containsNone(null, null);                      // returns true
     * Strings.containsNone("", "");                          // returns true
     * Strings.containsNone("", null);                        // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be checked
     * @return {@code true} if none of the substrings are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, {@code false} otherwise
     * @see #containsAny(String, String[])
     */
    public static boolean containsNone(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(str, valuesToFind);
    }

    /**
     * Checks if none of the specified substrings are present in the given string, ignoring case considerations.
     *
     * <p>This method determines whether none of the substrings in the specified array appear
     * in the input string, performing case-insensitive comparisons. The method returns {@code true} 
     * if the string is {@code null} or empty, or if the specified substring array is empty or {@code null}.</p>
     *
     * <p>This method is equivalent to {@code !Strings.containsAnyIgnoreCase(str, valuesToFind)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if none of the substrings are present ignoring case
     * Strings.containsNoneIgnoreCase("Hello World", "xyz", "abc");     // returns true
     * Strings.containsNoneIgnoreCase("Hello World", "HELLO", "xyz");   // returns false
     * Strings.containsNoneIgnoreCase("test", "ABC", "XYZ");            // returns true
     * Strings.containsNoneIgnoreCase("", "test");                      // returns true
     * Strings.containsNoneIgnoreCase(null, "test");                    // returns true
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the array of substrings to be checked
     * @return {@code true} if none of the substrings are found in the given string or if the given string is {@code null} or empty, or if the specified {@code valuesToFind} char array is {@code null} or empty, ignoring case considerations, {@code false} otherwise
     * @see #containsAnyIgnoreCase(String, String[])
     */
    public static boolean containsNoneIgnoreCase(final String str, final String... valuesToFind) {
        if (isEmpty(str) || N.isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAnyIgnoreCase(str, valuesToFind);
    }

    /**
     * Checks if the given string contains only the specified characters.
     *
     * <p>This method determines whether every character in the input string is contained
     * in the specified character array. The method returns {@code true} if the string is 
     * {@code null} or empty. If the character array is {@code null} or empty but the string 
     * is not empty, the method returns {@code false}.</p>
     *
     * <p>The method checks that all characters in the string are from the allowed set.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string contains only specified characters
     * Strings.containsOnly("aaa", 'a');                  // returns true
     * Strings.containsOnly("abc", 'a', 'b', 'c', 'd');   // returns true
     * Strings.containsOnly("abcd", 'a', 'b', 'c');       // returns false ('d' not allowed)
     * Strings.containsOnly("", 'a');                     // returns true
     * Strings.containsOnly(null, 'a');                   // returns true
     * Strings.containsOnly("test");                      // returns false (empty allowed set)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param valuesToFind the character to be checked
     * @return {@code true} if the given string contains only the specified character or the given string is {@code null} or empty, {@code false} otherwise
     */
    public static boolean containsOnly(final String str, final char... valuesToFind) {
        if (isEmpty(str)) {
            return true;
        } else if (N.isEmpty(valuesToFind)) {
            return false;
        }

        return indexOfAnyBut(str, valuesToFind) == N.INDEX_NOT_FOUND;
    }

    /**
     * Checks if the given string contains any whitespace characters.
     *
     * <p>This method determines whether the input string contains at least one whitespace character
     * as defined by {@link Character#isWhitespace(char)}. This includes spaces, tabs, newlines,
     * and other Unicode whitespace characters. If the string is {@code null} or empty, 
     * the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a whitespace character is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check for whitespace presence
     * Strings.containsWhitespace("hello world");    // returns true (space)
     * Strings.containsWhitespace("hello\tworld");   // returns true (tab)
     * Strings.containsWhitespace("hello\nworld");   // returns true (newline)
     * Strings.containsWhitespace("helloworld");     // returns false
     * Strings.containsWhitespace("");               // returns false
     * Strings.containsWhitespace(null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @return {@code true} if the string contains any whitespace characters, {@code false} otherwise
     */
    // From org.springframework.util.StringUtils, under Apache License 2.0
    public static boolean containsWhitespace(final String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        for (int i = 0, len = str.length(); i < len; i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string starts with the specified prefix.
     *
     * <p>This method determines whether the input string begins with the specified prefix string.
     * The comparison is case-sensitive. If either the string or the prefix is {@code null}, 
     * or if the prefix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>This method delegates to the standard {@link String#startsWith(String)} method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string starts with prefix
     * Strings.startsWith("hello world", "hello");   // returns true
     * Strings.startsWith("hello world", "Hello");   // returns false (case-sensitive)
     * Strings.startsWith("hello", "hello world");   // returns false (prefix too long)
     * Strings.startsWith("test", "");               // returns true (empty prefix)
     * Strings.startsWith(null, "test");             // returns false
     * Strings.startsWith("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @return {@code true} if the string starts with the specified prefix, {@code false} otherwise
     */
    public static boolean startsWith(final String str, final String prefix) {
        return startsWith(str, prefix, false);
    }

    /**
     * Checks if the given string starts with the specified prefix, ignoring case considerations.
     *
     * <p>This method determines whether the input string begins with the specified prefix string,
     * performing a case-insensitive comparison. If either the string or the prefix is {@code null}, 
     * or if the prefix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>The method uses {@link String#regionMatches(boolean, int, String, int, int)} for comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string starts with prefix ignoring case
     * Strings.startsWithIgnoreCase("Hello World", "hello");   // returns true
     * Strings.startsWithIgnoreCase("Hello World", "HELLO");   // returns true
     * Strings.startsWithIgnoreCase("test", "TEST");           // returns true
     * Strings.startsWithIgnoreCase("hello", "hello world");   // returns false (prefix too long)
     * Strings.startsWithIgnoreCase(null, "test");             // returns false
     * Strings.startsWithIgnoreCase("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @return {@code true} if the string starts with the specified prefix, ignoring case considerations, {@code false} otherwise
     */
    public static boolean startsWithIgnoreCase(final String str, final String prefix) {
        return startsWith(str, prefix, true);
    }

    /**
     * Checks if the given string starts with the specified prefix, with an option to ignore case considerations.
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param prefix the prefix to be checked
     * @param ignoreCase if {@code true}, the comparison is case-insensitive
     * @return {@code true} if the string starts with the specified prefix, considering the case sensitivity option, {@code false} otherwise
     */
    private static boolean startsWith(final String str, final String prefix, final boolean ignoreCase) {
        if (str == null || prefix == null || prefix.length() > str.length()) {
            return false;
        }

        return ignoreCase ? str.regionMatches(true, 0, prefix, 0, prefix.length()) : str.startsWith(prefix);
    }

    /**
     * Checks if the given string starts with any of the specified substrings.
     *
     * <p>This method determines whether the input string begins with at least one of the specified
     * prefix strings. The comparison is case-sensitive. If the string is {@code null} or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching prefix is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string starts with any prefix
     * Strings.startsWithAny("hello world", "hi", "hello");   // returns true
     * Strings.startsWithAny("hello world", "Hi", "Hello");   // returns false (case-sensitive)
     * Strings.startsWithAny("test", "a", "b", "t");          // returns true
     * Strings.startsWithAny("test", "a", "b", "c");          // returns false
     * Strings.startsWithAny(null, "test");                   // returns false
     * Strings.startsWithAny("test");                         // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string starts with any of the specified substrings, {@code false} otherwise
     */
    public static boolean startsWithAny(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String substr : substrs) {
            if (startsWith(str, substr)) {

                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string starts with any of the specified substrings, ignoring case considerations.
     *
     * <p>This method determines whether the input string begins with at least one of the specified
     * prefix strings, performing case-insensitive comparisons. If the string is {@code null} or 
     * the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching prefix is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string starts with any prefix ignoring case
     * Strings.startsWithAnyIgnoreCase("Hello World", "hi", "hello");   // returns true
     * Strings.startsWithAnyIgnoreCase("Hello World", "HI", "HELLO");   // returns true
     * Strings.startsWithAnyIgnoreCase("test", "A", "B", "T");          // returns true
     * Strings.startsWithAnyIgnoreCase("test", "A", "B", "C");          // returns false
     * Strings.startsWithAnyIgnoreCase(null, "test");                   // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string starts with any of the specified substrings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean startsWithAnyIgnoreCase(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String substr : substrs) {
            if (startsWithIgnoreCase(str, substr)) {

                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with the specified suffix.
     *
     * <p>This method determines whether the input string ends with the specified suffix string.
     * The comparison is case-sensitive. If either the string or the suffix is {@code null}, 
     * or if the suffix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>This method delegates to the standard {@link String#endsWith(String)} method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string ends with suffix
     * Strings.endsWith("hello world", "world");   // returns true
     * Strings.endsWith("hello world", "World");   // returns false (case-sensitive)
     * Strings.endsWith("hello", "hello world");   // returns false (suffix too long)
     * Strings.endsWith("test", "");               // returns true (empty suffix)
     * Strings.endsWith(null, "test");             // returns false
     * Strings.endsWith("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @return {@code true} if the string ends with the specified suffix, {@code false} otherwise
     */
    public static boolean endsWith(final String str, final String suffix) {
        return endsWith(str, suffix, false);
    }

    /**
     * Checks if the given string ends with the specified suffix, ignoring case considerations.
     *
     * <p>This method determines whether the input string ends with the specified suffix string,
     * performing a case-insensitive comparison. If either the string or the suffix is {@code null}, 
     * or if the suffix is longer than the string, the method returns {@code false}.</p>
     *
     * <p>The method uses {@link String#regionMatches(boolean, int, String, int, int)} for comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string ends with suffix ignoring case
     * Strings.endsWithIgnoreCase("Hello World", "world");   // returns true
     * Strings.endsWithIgnoreCase("Hello World", "WORLD");   // returns true
     * Strings.endsWithIgnoreCase("test", "TEST");           // returns true
     * Strings.endsWithIgnoreCase("hello", "hello world");   // returns false (suffix too long)
     * Strings.endsWithIgnoreCase(null, "test");             // returns false
     * Strings.endsWithIgnoreCase("test", null);             // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @return {@code true} if the string ends with the specified suffix, ignoring case considerations, {@code false} otherwise
     */
    public static boolean endsWithIgnoreCase(final String str, final String suffix) {
        return endsWith(str, suffix, true);
    }

    /**
     * Checks if the given string ends with any of the specified substrings.
     *
     * <p>This method determines whether the input string ends with at least one of the specified
     * suffix strings. The comparison is case-sensitive. If the string is {@code null} or the 
     * substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching suffix is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string ends with any suffix
     * Strings.endsWithAny("hello.txt", ".txt", ".doc");   // returns true
     * Strings.endsWithAny("hello.txt", ".TXT", ".DOC");   // returns false (case-sensitive)
     * Strings.endsWithAny("test", "st", "ing");           // returns true
     * Strings.endsWithAny("test", "ing", "ed");           // returns false
     * Strings.endsWithAny(null, "test");                  // returns false
     * Strings.endsWithAny("test");                        // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string ends with any of the specified substrings, {@code false} otherwise
     */
    public static boolean endsWithAny(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String searchString : substrs) {
            if (endsWith(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with any of the specified substrings, ignoring case considerations.
     *
     * <p>This method determines whether the input string ends with at least one of the specified
     * suffix strings, performing case-insensitive comparisons. If the string is {@code null} or 
     * the substring array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a matching suffix is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string ends with any suffix ignoring case
     * Strings.endsWithAnyIgnoreCase("hello.txt", ".TXT", ".DOC");   // returns true
     * Strings.endsWithAnyIgnoreCase("HELLO.TXT", ".txt", ".doc");   // returns true
     * Strings.endsWithAnyIgnoreCase("test", "ST", "ING");           // returns true
     * Strings.endsWithAnyIgnoreCase("test", "ING", "ED");           // returns false
     * Strings.endsWithAnyIgnoreCase(null, "test");                  // returns false
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param substrs the array of substrings to be checked
     * @return {@code true} if the string ends with any of the specified substrings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean endsWithAnyIgnoreCase(final String str, final String... substrs) {
        if (str == null || N.isEmpty(substrs)) {
            return false;
        }

        for (final String searchString : substrs) {
            if (endsWithIgnoreCase(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string ends with the specified suffix, with an option to ignore case considerations.
     *
     * @param str the string to be checked, may be {@code null} or empty
     * @param suffix the suffix to be checked
     * @param ignoreCase if {@code true}, the comparison is case-insensitive
     * @return {@code true} if the string ends with the specified suffix, considering the case sensitivity option, {@code false} otherwise
     */
    private static boolean endsWith(final String str, final String suffix, final boolean ignoreCase) {
        if (str == null || suffix == null || suffix.length() > str.length()) {
            return false;
        }

        final int strOffset = str.length() - suffix.length();

        return ignoreCase ? str.regionMatches(true, strOffset, suffix, 0, suffix.length()) : str.endsWith(suffix);
    }

    /**
     * Compares two strings for equality.
     *
     * <p>This method checks if two strings are equal, handling {@code null} values safely.
     * Two {@code null} values are considered equal. The comparison is case-sensitive and
     * includes a length check for optimization before comparing content.</p>
     *
     * <p>This method is null-safe and more efficient than using {@link String#equals(Object)}
     * when either string might be {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Compare strings for equality
     * Strings.equals("hello", "hello");   // returns true
     * Strings.equals("hello", "Hello");   // returns false (case-sensitive)
     * Strings.equals(null, null);         // returns true
     * Strings.equals("test", null);       // returns false
     * Strings.equals(null, "test");       // returns false
     * Strings.equals("", "");             // returns true
     * }</pre>
     *
     * @param a the first string to compare, may be {@code null}
     * @param b the second string to compare, may be {@code null}
     * @return {@code true} if the strings are equal, {@code false} otherwise
     */
    public static boolean equals(final String a, final String b) {
        return (a == null) ? b == null : (b != null && a.length() == b.length() && a.equals(b));
    }

    /**
     * Compares two strings for equality, ignoring case considerations.
     *
     * <p>This method checks if two strings are equal ignoring their case, handling {@code null} 
     * values safely. Two {@code null} values are considered equal. The comparison uses
     * {@link String#equalsIgnoreCase(String)} for {@code non-null} values.</p>
     *
     * <p>This method is null-safe alternative to {@link String#equalsIgnoreCase(String)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Compare strings for equality ignoring case
     * Strings.equalsIgnoreCase("hello", "HELLO");   // returns true
     * Strings.equalsIgnoreCase("Hello", "hello");   // returns true
     * Strings.equalsIgnoreCase(null, null);         // returns true
     * Strings.equalsIgnoreCase("test", null);       // returns false
     * Strings.equalsIgnoreCase(null, "test");       // returns false
     * Strings.equalsIgnoreCase("", "");             // returns true
     * }</pre>
     *
     * @param a the first string to compare, may be {@code null}
     * @param b the second string to compare, may be {@code null}
     * @return {@code true} if the strings are equal, ignoring case considerations, {@code false} otherwise
     */
    public static boolean equalsIgnoreCase(final String a, final String b) {
        return (a == null) ? b == null : (a.equalsIgnoreCase(b));
    }

    /**
     * Checks if the given string is equal to any of the specified search strings.
     *
     * <p>This method determines whether the input string equals at least one of the strings
     * in the specified array. The comparison is case-sensitive and null-safe. If the search
     * string array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a match is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string equals any value
     * Strings.equalsAny("test", "test", "demo", "sample");   // returns true
     * Strings.equalsAny("test", "Test", "TEST");             // returns false (case-sensitive)
     * Strings.equalsAny(null, "test", null, "demo");         // returns true (null match)
     * Strings.equalsAny("test", "demo", "sample");           // returns false
     * Strings.equalsAny("test");                             // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null}
     * @param searchStrings the array of strings to compare against, may be {@code null} or empty
     * @return {@code true} if the string is equal to any of the specified search strings, {@code false} otherwise
     */
    public static boolean equalsAny(final String str, final String... searchStrings) {
        if (N.isEmpty(searchStrings)) {
            return false;
        }

        for (final String searchString : searchStrings) {
            if (equals(str, searchString)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the given string is equal to any of the specified search strings, ignoring case considerations.
     *
     * <p>This method determines whether the input string equals at least one of the strings
     * in the specified array, performing case-insensitive comparisons. The comparison is null-safe.
     * If the search string array is {@code null} or empty, the method returns {@code false}.</p>
     *
     * <p>The method stops checking as soon as a match is found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Check if string equals any value ignoring case
     * Strings.equalsAnyIgnoreCase("test", "TEST", "demo");     // returns true
     * Strings.equalsAnyIgnoreCase("Test", "test", "TEST");     // returns true
     * Strings.equalsAnyIgnoreCase(null, "test", null);         // returns true (null match)
     * Strings.equalsAnyIgnoreCase("test", "demo", "sample");   // returns false
     * Strings.equalsAnyIgnoreCase("test");                     // returns false (empty array)
     * }</pre>
     *
     * @param str the string to be checked, may be {@code null}
     * @param searchStrs the array of strings to compare against, may be {@code null} or empty
     * @return {@code true} if the string is equal to any of the specified search strings, ignoring case considerations, {@code false} otherwise
     */
    public static boolean equalsAnyIgnoreCase(final String str, final String... searchStrs) {
        if (N.isEmpty(searchStrs)) {
            return false;
        } else if (searchStrs.length == 1) {
            return equalsIgnoreCase(str, searchStrs[0]);
        } else if (searchStrs.length == 2) {
            if (equalsIgnoreCase(str, searchStrs[0])) {
                return true;
            }

            return equalsIgnoreCase(str, searchStrs[1]);
        }

        final String sourceText = str.toLowerCase();

        for (final String searchStr : searchStrs) {
            if (equals(sourceText, searchStr.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Compares two strings lexicographically, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive lexicographical comparison of two strings,
     * handling {@code null} values safely. {@code null} is considered less than any {@code non-null} string.
     * If both strings are {@code null}, they are considered equal (returns 0).</p>
     *
     * <p>The comparison uses {@link String#compareToIgnoreCase(String)} for {@code non-null} values.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Compare strings ignoring case
     * Strings.compareIgnoreCase("abc", "ABC");   // returns 0
     * Strings.compareIgnoreCase("abc", "def");   // returns negative value
     * Strings.compareIgnoreCase("def", "abc");   // returns positive value
     * Strings.compareIgnoreCase(null, "abc");    // returns -1
     * Strings.compareIgnoreCase("abc", null);    // returns 1
     * Strings.compareIgnoreCase(null, null);     // returns 0
     * }</pre>
     *
     * @param a the first string to compare, may be {@code null}
     * @param b the second string to compare, may be {@code null}
     * @return a negative integer, zero, or a positive integer as the first string is less than, equal to, or greater than the second string, ignoring case considerations
     */
    public static int compareIgnoreCase(final String a, final String b) {
        return a == null ? (b == null ? 0 : -1) : (b == null ? 1 : a.compareToIgnoreCase(b));
    }

    /**
     * Compares two Strings and returns the index at which the Strings begin to differ.
     *
     * <p>This method finds the first position where two strings have different characters.
     * If the strings are equal or both are empty (including {@code null}), the method returns -1.
     * If one string is a prefix of the other, the method returns the length of the shorter string.</p>
     *
     * <p>The comparison is case-sensitive and character-by-character.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Find index of first difference
     * Strings.indexOfDifference("i am a machine", "i am a robot");   // returns 7
     * Strings.indexOfDifference("abc", "abc");                       // returns -1 (identical)
     * Strings.indexOfDifference("ab", "abxyz");                      // returns 2
     * Strings.indexOfDifference("abcde", "abxyz");                   // returns 2
     * Strings.indexOfDifference("abcde", "xyz");                     // returns 0
     * Strings.indexOfDifference("", "abc");                          // returns 0
     * Strings.indexOfDifference(null, "abc");                        // returns 0
     * Strings.indexOfDifference(null, null);                         // returns -1
     * Strings.indexOfDifference("", "");                             // returns -1
     * Strings.indexOfDifference(null, "");                           // returns -1
     * }</pre>
     *
     * @param a the first String, may be {@code null}
     * @param b the second String, may be {@code null}
     * @return the index where the strings begin to differ, or -1 if they are equal
     */
    public static int indexOfDifference(final String a, final String b) {
        if (N.equals(a, b) || (isEmpty(a) && isEmpty(b))) {
            return N.INDEX_NOT_FOUND;
        }

        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        int i = 0;
        for (final int len = N.min(a.length(), b.length()); i < len; i++) {
            if (a.charAt(i) != b.charAt(i)) {
                break;
            }
        }

        if (i < b.length() || i < a.length()) {
            return i;
        }

        return N.INDEX_NOT_FOUND;
    }

    /**
     * Compares all Strings in an array and returns the index at which the Strings begin to differ.
     *
     * <p>This method finds the first position where any two strings in the array have different
     * characters. If all strings are equal, the array is empty, has only one element, or all
     * elements are {@code null}/empty, the method returns -1. If any string is {@code null},
     * it's treated as having length 0.</p>
     *
     * <p>The comparison stops at the length of the shortest string. If all strings are identical
     * up to that point but have different lengths, the method returns the length of the shortest string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Find index of first difference across multiple strings
     * Strings.indexOfDifference("i am a machine", "i am a robot");   // returns 7
     * Strings.indexOfDifference("abc", "abc", "abc");                // returns -1
     * Strings.indexOfDifference("abc", "a");                         // returns 1
     * Strings.indexOfDifference("ab", "abxyz", "abcde");             // returns 2
     * Strings.indexOfDifference("", "abc", "xyz");                   // returns 0
     * Strings.indexOfDifference((String[]) null);                    // returns -1
     * }</pre>
     *
     * @param strs array of Strings, entries may be null
     * @return the index where strings begin to differ, or -1 if all strings are equal or null/empty
     */
    public static int indexOfDifference(final String... strs) {
        if (N.len(strs) <= 1) {
            return N.INDEX_NOT_FOUND;
        }

        final int arrayLen = strs.length;
        int shortestStrLen = Integer.MAX_VALUE;
        int longestStrLen = 0;

        // find the min and max string lengths; this avoids checking to make
        // sure we are not exceeding the length of the string each time through
        // the bottom loop.
        for (final String str : strs) {
            if (str == null) {
                shortestStrLen = 0;
            } else {
                shortestStrLen = Math.min(str.length(), shortestStrLen);
                longestStrLen = Math.max(str.length(), longestStrLen);
            }
        }

        // handle lists containing all nulls or all empty strings
        if (longestStrLen == 0) {
            return N.INDEX_NOT_FOUND;
        }

        if (shortestStrLen == 0) {
            return 0;
        }

        // find the position with the first difference across all strings
        int firstDiff = -1;
        char comparisonChar = 0;

        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
            comparisonChar = strs[0].charAt(stringPos);

            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {
                    firstDiff = stringPos;
                    break;
                }
            }

            if (firstDiff != -1) {
                break;
            }
        }

        if (firstDiff == -1 && shortestStrLen != longestStrLen) {
            // we compared all the characters up to the length of the
            // shortest string and didn't find a match, but the string lengths
            // vary, so return the length of the shortest string.
            return shortestStrLen;
        }

        return firstDiff;
    }

    /**
     * Returns the length of the common prefix between two CharSequences.
     *
     * <p>This method compares the two CharSequences character by character from the beginning and returns
     * the number of characters that are identical. The comparison stops when a mismatch is found or when
     * the end of either CharSequence is reached. The method properly handles Unicode surrogate pairs.</p>
     *
     * <p>The method returns 0 if either CharSequence is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lengthOfCommonPrefix("hello", "help");    // returns 3 (common prefix "hel")
     * Strings.lengthOfCommonPrefix("abc", "abcdef");    // returns 3 (common prefix "abc")
     * Strings.lengthOfCommonPrefix("test", "best");     // returns 0 (no common prefix)
     * Strings.lengthOfCommonPrefix("", "hello");        // returns 0 (empty string)
     * Strings.lengthOfCommonPrefix(null, "hello");      // returns 0 (null input)
     * Strings.lengthOfCommonPrefix("hello", "hello");   // returns 5 (identical strings)
     * }</pre>
     *
     * @param a the first CharSequence to compare, may be {@code null}
     * @param b the second CharSequence to compare, may be {@code null}
     * @return the length of the common prefix, or 0 if either CharSequence is {@code null} or empty.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #lengthOfCommonSuffix(CharSequence, CharSequence)
     */
    public static int lengthOfCommonPrefix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        final int maxPrefixLength = Math.min(a.length(), b.length());
        int cnt = 0;

        while (cnt < maxPrefixLength && a.charAt(cnt) == b.charAt(cnt)) {
            cnt++;
        }

        if (validSurrogatePairAt(a, cnt - 1) || validSurrogatePairAt(b, cnt - 1)) {
            cnt--;
        }

        return cnt;
    }

    /**
     * Returns the length of the common suffix between two CharSequences.
     *
     * <p>This method compares the two CharSequences character by character from the end and returns
     * the number of characters that are identical. The comparison stops when a mismatch is found or when
     * the beginning of either CharSequence is reached. The method properly handles Unicode surrogate pairs.</p>
     *
     * <p>The method returns 0 if either CharSequence is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lengthOfCommonSuffix("hello", "jello");   // returns 4 (common suffix "ello")
     * Strings.lengthOfCommonSuffix("testing", "ing");   // returns 3 (common suffix "ing")
     * Strings.lengthOfCommonSuffix("test", "best");     // returns 3 (common suffix "est")
     * Strings.lengthOfCommonSuffix("abc", "xyz");       // returns 0 (no common suffix)
     * Strings.lengthOfCommonSuffix("", "hello");        // returns 0 (empty string)
     * Strings.lengthOfCommonSuffix(null, "hello");      // returns 0 (null input)
     * }</pre>
     *
     * @param a the first CharSequence to compare, may be {@code null}
     * @param b the second CharSequence to compare, may be {@code null}
     * @return the length of the common suffix, or 0 if either CharSequence is {@code null} or empty.
     * @see #commonSuffix(CharSequence, CharSequence)
     * @see #lengthOfCommonPrefix(CharSequence, CharSequence)
     */
    public static int lengthOfCommonSuffix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return 0;
        }

        final int aLength = a.length();
        final int bLength = b.length();
        final int maxSuffixLength = Math.min(aLength, bLength);
        int cnt = 0;

        while (cnt < maxSuffixLength && a.charAt(aLength - cnt - 1) == b.charAt(bLength - cnt - 1)) {
            cnt++;
        }

        if (validSurrogatePairAt(a, aLength - cnt - 1) || validSurrogatePairAt(b, bLength - cnt - 1)) {
            cnt--;
        }

        return cnt;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * Returns the longest string {@code prefix} such that
     * {@code a.toString().startsWith(prefix) && b.toString().startsWith(prefix)}
     * , taking care not to split surrogate pairs. If {@code a} and {@code b}
     * have no common prefix, returns the empty string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.commonPrefix("abc", "ab");    // returns "ab"
     * Strings.commonPrefix("abc", "xyz");   // returns ""
     * }</pre>
     *
     * @param a the first CharSequence to compare, may be {@code null}
     * @param b the second CharSequence to compare, may be {@code null}
     * @return the longest common prefix, or an empty string if there is no common prefix
     */
    public static String commonPrefix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int commonPrefixLen = lengthOfCommonPrefix(a, b);

        if (commonPrefixLen == a.length()) {
            return a.toString();
        } else if (commonPrefixLen == b.length()) {
            return b.toString();
        } else {
            return a.subSequence(0, commonPrefixLen).toString();
        }
    }

    /**
     * Returns the longest common prefix among an array of CharSequences.
     *
     * <p>This method finds the longest string that appears at the beginning of all provided CharSequences.
     * It compares all CharSequences in the array and returns the characters that are common to all of them
     * from the beginning. The comparison is case-sensitive.</p>
     *
     * <p>The method returns an empty string if the array is empty, {@code null}, any CharSequence is {@code null} or empty,
     * or if there is no common prefix among the CharSequences.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.commonPrefix("flower", "flow", "flight");                     // returns "fl"
     * Strings.commonPrefix("dog", "racecar", "car");                        // returns "" (no common prefix)
     * Strings.commonPrefix("interspecies", "interstellar", "interstate");   // returns "inters"
     * Strings.commonPrefix("prefix");                                       // returns "prefix" (single element)
     * Strings.commonPrefix();                                               // returns "" (empty array)
     * Strings.commonPrefix("test", null, "testing");                        // returns "" (null element)
     * Strings.commonPrefix("", "hello");                                    // returns "" (empty element)
     * }</pre>
     *
     * @param strs the array of CharSequences to compare. It can be empty or contain {@code null} elements.
     * @return the longest common prefix among the given CharSequences, or an empty string if no common prefix exists.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #lengthOfCommonPrefix(CharSequence, CharSequence)
     */
    public static String commonPrefix(final CharSequence... strs) {
        if (N.isEmpty(strs)) {
            return EMPTY;
        }

        if (strs.length == 1) {
            return isEmpty(strs[0]) ? EMPTY : strs[0].toString();
        } else if (isAnyEmpty(strs)) {
            return EMPTY;
        }

        String commonPrefix = commonPrefix(strs[0], strs[1]);

        if (isEmpty(commonPrefix)) {
            return EMPTY;
        }

        for (int i = 2, len = strs.length; i < len; i++) {
            commonPrefix = commonPrefix(commonPrefix, strs[i]);

            if (isEmpty(commonPrefix)) {
                return commonPrefix;
            }
        }

        return commonPrefix;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * Returns the longest string {@code suffix} such that
     * {@code a.toString().endsWith(suffix) && b.toString().endsWith(suffix)},
     * taking care not to split surrogate pairs. If {@code a} and {@code b} have
     * no common suffix, returns the empty string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.commonSuffix("abc", "bc");    // returns "bc"
     * Strings.commonSuffix("abc", "xyz");   // returns ""
     * }</pre>
     *
     * @param a the first CharSequence to compare, may be {@code null}
     * @param b the second CharSequence to compare, may be {@code null}
     * @return the longest common suffix, or an empty string if there is no common suffix
     */
    public static String commonSuffix(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int aLength = a.length();
        final int commonSuffixLen = lengthOfCommonSuffix(a, b);

        if (commonSuffixLen == aLength) {
            return a.toString();
        } else if (commonSuffixLen == b.length()) {
            return b.toString();
        } else {
            return a.subSequence(aLength - commonSuffixLen, aLength).toString();
        }
    }

    /**
     * Returns the longest common suffix among an array of CharSequences.
     *
     * <p>This method finds the longest string that appears at the end of all provided CharSequences.
     * It compares all CharSequences in the array and returns the characters that are common to all of them
     * from the end. The comparison is case-sensitive.</p>
     *
     * <p>The method returns an empty string if the array is empty, {@code null}, any CharSequence is {@code null} or empty,
     * or if there is no common suffix among the CharSequences.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.commonSuffix("testing", "eating", "meeting");   // returns "ting"
     * Strings.commonSuffix("hello", "jello", "yellow");       // returns "llo"
     * Strings.commonSuffix("abc", "xyz", "123");              // returns "" (no common suffix)
     * Strings.commonSuffix("suffix");                         // returns "suffix" (single element)
     * Strings.commonSuffix();                                 // returns "" (empty array)
     * Strings.commonSuffix("test", null, "best");             // returns "" (null element)
     * Strings.commonSuffix("", "hello");                      // returns "" (empty element)
     * }</pre>
     *
     * @param strs the array of CharSequences to compare. It can be empty or contain {@code null} elements.
     * @return the longest common suffix among the given CharSequences, or an empty string if no common suffix exists.
     * @see #commonSuffix(CharSequence, CharSequence)
     * @see #lengthOfCommonSuffix(CharSequence, CharSequence)
     */
    public static String commonSuffix(final CharSequence... strs) {
        if (N.isEmpty(strs)) {
            return EMPTY;
        }

        if (strs.length == 1) {
            return isEmpty(strs[0]) ? EMPTY : strs[0].toString();
        } else if (isAnyEmpty(strs)) {
            return EMPTY;
        }

        String commonSuffix = commonSuffix(strs[0], strs[1]);

        if (isEmpty(commonSuffix)) {
            return EMPTY;
        }

        for (int i = 2, len = strs.length; i < len; i++) {
            commonSuffix = commonSuffix(commonSuffix, strs[i]);

            if (isEmpty(commonSuffix)) {
                return commonSuffix;
            }
        }

        return commonSuffix;
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * True when a valid surrogate pair starts at the given {@code index} in the
     * given {@code string}. Out-of-range indexes return {@code false}.
     *
     * @param str the string to check, may be {@code null}
     * @param index the index to check for surrogate pair
     * @return {@code true} if a valid surrogate pair starts at the given index, {@code false} otherwise
     */
    static boolean validSurrogatePairAt(final CharSequence str, final int index) {
        return index >= 0 && index <= (str.length() - 2) && Character.isHighSurrogate(str.charAt(index)) && Character.isLowSurrogate(str.charAt(index + 1));
    }

    /**
     * Returns the longest common substring between two given CharSequences.
     *
     * <p>This method finds the longest sequence of characters that appears in both CharSequences at any position.
     * Unlike common prefix/suffix methods, the common substring can appear anywhere in both CharSequences.
     * The comparison is case-sensitive and uses dynamic programming for efficient computation.</p>
     *
     * <p>The method returns an empty string if either CharSequence is {@code null}, empty, or if there is no common substring.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.longestCommonSubstring("abcdxyz", "xyzabcd");       // returns "abcd" (or "xyz")
     * Strings.longestCommonSubstring("zxabcdezy", "yzabcdezx");   // returns "abcdez"
     * Strings.longestCommonSubstring("hello", "yellow");          // returns "ello"
     * Strings.longestCommonSubstring("abc", "def");               // returns "" (no common substring)
     * Strings.longestCommonSubstring("", "hello");                // returns "" (empty string)
     * Strings.longestCommonSubstring(null, "hello");              // returns "" (null input)
     * }</pre>
     *
     * @param a the first CharSequence to compare, may be {@code null}
     * @param b the second CharSequence to compare, may be {@code null}
     * @return the longest common substring, or an empty string if no common substring exists.
     * @see #commonPrefix(CharSequence, CharSequence)
     * @see #commonSuffix(CharSequence, CharSequence)
     */
    public static String longestCommonSubstring(final CharSequence a, final CharSequence b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY;
        }

        final int lenA = N.len(a);
        final int lenB = N.len(b);

        char[] charsToCheck = null;
        if (lenA < lenB) {
            charsToCheck = a.toString().toCharArray();
        } else {
            charsToCheck = b.toString().toCharArray();
        }

        checkInputChars(charsToCheck, lenA < lenB ? "a" : "b", true);

        final int[] dp = new int[lenB + 1];
        int endIndex = 0;
        int maxLen = 0;

        if (lenA > 16 || lenB > 16) {
            final char[] chsA = lenA < lenB ? charsToCheck : a.toString().toCharArray();
            final char[] chsB = lenA < lenB ? b.toString().toCharArray() : charsToCheck;

            for (int i = 1; i <= lenA; i++) {
                for (int j = lenB; j > 0; j--) {
                    if (chsA[i - 1] == chsB[j - 1]) {
                        dp[j] = 1 + dp[j - 1];

                        if (dp[j] > maxLen) {
                            maxLen = dp[j];
                            endIndex = i;
                        }
                    } else {
                        dp[j] = 0;
                    }
                }
            }
        } else {
            for (int i = 1; i <= lenA; i++) {
                for (int j = lenB; j > 0; j--) {
                    if (a.charAt(i - 1) == b.charAt(j - 1)) {
                        dp[j] = 1 + dp[j - 1];

                        if (dp[j] > maxLen) {
                            maxLen = dp[j];
                            endIndex = i;
                        }
                    } else {
                        dp[j] = 0;
                    }
                }
            }
        }

        if (maxLen == 0) {
            return EMPTY;
        }

        return a.subSequence(endIndex - maxLen, endIndex).toString();
    }

    /**
     * Returns the first character of the given string as an OptionalChar.
     *
     * <p>This method extracts the first character from the provided string and wraps it in an OptionalChar.
     * If the string is {@code null} or empty, an empty OptionalChar is returned, allowing for safe handling
     * of edge cases without throwing exceptions.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstChar("Hello");      // returns OptionalChar.of('H')
     * Strings.firstChar("A");          // returns OptionalChar.of('A')
     * Strings.firstChar("");           // returns OptionalChar.empty()
     * Strings.firstChar(null);         // returns OptionalChar.empty()
     * Strings.firstChar("  spaces");   // returns OptionalChar.of(' ')
     * }</pre>
     *
     * @param str the input string from which to extract the first character, may be {@code null} or empty
     * @return an OptionalChar containing the first character of the string, or an empty OptionalChar if the string is {@code null} or empty.
     * @see #lastChar(String)
     * @see OptionalChar
     */
    public static OptionalChar firstChar(final String str) {
        if (str == null || str.isEmpty()) {
            return OptionalChar.empty();
        }

        return OptionalChar.of(str.charAt(0));
    }

    /**
     * Returns the last character of the given string as an OptionalChar.
     *
     * <p>This method extracts the last character from the provided string and wraps it in an OptionalChar.
     * If the string is {@code null} or empty, an empty OptionalChar is returned, allowing for safe handling
     * of edge cases without throwing exceptions.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastChar("Hello");   // returns OptionalChar.of('o')
     * Strings.lastChar("A");       // returns OptionalChar.of('A')
     * Strings.lastChar("");        // returns OptionalChar.empty()
     * Strings.lastChar(null);      // returns OptionalChar.empty()
     * Strings.lastChar("test ");   // returns OptionalChar.of(' ')
     * }</pre>
     *
     * @param str the input string from which to extract the last character, may be {@code null} or empty
     * @return an OptionalChar containing the last character of the string, or an empty OptionalChar if the string is {@code null} or empty.
     * @see #firstChar(String)
     * @see OptionalChar
     */
    public static OptionalChar lastChar(final String str) {
        if (str == null || str.isEmpty()) {
            return OptionalChar.empty();
        }

        return OptionalChar.of(str.charAt(str.length() - 1));
    }

    /**
     * Returns at most the first {@code n} characters of the specified string.
     *
     * <p>This method extracts up to {@code n} characters from the beginning of the string.
     * If the string length is less than or equal to {@code n}, the entire string is returned.
     * If the string is {@code null} or empty, or if {@code n} is 0, an empty string is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.firstChars("Hello World", 5);   // returns "Hello"
     * Strings.firstChars("Hi", 5);            // returns "Hi" (string shorter than n)
     * Strings.firstChars("Testing", 0);       // returns ""
     * Strings.firstChars("", 5);              // returns ""
     * Strings.firstChars(null, 5);            // returns ""
     * Strings.firstChars("Example", 7);       // returns "Example" (exact length)
     * }</pre>
     *
     * @param str the input string from which to extract characters, may be {@code null} or empty
     * @param n the maximum number of characters to return from the beginning of the string.
     * @return at most the first {@code n} characters of the string, or an empty string if the input is {@code null} or empty.
     * @throws IllegalArgumentException if {@code n} is negative.
     * @see #lastChars(String, int)
     */
    @Beta
    public static String firstChars(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (str == null || str.isEmpty() || n == 0) {
            return EMPTY;
        } else if (str.length() <= n) {
            return str;
        } else {
            return str.substring(0, n);
        }
    }

    /**
     * Returns at most the last {@code n} characters of the specified string.
     *
     * <p>This method extracts up to {@code n} characters from the end of the string.
     * If the string length is less than or equal to {@code n}, the entire string is returned.
     * If the string is {@code null} or empty, or if {@code n} is 0, an empty string is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lastChars("Hello World", 5);   // returns "World"
     * Strings.lastChars("Hi", 5);            // returns "Hi" (string shorter than n)
     * Strings.lastChars("Testing", 0);       // returns ""
     * Strings.lastChars("", 5);              // returns ""
     * Strings.lastChars(null, 5);            // returns ""
     * Strings.lastChars("Example", 7);       // returns "Example" (exact length)
     * }</pre>
     *
     * @param str the input string from which to extract characters, may be {@code null} or empty
     * @param n the maximum number of characters to return from the end of the string.
     * @return at most the last {@code n} characters of the string, or an empty string if the input is {@code null} or empty.
     * @throws IllegalArgumentException if {@code n} is negative.
     * @see #firstChars(String, int)
     */
    @Beta
    public static String lastChars(final String str, final int n) throws IllegalArgumentException {
        N.checkArgNotNegative(n, cs.n);

        if (str == null || str.isEmpty() || n == 0) {
            return EMPTY;
        } else if (str.length() <= n) {
            return str;
        } else {
            return str.substring(str.length() - n);
        }
    }

    /**
     * Returns a substring from the specified string starting at the given index.
     *
     * <p>This method extracts a substring from the provided string starting at {@code inclusiveBeginIndex}
     * and continuing to the end of the string. Unlike {@code String.substring()}, this method returns
     * {@code null} instead of throwing an exception for invalid indices.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the index is negative,
     * or the index is greater than the string length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello World", 6);   // returns "World"
     * Strings.substring("Hello", 0);         // returns "Hello"
     * Strings.substring("Hello", 5);         // returns "" (index at string length)
     * Strings.substring("Hello", -1);        // returns null (negative index)
     * Strings.substring("Hello", 10);        // returns null (index > length)
     * Strings.substring(null, 0);            // returns null
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param inclusiveBeginIndex the starting index of the substring (inclusive).
     * @return the substring starting from the specified index, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int)
     * @see #substring(String, int, int)
     * @see #substringAfter(String, char)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex) {
        if (str == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        return str.substring(inclusiveBeginIndex);
    }

    /**
     * Returns a substring from the specified string between the given indices.
     *
     * <p>This method extracts a substring from the provided string starting at {@code inclusiveBeginIndex}
     * and ending before {@code exclusiveEndIndex}. Unlike {@code String.substring()}, this method returns
     * {@code null} instead of throwing an exception for invalid indices. If {@code exclusiveEndIndex}
     * exceeds the string length, it is adjusted to the string length.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, either index is negative,
     * or the begin index is greater than the end index or string length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello World", 0, 5);    // returns "Hello"
     * Strings.substring("Hello World", 6, 11);   // returns "World"
     * Strings.substring("Hello", 1, 10);         // returns "ello" (end index adjusted)
     * Strings.substring("Hello", 2, 2);          // returns "" (empty range)
     * Strings.substring("Hello", -1, 3);         // returns null (negative index)
     * Strings.substring("Hello", 3, 1);          // returns null (begin > end)
     * Strings.substring(null, 0, 5);             // returns null
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param inclusiveBeginIndex the starting index of the substring (inclusive).
     * @param exclusiveEndIndex the ending index of the substring (exclusive).
     * @return the substring between the specified indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || inclusiveBeginIndex < 0 || exclusiveEndIndex < 0 || inclusiveBeginIndex > exclusiveEndIndex || inclusiveBeginIndex > str.length()) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, N.min(exclusiveEndIndex, str.length()));
    }

    /**
     * Returns a substring from the specified string using a function to determine the end index.
     *
     * <p>This method extracts a substring starting at {@code inclusiveBeginIndex}. The end index is
     * determined by applying the provided {@code IntUnaryOperator} function to the begin index.
     * This allows for dynamic calculation of the substring length based on the starting position.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the begin index is negative,
     * or if the function returns a negative end index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Get next 3 characters from index
     * Strings.substring("Hello World", 0, i -> i + 3);   // returns "Hel"
     * Strings.substring("Hello World", 6, i -> i + 5);   // returns "World"
     * 
     * // Get to string length
     * Strings.substring("Hello", 2, i -> 5);             // returns "llo"
     * 
     * // Invalid cases
     * Strings.substring("Hello", -1, i -> i + 3);        // returns null (negative index)
     * Strings.substring(null, 0, i -> i + 3);            // returns null
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param inclusiveBeginIndex the starting index of the substring (inclusive).
     * @param funcOfExclusiveEndIndex function that calculates the end index based on the begin index.
     * @return the substring determined by the indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, int, IntUnaryOperator)
     * @see #substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || inclusiveBeginIndex < 0) {
            return null;
        }

        return substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex.applyAsInt(inclusiveBeginIndex));
    }

    /**
     * Returns a substring from the specified string using a function to determine the begin index.
     *
     * <p>This method extracts a substring ending before {@code exclusiveEndIndex}. The begin index is
     * determined by applying the provided {@code IntUnaryOperator} function to the end index.
     * This allows for dynamic calculation of the substring start based on the ending position.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the end index is negative,
     * or if the function returns a negative begin index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Get 3 characters before end index
     * Strings.substring("Hello World", i -> i - 3, 8);   // returns "Wor"
     * Strings.substring("Hello World", i -> i - 5, 5);   // returns "Hello"
     * 
     * // Get from start to index
     * Strings.substring("Hello", i -> 0, 3);             // returns "Hel"
     * 
     * // Invalid cases
     * Strings.substring("Hello", i -> i - 3, -1);        // returns null (negative end index)
     * Strings.substring(null, i -> 0, 5);                // returns null
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param funcOfInclusiveBeginIndex function that calculates the begin index based on the end index.
     * @param exclusiveEndIndex the ending index of the substring (exclusive).
     * @return the substring determined by the indices, or {@code null} if the input is invalid.
     * @see StrUtil#substring(String, IntUnaryOperator, int)
     * @see #substring(String, int, int)
     */
    @MayReturnNull
    public static String substring(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex < 0) {
            return null;
        }

        return substring(str, funcOfInclusiveBeginIndex.applyAsInt(exclusiveEndIndex), exclusiveEndIndex);
    }

    /**
     * Returns a substring starting from the first occurrence of the specified character.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfInclusiveBeginIndex} in the string
     * and returns the substring starting from that character (inclusive) to the end of the string.
     * The delimiter character is included in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello World", ' ');        // returns " World"
     * Strings.substring("user@example.com", '@');   // returns "@example.com"
     * Strings.substring("Hello", 'x');              // returns null (not found)
     * Strings.substring("", 'a');                   // returns null (empty string)
     * Strings.substring(null, 'a');                 // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null} or empty
     * @param delimiterOfInclusiveBeginIndex the character marking the start of the substring (inclusive).
     * @return the substring starting from the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, char)
     * @deprecated Use {@link #substringAfter(String, char)} for clearer semantics
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final char delimiterOfInclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        return substring(str, str.indexOf(delimiterOfInclusiveBeginIndex));
    }

    /**
     * Returns a substring starting from the first occurrence of the specified delimiter string.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfInclusiveBeginIndex} in the string
     * and returns the substring starting from that delimiter (inclusive) to the end of the string.
     * The delimiter string is included in the returned substring. If the delimiter is empty,
     * the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello World", "Wo");       // returns "World"
     * Strings.substring("user@example.com", "@");   // returns "@example.com"
     * Strings.substring("Hello", "xyz");            // returns null (not found)
     * Strings.substring("Hello", "");               // returns "Hello" (empty delimiter)
     * Strings.substring(null, "test");              // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfInclusiveBeginIndex the delimiter string marking the start of the substring (inclusive).
     * @return the substring starting from the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @deprecated Use {@link #substringAfter(String, String)} for clearer semantics
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final String delimiterOfInclusiveBeginIndex) {
        if (str == null || delimiterOfInclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfInclusiveBeginIndex.isEmpty()) {
            return str;
        }

        return substring(str, str.indexOf(delimiterOfInclusiveBeginIndex));
    }

    /**
     * Returns a substring between a starting index and the first occurrence of a delimiter character.
     *
     * <p>This method extracts a substring starting from {@code inclusiveBeginIndex} and ending before
     * the first occurrence of {@code delimiterOfExclusiveEndIndex} found after the begin index.
     * The search for the delimiter starts at {@code inclusiveBeginIndex + 1}.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, the begin index is invalid,
     * or if the delimiter is not found after the begin index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello, World!", 0, ',');   // returns "Hello"
     * Strings.substring("a-b-c-d", 2, '-');         // returns "b"
     * Strings.substring("test", 0, 'x');            // returns null (delimiter not found)
     * Strings.substring("test", -1, 't');           // returns null (invalid index)
     * Strings.substring(null, 0, ',');              // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null} or empty
     * @param inclusiveBeginIndex the starting index of the substring (inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (exclusive).
     * @return the substring between the index and delimiter, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final int inclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.isEmpty() || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1);

        // inconsistant behavior
        //    if (index < 0 && str.charAt(inclusiveBeginIndex) == delimiterOfExclusiveEndIndex) {
        //        return EMPTY_STRING;
        //    }

        return substring(str, inclusiveBeginIndex, index);
    }

    /**
     * Returns a substring between a starting index and the first occurrence of a delimiter string.
     *
     * <p>This method extracts a substring starting from {@code inclusiveBeginIndex} and ending before
     * the first occurrence of {@code delimiterOfExclusiveEndIndex} found after the begin index.
     * The search for the delimiter starts at {@code inclusiveBeginIndex + 1}. If the delimiter is empty,
     * an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * the begin index is invalid, or if the delimiter is not found after the begin index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("Hello, World!", 0, ", ");        // returns "Hello"
     * Strings.substring("<tag>content</tag>", 5, "</");   // returns "content"
     * Strings.substring("test", 0, "xyz");                // returns null (delimiter not found)
     * Strings.substring("test", 0, "");                   // returns "" (empty delimiter)
     * Strings.substring(null, 0, "test");                 // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param inclusiveBeginIndex the starting index of the substring (inclusive).
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring (exclusive).
     * @return the substring between the index and delimiter, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        return substring(str, inclusiveBeginIndex, str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1));
    }

    /**
     * Returns a substring from the last occurrence of a delimiter character to a specified end index.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfInclusiveBeginIndex} before
     * {@code exclusiveEndIndex - 1} and returns the substring starting from that delimiter (inclusive)
     * up to the end index (exclusive).</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, the end index is negative,
     * or if the delimiter is not found before the end index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("a-b-c-d", '-', 7);        // returns "-d" (last '-' before index 6)
     * Strings.substring("hello world", ' ', 11);   // returns " world"
     * Strings.substring("test", 'x', 4);           // returns null (delimiter not found)
     * Strings.substring("test", 't', -1);          // returns null (negative index)
     * Strings.substring(null, 'a', 5);             // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null} or empty
     * @param delimiterOfInclusiveBeginIndex the character marking the start of the substring (inclusive).
     * @param exclusiveEndIndex the ending index of the substring (exclusive).
     * @return the substring from the last delimiter to the end index, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final char delimiterOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || str.isEmpty() || exclusiveEndIndex < 0) {
            return null;
        }

        return substring(str, str.lastIndexOf(delimiterOfInclusiveBeginIndex, exclusiveEndIndex - 1), exclusiveEndIndex);
    }

    /**
     * Returns a substring from the last occurrence of a delimiter string to a specified end index.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfInclusiveBeginIndex} before
     * {@code exclusiveEndIndex - delimiterOfInclusiveBeginIndex.length()} and returns the substring
     * starting from that delimiter (inclusive) up to the end index (exclusive). If the delimiter is empty,
     * an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * the end index is negative, or if the delimiter is not found before the adjusted search position.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substring("<a><b><c>", "<", 9);      // returns "<c>" (last '<' before adjusted position)
     * Strings.substring("foo-bar-baz", "-", 11);   // returns "-baz"
     * Strings.substring("test", "xyz", 4);         // returns null (delimiter not found)
     * Strings.substring("test", "", 4);            // returns "" (empty delimiter)
     * Strings.substring(null, "test", 5);          // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfInclusiveBeginIndex the delimiter string marking the start of the substring (inclusive).
     * @param exclusiveEndIndex the ending index of the substring (exclusive).
     * @return the substring from the last delimiter to the end index, or {@code null} if not found.
     * @see #substring(String, int, int)
     * @deprecated Use more explicit substring methods with clear start/end indices
     */
    @MayReturnNull
    @Deprecated
    public static String substring(final String str, final String delimiterOfInclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfInclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfInclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        return substring(str, str.lastIndexOf(delimiterOfInclusiveBeginIndex, exclusiveEndIndex - delimiterOfInclusiveBeginIndex.length()), exclusiveEndIndex);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter character.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * This is useful for extracting content after a known separator.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfter("user@example.com", '@');   // returns "example.com"
     * Strings.substringAfter("Hello World", ' ');        // returns "World"
     * Strings.substringAfter("test", 'x');               // returns null (not found)
     * Strings.substringAfter("test:", ':');              // returns "" (delimiter at end)
     * Strings.substringAfter("", 'a');                   // returns null (empty string)
     * Strings.substringAfter(null, 'a');                 // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null} or empty
     * @param delimiterOfExclusiveBeginIndex the character after which to extract the substring.
     * @return the substring after the delimiter, or {@code null} if the delimiter is not found.
     * @see #substringBefore(String, char)
     * @see #substringAfterLast(String, char)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final char delimiterOfExclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + 1);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter string.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * If the delimiter is empty, the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfter("www.example.com", "www.");   // returns "example.com"
     * Strings.substringAfter("Hello::World", "::");        // returns "World"
     * Strings.substringAfter("NoDelimiter", "xyz");        // returns null (not found)
     * Strings.substringAfter("test", "");                  // returns "test" (empty delimiter)
     * Strings.substringAfter(null, "test");                // returns null
     * Strings.substringAfter("test", null);                // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string after which to extract the substring.
     * @return the substring after the delimiter, or {@code null} if the delimiter is not found.
     * @see #substringBefore(String, String)
     * @see #substringAfterLast(String, String)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return str;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the first occurrence of a delimiter, up to a specified end index.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns the substring after it up to {@code exclusiveEndIndex}. The delimiter itself is not
     * included. If the delimiter is empty, returns the substring from start to the end index.</p>
     *
     * <p>The method returns {@code null} if any input is {@code null}, the end index is negative,
     * the delimiter is not found, or if the delimiter's position would exceed the end index.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfter("Hello, World!", ", ", 10);   // returns "Wo"
     * Strings.substringAfter("a-b-c-d", "-", 5);           // returns "b"
     * Strings.substringAfter("test", "t", 3);              // returns "es"
     * Strings.substringAfter("test", "", 2);               // returns "te" (empty delimiter)
     * Strings.substringAfter("test", "st", 4);             // returns null (delimiter end > endIndex)
     * Strings.substringAfter(null, "test", 5);             // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string after which to extract the substring.
     * @param exclusiveEndIndex the ending index of the substring (exclusive).
     * @return the substring after the delimiter up to the end index, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringBetween(String, String, int)
     */
    @MayReturnNull
    public static String substringAfter(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return substring(str, 0, exclusiveEndIndex);
        } else if (exclusiveEndIndex == 0) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0 || index + delimiterOfExclusiveBeginIndex.length() > exclusiveEndIndex) {
            return null;
        }

        return substring(str, index + delimiterOfExclusiveBeginIndex.length(), exclusiveEndIndex);
    }

    /**
     * Returns the substring after the first occurrence of the specified delimiter, ignoring case.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of
     * {@code delimiterOfExclusiveBeginIndex} in the string and returns everything after it.
     * The delimiter itself is not included in the returned substring. If the delimiter is empty,
     * the entire string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found (case-insensitive).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterIgnoreCase("Hello WORLD", "hello ");   // returns "WORLD"
     * Strings.substringAfterIgnoreCase("user@EXAMPLE.com", "@");   // returns "EXAMPLE.com"
     * Strings.substringAfterIgnoreCase("Test", "TEST");            // returns "" (delimiter is entire string)
     * Strings.substringAfterIgnoreCase("NoMatch", "xyz");          // returns null (not found)
     * Strings.substringAfterIgnoreCase("test", "");                // returns "test" (empty delimiter)
     * Strings.substringAfterIgnoreCase(null, "test");              // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string after which to extract the substring.
     * @return the substring after the delimiter (case-insensitive), or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringAfterLastIgnoreCase(String, String)
     */
    @Beta
    @MayReturnNull
    public static String substringAfterIgnoreCase(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return str;
        }

        final int index = indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter character.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * This is useful for extracting file extensions, last path segments, or final components.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, empty, or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterLast("com.example.App", '.');       // returns "App"
     * Strings.substringAfterLast("/home/user/file.txt", '/');   // returns "file.txt"
     * Strings.substringAfterLast("NoDelimiter", '.');           // returns null (not found)
     * Strings.substringAfterLast("test.", '.');                 // returns "" (delimiter at end)
     * Strings.substringAfterLast("", 'a');                      // returns null (empty string)
     * Strings.substringAfterLast(null, 'a');                    // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null} or empty
     * @param delimiterOfExclusiveBeginIndex the character after which to extract the substring.
     * @return the substring after the last occurrence of the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, char)
     * @see #substringBeforeLast(String, char)
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final char delimiterOfExclusiveBeginIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + 1);
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter string.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveBeginIndex} in the string
     * and returns everything after it. The delimiter itself is not included in the returned substring.
     * If the delimiter is empty, an empty string is returned.</p>
     *
     * <p>The method returns {@code null} if the string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterLast("a.b.c.txt", ".");              // returns "txt"
     * Strings.substringAfterLast("folder1/folder2/file", "/");   // returns "file"
     * Strings.substringAfterLast("NoDelimiter", "::");           // returns null (not found)
     * Strings.substringAfterLast("test::", "::");                // returns "" (delimiter at end)
     * Strings.substringAfterLast("test", "");                    // returns "" (empty delimiter)
     * Strings.substringAfterLast(null, "test");                  // returns null
     * }</pre>
     *
     * @param str the input string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string after which to extract the substring.
     * @return the substring after the last occurrence of the delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     * @see #substringBeforeLast(String, String)
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter within the given range.
     *
     * <p>This method searches for the last occurrence of the delimiter starting from the back of the string,
     * limited by the exclusiveEndIndex. The search is performed in the range [0, exclusiveEndIndex).
     * If found, it returns the substring after the delimiter up to the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the exclusiveEndIndex is negative, the delimiter is not found, or if the delimiter occurs at or beyond
     * the exclusiveEndIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterLast("com.example.Test", ".", 11);   // returns "example"
     * Strings.substringAfterLast("a.b.c.d", ".", 5);             // returns "b"
     * Strings.substringAfterLast("hello", ".", 5);               // returns null (delimiter not found)
     * Strings.substringAfterLast("test.", ".", 5);               // returns "" (empty string after delimiter)
     * Strings.substringAfterLast(null, ".", 5);                  // returns null
     * Strings.substringAfterLast("test", null, 5);               // returns null
     * Strings.substringAfterLast("test", ".", -1);               // returns null
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter to search for, may be {@code null}
     * @param exclusiveEndIndex the exclusive end index for the search range.
     * @return the substring after the last occurrence of the delimiter within the range, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        } else if (exclusiveEndIndex == 0) {
            return null;
        }

        final int lengthOfDelimiter = delimiterOfExclusiveBeginIndex.length();

        final int index = str.lastIndexOf(delimiterOfExclusiveBeginIndex, exclusiveEndIndex - lengthOfDelimiter);

        if (index < 0 || index + lengthOfDelimiter > exclusiveEndIndex) {
            return null;
        }

        return str.substring(index + lengthOfDelimiter, exclusiveEndIndex);
    }

    /**
     * Returns the substring after the last occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the last occurrence of the delimiter in the string.
     * If found, it returns the substring after the delimiter. The comparison ignores differences in case
     * between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterLastIgnoreCase("com.Example.Test", ".example.");   // returns "Test"
     * Strings.substringAfterLastIgnoreCase("COM.EXAMPLE.TEST", ".example.");   // returns "TEST"
     * Strings.substringAfterLastIgnoreCase("test.example", ".EXAMPLE");        // returns ""
     * Strings.substringAfterLastIgnoreCase("hello", ".");                      // returns null
     * Strings.substringAfterLastIgnoreCase(null, ".");                         // returns null
     * Strings.substringAfterLastIgnoreCase("test", null);                      // returns null
     * Strings.substringAfterLastIgnoreCase("test", "");                        // returns ""
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter to search for, case-insensitive, may be {@code null}
     * @return the substring after the last occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringAfterLastIgnoreCase(final String str, final String delimiterOfExclusiveBeginIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveBeginIndex.isEmpty()) {
            return EMPTY;
        }

        final int index = lastIndexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(index + delimiterOfExclusiveBeginIndex.length());
    }

    /**
     * Returns the substring after the first occurrence of any of the specified delimiter characters.
     *
     * <p>This method searches for the first occurrence of any character in the delimiters array.
     * When found, it returns the substring after that delimiter character. The search stops
     * at the first match.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter characters are found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterAny("user@example.com", '@', '.');    // returns "example.com"
     * Strings.substringAfterAny("first.last@domain", '.', '@');   // returns "last@domain"
     * Strings.substringAfterAny("no-delimiters", '@', '.');       // returns null
     * Strings.substringAfterAny("@leading", '@');                 // returns "leading"
     * Strings.substringAfterAny(null, '@');                       // returns null
     * Strings.substringAfterAny("test", null);                    // returns null
     * Strings.substringAfterAny("test", new char[0]);             // returns null
     * 
     * Strings.substringAfterAny("abc", '\uDC00', 'a');            // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.substringAfterAny("abc", '\uDFFF', 'a');            // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimitersOfExclusiveBeginIndex the array of delimiter characters to search for.
     * @return the substring after the first occurrence of any delimiter, or {@code null} if not found.
     * @throws IllegalArgumentException if any char in {@code delimitersOfExclusiveBeginIndex} contains low-surrogate or high-surrogate code unit.
     * @see #substringAfter(String, String)
     */
    @MayReturnNull
    public static String substringAfterAny(final String str, final char... delimitersOfExclusiveBeginIndex) throws IllegalArgumentException {
        checkInputChars(delimitersOfExclusiveBeginIndex, cs.delimitersOfExclusiveBeginIndex, true);

        if (str == null || N.isEmpty(delimitersOfExclusiveBeginIndex)) {
            return null;
        }

        int index = -1;

        for (final char delimiterOfExclusiveBeginIndex : delimitersOfExclusiveBeginIndex) {
            index = str.indexOf(delimiterOfExclusiveBeginIndex);

            if (index >= 0) {
                return str.substring(index + 1);
            }
        }

        return null;
    }

    /**
     * Returns the substring after the first occurrence of any of the specified delimiter strings.
     *
     * <p>This method searches for the first occurrence of any string in the delimiters array.
     * When found, it returns the substring after that delimiter string. The search stops
     * at the first match. Each delimiter is checked in the order provided.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter strings are found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringAfterAny("user@@domain.com", "@@", "@");   // returns "domain.com"
     * Strings.substringAfterAny("Hello World Java", " ", ", ");   // returns "World Java"
     * Strings.substringAfterAny("no-match", "@@", "##");          // returns null
     * Strings.substringAfterAny("@@leading", "@@");               // returns "leading"
     * Strings.substringAfterAny(null, "@@");                      // returns null
     * Strings.substringAfterAny("test", null);                    // returns null
     * Strings.substringAfterAny("test", new String[0]);           // returns null
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimitersOfExclusiveBeginIndex the array of delimiter strings to search for.
     * @return the substring after the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringAfter(String, String)
     */
    @MayReturnNull
    public static String substringAfterAny(final String str, final String... delimitersOfExclusiveBeginIndex) {
        if (str == null || N.isEmpty(delimitersOfExclusiveBeginIndex)) {
            return null;
        }

        String substr = null;

        for (final String delimiterOfExclusiveBeginIndex : delimitersOfExclusiveBeginIndex) {
            substr = substringAfter(str, delimiterOfExclusiveBeginIndex);

            if (substr != null) {
                return substr;
            }
        }

        return null;
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter character.
     *
     * <p>This method searches for the first occurrence of the delimiter character in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null} or if the delimiter
     * character is not found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBefore("user@example.com", '@');   // returns "user"
     * Strings.substringBefore("first.last", '.');         // returns "first"
     * Strings.substringBefore("no-delimiter", '@');       // returns null
     * Strings.substringBefore("@leading", '@');           // returns ""
     * Strings.substringBefore(null, '@');                 // returns null
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter character to search for.
     * @return the substring before the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final char delimiterOfExclusiveEndIndex) {
        if (str == null) {
            return null;
        }

        final int index = str.indexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter string.
     *
     * <p>This method searches for the first occurrence of the delimiter string in the input string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBefore("user@example.com", "@");        // returns "user"
     * Strings.substringBefore("Hello World Java", " World");   // returns "Hello"
     * Strings.substringBefore("no-delimiter", "@");            // returns null
     * Strings.substringBefore("@leading", "@");                // returns ""
     * Strings.substringBefore(null, "@");                      // returns null
     * Strings.substringBefore("test", null);                   // returns null
     * Strings.substringBefore("test", "");                     // returns ""
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, may be {@code null}
     * @return the substring before the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(0, endIndex);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter starting from a given index.
     *
     * <p>This method searches for the first occurrence of the delimiter string starting from the
     * inclusiveBeginIndex + 1. If found, it returns the substring from inclusiveBeginIndex up to
     * (but not including) the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the inclusiveBeginIndex is negative or greater than the string length, the delimiter is not found,
     * or if the delimiter is empty and inclusiveBeginIndex equals the string length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBefore("user@example@com", 5, "@");   // returns "example"
     * Strings.substringBefore("Hello World Java", 6, " ");   // returns "World"
     * Strings.substringBefore("test", 0, "@");               // returns null (delimiter not found)
     * Strings.substringBefore("test@end", 4, "@");           // returns null (no delimiter after index 4)
     * Strings.substringBefore(null, 0, "@");                 // returns null
     * Strings.substringBefore("test", -1, "@");              // returns null
     * Strings.substringBefore("test", 0, "");                // returns ""
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param inclusiveBeginIndex the index to start the substring from (inclusive).
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, may be {@code null}
     * @return the substring from inclusiveBeginIndex to the first occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBefore(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        } else if (inclusiveBeginIndex == str.length()) {
            return null;
        }

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, inclusiveBeginIndex + 1);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, endIndex);
    }

    /**
     * Returns the substring before the first occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the delimiter in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the delimiter. The comparison ignores differences in case between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns an empty string if the delimiter is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeIgnoreCase("User@Example.com", "@EXAMPLE");   // returns "User"
     * Strings.substringBeforeIgnoreCase("HELLO world", " WORLD");          // returns "HELLO"
     * Strings.substringBeforeIgnoreCase("test", "TEST");                   // returns ""
     * Strings.substringBeforeIgnoreCase("no-match", "@");                  // returns null
     * Strings.substringBeforeIgnoreCase(null, "@");                        // returns null
     * Strings.substringBeforeIgnoreCase("test", null);                     // returns null
     * Strings.substringBeforeIgnoreCase("test", "");                       // returns ""
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, case-insensitive, may be {@code null}
     * @return the substring before the first occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBeforeIgnoreCase(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return EMPTY;
        }

        final int endIndex = indexOfIgnoreCase(str, delimiterOfExclusiveEndIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(0, endIndex);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter character.
     *
     * <p>This method searches for the last occurrence of the delimiter character in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, empty, or if the
     * delimiter character is not found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeLast("com.example.Test", '.');   // returns "com.example"
     * Strings.substringBeforeLast("user@example@com", '@');   // returns "user@example"
     * Strings.substringBeforeLast("no-delimiter", '.');       // returns null
     * Strings.substringBeforeLast(".leading", '.');           // returns ""
     * Strings.substringBeforeLast(null, '.');                 // returns null
     * Strings.substringBeforeLast("", '.');                   // returns null
     * }</pre>
     *
     * @param str the string to search in, may be {@code null} or empty
     * @param delimiterOfExclusiveEndIndex the delimiter character to search for.
     * @return the substring before the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.isEmpty()) {
            return null;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter string.
     *
     * <p>This method searches for the last occurrence of the delimiter string in the input string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns the original string if the delimiter is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeLast("com.example.Test", ".");         // returns "com.example"
     * Strings.substringBeforeLast("Hello World World", " World");   // returns "Hello World"
     * Strings.substringBeforeLast("no-delimiter", ".");             // returns null
     * Strings.substringBeforeLast(".leading", ".");                 // returns ""
     * Strings.substringBeforeLast(null, ".");                       // returns null
     * Strings.substringBeforeLast("test", null);                    // returns null
     * Strings.substringBeforeLast("test", "");                      // returns "test"
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, may be {@code null}
     * @return the substring before the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str;
        }

        final int index = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter starting from a given index.
     *
     * <p>This method searches for the last occurrence of the delimiter string in the input string.
     * If found and it occurs at or after the inclusiveBeginIndex, it returns the substring from
     * inclusiveBeginIndex up to (but not including) the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the inclusiveBeginIndex is negative or greater than the string length, the delimiter is not found,
     * or if the delimiter is found before the inclusiveBeginIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeLast("com.example.Test", 4, ".");   // returns "example"
     * Strings.substringBeforeLast("a.b.c.d", 2, ".");            // returns "b.c"
     * Strings.substringBeforeLast("test", 0, ".");               // returns null (delimiter not found)
     * Strings.substringBeforeLast("a.b", 3, ".");                // returns null (delimiter before index)
     * Strings.substringBeforeLast(null, 0, ".");                 // returns null
     * Strings.substringBeforeLast("test", -1, ".");              // returns null
     * Strings.substringBeforeLast("test", 0, "");                // returns "test"
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param inclusiveBeginIndex the index to start the substring from (inclusive).
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, may be {@code null}
     * @return the substring from inclusiveBeginIndex to the last occurrence of the delimiter, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBeforeLast(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || inclusiveBeginIndex < 0 || inclusiveBeginIndex > str.length()) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str.substring(inclusiveBeginIndex);
        } else if (inclusiveBeginIndex == str.length()) {
            return null;
        }

        final int endIndex = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0 || endIndex < inclusiveBeginIndex) {
            return null;
        }

        return str.substring(inclusiveBeginIndex, endIndex);
    }

    /**
     * Returns the substring before the last occurrence of the specified delimiter, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the last occurrence of the delimiter in the string.
     * If found, it returns the substring from the beginning of the string up to (but not including)
     * the last occurrence of the delimiter. The comparison ignores differences in case between the string
     * and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * or if the delimiter is not found. Returns the original string if the delimiter is empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeLastIgnoreCase("Com.Example.TEST", ".test");     // returns "Com.Example"
     * Strings.substringBeforeLastIgnoreCase("HELLO world WORLD", " world");   // returns "HELLO world"
     * Strings.substringBeforeLastIgnoreCase("test", "TEST");                  // returns ""
     * Strings.substringBeforeLastIgnoreCase("no-match", "@");                 // returns null
     * Strings.substringBeforeLastIgnoreCase(null, "@");                       // returns null
     * Strings.substringBeforeLastIgnoreCase("test", null);                    // returns null
     * Strings.substringBeforeLastIgnoreCase("test", "");                      // returns "test"
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string to search for, case-insensitive, may be {@code null}
     * @return the substring before the last occurrence of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBeforeLastIgnoreCase(final String str, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null) {
            return null;
        }

        if (delimiterOfExclusiveEndIndex.isEmpty()) {
            return str;
        }

        final int index = lastIndexOfIgnoreCase(str, delimiterOfExclusiveEndIndex);

        if (index < 0) {
            return null;
        }

        return str.substring(0, index);
    }

    /**
     * Returns the substring before the first occurrence of any of the specified delimiter characters.
     *
     * <p>This method searches for the first occurrence of any character in the delimiters array.
     * When found, it returns the substring from the beginning of the string up to (but not including)
     * that delimiter character. The search stops at the first match.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter characters are found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeAny("user@example.com", '@', '.');    // returns "user"
     * Strings.substringBeforeAny("first.last@domain", '.', '@');   // returns "first"
     * Strings.substringBeforeAny("no-delimiters", '@', '.');       // returns null
     * Strings.substringBeforeAny("@leading", '@');                 // returns ""
     * Strings.substringBeforeAny(null, '@');                       // returns null
     * Strings.substringBeforeAny("test", null);                    // returns null
     * Strings.substringBeforeAny("test", new char[0]);             // returns null
     * 
     * Strings.substringBeforeAny("abc", '\uDC00', 'a');            // throws IllegalArgumentException for Character.isLowSurrogate('\uDC00') is true
     * Strings.substringBeforeAny("abc", '\uDFFF', 'a');            // throws IllegalArgumentException for Character.isHighSurrogate('\uDFFF') is true
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimitersOfExclusiveEndIndex the array of delimiter characters to search for.
     * @return the substring before the first occurrence of any delimiter, or {@code null} if not found.
     * @throws IllegalArgumentException if any char in {@code delimitersOfExclusiveEndIndex} contains low-surrogate or high-surrogate code unit.
     * @see #substringBefore(String, String)
     */
    @MayReturnNull
    public static String substringBeforeAny(final String str, final char... delimitersOfExclusiveEndIndex) throws IllegalArgumentException {
        checkInputChars(delimitersOfExclusiveEndIndex, cs.delimitersOfExclusiveEndIndex, true);

        if (str == null || N.isEmpty(delimitersOfExclusiveEndIndex)) {
            return null;
        }

        int index = -1;

        for (final char delimiterOfExclusiveEndIndex : delimitersOfExclusiveEndIndex) {
            index = str.indexOf(delimiterOfExclusiveEndIndex);

            if (index >= 0) {
                return str.substring(0, index);
            }
        }

        return null;
    }

    /**
     * Returns the substring before the first occurrence of any of the specified delimiter strings.
     *
     * <p>This method searches for the first occurrence of any string in the delimiters array.
     * When found, it returns the substring from the beginning of the string up to (but not including)
     * that delimiter string. The search stops at the first match. Each delimiter is checked in the
     * order provided.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiters array
     * is {@code null} or empty, or if none of the delimiter strings are found in the string.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBeforeAny("user@@domain.com", "@@", "@");       // returns "user"
     * Strings.substringBeforeAny("Hello World Java", " World", " ");   // returns "Hello"
     * Strings.substringBeforeAny("no-match", "@@", "##");              // returns null
     * Strings.substringBeforeAny("@@leading", "@@");                   // returns ""
     * Strings.substringBeforeAny(null, "@@");                          // returns null
     * Strings.substringBeforeAny("test", null);                        // returns null
     * Strings.substringBeforeAny("test", new String[0]);               // returns null
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimitersOfExclusiveEndIndex the array of delimiter strings to search for.
     * @return the substring before the first occurrence of any delimiter, or {@code null} if not found.
     * @see #substringBefore(String, String)
     */
    @MayReturnNull
    public static String substringBeforeAny(final String str, final String... delimitersOfExclusiveEndIndex) {
        if (str == null || N.isEmpty(delimitersOfExclusiveEndIndex)) {
            return null;
        }

        String substr = null;

        for (final String delimiterOfExclusiveEndIndex : delimitersOfExclusiveEndIndex) {
            substr = substringBefore(str, delimiterOfExclusiveEndIndex);

            if (substr != null) {
                return substr;
            }
        }

        return null;
    }

    /**
     * Returns the substring between two specified indices.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending at exclusiveEndIndex - 1. The character at exclusiveBeginIndex and the character at
     * exclusiveEndIndex are not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveBeginIndex is less than -1,
     * exclusiveBeginIndex is greater than or equal to exclusiveEndIndex, or exclusiveBeginIndex is greater than
     * or equal to the string length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("abcdef", 0, 3);    // returns "bc"
     * Strings.substringBetween("abcdef", -1, 3);   // returns "abc"
     * Strings.substringBetween("abcdef", 2, 6);    // returns "def"
     * Strings.substringBetween("abcdef", 2, 10);   // returns "def" (endIndex capped at length)
     * Strings.substringBetween(null, 0, 3);        // returns null
     * Strings.substringBetween("test", 3, 3);      // returns null (beginIndex >= endIndex)
     * Strings.substringBetween("test", -2, 3);     // returns null (beginIndex < -1)
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param exclusiveBeginIndex the exclusive beginning index (the character at this index is not included).
     * @param exclusiveEndIndex the exclusive ending index (the character at this index is not included).
     * @return the substring between the specified indices, or {@code null} if the indices are invalid.
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= exclusiveEndIndex || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        return str.substring(exclusiveBeginIndex + 1, N.min(exclusiveEndIndex, str.length()));
    }

    /**
     * Returns the substring between a specified index and the first occurrence of a delimiter character.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending before the first occurrence of the delimiter character found after that position.
     * The delimiter itself is not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveBeginIndex is less than -1,
     * exclusiveBeginIndex is greater than or equal to the string length, or if the delimiter is not found
     * after the exclusiveBeginIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("user@example.com", 3, '@');   // returns "r"
     * Strings.substringBetween("a,b,c,d", 1, ',');            // returns "b"
     * Strings.substringBetween("test", -1, 's');              // returns "te"
     * Strings.substringBetween("test", 2, 'x');               // returns null (delimiter not found)
     * Strings.substringBetween(null, 0, '@');                 // returns null
     * Strings.substringBetween("test", 4, '@');               // returns null (beginIndex >= length)
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param exclusiveBeginIndex the exclusive beginning index (the character at this index is not included).
     * @param delimiterOfExclusiveEndIndex the delimiter character marking the end of the substring.
     * @return the substring between the index and the delimiter, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int startIndex = exclusiveBeginIndex + 1;
        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between a specified index and the first occurrence of a delimiter string.
     *
     * <p>This method extracts a substring from the input string starting from exclusiveBeginIndex + 1
     * and ending before the first occurrence of the delimiter string found after that position.
     * The delimiter itself is not included in the result.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * exclusiveBeginIndex is less than -1, exclusiveBeginIndex is greater than or equal to the string length,
     * or if the delimiter is not found after the exclusiveBeginIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("Hello World Java", 5, " ");    // returns "World"
     * Strings.substringBetween("user@@domain.com", 3, "@@");   // returns "r"
     * Strings.substringBetween("test", -1, "st");              // returns "te"
     * Strings.substringBetween("test", 2, "xyz");              // returns null (delimiter not found)
     * Strings.substringBetween(null, 0, "@");                  // returns null
     * Strings.substringBetween("test", 0, null);               // returns null
     * Strings.substringBetween("test", 4, "@");                // returns null (beginIndex >= length)
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param exclusiveBeginIndex the exclusive beginning index (the character at this index is not included).
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, may be {@code null}
     * @return the substring between the index and the delimiter, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int startIndex = exclusiveBeginIndex + 1;
        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between the first occurrence of a delimiter character and a specified index.
     *
     * <p>This method searches for the first occurrence of the delimiter character in the string.
     * If found and it occurs before the exclusiveEndIndex, it returns the substring starting after
     * the delimiter and ending before the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, exclusiveEndIndex is less than
     * or equal to 0, the delimiter is not found, or if the delimiter occurs at or after the exclusiveEndIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("user@example", '@', 11);   // returns "example"
     * Strings.substringBetween("a,b,c", ',', 3);           // returns "b"
     * Strings.substringBetween("test", 't', 4);            // returns "es"
     * Strings.substringBetween("test", 'x', 4);            // returns null (delimiter not found)
     * Strings.substringBetween("test", 't', 1);            // returns null (delimiter at or after endIndex)
     * Strings.substringBetween(null, '@', 5);              // returns null
     * Strings.substringBetween("test", '@', 0);            // returns null (endIndex <= 0)
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter character marking the beginning of the substring.
     * @param exclusiveEndIndex the exclusive ending index (the character at this index is not included).
     * @return the substring between the delimiter and the index, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex <= 0) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0 || startIndex >= exclusiveEndIndex) {
            return null;
        }

        startIndex += 1;

        if (startIndex > exclusiveEndIndex) {
            return null;
        }

        return str.substring(startIndex, exclusiveEndIndex);
    }

    /**
     * Returns the substring between the first occurrence of a delimiter string and a specified index.
     *
     * <p>This method searches for the first occurrence of the delimiter string in the input string.
     * If found and it occurs before the exclusiveEndIndex, it returns the substring starting after
     * the delimiter and ending before the exclusiveEndIndex.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * exclusiveEndIndex is negative, the delimiter is not found, or if the delimiter's end position is
     * greater than the exclusiveEndIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("Hello World Java", " ", 11);   // returns "World"
     * Strings.substringBetween("user@@domain", "@@", 13);      // returns "domain"
     * Strings.substringBetween("test", "es", 4);               // returns "t"
     * Strings.substringBetween("test", "xyz", 4);              // returns null (delimiter not found)
     * Strings.substringBetween("test", "st", 2);               // returns null (delimiter ends after endIndex)
     * Strings.substringBetween(null, "@", 5);                  // returns null
     * Strings.substringBetween("test", null, 5);               // returns null
     * Strings.substringBetween("test", "@", -1);               // returns null (endIndex < 0)
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, may be {@code null}
     * @param exclusiveEndIndex the exclusive ending index (the character at this index is not included).
     * @return the substring between the delimiter and the index, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || exclusiveEndIndex < 0) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0 || startIndex > exclusiveEndIndex) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        if (startIndex > exclusiveEndIndex) {
            return null;
        }

        return str.substring(startIndex, exclusiveEndIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter character.
     *
     * <p>This method searches for the first occurrence of the delimiter character, then searches for
     * the next occurrence of the same delimiter character after the first one. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the string length is 1 or less,
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("a,b,c", ',', ',');        // returns "b"
     * Strings.substringBetween("'quoted'", '\'', '\'');   // returns "quoted"
     * Strings.substringBetween("test", 't', 't');         // returns "es"
     * Strings.substringBetween("abc", 'a', 'c');          // returns "b"
     * Strings.substringBetween("no-match", 'x', 'y');     // returns null (first delimiter not found)
     * Strings.substringBetween("a,b", ',', ',');          // returns null (second delimiter not found)
     * Strings.substringBetween(null, ',', ',');           // returns null
     * Strings.substringBetween("", ',', ',');             // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter character marking the beginning of the substring.
     * @param delimiterOfExclusiveEndIndex the delimiter character marking the end of the substring.
     * @return the substring between the two delimiter occurrences, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        if (str == null || str.length() <= 1) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return null;
        }

        // even delimiterOfExclusiveBeginIndex and delimiterOfExclusiveEndIndex are equal, but should consider them as different chars. see: substringBetween(String str, String tag)
        //    if (delimiterOfExclusiveBeginIndex == delimiterOfExclusiveEndIndex) {
        //        return EMPTY_STRING;
        //    }

        startIndex += 1;

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter string.
     *
     * <p>This method searches for the first occurrence of the delimiter string, then searches for
     * the next occurrence of the same delimiter string after the first one. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("#content#", "#");             // returns "content"
     * Strings.substringBetween("<tag>value<tag>", "<tag>");   // returns "value"
     * Strings.substringBetween("@@text@@", "@@");             // returns "text"
     * Strings.substringBetween("no-match", "[[");             // returns null (delimiter not found)
     * Strings.substringBetween("[[only-one", "[[");           // returns null (second delimiter not found)
     * Strings.substringBetween(null, "[[");                   // returns null
     * Strings.substringBetween("test", null);                 // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiter the delimiter string marking both the beginning and end of the substring, may be {@code null}
     * @return the substring between two occurrences of the delimiter, or {@code null} if not found or the specified source string is empty or {@code null}.
     * @see #substringBetween(String, String, String)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiter) {
        return substringBetween(str, delimiter, delimiter);
    }

    /**
     * Returns the substring between two different delimiter strings.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter, then searches for
     * the first occurrence of the ending delimiter after the beginning delimiter. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * the beginning delimiter is not found, or the ending delimiter is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("<tag>content</tag>", "<tag>", "</tag>");            // returns "content"
     * Strings.substringBetween("[[start]]middle[[end]]", "[[start]]", "[[end]]");   // returns "middle"
     * Strings.substringBetween("Hello [World]!", "[", "]");                         // returns "World"
     * Strings.substringBetween("no-match", "[[", "]]");                             // returns null (begin delimiter not found)
     * Strings.substringBetween("[[no-end", "[[", "]]");                             // returns null (end delimiter not found)
     * Strings.substringBetween(null, "[[", "]]");                                   // returns null
     * Strings.substringBetween("test", null, "]]");                                 // returns null
     * Strings.substringBetween("test", "[[", null);                                 // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, may be {@code null}
     * @return the substring between the two delimiters, or {@code null} if not found.
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringBetween(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
    }

    /**
     * Returns the substring between two delimiter strings, starting the search from a specified index.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter starting from the fromIndex.
     * If fromIndex is less than or equal to 0, the search starts from the beginning of the string.
     * Then it searches for the first occurrence of the ending delimiter after the beginning delimiter.
     * If both are found, it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * fromIndex is greater than the string length, the beginning delimiter is not found, or the ending delimiter
     * is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetween("<a>text1</a><a>text2</a>", 5, "<a>", "</a>");   // returns "text2"
     * Strings.substringBetween("{{x}}{{y}}", 3, "{{", "}}");                    // returns "y"
     * Strings.substringBetween("Hello World", 0, "Hello", "World");             // returns " "
     * Strings.substringBetween("test", 10, "t", "t");                           // returns null (fromIndex > length)
     * Strings.substringBetween("no-match", 0, "{{", "}}");                      // returns null (delimiter not found)
     * Strings.substringBetween(null, 0, "{{", "}}");                            // returns null
     * Strings.substringBetween("test", 0, null, "}}");                          // returns null
     * Strings.substringBetween("test", 0, "{{", null);                          // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param fromIndex the index to start searching from. If less than or equal to 0, search starts from the beginning.
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, may be {@code null}
     * @return the substring between the two delimiters, or {@code null} if not found.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null || fromIndex > str.length()) {
            return null;
        }

        int startIndex = fromIndex <= 0 ? str.indexOf(delimiterOfExclusiveBeginIndex) : str.indexOf(delimiterOfExclusiveBeginIndex, fromIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = str.indexOf(delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Returns the substring between two occurrences of the same delimiter string, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the delimiter string,
     * then searches for the next occurrence of the same delimiter string after the first one.
     * If both are found, it returns the substring between them (exclusive of both delimiters).
     * The comparison ignores differences in case between the string and the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the first delimiter is not found, or the second delimiter is not found after the first one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenIgnoreCaes("#CONTENT#", "#");             // returns "CONTENT"
     * Strings.substringBetweenIgnoreCaes("<TAG>value<TAG>", "<tag>");   // returns "value"
     * Strings.substringBetweenIgnoreCaes("@@Text@@", "@@");             // returns "Text"
     * Strings.substringBetweenIgnoreCaes("no-match", "[[");             // returns null (delimiter not found)
     * Strings.substringBetweenIgnoreCaes("[[only-one", "[[");           // returns null (second delimiter not found)
     * Strings.substringBetweenIgnoreCaes(null, "[[");                   // returns null
     * Strings.substringBetweenIgnoreCaes("test", null);                 // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiter the delimiter string marking both the beginning and end of the substring, case-insensitive, may be {@code null}
     * @return the substring between two occurrences of the delimiter (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final String delimiter) {
        return substringBetweenIgnoreCaes(str, delimiter, delimiter);
    }

    /**
     * Returns the substring between two different delimiter strings, ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the beginning delimiter,
     * then searches for the first occurrence of the ending delimiter after the beginning delimiter.
     * If both are found, it returns the substring between them (exclusive of both delimiters).
     * The comparison ignores differences in case between the string and the delimiters.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * the beginning delimiter is not found, or the ending delimiter is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenIgnoreCaes("<TAG>content</TAG>", "<tag>", "</tag>");            // returns "content"
     * Strings.substringBetweenIgnoreCaes("[[START]]middle[[END]]", "[[start]]", "[[end]]");   // returns "middle"
     * Strings.substringBetweenIgnoreCaes("Hello [WORLD]!", "[", "]");                         // returns "WORLD"
     * Strings.substringBetweenIgnoreCaes("no-match", "[[", "]]");                             // returns null (begin delimiter not found)
     * Strings.substringBetweenIgnoreCaes("[[no-end", "[[", "]]");                             // returns null (end delimiter not found)
     * Strings.substringBetweenIgnoreCaes(null, "[[", "]]");                                   // returns null
     * Strings.substringBetweenIgnoreCaes("test", null, "]]");                                 // returns null
     * Strings.substringBetweenIgnoreCaes("test", "[[", null);                                 // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, case-insensitive, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, case-insensitive, may be {@code null}
     * @return the substring between the two delimiters (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringBetweenIgnoreCaes(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
    }

    /**
     * Returns the substring between two delimiter strings, starting the search from a specified index and ignoring case considerations.
     *
     * <p>This method performs a case-insensitive search for the first occurrence of the beginning delimiter
     * starting from the fromIndex. If fromIndex is less than or equal to 0, the search starts from the
     * beginning of the string. Then it searches for the first occurrence of the ending delimiter after
     * the beginning delimiter. If both are found, it returns the substring between them (exclusive of
     * both delimiters). The comparison ignores differences in case between the string and the delimiters.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * fromIndex is greater than the string length, the beginning delimiter is not found, or the ending delimiter
     * is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenIgnoreCaes("<A>text1</A><A>text2</A>", 5, "<a>", "</a>");   // returns "text2"
     * Strings.substringBetweenIgnoreCaes("{{X}}{{Y}}", 3, "{{", "}}");                    // returns "Y"
     * Strings.substringBetweenIgnoreCaes("HELLO world", 0, "hello", "WORLD");             // returns " "
     * Strings.substringBetweenIgnoreCaes("test", 10, "t", "t");                           // returns null (fromIndex > length)
     * Strings.substringBetweenIgnoreCaes("no-match", 0, "{{", "}}");                      // returns null (delimiter not found)
     * Strings.substringBetweenIgnoreCaes(null, 0, "{{", "}}");                            // returns null
     * Strings.substringBetweenIgnoreCaes("test", 0, null, "}}");                          // returns null
     * Strings.substringBetweenIgnoreCaes("test", 0, "{{", null);                          // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param fromIndex the index to start searching from. If less than or equal to 0, search starts from the beginning.
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, case-insensitive, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, case-insensitive, may be {@code null}
     * @return the substring between the two delimiters (case-insensitive), or {@code null} if not found.
     */
    @Beta
    @MayReturnNull
    public static String substringBetweenIgnoreCaes(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null || fromIndex > str.length()) {
            return null;
        }

        int startIndex = fromIndex <= 0 ? indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex)
                : indexOfIgnoreCase(str, delimiterOfExclusiveBeginIndex, fromIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = indexOfIgnoreCase(str, delimiterOfExclusiveEndIndex, startIndex);

        if (endIndex < 0) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Extracts a substring between two exclusive indices, where the end index is calculated by a function.
     *
     * <p>This method extracts a substring from the input string starting from {@code exclusiveBeginIndex + 1}
     * and ending at the position calculated by {@code funcOfExclusiveEndIndex.applyAsInt(exclusiveBeginIndex)}.
     * Both the begin and end indices are exclusive, meaning the characters at these positions are not included
     * in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the begin index is less than -1
     * or greater than or equal to the string length, or if the calculated end index is invalid.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract substring with dynamic end index
     * Strings.substringBetween("Hello World", 0, i -> i + 6);   // returns "ello "
     * Strings.substringBetween("Hello World", 5, i -> i + 6);   // returns " World"
     * Strings.substringBetween("Hello World", -1, i -> 5);      // returns "Hello"
     * 
     * // Invalid cases
     * Strings.substringBetween(null, 0, i -> 5);                // returns null
     * Strings.substringBetween("Hello", 10, i -> 15);           // returns null
     * Strings.substringBetween("Hello", 2, i -> 2);             // returns null (end <= begin)
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param exclusiveBeginIndex the exclusive beginning index (the character at this index is not included).
     * @param funcOfExclusiveEndIndex a function that calculates the exclusive end index based on the begin index.
     * @return the substring between the specified indices, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final int exclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || exclusiveBeginIndex < -1 || exclusiveBeginIndex >= str.length()) {
            return null;
        }

        final int endIndex = N.min(funcOfExclusiveEndIndex.applyAsInt(exclusiveBeginIndex), str.length());

        if (endIndex < 0 || endIndex <= exclusiveBeginIndex) {
            return null;
        }

        return str.substring(exclusiveBeginIndex + 1, endIndex);
    }

    /**
     * Extracts a substring between two exclusive indices, where the begin index is calculated by a function.
     *
     * <p>This method extracts a substring from the input string starting from a position calculated by
     * {@code funcOfExclusiveBeginIndex.applyAsInt(exclusiveEndIndex) + 1} and ending at {@code exclusiveEndIndex}.
     * Both the begin and end indices are exclusive, meaning the characters at these positions are not included
     * in the returned substring.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the end index is less than or equal to 0,
     * or if the calculated begin index is invalid.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract substring with dynamic begin index
     * Strings.substringBetween("Hello World", i -> i - 6, 11);   // returns "World"
     * Strings.substringBetween("Hello World", i -> -1, 5);       // returns "Hello"
     * Strings.substringBetween("Hello World", i -> 2, 8);        // returns "lo Wo"
     * 
     * // Invalid cases
     * Strings.substringBetween(null, i -> 0, 5);                 // returns null
     * Strings.substringBetween("Hello", i -> 0, 0);              // returns null (end <= 0)
     * Strings.substringBetween("Hello", i -> 5, 3);              // returns null (begin >= end)
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param funcOfExclusiveBeginIndex a function that calculates the exclusive begin index based on the end index.
     * @param exclusiveEndIndex the exclusive ending index (the character at this index is not included).
     * @return the substring between the specified indices, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final int exclusiveEndIndex) {
        if (str == null || exclusiveEndIndex <= 0) {
            return null;
        }

        final int endIndex = N.min(exclusiveEndIndex, str.length());
        int startIndex = funcOfExclusiveBeginIndex.applyAsInt(endIndex);

        if (startIndex < -1 || startIndex >= endIndex) {
            return null;
        }

        return str.substring(startIndex + 1, endIndex);
    }

    /**
     * Extracts a substring between a delimiter and a calculated end index.
     *
     * <p>This method finds the first occurrence of {@code delimiterOfExclusiveBeginIndex} in the input string,
     * then extracts a substring starting from the position after this delimiter and ending at the position
     * calculated by {@code funcOfExclusiveEndIndex.applyAsInt(startIndex)}, where {@code startIndex} is the
     * position right after the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the delimiter is {@code null}
     * or not found, if the delimiter length is greater than or equal to the string length, or if the calculated
     * end index is invalid.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract substring after delimiter with dynamic end
     * Strings.substringBetween("Hello:World", ":", i -> i + 5);   // returns "World"
     * Strings.substringBetween("A=B=C", "=", i -> i + 1);         // returns "B"
     * Strings.substringBetween("[content]", "[", i -> i + 7);     // returns "content"
     * 
     * // Invalid cases
     * Strings.substringBetween(null, ":", i -> 5);                // returns null
     * Strings.substringBetween("Hello", "x", i -> 10);            // returns null (delimiter not found)
     * Strings.substringBetween("Hello", "Hello", i -> 10);        // returns null (delimiter too long)
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter marking the beginning of the substring (non-inclusive).
     * @param funcOfExclusiveEndIndex a function that calculates the exclusive end index based on the start index after the delimiter.
     * @return the substring between the delimiter and calculated end index, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveBeginIndex.length() >= str.length()) {
            return null;
        }

        int startIndex = str.indexOf(delimiterOfExclusiveBeginIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = N.min(funcOfExclusiveEndIndex.applyAsInt(startIndex), str.length());

        if (endIndex < 0 || endIndex < startIndex) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Extracts a substring between a calculated begin index and a delimiter.
     *
     * <p>This method finds the last occurrence of {@code delimiterOfExclusiveEndIndex} in the input string,
     * then extracts a substring starting from a position calculated by
     * {@code funcOfExclusiveBeginIndex.applyAsInt(endIndex) + 1} and ending at the position of the delimiter,
     * where {@code endIndex} is the position of the last occurrence of the delimiter.</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, if the delimiter is {@code null}
     * or not found, if the delimiter length is greater than or equal to the string length, or if the calculated
     * begin index is invalid.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract substring with dynamic begin before delimiter
     * Strings.substringBetween("Hello:World", i -> i - 5, ":");   // returns "Hello"
     * Strings.substringBetween("A=B=C", i -> i - 1, "=");         // returns "B"
     * Strings.substringBetween("[content]", i -> 0, "]");         // returns "content"
     * 
     * // Invalid cases
     * Strings.substringBetween(null, i -> 0, ":");                // returns null
     * Strings.substringBetween("Hello", i -> 0, "x");             // returns null (delimiter not found)
     * Strings.substringBetween("Hello", i -> 0, "Hello");         // returns null (delimiter too long)
     * }</pre>
     *
     * @param str the input string from which to extract the substring, may be {@code null}
     * @param funcOfExclusiveBeginIndex a function that calculates the exclusive begin index based on the end index of the delimiter.
     * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (non-inclusive).
     * @return the substring between the calculated begin index and delimiter, or {@code null} if invalid parameters are provided.
     * @see #substringBetween(String, int, int)
     */
    @MayReturnNull
    public static String substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveEndIndex == null || delimiterOfExclusiveEndIndex.length() >= str.length()) {
            return null;
        }

        final int endIndex = N.min(str.lastIndexOf(delimiterOfExclusiveEndIndex), str.length());

        if (endIndex < 0) {
            return null;
        }

        final int startIndex = funcOfExclusiveBeginIndex.applyAsInt(endIndex);

        if (startIndex < -1 || startIndex >= endIndex) {
            return null;
        }

        return str.substring(startIndex + 1, endIndex);
    }

    /**
     * Returns the substring between the first and last occurrences of the same delimiter string.
     *
     * <p>This method searches for the first occurrence of the delimiter string, then searches for
     * the last occurrence of the same delimiter string in the input string. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, the delimiter is {@code null},
     * the first delimiter is not found, or the last delimiter is not found after the first one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenFirstAndLast("[middle[]]", "[");            // returns "middle"
     * Strings.substringBetweenFirstAndLast("<tag>value<tag>", "<tag>");   // returns "value"
     * Strings.substringBetweenFirstAndLast("@@text@@", "@@");             // returns "text"
     * Strings.substringBetweenFirstAndLast("no-match", "[[");             // returns null (delimiter not found)
     * Strings.substringBetweenFirstAndLast("[[only-one", "[[");           // returns null (last delimiter not found)
     * Strings.substringBetweenFirstAndLast(null, "[[");                   // returns null
     * Strings.substringBetweenFirstAndLast("test", null);                 // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiter the delimiter string marking both the beginning and end of the substring, may be {@code null}
     * @return the substring between the first and last occurrences of the delimiter, or {@code null} if not found.
     * @see StrUtil#substringBetweenFirstAndLast(String, String)
     */
    @MayReturnNull
    public static String substringBetweenFirstAndLast(final String str, final String delimiter) {
        return substringBetweenFirstAndLast(str, delimiter, delimiter);
    }

    /**
     * Returns the substring between two different delimiter strings, using the first occurrence of the
     * beginning delimiter and the last occurrence of the ending delimiter.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter, then searches for
     * the last occurrence of the ending delimiter in the input string. If both are found,
     * it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * the beginning delimiter is not found, or the ending delimiter is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenFirstAndLast("[middle[]]", "[", "]");                    // returns "middle[]"
     * Strings.substringBetweenFirstAndLast("<tag>content</tag>", "<tag>", "</tag>");   // returns "content"
     * Strings.substringBetweenFirstAndLast("Hello [World]!", "[", "]");                // returns "World"
     * Strings.substringBetweenFirstAndLast("no-match", "[[", "]]");                    // returns null (begin delimiter not found)
     * Strings.substringBetweenFirstAndLast("[[no-end", "[[", "]]");                    // returns null (last delimiter not found)
     * Strings.substringBetweenFirstAndLast(null, "[[", "]]");                          // returns null
     * Strings.substringBetweenFirstAndLast("test", null, "]]");                        // returns null
     * Strings.substringBetweenFirstAndLast("test", "[[", null);                        // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, may be {@code null}
     * @return the substring between the two delimiters, or {@code null} if not found.
     * @see StrUtil#substringBetweenFirstAndLast(String, String, String)
     */
    @MayReturnNull
    public static String substringBetweenFirstAndLast(final String str, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        return substringBetweenFirstAndLast(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
    }

    /**
     * Returns the substring between two delimiter strings, using the first occurrence of the beginning
     * delimiter and the last occurrence of the ending delimiter, starting the search from a specified index.
     *
     * <p>This method searches for the first occurrence of the beginning delimiter starting from the fromIndex.
     * If fromIndex is less than or equal to 0, the search starts from the beginning of the string.
     * Then it searches for the last occurrence of the ending delimiter in the input string.
     * If both are found, it returns the substring between them (exclusive of both delimiters).</p>
     *
     * <p>The method returns {@code null} if the input string is {@code null}, either delimiter is {@code null},
     * fromIndex is greater than the string length, the beginning delimiter is not found, or the ending delimiter
     * is not found after the beginning delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.substringBetweenFirstAndLast("<<data>>more<<data>>", 2, "<<", ">>");   // returns "data"
     * Strings.substringBetweenFirstAndLast("{{x}}{{y}}", 3, "{{", "}}");             // returns "y"
     * Strings.substringBetweenFirstAndLast("Hello World", 0, "Hello", "World");      // returns " "
     * Strings.substringBetweenFirstAndLast("test", 10, "t", "t");                    // returns null (fromIndex > length)
     * Strings.substringBetweenFirstAndLast("no-match", 0, "{{", "}}");               // returns null (delimiter not found)
     * Strings.substringBetweenFirstAndLast(null, 0, "{{", "}}");                     // returns null
     * Strings.substringBetweenFirstAndLast("test", 0, null, "}}");                   // returns null
     * Strings.substringBetweenFirstAndLast("test", 0, "{{", null);                   // returns null
     * }</pre>
     *
     * @param str the string to extract from, may be {@code null}
     * @param fromIndex the index to start searching from. If less than or equal to 0, search starts from the beginning.
     * @param delimiterOfExclusiveBeginIndex the delimiter string marking the beginning of the substring, may be {@code null}
     * @param delimiterOfExclusiveEndIndex the delimiter string marking the end of the substring, may be {@code null}
     * @return the substring between the two delimiters, or {@code null} if not found.
     * @see StrUtil#substringBetweenFirstAndLast(String, int, String, String)
     */
    @MayReturnNull
    public static String substringBetweenFirstAndLast(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        if (str == null || delimiterOfExclusiveBeginIndex == null || delimiterOfExclusiveEndIndex == null || fromIndex > str.length()) {
            return null;
        }

        int startIndex = fromIndex <= 0 ? str.indexOf(delimiterOfExclusiveBeginIndex) : str.indexOf(delimiterOfExclusiveBeginIndex, fromIndex);

        if (startIndex < 0) {
            return null;
        }

        startIndex += delimiterOfExclusiveBeginIndex.length();

        final int endIndex = str.lastIndexOf(delimiterOfExclusiveEndIndex);

        if (endIndex < 0 || endIndex < startIndex) {
            return null;
        }

        return str.substring(startIndex, endIndex);
    }

    /**
     * Finds all substrings between specified character delimiters.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters. It uses the default extraction strategy which performs simple
     * sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract content between brackets
     * Strings.substringsBetween("3[a]2[b]", '[', ']');             // returns ["a", "b"]
     * Strings.substringsBetween("(hello)(world)", '(', ')');       // returns ["hello", "world"]
     * Strings.substringsBetween("<tag>content</tag>", '<', '>');   // returns ["tag", "/tag"]
     * 
     * // Empty results
     * Strings.substringsBetween(null, '[', ']');                   // returns []
     * Strings.substringsBetween("no delimiters", '[', ']');        // returns []
     * Strings.substringsBetween("", '[', ']');                     // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified character delimiters using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // With nested delimiters
     * String str = "3[a2[c]]2[a]";
     * Strings.substringsBetween(str, '[', ']', ExtractStrategy.DEFAULT);         // returns ["a2[c", "a"]
     * Strings.substringsBetween(str, '[', ']', ExtractStrategy.STACK_BASED);     // returns ["c", "a2[c]", "a"]
     * Strings.substringsBetween(str, '[', ']', ExtractStrategy.IGNORE_NESTED);   // returns ["a2[c]", "a"]
     * 
     * // Simple cases
     * Strings.substringsBetween("(a)(b)", '(', ')', ExtractStrategy.DEFAULT);    // returns ["a", "b"]
     * Strings.substringsBetween(null, '[', ']', ExtractStrategy.DEFAULT);        // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        return substringsBetween(str, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex), extractStrategy);
    }

    /**
     * Finds all substrings between specified character delimiters within a given range.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter characters.
     * It uses the default extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null} or if no matches are found
     * within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Search within specific range
     * Strings.substringsBetween("a[b]c[d]e[f]", 2, 8, '[', ']');   // returns ["b", "d"]
     * Strings.substringsBetween("(1)(2)(3)", 0, 6, '(', ')');      // returns ["1", "2"]
     * Strings.substringsBetween("no match", 0, 8, '[', ']');       // returns []
     * 
     * // Edge cases
     * Strings.substringsBetween("a[b]c", 4, 5, '[', ']');          // returns []
     * Strings.substringsBetween(null, 0, 5, '[', ']');             // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the index to start the search from (inclusive).
     * @param toIndex the index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final char delimiterOfExclusiveBeginIndex,
            final char delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, fromIndex, toIndex, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                ExtractStrategy.DEFAULT, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings. It uses the default extraction strategy which performs simple
     * sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract content between string delimiters
     * Strings.substringsBetween("a<tag>b</tag>c<tag>d</tag>", "<tag>", "</tag>");   // returns ["b", "d"]
     * Strings.substringsBetween("start:middle:end", "start:", ":end");              // returns ["middle"]
     * Strings.substringsBetween("[[content]]", "[[", "]]");                         // returns ["content"]
     * 
     * // Empty results
     * Strings.substringsBetween(null, "<", ">");                                    // returns []
     * Strings.substringsBetween("no match", "<", ">");                              // returns []
     * Strings.substringsBetween("test", null, ">");                                 // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified string delimiters using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * Strings.substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.DEFAULT);         // returns ["a2[c", "a"]
     * Strings.substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.STACK_BASED);     // returns ["c", "a2[c]", "a"]
     * Strings.substringsBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.IGNORE_NESTED);   // returns ["a2[c]", "a"]
     * 
     * // String: [[b[a]]c]
     * Strings.substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.DEFAULT);            // returns ["[b[a"]
     * Strings.substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.STACK_BASED);        // returns ["a", "b[a]", "[b[a]]c"]
     * Strings.substringsBetween("[[b[a]]c]", "[", "]", ExtractStrategy.IGNORE_NESTED);      // returns ["[b[a]]c"]
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringsBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<String> substringsBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        return substringsBetween(str, 0, N.len(str), delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter strings.
     * It uses the default extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * or if no matches are found within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Search within specific range
     * Strings.substringsBetween("a<b>c<d>e<f>", 2, 10, "<", ">");        // returns ["b", "d"]
     * Strings.substringsBetween("[[1]][[2]][[3]]", 0, 10, "[[", "]]");   // returns ["1", "2"]
     * Strings.substringsBetween("no match", 0, 8, "<", ">");             // returns []
     * 
     * // Edge cases
     * Strings.substringsBetween("a<b>c", 4, 5, "<", ">");                // returns []
     * Strings.substringsBetween(null, 0, 5, "<", ">");                   // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the index to start the search from (inclusive).
     * @param toIndex the index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        return substringsBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT,
                Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range using the given extraction strategy.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for occurrences of text between the specified beginning and ending delimiter strings, up to a maximum
     * count specified by {@code maxCount}. The extraction strategy determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null},
     * if {@code maxCount} is 0, or if no matches are found within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extract with different strategies
     * String str = "3[a2[c]]2[a]";
     * Strings.substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.DEFAULT, 10);         // returns ["a2[c", "a"]
     * Strings.substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.STACK_BASED, 10);     // returns ["c", "a2[c]", "a"]
     * Strings.substringsBetween(str, 0, str.length(), "[", "]", ExtractStrategy.IGNORE_NESTED, 10);   // returns ["a2[c]", "a"]
     * 
     * // Limit results
     * Strings.substringsBetween("a[b]c[d]e[f]", 0, 15, "[", "]", ExtractStrategy.DEFAULT, 2);         // returns ["b", "d"]
     * Strings.substringsBetween("test", 0, 4, "[", "]", ExtractStrategy.DEFAULT, 0);                  // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the index to start the search from (inclusive).
     * @param toIndex the index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @param maxCount the maximum number of substrings to extract; if {@code Integer.MAX_VALUE}, all matching substrings will be extracted.
     * @return a list of matched substrings, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @throws IllegalArgumentException if maxCount is negative or extractStrategy is {@code null}.
     * @see #substringsBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<String> substringsBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex, final ExtractStrategy extractStrategy, final int maxCount) {

        final List<int[]> substringIndices = substringIndicesBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex,
                extractStrategy, maxCount);

        final List<String> res = new ArrayList<>(substringIndices.size());

        for (final int[] e : substringIndices) {
            res.add(str.substring(e[0], e[1]));
        }

        return res;

    }

    /**
     * Finds all substrings between specified character delimiters and returns their indices.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). It uses the default
     * extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Get indices of content between brackets
     * Strings.substringIndicesBetween("3[a]2[b]", '[', ']');          // returns [[2, 3], [6, 7]]
     * Strings.substringIndicesBetween("(hello)(world)", '(', ')');    // returns [[1, 6], [8, 13]]
     * Strings.substringIndicesBetween("<tag>text</tag>", '<', '>');   // returns [[1, 4], [10, 14]]
     * 
     * // Empty results
     * Strings.substringIndicesBetween(null, '[', ']');                // returns []
     * Strings.substringIndicesBetween("", '[', ']');                  // returns []
     * Strings.substringIndicesBetween("no match", '[', ']');          // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
        return substringIndicesBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified character delimiters and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter characters, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.DEFAULT);         // returns [[2, 6], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.STACK_BASED);     // returns [[5, 6], [2, 7], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.IGNORE_NESTED);   // returns [[2, 7], [10, 11]]
     * 
     * // Simple cases
     * Strings.substringIndicesBetween("(a)(b)", '(', ')', ExtractStrategy.DEFAULT);               // returns [[1, 2], [4, 5]]
     * Strings.substringIndicesBetween(null, '[', ']', ExtractStrategy.DEFAULT);                   // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        if (str == null || str.isEmpty()) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, 0, str.length(), String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified character delimiters within a given range and returns their indices.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter characters, and returns
     * a list of int arrays where each array contains the start and end indices of a matched substring
     * (exclusive of the delimiters themselves). It uses the default extraction strategy which performs
     * simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, empty, or if no matches are found
     * within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Search within specific range
     * Strings.substringIndicesBetween("a[b]c[d]e[f]", 2, 8, '[', ']');   // returns [[3, 4], [6, 7]]
     * Strings.substringIndicesBetween("(1)(2)(3)", 0, 6, '(', ')');      // returns [[1, 2], [4, 5]]
     * Strings.substringIndicesBetween("no match", 0, 8, '[', ']');       // returns []
     * 
     * // Edge cases
     * Strings.substringIndicesBetween("a[b]c", 4, 5, '[', ']');          // returns []
     * Strings.substringIndicesBetween(null, 0, 5, '[', ']');             // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the starting index to search from (inclusive).
     * @param toIndex the ending index to search until (exclusive).
     * @param delimiterOfExclusiveBeginIndex the character marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the character marking the end of the substring (non-inclusive).
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final char delimiterOfExclusiveBeginIndex,
            final char delimiterOfExclusiveEndIndex) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));

        if (str == null || str.isEmpty()) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, fromIndex, toIndex, String.valueOf(delimiterOfExclusiveBeginIndex), String.valueOf(delimiterOfExclusiveEndIndex),
                ExtractStrategy.DEFAULT, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters and returns their indices.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). It uses the default
     * extraction strategy which performs simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Get indices of content between string delimiters
     * Strings.substringIndicesBetween("a<tag>b</tag>c<tag>d</tag>", "<tag>", "</tag>");   // returns [[6, 7], [19, 20]]
     * Strings.substringIndicesBetween("start:middle:end", "start:", ":end");              // returns [[6, 12]]
     * Strings.substringIndicesBetween("[[content]]", "[[", "]]");                         // returns [[2, 9]]
     * 
     * // Empty results
     * Strings.substringIndicesBetween(null, "<", ">");                                    // returns []
     * Strings.substringIndicesBetween("no match", "<", ">");                              // returns []
     * Strings.substringIndicesBetween("test", null, ">");                                 // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) {
        return substringIndicesBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT);
    }

    /**
     * Finds all substrings between specified string delimiters and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string for all occurrences of text between the specified beginning
     * and ending delimiter strings, and returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.DEFAULT);         // returns [[2, 6], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.STACK_BASED);     // returns [[5, 6], [2, 7], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", "[", "]", ExtractStrategy.IGNORE_NESTED);   // returns [[2, 7], [10, 11]]
     * 
     * // String: [[b[a]]c]
     * Strings.substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.DEFAULT);            // returns [[1, 5]]
     * Strings.substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.STACK_BASED);        // returns [[4, 5], [2, 6], [1, 8]]
     * Strings.substringIndicesBetween("[[b[a]]c]", "[", "]", ExtractStrategy.IGNORE_NESTED);      // returns [[1, 8]]
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IllegalArgumentException if extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final String delimiterOfExclusiveBeginIndex, final String delimiterOfExclusiveEndIndex,
            final ExtractStrategy extractStrategy) {
        if (str == null || isEmpty(delimiterOfExclusiveBeginIndex) || isEmpty(delimiterOfExclusiveEndIndex)) {
            return new ArrayList<>();
        }

        return substringIndicesBetween(str, 0, str.length(), delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, extractStrategy, Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range and returns their indices.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for all occurrences of text between the specified beginning and ending delimiter strings, and returns
     * a list of int arrays where each array contains the start and end indices of a matched substring
     * (exclusive of the delimiters themselves). It uses the default extraction strategy which performs
     * simple sequential matching of begin/end delimiters.</p>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, or if no matches are found within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Search within specific range
     * Strings.substringIndicesBetween("a<b>c<d>e<f>", 2, 10, "<", ">");        // returns [[3, 4], [6, 7]]
     * Strings.substringIndicesBetween("[[1]][[2]][[3]]", 0, 10, "[[", "]]");   // returns [[2, 3], [7, 8]]
     * Strings.substringIndicesBetween("no match", 0, 8, "<", ">");             // returns []
     * 
     * // Edge cases
     * Strings.substringIndicesBetween("a<b>c", 4, 5, "<", ">");                // returns []
     * Strings.substringIndicesBetween(null, 0, 5, "<", ">");                   // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the starting index to search from (inclusive).
     * @param toIndex the ending index to search until (exclusive).
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringIndicesBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex) throws IndexOutOfBoundsException {
        return substringIndicesBetween(str, fromIndex, toIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex, ExtractStrategy.DEFAULT,
                Integer.MAX_VALUE);
    }

    /**
     * Finds all substrings between specified string delimiters within a given range and returns their indices using the given extraction strategy.
     *
     * <p>This method searches the input string from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * for occurrences of text between the specified beginning and ending delimiter strings, up to a maximum
     * count specified by {@code maxCount}. It returns a list of int arrays where each array contains the start
     * and end indices of a matched substring (exclusive of the delimiters themselves). The extraction strategy
     * determines how nested delimiters are handled:
     * <ul>
     *   <li>{@code ExtractStrategy.DEFAULT} - Simple sequential matching of begin/end delimiters</li>
     *   <li>{@code ExtractStrategy.STACK_BASED} - Stack-based approach that extracts all nested levels</li>
     *   <li>{@code ExtractStrategy.IGNORE_NESTED} - Stack-based approach that ignores nested substrings</li>
     * </ul>
     *
     * <p>The method returns an empty list if the input string is {@code null}, if either delimiter is {@code null}
     * or empty, if {@code maxCount} is 0, or if no matches are found within the specified range.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // String: 3[a2[c]]2[a]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.DEFAULT, 10);         // returns [[2, 6], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.STACK_BASED, 10);     // returns [[5, 6], [2, 7], [10, 11]]
     * Strings.substringIndicesBetween("3[a2[c]]2[a]", 0, 12, "[", "]", ExtractStrategy.IGNORE_NESTED, 10);   // returns [[2, 7], [10, 11]]
     * 
     * // Limit results
     * Strings.substringIndicesBetween("a[b]c[d]e[f]", 0, 15, "[", "]", ExtractStrategy.DEFAULT, 2);          // returns [[2, 3], [6, 7]]
     * Strings.substringIndicesBetween("test", 0, 4, "[", "]", ExtractStrategy.DEFAULT, 0);                   // returns []
     * }</pre>
     *
     * @param str the string to search in, may be {@code null}
     * @param fromIndex the index to start the search from (inclusive).
     * @param toIndex the index to end the search at (exclusive).
     * @param delimiterOfExclusiveBeginIndex the string marking the beginning of the substring (non-inclusive).
     * @param delimiterOfExclusiveEndIndex the string marking the end of the substring (non-inclusive).
     * @param extractStrategy the strategy to use for handling nested delimiters.
     * @param maxCount the maximum number of matches to find.
     * @return a list of int arrays containing the start and end indices (exclusive of delimiters) of each
     *         matching substring, or an empty list if no match is found or the input is {@code null}.
     * @throws IndexOutOfBoundsException if the indices are invalid.
     * @throws IllegalArgumentException if maxCount is negative or extractStrategy is {@code null}.
     * @see #substringIndicesBetween(String, String, String, ExtractStrategy)
     * @see #substringsBetween(String, int, int, String, String, ExtractStrategy, int)
     */
    public static List<int[]> substringIndicesBetween(final String str, final int fromIndex, final int toIndex, final String delimiterOfExclusiveBeginIndex,
            final String delimiterOfExclusiveEndIndex, final ExtractStrategy extractStrategy, final int maxCount) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));
        N.checkArgNotNegative(maxCount, cs.max);
        N.checkArgNotNull(extractStrategy, cs.extractStrategy);

        if (str == null || isEmpty(delimiterOfExclusiveBeginIndex) || isEmpty(delimiterOfExclusiveEndIndex) || maxCount == 0) {
            return new ArrayList<>();
        }

        int idx = str.indexOf(delimiterOfExclusiveBeginIndex, fromIndex);

        if (idx < 0) {
            return new ArrayList<>();
        }

        final List<int[]> res = new ArrayList<>(N.min(maxCount, 10));

        final int lengthOfDelimiterOfExclusiveBeginIndex = delimiterOfExclusiveBeginIndex.length();
        final int lengthOfDelimiterOfExclusiveEndIndex = delimiterOfExclusiveEndIndex.length();

        idx += lengthOfDelimiterOfExclusiveBeginIndex;

        if (extractStrategy == ExtractStrategy.DEFAULT) {
            int endIndex = -1;

            do {
                endIndex = indexOf(str, delimiterOfExclusiveEndIndex, idx);

                if (endIndex < 0 || endIndex >= toIndex) {
                    break;
                }

                res.add(new int[] { idx, endIndex });

                if (res.size() >= maxCount) {
                    break;
                }

                idx = indexOf(str, delimiterOfExclusiveBeginIndex, endIndex + lengthOfDelimiterOfExclusiveEndIndex);

                if (idx < 0) {
                    break;
                }

                idx += lengthOfDelimiterOfExclusiveBeginIndex;
            } while (idx < toIndex);
        } else {
            final Deque<Integer> queue = new LinkedList<>();

            queue.add(idx);
            int next = -1;

            for (int i = idx; i < toIndex;) {
                if (queue.size() == 0) {
                    idx = next >= i ? next : str.indexOf(delimiterOfExclusiveBeginIndex, i);

                    if (idx < 0) {
                        break;
                    } else {
                        idx += lengthOfDelimiterOfExclusiveBeginIndex;
                        queue.add(idx);
                        i = idx;
                    }
                }

                idx = str.indexOf(delimiterOfExclusiveEndIndex, i);

                if (idx < 0) {
                    break;
                } else {
                    final int endIndex = idx;
                    idx = res.size() > 0 ? Math.max(res.get(res.size() - 1)[1] + lengthOfDelimiterOfExclusiveEndIndex, queue.peekLast()) : queue.peekLast();

                    while ((idx = str.indexOf(delimiterOfExclusiveBeginIndex, idx)) >= 0 && idx < endIndex) {
                        idx += lengthOfDelimiterOfExclusiveBeginIndex;
                        queue.push(idx);
                    }

                    if (idx > 0) {
                        next = idx;
                    }

                    final int startIndex = queue.pop();

                    if (extractStrategy == ExtractStrategy.IGNORE_NESTED && res.size() > 0 && startIndex < res.get(res.size() - 1)[0]) {
                        while (res.size() > 0 && startIndex < res.get(res.size() - 1)[0]) {
                            res.remove(res.size() - 1);
                        }
                    }

                    res.add(new int[] { startIndex, endIndex });

                    if (res.size() >= maxCount) {
                        break;
                    }

                    i = endIndex + lengthOfDelimiterOfExclusiveEndIndex;
                }
            }
        }

        return res;
    }

    /**
     * Returns a new String with the specified range replaced with the replacement String.
     *
     * <p>This method creates a new string by replacing the characters from {@code fromIndex} (inclusive)
     * to {@code toIndex} (exclusive) with the specified replacement string. The original string remains unchanged.
     * If the replacement is {@code null}, it is treated as an empty string.</p>
     *
     * <p>The method handles special cases gracefully: if the input string is {@code null} or empty,
     * it returns the replacement string (or empty if replacement is {@code null}). If {@code fromIndex}
     * equals {@code toIndex} and replacement is empty, the original string is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Replace range with new text
     * Strings.replaceRange("Hello World", 6, 11, "Java");        // returns "Hello Java"
     * Strings.replaceRange("Hello World", 0, 5, "Hi");           // returns "Hi World"
     * Strings.replaceRange("Hello World", 5, 5, " Beautiful");   // returns "Hello Beautiful World"
     *
     * // Delete range (null or empty replacement)
     * Strings.replaceRange("Hello World", 5, 11, null);          // returns "Hello"
     * Strings.replaceRange("Hello World", 5, 11, "");            // returns "Hello"
     *
     * // Edge cases
     * Strings.replaceRange(null, 0, 0, "Text");                  // returns "Text"
     * Strings.replaceRange("", 0, 0, "Text");                    // returns "Text"
     * }</pre>
     *
     * @param str the original string, may be {@code null}
     * @param fromIndex the initial index of the range to be replaced, inclusive. It must be &gt;= 0 and &lt;= {@code str.length()}.
     * @param toIndex the final index of the range to be replaced, exclusive. It must be &gt;= {@code fromIndex} and &lt;= {@code str.length()}.
     * @param replacement the string to replace the specified range in the original string, may be {@code null}
     * @return a new string with the specified range replaced by the replacement string.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds or indices are invalid.
     * @see N#replaceRange(String, int, int, String)
     */
    @Beta
    public static String replaceRange(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(str));

        if (N.isEmpty(str)) {
            return replacement == null ? EMPTY : replacement;
        } else if (fromIndex == toIndex && N.isEmpty(replacement)) {
            return str;
        }

        if (N.isEmpty(replacement)) {
            return str.substring(0, fromIndex) + str.substring(toIndex);
        } else {
            return str.substring(0, fromIndex) + N.nullToEmpty(replacement) + str.substring(toIndex);
        }
    }

    /**
     * Moves a specified range of characters within a string to a new position.
     *
     * <p>This method extracts a substring from the range [fromIndex, toIndex) and moves it to the specified
     * new position. The newPositionAfterMove parameter indicates where the start of the moved range
     * should be positioned in the resulting string. The original string remains unchanged, and a new string
     * with the rearranged characters is returned.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Moving a range of characters
     * Strings.moveRange("ABCDEFGH", 2, 5, 0);      // returns "CDEABFGH" (moves "CDE" to position 0)
     * Strings.moveRange("ABCDEFGH", 2, 5, 5);      // returns "ABFGHCDE" (moves "CDE" to position 5)
     * Strings.moveRange("Hello World", 0, 5, 6);   // returns " WorldHello" (moves "Hello" to position 6)
     *
     * // Edge cases
     * Strings.moveRange(null, 0, 0, 0);            // returns ""
     * Strings.moveRange("", 0, 0, 0);              // returns ""
     * Strings.moveRange("ABC", 1, 1, 1);           // returns "ABC" (no change when fromIndex == toIndex)
     * Strings.moveRange("ABC", 0, 2, 0);           // returns "ABC" (no change when already at position)
     * }</pre>
     *
     * @param str the original string to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove the zero-based index where the first element of the range will be placed after the move;
     *      must be between 0 and lengthOfString - lengthOfRange, inclusive.
     * @return a new string with the specified range moved to the new position. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the string
     * @see N#moveRange(String, int, int, int)
     */
    @Beta
    public static String moveRange(final String str, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = N.len(str);
        N.checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (N.isEmpty(str)) {
            return EMPTY;
        }

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return str;
        }

        if (newPositionAfterMove < fromIndex) {
            return Strings.concat(str.substring(0, newPositionAfterMove), str.substring(fromIndex, toIndex), str.substring(newPositionAfterMove, fromIndex),
                    str.substring(toIndex));
        } else {
            final int m = toIndex + (newPositionAfterMove - fromIndex);

            return Strings.concat(str.substring(0, fromIndex), str.substring(toIndex, m), str.substring(fromIndex, toIndex), str.substring(m));
        }
    }

    /**
     * Deletes a specified range of characters from a string.
     *
     * <p>This method removes characters from the range [fromIndex, toIndex) in the given string.
     * The original string remains unchanged, and a new string without the specified range is returned.
     * If the range is empty (fromIndex == toIndex) or starts beyond the string length, the original string is returned.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Deleting a range of characters
     * Strings.deleteRange("ABCDEFGH", 2, 5);       // returns "ABFGH" (removes "CDE")
     * Strings.deleteRange("Hello World", 5, 11);   // returns "Hello" (removes " World")
     * Strings.deleteRange("Test", 0, 2);           // returns "st" (removes "Te")
     *
     * // Edge cases
     * Strings.deleteRange(null, 0, 1);             // returns ""
     * Strings.deleteRange("", 0, 0);               // returns "" (OK - valid range for empty string)
     * Strings.deleteRange("ABC", 1, 1);            // returns "ABC" (no deletion when fromIndex == toIndex)
     * Strings.deleteRange("ABC", 3, 5);            // returns "ABC" (no deletion when fromIndex >= length)
     * Strings.deleteRange("ABC", 0, 10);           // returns "" (deletes entire string and beyond)
     * }</pre>
     *
     * @param str the input string from which a range of characters are to be deleted; may be {@code null}
     * @param fromIndex the initial index of the range to be deleted, inclusive; must be &gt;= 0 and &lt;= {@code str.length()}
     * @param toIndex the final index of the range to be deleted, exclusive; must be &gt;= {@code fromIndex} and &lt;= {@code str.length()}
     * @return a new string with the specified range of characters deleted. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see N#deleteRange(String, int, int)
     * @see #replaceRange(String, int, int, String)
     */
    @Beta
    public static String deleteRange(final String str, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        final int len = N.len(str);

        N.checkFromToIndex(fromIndex, toIndex, len);

        if (N.isEmpty(str)) {
            return EMPTY;
        }

        if (fromIndex == toIndex || fromIndex >= len) {
            return str;
        } else if (toIndex - fromIndex >= len) {
            return Strings.EMPTY;
        }

        return Strings.concat(str.substring(0, fromIndex) + str.substring(toIndex));
    }

    /**
     * Joins the elements of a boolean array into a single String using the default element separator.
     *
     * <p>This method concatenates all elements in the array, separating them with the default
     * element separator. The boolean values are converted to their string representations ("true" or "false").</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining boolean arrays
     * Strings.join(new boolean[] {true, false, true});   // returns "true, false, true" (using default separator)
     * Strings.join(new boolean[] {true});                // returns "true"
     * 
     * // Edge cases
     * Strings.join((boolean[]) null);                    // returns ""
     * Strings.join(new boolean[] {});                    // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a boolean array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all elements in the array, separating them with the provided
     * delimiter string. The boolean values are converted to their string representations ("true" or "false").
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining boolean arrays with string delimiters
     * Strings.join(new boolean[] {true, false, true}, ", ");    // returns "true, false, true"
     * Strings.join(new boolean[] {true, false, true}, " - ");   // returns "true - false - true"
     * Strings.join(new boolean[] {true, false, true}, "");      // returns "truefalsetrue"
     * 
     * // Edge cases
     * Strings.join((boolean[]) null, ", ");                     // returns ""
     * Strings.join(new boolean[] {}, ", ");                     // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a boolean array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The boolean values are converted to their
     * string representations ("true" or "false"). If the delimiter is empty, the elements are
     * concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining a range of boolean array elements
     * boolean[] arr = {true, false, true, false, true};
     * Strings.join(arr, 1, 4, ", ");                // returns "false, true, false"
     * Strings.join(arr, 0, 3, " - ");               // returns "true - false - true"
     * Strings.join(arr, 2, 5, "");                  // returns "truefalsetrue"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ");                // returns "" (fromIndex == toIndex)
     * Strings.join((boolean[]) null, 0, 0, ", ");   // returns ""
     * }</pre>
     *
     * @param a the boolean array to join
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(boolean[], int, int, String, String, String)
     */
    public static String join(final boolean[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a boolean array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. The boolean values are converted to their string representations ("true" or "false").
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining with prefix and suffix
     * boolean[] arr = {true, false, true, false, true};
     * Strings.join(arr, 0, 3, ", ", "[", "]");           // returns "[true, false, true]"
     * Strings.join(arr, 1, 4, " | ", "Results: ", "");   // returns "Results: false | true | false"
     * Strings.join(arr, 2, 3, ", ", "(", ")");           // returns "(true)"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ", "[", "]");           // returns "[]" (empty range)
     * Strings.join(null, 0, 0, ", ", "[", "]");          // returns "[]"
     * Strings.join(arr, 0, 2, "", "<", ">");             // returns "<truefalse>"
     * }</pre>
     *
     * @param a the array containing the elements to join together. It can be empty.
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final boolean[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 5 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a char array into a single String using the default element separator.
     *
     * <p>This method concatenates all characters in the array, separating them with the default
     * element separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining char arrays
     * Strings.join(new char[] {'a', 'b', 'c'});   // returns "a, b, c" (using default separator)
     * Strings.join(new char[] {'x'});             // returns "x"
     * 
     * // Edge cases
     * Strings.join((char[]) null);                // returns ""
     * Strings.join(new char[] {});                // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a char array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all characters in the array, separating them with the provided
     * delimiter string. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining char arrays with string delimiters
     * Strings.join(new char[] {'a', 'b', 'c'}, ", ");    // returns "a, b, c"
     * Strings.join(new char[] {'x', 'y', 'z'}, " - ");   // returns "x - y - z"
     * Strings.join(new char[] {'A', 'B', 'C'}, "");      // returns "ABC"
     * 
     * // Edge cases
     * Strings.join((char[]) null, ", ");                 // returns ""
     * Strings.join(new char[] {}, ", ");                 // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a char array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. If the delimiter is empty, the elements are
     * concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining a range of char array elements
     * char[] arr = {'a', 'b', 'c', 'd', 'e'};
     * Strings.join(arr, 1, 4, ", ");             // returns "b, c, d"
     * Strings.join(arr, 0, 3, " - ");            // returns "a - b - c"
     * Strings.join(arr, 2, 5, "");               // returns "cde"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ");             // returns "" (fromIndex == toIndex)
     * Strings.join((char[]) null, 0, 0, ", ");   // returns ""
     * }</pre>
     *
     * @param a the char array to join
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(char[], int, int, String, String, String)
     */
    public static String join(final char[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a char array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining with prefix and suffix
     * char[] arr = {'a', 'b', 'c', 'd', 'e'};
     * Strings.join(arr, 0, 3, ", ", "[", "]");         // returns "[a, b, c]"
     * Strings.join(arr, 1, 4, " | ", "Chars: ", "");   // returns "Chars: b | c | d"
     * Strings.join(arr, 2, 3, ", ", "(", ")");         // returns "(c)"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ", "[", "]");         // returns "[]" (empty range)
     * Strings.join(null, 0, 0, ", ", "[", "]");        // returns "[]"
     * Strings.join(arr, 0, 2, "", "<", ">");           // returns "<ab>"
     * }</pre>
     *
     * @param a the array containing the elements to join together. It can be empty.
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final char[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 1 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a byte array into a single String using the default element separator.
     *
     * <p>This method concatenates all byte values in the array, separating them with the default
     * element separator. The byte values are converted to their string representations.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining byte arrays
     * Strings.join(new byte[] {1, 2, 3});   // returns "1, 2, 3" (using default separator)
     * Strings.join(new byte[] {127});       // returns "127"
     * 
     * // Edge cases
     * Strings.join((byte[]) null);          // returns ""
     * Strings.join(new byte[] {});          // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a byte array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all byte values in the array, separating them with the provided
     * delimiter string. The byte values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining byte arrays with string delimiters
     * Strings.join(new byte[] {1, 2, 3}, ", ");       // returns "1, 2, 3"
     * Strings.join(new byte[] {10, 20, 30}, " - ");   // returns "10 - 20 - 30"
     * Strings.join(new byte[] {1, 2, 3}, "");         // returns "123"
     * 
     * // Edge cases
     * Strings.join((byte[]) null, ", ");              // returns ""
     * Strings.join(new byte[] {}, ", ");              // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a byte array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The byte values are converted to their
     * string representations. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining a range of byte array elements
     * byte[] arr = {1, 2, 3, 4, 5};
     * Strings.join(arr, 1, 4, ", ");             // returns "2, 3, 4"
     * Strings.join(arr, 0, 3, " - ");            // returns "1 - 2 - 3"
     * Strings.join(arr, 2, 5, "");               // returns "345"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ");             // returns "" (fromIndex == toIndex)
     * Strings.join((byte[]) null, 0, 0, ", ");   // returns ""
     * }</pre>
     *
     * @param a the byte array to join
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     * @see #join(byte[], int, int, String, String, String)
     */
    public static String join(final byte[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins a range of elements from a byte array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string, and wrapping the result with the specified
     * prefix and suffix. The byte values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is null/empty or fromIndex equals toIndex,
     * it returns just the prefix and suffix concatenated (or an empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining with prefix and suffix
     * byte[] arr = {1, 2, 3, 4, 5};
     * Strings.join(arr, 0, 3, ", ", "[", "]");         // returns "[1, 2, 3]"
     * Strings.join(arr, 1, 4, " | ", "Bytes: ", "");   // returns "Bytes: 2 | 3 | 4"
     * Strings.join(arr, 2, 3, ", ", "(", ")");         // returns "(3)"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ", "[", "]");         // returns "[]" (empty range)
     * Strings.join(null, 0, 0, ", ", "[", "]");        // returns "[]"
     * Strings.join(arr, 0, 2, "", "<", ">");           // returns "<12>"
     * }</pre>
     *
     * @param a the array containing the elements to join together. It can be empty.
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final byte[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 4 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of a short array into a single String using the default element separator.
     *
     * <p>This method concatenates all short values in the array, separating them with the default
     * element separator. The short values are converted to their string representations.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining short arrays
     * Strings.join(new short[] {1, 2, 3});   // returns "1, 2, 3" (using default separator)
     * Strings.join(new short[] {32767});     // returns "32767"
     * 
     * // Edge cases
     * Strings.join((short[]) null);          // returns ""
     * Strings.join(new short[] {});          // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(short[], int, int, String, String, String)
     */
    public static String join(final short[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of a short array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates all short values in the array, separating them with the provided
     * delimiter string. The short values are converted to their string representations.
     * If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining short arrays with string delimiters
     * Strings.join(new short[] {1, 2, 3}, ", ");          // returns "1, 2, 3"
     * Strings.join(new short[] {100, 200, 300}, " - ");   // returns "100 - 200 - 300"
     * Strings.join(new short[] {1, 2, 3}, "");            // returns "123"
     * 
     * // Edge cases
     * Strings.join((short[]) null, ", ");                 // returns ""
     * Strings.join(new short[] {}, ", ");                 // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(short[], int, int, String, String, String)
     */
    public static String join(final short[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins a range of elements from a short array into a single String using the specified string delimiter.
     *
     * <p>This method concatenates elements from the specified range [fromIndex, toIndex) in the array,
     * separating them with the provided delimiter string. The short values are converted to their
     * string representations. If the delimiter is empty, the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty arrays, or when fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Joining a range of short array elements
     * short[] arr = {10, 20, 30, 40, 50};
     * Strings.join(arr, 1, 4, ", ");              // returns "20, 30, 40"
     * Strings.join(arr, 0, 3, " - ");             // returns "10 - 20 - 30"
     * Strings.join(arr, 2, 5, "");                // returns "30304050"
     * 
     * // Edge cases
     * Strings.join(arr, 1, 1, ", ");              // returns "" (fromIndex == toIndex)
     * Strings.join((short[]) null, 0, 0, ", ");   // returns ""
     * }</pre>
     *
     * @param a the short array to join
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of array bounds
     */
    public static String join(final short[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided short array into a single String.
     *
     * <p>This method concatenates the string representations of array elements from the specified range
     * using the provided delimiter, prefix, and suffix. Elements are converted to their string representation
     * and joined in the order they appear in the array.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {1, 2, 3, 4, 5};
     * 
     * // Basic joining with delimiter
     * Strings.join(numbers, 0, 5, ", ", "", "");            // returns "1, 2, 3, 4, 5"
     * Strings.join(numbers, 1, 4, "-", "", "");             // returns "2-3-4"
     * 
     * // With prefix and suffix
     * Strings.join(numbers, 0, 3, ", ", "[", "]");          // returns "[1, 2, 3]"
     * Strings.join(numbers, 0, 5, ", ", "Numbers: ", "");   // returns "Numbers: 1, 2, 3, 4, 5"
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "", "");               // returns ""
     * Strings.join(numbers, 2, 2, ", ", "[", "]");          // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final short[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 5 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided int array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code Strings.join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * Strings.join(numbers);   // returns "1, 2, 3, 4, 5" (using default separator)
     * 
     * int[] empty = {};
     * Strings.join(empty);   // returns ""
     * Strings.join(null);    // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided int array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * Strings.join(numbers, ", ");      // returns "1, 2, 3, 4, 5"
     * Strings.join(numbers, " - ");     // returns "1 - 2 - 3 - 4 - 5"
     * Strings.join(numbers, "");        // returns "12345"
     * Strings.join(numbers, " and ");   // returns "1 and 2 and 3 and 4 and 5"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided int array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * Strings.join(numbers, 1, 4, ", ");    // returns "2, 3, 4"
     * Strings.join(numbers, 0, 3, " - ");   // returns "1 - 2 - 3"
     * Strings.join(numbers, 2, 5, "");      // returns "345"
     * 
     * // Edge cases
     * Strings.join(numbers, 2, 2, ", ");    // returns "" (fromIndex == toIndex)
     * Strings.join(numbers, 0, 1, ", ");    // returns "1" (single element)
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(int[], int, int, String, String, String)
     */
    public static String join(final int[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided int array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * 
     * // Basic joining with delimiter
     * Strings.join(numbers, 0, 5, ", ", "", "");             // returns "1, 2, 3, 4, 5"
     * Strings.join(numbers, 1, 4, "-", "", "");              // returns "2-3-4"
     * 
     * // With prefix and suffix
     * Strings.join(numbers, 0, 3, ", ", "[", "]");           // returns "[1, 2, 3]"
     * Strings.join(numbers, 0, 5, ", ", "Numbers: ", "");    // returns "Numbers: 1, 2, 3, 4, 5"
     * Strings.join(numbers, 2, 4, " | ", "Result: ", "!");   // returns "Result: 3 | 4!"
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]");              // returns "[]"
     * Strings.join(numbers, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final int[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided long array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code Strings.join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L};
     * Strings.join(numbers);   // returns "100, 200, 300" (using default separator)
     * 
     * long[] empty = {};
     * Strings.join(empty);   // returns ""
     * Strings.join(null);    // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided long array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L};
     * Strings.join(numbers, ", ");      // returns "100, 200, 300"
     * Strings.join(numbers, " - ");     // returns "100 - 200 - 300"
     * Strings.join(numbers, "");        // returns "100200300"
     * Strings.join(numbers, " and ");   // returns "100 and 200 and 300"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided long array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * Strings.join(numbers, 1, 4, ", ");    // returns "200, 300, 400"
     * Strings.join(numbers, 0, 3, " - ");   // returns "100 - 200 - 300"
     * Strings.join(numbers, 2, 5, "");      // returns "300400500"
     * 
     * // Edge cases
     * Strings.join(numbers, 2, 2, ", ");    // returns "" (fromIndex == toIndex)
     * Strings.join(numbers, 0, 1, ", ");    // returns "100" (single element)
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(long[], int, int, String, String, String)
     */
    public static String join(final long[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided long array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * 
     * // Basic joining with delimiter
     * Strings.join(numbers, 0, 5, ", ", "", "");             // returns "100, 200, 300, 400, 500"
     * Strings.join(numbers, 1, 4, "-", "", "");              // returns "200-300-400"
     * 
     * // With prefix and suffix
     * Strings.join(numbers, 0, 3, ", ", "[", "]");           // returns "[100, 200, 300]"
     * Strings.join(numbers, 0, 5, ", ", "Values: ", "");     // returns "Values: 100, 200, 300, 400, 500"
     * Strings.join(numbers, 2, 4, " | ", "Result: ", "!");   // returns "Result: 300 | 400!"
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]");              // returns "[]"
     * Strings.join(numbers, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final long[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided float array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code Strings.join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.7f, 3.14f};
     * Strings.join(numbers);   // returns "1.5, 2.7, 3.14" (using default separator)
     * 
     * float[] empty = {};
     * Strings.join(empty);   // returns ""
     * Strings.join(null);    // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided float array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.7f, 3.14f};
     * Strings.join(numbers, ", ");      // returns "1.5, 2.7, 3.14"
     * Strings.join(numbers, " - ");     // returns "1.5 - 2.7 - 3.14"
     * Strings.join(numbers, "");        // returns "1.52.73.14"
     * Strings.join(numbers, " and ");   // returns "1.5 and 2.7 and 3.14"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided float array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
     * Strings.join(numbers, 1, 4, ", ");    // returns "2.2, 3.3, 4.4"
     * Strings.join(numbers, 0, 3, " - ");   // returns "1.1 - 2.2 - 3.3"
     * Strings.join(numbers, 2, 5, "");      // returns "3.34.45.5"
     * 
     * // Edge cases
     * Strings.join(numbers, 2, 2, ", ");    // returns "" (fromIndex == toIndex)
     * Strings.join(numbers, 0, 1, ", ");    // returns "1.1" (single element)
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(float[], int, int, String, String, String)
     */
    public static String join(final float[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided float array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
     * 
     * // Basic joining with delimiter
     * Strings.join(numbers, 0, 5, ", ", "", "");             // returns "1.1, 2.2, 3.3, 4.4, 5.5"
     * Strings.join(numbers, 1, 4, "-", "", "");              // returns "2.2-3.3-4.4"
     * 
     * // With prefix and suffix
     * Strings.join(numbers, 0, 3, ", ", "[", "]");           // returns "[1.1, 2.2, 3.3]"
     * Strings.join(numbers, 0, 5, ", ", "Values: ", "");     // returns "Values: 1.1, 2.2, 3.3, 4.4, 5.5"
     * Strings.join(numbers, 2, 4, " | ", "Result: ", "!");   // returns "Result: 3.3 | 4.4!"
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]");              // returns "[]"
     * Strings.join(numbers, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final float[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins all elements of the provided double array into a single String.
     *
     * <p>This method concatenates all elements of the array using the default element separator.
     * It is equivalent to calling {@code Strings.join(a, 0, a.length, ELEMENT_SEPARATOR)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.7, 3.14159};
     * Strings.join(numbers);   // returns "1.5, 2.7, 3.14159" (using default separator)
     * 
     * double[] empty = {};
     * Strings.join(empty);   // returns ""
     * Strings.join(null);    // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins all elements of the provided double array into a single String using the specified delimiter.
     *
     * <p>This method concatenates all elements of the array using the provided string delimiter.
     * Each element is converted to its string representation and separated by the delimiter.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.7, 3.14159};
     * Strings.join(numbers, ", ");      // returns "1.5, 2.7, 3.14159"
     * Strings.join(numbers, " - ");     // returns "1.5 - 2.7 - 3.14159"
     * Strings.join(numbers, "");        // returns "1.52.73.14159"
     * Strings.join(numbers, " and ");   // returns "1.5 and 2.7 and 3.14159"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided double array from the specified range into a single String.
     *
     * <p>This method concatenates elements from index {@code fromIndex} (inclusive) to {@code toIndex} (exclusive)
     * using the provided string delimiter. Each element is converted to its string representation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.1, 2.2, 3.3, 4.4, 5.5};
     * Strings.join(numbers, 1, 4, ", ");    // returns "2.2, 3.3, 4.4"
     * Strings.join(numbers, 0, 3, " - ");   // returns "1.1 - 2.2 - 3.3"
     * Strings.join(numbers, 2, 5, "");      // returns "3.34.45.5"
     * 
     * // Edge cases
     * Strings.join(numbers, 2, 2, ", ");    // returns "" (fromIndex == toIndex)
     * Strings.join(numbers, 0, 1, ", ");    // returns "1.1" (single element)
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     * @see #join(double[], int, int, String, String, String)
     */
    public static String join(final double[] a, final int fromIndex, final int toIndex, final String delimiter) throws IndexOutOfBoundsException {
        return join(a, fromIndex, toIndex, delimiter, EMPTY, EMPTY);
    }

    /**
     * Joins the elements of the provided double array into a single String with delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements from the specified range of the array using the provided delimiter,
     * and adds the specified prefix at the beginning and suffix at the end of the result.</p>
     *
     * <p>If the array is {@code null} or empty, or if {@code fromIndex == toIndex}, the method returns
     * an appropriate combination of prefix and suffix, or an empty string if both are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.1, 2.2, 3.3, 4.4, 5.5};
     * 
     * // Basic joining with delimiter
     * Strings.join(numbers, 0, 5, ", ", "", "");             // returns "1.1, 2.2, 3.3, 4.4, 5.5"
     * Strings.join(numbers, 1, 4, "-", "", "");              // returns "2.2-3.3-4.4"
     * 
     * // With prefix and suffix
     * Strings.join(numbers, 0, 3, ", ", "[", "]");           // returns "[1.1, 2.2, 3.3]"
     * Strings.join(numbers, 0, 5, ", ", "Values: ", "");     // returns "Values: 1.1, 2.2, 3.3, 4.4, 5.5"
     * Strings.join(numbers, 2, 4, " | ", "Result: ", "!");   // returns "Result: 3.3 | 4.4!"
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]");              // returns "[]"
     * Strings.join(numbers, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null} or empty
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final double[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix)
            throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return N.toString(a[fromIndex]);
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 6 + N.len(delimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            if (isEmpty(delimiter)) {
                for (int i = fromIndex; i < toIndex; i++) {
                    sb.append(a[i]);
                }
            } else {
                for (int i = fromIndex; i < toIndex; i++) {
                    if (i > fromIndex) {
                        sb.append(delimiter);
                    }

                    sb.append(a[i]);
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the elements of the provided array into a single String.
     *
     * <p>This method concatenates all elements in the array using the default element separator.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * Null elements are handled as "null" strings.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * Strings.join(arr);   // returns "apple, banana, cherry"
     * 
     * Object[] mixed = {1, "hello", true};
     * Strings.join(mixed);           // returns "1, hello, true"
     * 
     * Strings.join(null);            // returns ""
     * Strings.join(new String[0]);   // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a) {
        return join(a, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * Strings.join(arr, " - ");   // returns "apple - banana - cherry"
     * Strings.join(arr, "");      // returns "applebananacherry"
     * Strings.join(arr, ", ");    // returns "apple, banana, cherry"
     * 
     * Object[] mixed = {1, 2, 3};
     * Strings.join(mixed, " and ");        // returns "1 and 2 and 3"
     * 
     * Strings.join(null, ", ");            // returns ""
     * Strings.join(new String[0], ", ");   // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a, final String delimiter) {
        if (N.isEmpty(a)) {
            return EMPTY;
        }

        return join(a, 0, a.length, delimiter);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty and both prefix and suffix are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * Strings.join(arr, ", ", "[", "]");              // returns "[apple, banana, cherry]"
     * Strings.join(arr, " | ", "Items: ", ".");       // returns "Items: apple | banana | cherry."
     * 
     * Strings.join(new String[0], ", ", "[", "]");    // returns "[]"
     * Strings.join(null, ", ", "Start: ", " :End");   // returns "Start:  :End"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string with prefix and suffix applied.
     * @see #join(Object[], String, String, String, boolean)
     */
    public static String join(final Object[] a, final String delimiter, final String prefix, final String suffix) {
        return join(a, 0, N.len(a), delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided array into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements in the array, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty and both prefix and suffix are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry "};
     * Strings.join(arr, ", ", "[", "]", true);    // returns "[apple, banana, cherry]"
     * Strings.join(arr, ", ", "[", "]", false);   // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Object[] mixed = {1, "  hello  ", true};
     * Strings.join(mixed, " | ", "", "", true);   // returns "1 | hello | true"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Object[] a, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        return join(a, 0, N.len(a), delimiter, prefix, suffix, trim);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry", "date", "elderberry"};
     * Strings.join(arr, 1, 4, " - ");   // returns "banana - cherry - date"
     * Strings.join(arr, 0, 3, ", ");    // returns "apple, banana, cherry"
     * Strings.join(arr, 2, 4, "");      // returns "cherrydate"
     * }</pre>
     *
     * @param a the array containing the elements to join together.
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Object[], int, int, String, String, String, boolean)
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter) {
        return join(a, fromIndex, toIndex, delimiter, false);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter and optional trimming.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry ", " date "};
     * Strings.join(arr, 1, 3, " - ", true);    // returns "banana - cherry"
     * Strings.join(arr, 1, 3, " - ", false);   // returns " banana  -  cherry "
     * Strings.join(arr, 0, 4, "", true);       // returns "applebananacherrydate"
     * }</pre>
     *
     * @param a the array containing the elements to join together.
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Object[], int, int, String, String, String, boolean)
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final boolean trim) {
        return join(a, fromIndex, toIndex, delimiter, null, null, trim);
    }

    /** 
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.</p>
     *
     * <p>The method returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and both prefix and suffix are empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry", "date"};
     * Strings.join(arr, 1, 3, ", ", "[", "]");           // returns "[banana, cherry]"
     * Strings.join(arr, 0, 4, " | ", "Fruits: ", ".");   // returns "Fruits: apple | banana | cherry | date."
     * Strings.join(arr, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix) {
        return join(a, fromIndex, toIndex, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided array from the specified range into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates elements in the array from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method handles edge cases gracefully: if the array is {@code null} or empty, or if {@code fromIndex == toIndex},
     * it returns just the concatenation of prefix and suffix (or an empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {" apple ", " banana ", " cherry ", " date "};
     * Strings.join(arr, 1, 3, ", ", "[", "]", true);           // returns "[banana, cherry]"
     * Strings.join(arr, 1, 3, ", ", "[", "]", false);          // returns "[ banana ,  cherry ]"
     * Strings.join(arr, 0, 4, " | ", "Items: ", ".", true);    // returns "Items: apple | banana | cherry | date."
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]", true);          // returns "[]"
     * Strings.join(new String[0], 0, 0, ", ", "", "", true);   // returns ""
     * }</pre>
     *
     * @param a the array containing the elements to join together, may be {@code null}
     * @param fromIndex the start index in the array from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the array up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the array size.
     */
    public static String join(final Object[] a, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix,
            final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.len(a));

        if (N.isEmpty(a) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        } else if (toIndex - fromIndex == 1 && isEmpty(prefix) && isEmpty(suffix)) {
            return toString(a[fromIndex], trim);
        }

        final int len = toIndex - fromIndex;
        final String[] elements = new String[len];

        for (int i = fromIndex, j = 0; i < toIndex; i++, j++) {
            elements[j] = toString(a[i], trim);
        }

        elements[0] = concat(prefix, elements[0]);
        elements[len - 1] = concat(elements[len - 1], suffix);

        return String.join(nullToEmpty(delimiter), elements);
    }

    /**
     * Joins the elements of the provided Iterable into a single String.
     *
     * <p>This method concatenates all elements in the iterable using the default element separator.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * Null elements are handled as "null" strings.</p>
     *
     * <p>The method returns an empty string if the specified Iterable is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list);   // returns "apple, banana, cherry"
     * 
     * Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
     * Strings.join(numbers);             // returns "1, 2, 3" (order may vary)
     * 
     * Strings.join(null);                // returns ""
     * Strings.join(new ArrayList<>());   // returns ""
     * }</pre>
     *
     * @param c the Iterable containing the elements to join together, may be {@code null}
     * @return the concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c) {
        return join(c, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified Iterable is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list, " - ");   // returns "apple - banana - cherry"
     * Strings.join(list, "");      // returns "applebananacherry"
     * Strings.join(list, ", ");    // returns "apple, banana, cherry"
     * 
     * List<Integer> numbers = Arrays.asList(1, 2, 3);
     * Strings.join(numbers, " and ");          // returns "1 and 2 and 3"
     * 
     * Strings.join(null, ", ");                // returns ""
     * Strings.join(new ArrayList<>(), ", ");   // returns ""
     * }</pre>
     *
     * @param c the Iterable containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c, final String delimiter) {
        return join(c == null ? null : c.iterator(), delimiter);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the Iterable is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list, ", ", "[", "]");                // returns "[apple, banana, cherry]"
     * Strings.join(list, " | ", "Items: ", ".");         // returns "Items: apple | banana | cherry."
     * 
     * Strings.join(new ArrayList<>(), ", ", "[", "]");   // returns "[]"
     * Strings.join(null, ", ", "Start: ", " :End");      // returns "Start:  :End"
     * }</pre>
     *
     * @param c the Iterable containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty and <i>prefix, suffix</i> are empty.
     * @see #join(Iterable, String, String, String, boolean)
     */
    public static String join(final Iterable<?> c, final String delimiter, final String prefix, final String suffix) {
        return join(c == null ? null : c.iterator(), delimiter, prefix, suffix);
    }

    /**
     * Joins the elements of the provided Iterable into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements in the iterable, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>For Collection types, this method delegates to the more efficient range-based join method.
     * For other Iterable types, it uses iterator-based processing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ");
     * Strings.join(list, ", ", "[", "]", true);    // returns "[apple, banana, cherry]"
     * Strings.join(list, ", ", "[", "]", false);   // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Set<String> set = new HashSet<>(Arrays.asList("  one  ", "  two  "));
     * Strings.join(set, " | ", "", "", true);   // returns "one | two" (order may vary)
     * }</pre>
     *
     * @param c the Iterable containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified Iterable is {@code null} or empty and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Iterable<?> c, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        if (c instanceof final Collection<?> coll) { // NOSONAR
            return join(coll, 0, coll.size(), delimiter, prefix, suffix, trim);
        } else {
            return join(c == null ? null : c.iterator(), delimiter, prefix, suffix, trim);
        }
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.</p>
     *
     * <p>The method returns an empty string if the specified Collection is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
     * Strings.join(list, 1, 4, " - ");   // returns "banana - cherry - date"
     * Strings.join(list, 0, 3, ", ");    // returns "apple, banana, cherry"
     * Strings.join(list, 2, 4, "");      // returns "cherrydate"
     * }</pre>
     *
     * @param c the Collection containing the elements to join together.
     * @param fromIndex the start index in the collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified Collection is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Collection, int, int, String, String, String, boolean)
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter) {
        return join(c, fromIndex, toIndex, delimiter, false);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter and optional trimming.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method returns an empty string if the specified Collection is {@code null} or empty, or if {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ", " date ");
     * Strings.join(list, 1, 3, " - ", true);    // returns "banana - cherry"
     * Strings.join(list, 1, 3, " - ", false);   // returns " banana  -  cherry "
     * Strings.join(list, 0, 4, "", true);       // returns "applebananacherrydate"
     * }</pre>
     *
     * @param c the Collection containing the elements to join together.
     * @param fromIndex the start index in the collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified Collection is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of bounds
     * @see #join(Collection, int, int, String, String, String, boolean)
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final boolean trim) {
        return join(c, fromIndex, toIndex, delimiter, null, null, trim);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the collection is {@code null} or empty or {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry", "date");
     * Strings.join(list, 1, 3, ", ", "[", "]");           // returns "[banana, cherry]"
     * Strings.join(list, 0, 4, " | ", "Fruits: ", ".");   // returns "Fruits: apple | banana | cherry | date."
     * Strings.join(list, 2, 2, ", ", "[", "]");           // returns "[]"
     * }</pre>
     *
     * @param c the Collection containing the elements to join together, may be {@code null}
     * @param fromIndex the start index in the Collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the Collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified Collection is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the Collection size.
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix) {
        return join(c, fromIndex, toIndex, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided Collection from the specified range into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates elements in the collection from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive),
     * separating each element with the specified delimiter string.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.</p>
     *
     * <p>The method efficiently handles List types with RandomAccess for better performance.
     * It returns just the concatenation of prefix and suffix if the collection is {@code null} or empty or {@code fromIndex == toIndex}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ", " date ");
     * Strings.join(list, 1, 3, ", ", "[", "]", true);              // returns "[banana, cherry]"
     * Strings.join(list, 1, 3, ", ", "[", "]", false);             // returns "[ banana ,  cherry ]"
     * Strings.join(list, 0, 4, " | ", "Items: ", ".", true);       // returns "Items: apple | banana | cherry | date."
     * 
     * // Edge cases
     * Strings.join(null, 0, 0, ", ", "[", "]", true);              // returns "[]"
     * Strings.join(new ArrayList<>(), 0, 0, ", ", "", "", true);   // returns ""
     * }</pre>
     *
     * @param c the Collection containing the elements to join together, may be {@code null}
     * @param fromIndex the start index in the Collection from which to start joining elements. It must be a non-negative integer.
     * @param toIndex the end index in the Collection up to which to join elements. It must be a non-negative integer and not less than fromIndex.
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified array is {@code null} or empty or {@code fromIndex == toIndex} and <i>prefix, suffix</i> are empty.
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of the range of the Collection size.
     */
    public static String join(final Collection<?> c, final int fromIndex, final int toIndex, final String delimiter, final String prefix, final String suffix,
            final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.size(c));

        if (N.isEmpty(c) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final int len = toIndex - fromIndex;
        final String[] elements = new String[len];

        if (c instanceof final List<?> list && c instanceof RandomAccess) {

            for (int i = fromIndex, j = 0; i < toIndex; i++, j++) {
                elements[j] = toString(list.get(i), trim);
            }
        } else {
            int i = 0, j = 0;

            for (final Object e : c) {
                if (i++ >= fromIndex) {
                    elements[j++] = toString(e, trim);
                }

                if (i >= toIndex) {
                    break;
                }
            }
        }

        elements[0] = concat(prefix, elements[0]);
        elements[len - 1] = concat(elements[len - 1], suffix);

        return String.join(nullToEmpty(delimiter), elements);
    }

    /**
     * Joins the elements of the provided Iterator into a single String.
     *
     * <p>This method concatenates all elements from the iterator using the default element separator.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns an empty string if the specified Iterator is {@code null} or has no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list.iterator());   // returns "apple, banana, cherry"
     * 
     * Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
     * Strings.join(numbers.iterator());             // returns "1, 2, 3" (order may vary)
     * 
     * Strings.join(null);                           // returns ""
     * Strings.join(new ArrayList<>().iterator());   // returns ""
     * }</pre>
     *
     * @param iter the Iterator containing the elements to join together, may be {@code null}
     * @return the concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter) {
        return join(iter, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter string.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The delimiter can be empty, in which case the elements are concatenated without any separator.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns an empty string if the specified Iterator is {@code null} or has no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list.iterator(), " - ");   // returns "apple - banana - cherry"
     * Strings.join(list.iterator(), "");      // returns "applebananacherry"
     * Strings.join(list.iterator(), ", ");    // returns "apple, banana, cherry"
     * 
     * List<Integer> numbers = Arrays.asList(1, 2, 3);
     * Strings.join(numbers.iterator(), " and ");          // returns "1 and 2 and 3"
     * 
     * Strings.join(null, ", ");                           // returns ""
     * Strings.join(new ArrayList<>().iterator(), ", ");   // returns ""
     * }</pre>
     *
     * @param iter the Iterator containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter string that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @return the concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter, final String delimiter) {
        return join(iter, delimiter, EMPTY, EMPTY, false);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter, prefix, and suffix.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method returns just the concatenation of prefix and suffix if the Iterator is {@code null} or has no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * Strings.join(list.iterator(), ", ", "[", "]");                // returns "[apple, banana, cherry]"
     * Strings.join(list.iterator(), " | ", "Items: ", ".");         // returns "Items: apple | banana | cherry."
     * 
     * Strings.join(new ArrayList<>().iterator(), ", ", "[", "]");   // returns "[]"
     * Strings.join(null, ", ", "Start: ", " :End");                 // returns "Start:  :End"
     * }</pre>
     *
     * @param iter the Iterator containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty and <i>prefix, suffix</i> are empty.
     * @see #join(Iterator, String, String, String, boolean)
     */
    public static String join(final Iterator<?> iter, final String delimiter, final String prefix, final String suffix) {
        return join(iter, delimiter, prefix, suffix, false);
    }

    /**
     * Joins the elements of the provided Iterator into a single String with the specified delimiter, prefix, suffix, and optional trimming.
     *
     * <p>This method concatenates all elements from the iterator, separating each element with the specified delimiter.
     * The resulting string is prefixed and suffixed with the specified strings.
     * Each element is converted to a string representation using its {@code Strings.toString()} method.
     * If trim is {@code true}, leading and trailing whitespace is removed from each element's string representation.
     * The iterator is consumed during this operation.</p>
     *
     * <p>The method internally converts the iterator to a list and then uses the collection-based join method for processing.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList(" apple ", " banana ", " cherry ");
     * Strings.join(list.iterator(), ", ", "[", "]", true);    // returns "[apple, banana, cherry]"
     * Strings.join(list.iterator(), ", ", "[", "]", false);   // returns "[ apple ,  banana ,  cherry ]"
     * 
     * Set<String> set = new HashSet<>(Arrays.asList("  one  ", "  two  "));
     * Strings.join(set.iterator(), " | ", "", "", true);      // returns "one | two" (order may vary)
     * }</pre>
     *
     * @param iter the Iterator containing the elements to join together, may be {@code null}
     * @param delimiter the delimiter that separates each element. It can be empty, in which case the elements are concatenated without any delimiter.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each element.
     * @return the concatenated string. Returns an empty string if the specified Iterator is {@code null} or empty and <i>prefix, suffix</i> are empty.
     */
    public static String join(final Iterator<?> iter, final String delimiter, final String prefix, final String suffix, final boolean trim) {
        if (iter == null) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final List<?> list = N.toList(iter);

        return join(list, 0, list.size(), delimiter, prefix, suffix, trim);
    }

    /**
     * Joins the entries of the provided Map into a single String.
     *
     * <p>This method creates a string representation of the map entries using default delimiters.
     * Each entry is formatted as "key=value" and entries are separated by the default element separator.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty maps.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new HashMap<>();
     * map.put("apple", 5);
     * map.put("banana", 3);
     * Strings.joinEntries(map);   // returns "apple=5, banana=3" (order may vary)
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * Strings.joinEntries(emptyMap);   // returns ""
     * Strings.joinEntries(null);       // returns ""
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @return a string representation of the map entries, or an empty string if the map is {@code null} or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m) {
        return joinEntries(m, Strings.ELEMENT_SEPARATOR);
    }

    /**
     * Joins the entries of the provided Map into a single String using the specified entry delimiter.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key=value"
     * and entries are separated by the specified delimiter string.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty maps.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("name", 1);
     * map.put("age", 25);
     * Strings.joinEntries(map, ", ");      // returns "name=1, age=25"
     * Strings.joinEntries(map, " AND ");   // returns "name=1 AND age=25"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * Strings.joinEntries(emptyMap, ", ");   // returns ""
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param entryDelimiter the delimiter string that separates each entry.
     * @return a string representation of the map entries, or an empty string if the map is {@code null} or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter) {
        if (N.isEmpty(m)) {
            return EMPTY;
        }

        return joinEntries(m, 0, m.size(), entryDelimiter);
    }

    /**
     * Joins the entries of the provided Map into a single String using specified delimiters.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value"
     * and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty maps.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("min", 10);
     * map.put("max", 100);
     * Strings.joinEntries(map, ", ", " = ");        // returns "min = 10, max = 100"
     * Strings.joinEntries(map, " AND ", " IS ");    // returns "min IS 10 AND max IS 100"
     * Strings.joinEntries(map, "|", "");            // returns "min10|max100"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * Strings.joinEntries(emptyMap, ", ", " = ");   // returns ""
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param keyValueDelimiter the delimiter string that separates the key and value within each entry. It can be empty.
     * @return a string representation of the map entries, or an empty string if the map is {@code null} or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter) {
        if (N.isEmpty(m)) {
            return EMPTY;
        }

        return joinEntries(m, 0, m.size(), entryDelimiter, keyValueDelimiter);
    }

    /**
     * Joins the entries of the provided Map into a single String with specified delimiters and wrapping.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value",
     * entries are separated by the specified entry delimiter, and the entire result is wrapped with prefix and suffix strings.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is {@code null} or empty, the method returns only the concatenated prefix and suffix (or empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("x", 1);
     * map.put("y", 2);
     * Strings.joinEntries(map, ", ", "=", "[", "]");              // returns "[x=1, y=2]"
     * Strings.joinEntries(map, " AND ", " IS ", "WHERE ", ";");   // returns "WHERE x IS 1 AND y IS 2;"
     * 
     * Map<String, String> emptyMap = new HashMap<>();
     * Strings.joinEntries(emptyMap, ", ", "=", "[", "]");   // returns "[]"
     * Strings.joinEntries(emptyMap, ", ", "=", "", "");     // returns ""
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param keyValueDelimiter the delimiter string that separates the key and value within each entry. It can be empty.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string with prefix and suffix, or just prefix+suffix if the map is {@code null} or empty.
     * @see #joinEntries(Map, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter, final String prefix, final String suffix) {
        return joinEntries(m, 0, N.size(m), entryDelimiter, keyValueDelimiter, prefix, suffix, false);
    }

    /**
     * Joins the entries of the provided Map into a single String with full control over formatting.
     *
     * <p>This method creates a string representation of the map entries where each entry is formatted as "key[keyValueDelimiter]value",
     * entries are separated by the specified entry delimiter, and the entire result is wrapped with prefix and suffix strings.
     * The entryDelimiter and keyValueDelimiter can be empty for direct concatenation.
     * If trim is {@code true}, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is {@code null} or empty, the method returns only the concatenated prefix and suffix (or empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" name ", " John ");
     * map.put(" age ", " 25 ");
     * 
     * Strings.joinEntries(map, ", ", "=", "{", "}", false);   // returns "{ name = John ,  age = 25 }"
     * Strings.joinEntries(map, ", ", "=", "{", "}", true);    // returns "{name=John, age=25}"
     * 
     * Map<Integer, Integer> numbers = new LinkedHashMap<>();
     * numbers.put(1, 100);
     * numbers.put(2, 200);
     * Strings.joinEntries(numbers, " + ", "*", "(", ")", false);   // returns "(1*100 + 2*200)"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param entryDelimiter the delimiter that separates each entry. It can be empty.
     * @param keyValueDelimiter the delimiter that separates the key and value within each entry. It can be empty.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, trims the string representations of each key and value.
     * @return the concatenated string with prefix and suffix, or just prefix+suffix if the map is {@code null} or empty.
     */
    public static String joinEntries(final Map<?, ?> m, final String entryDelimiter, final String keyValueDelimiter, final String prefix, final String suffix,
            final boolean trim) {
        return joinEntries(m, 0, N.size(m), entryDelimiter, keyValueDelimiter, prefix, suffix, trim);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key=value" and entries are separated by the specified delimiter string.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is {@code null}, empty, or if fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("first", 1);
     * map.put("second", 2);
     * map.put("third", 3);
     * 
     * Strings.joinEntries(map, 0, 2, ", ");      // returns "first=1, second=2"
     * Strings.joinEntries(map, 1, 3, " AND ");   // returns "second=2 AND third=3"
     * Strings.joinEntries(map, 2, 2, ", ");      // returns ""
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of entries to include.
     * @param toIndex the ending index (exclusive) of entries to include.
     * @param entryDelimiter the delimiter string that separates each entry.
     * @return a string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with optional trimming.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key=value" and entries are separated by the specified delimiter string.
     * If trim is {@code true}, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is {@code null}, empty, or if fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" key1 ", " value1 ");
     * map.put(" key2 ", " value2 ");
     * map.put(" key3 ", " value3 ");
     * 
     * Strings.joinEntries(map, 0, 2, ", ", false);   // returns " key1 = value1 ,  key2 = value2 "
     * Strings.joinEntries(map, 0, 2, ", ", true);    // returns "key1=value1, key2=value2"
     * Strings.joinEntries(map, 1, 3, " | ", true);   // returns "key2=value2 | key3=value3"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of entries to include.
     * @param toIndex the ending index (exclusive) of entries to include.
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param trim if {@code true}, trims the string representations of each key and value.
     * @return a string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final boolean trim) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, WD.EQUAL, null, null, trim);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with specified delimiters.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value" and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is {@code null}, empty, or if fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("min", 10);
     * map.put("max", 100);
     * map.put("avg", 55);
     * 
     * Strings.joinEntries(map, 0, 2, ", ", " = ");       // returns "min = 10, max = 100"
     * Strings.joinEntries(map, 1, 3, " AND ", " IS ");   // returns "max IS 100 AND avg IS 55"
     * Strings.joinEntries(map, 0, 1, "|", "");           // returns "min10"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of entries to include.
     * @param toIndex the ending index (exclusive) of entries to include.
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param keyValueDelimiter the delimiter string that separates the key and value within each entry. It can be empty.
     * @return a string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     * @see #joinEntries(Map, int, int, String, String, String, String, boolean)
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with specified delimiters and optional trimming.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value" and entries are separated by the specified entry delimiter string.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * If trim is {@code true}, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>The method returns an empty string if the map is {@code null}, empty, or if fromIndex equals toIndex.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" name ", " John ");
     * map.put(" age ", " 25 ");
     * map.put(" city ", " NYC ");
     *
     * Strings.joinEntries(map, 0, 2, ", ", "=", false);        // returns " name = John ,  age = 25 "
     * Strings.joinEntries(map, 0, 2, ", ", "=", true);         // returns "name=John, age=25"
     * Strings.joinEntries(map, 1, 3, " AND ", " IS ", true);   // returns "age IS 25 AND city IS NYC"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of entries to include.
     * @param toIndex the ending index (exclusive) of entries to include.
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param keyValueDelimiter the delimiter string that separates the key and value within each entry. It can be empty.
     * @param trim if {@code true}, leading and trailing whitespace of each key and value will be removed.
     * @return a string representation of the specified range of map entries.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final boolean trim) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, null, null, trim);
    }

    /**     
     * Joins a subset of entries from the provided Map into a single String with specified delimiters and wrapping.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value", entries are separated by the specified entry delimiter,
     * and the entire result is wrapped with prefix and suffix strings.
     * The keyValueDelimiter can be empty, in which case the key and value are concatenated directly.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is {@code null}, empty, or if fromIndex equals toIndex, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("x", 1);
     * map.put("y", 2);
     * map.put("z", 3);
     * 
     * Strings.joinEntries(map, 0, 2, ", ", "=", "[", "]");              // returns "[x=1, y=2]"
     * Strings.joinEntries(map, 1, 3, " AND ", " IS ", "WHERE ", ";");   // returns "WHERE y IS 2 AND z IS 3;"
     * Strings.joinEntries(map, 2, 2, ", ", "=", "{", "}");              // returns "{}"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of entries to include.
     * @param toIndex the ending index (exclusive) of entries to include.
     * @param entryDelimiter the delimiter string that separates each entry.
     * @param keyValueDelimiter the delimiter string that separates the key and value within each entry. It can be empty.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @return the concatenated string with prefix and suffix.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final String prefix, final String suffix) {
        return joinEntries(m, fromIndex, toIndex, entryDelimiter, keyValueDelimiter, prefix, suffix, false);
    }

    /**
     * Joins a subset of entries from the provided Map into a single String with full control over formatting.
     *
     * <p>This method creates a string representation of a range of map entries (from fromIndex inclusive to toIndex exclusive)
     * where each entry is formatted as "key[keyValueDelimiter]value", entries are separated by the specified entry delimiter,
     * and the entire result is wrapped with prefix and suffix strings.
     * The entryDelimiter and keyValueDelimiter can be empty for direct concatenation.
     * If trim is {@code true}, the string representations of keys and values will be trimmed of leading and trailing whitespace.
     * The iteration order depends on the Map implementation.</p>
     *
     * <p>If the map is {@code null}, empty, or if fromIndex equals toIndex, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new LinkedHashMap<>();
     * map.put(" id ", " 123 ");
     * map.put(" name ", " John ");
     * map.put(" role ", " Admin ");
     * 
     * Strings.joinEntries(map, 0, 2, ", ", ":", "{", "}", false);          // returns "{ id : 123 ,  name : John }"
     * Strings.joinEntries(map, 0, 2, ", ", ":", "{", "}", true);           // returns "{id:123, name:John}"
     * Strings.joinEntries(map, 1, 3, " AND ", "=", "WHERE ", ";", true);   // returns "WHERE name=John AND role=Admin;"
     * 
     * // Empty range example
     * Strings.joinEntries(map, 2, 2, ", ", "=", "[", "]", false);          // returns "[]"
     * }</pre>
     *
     * @param m the Map containing the entries to join, may be {@code null} or empty
     * @param fromIndex the start index in the entry set from which to start joining entries. It should be non-negative and no larger than the size of the map.
     * @param toIndex the end index in the entry set up to which to join entries. It should be non-negative, no larger than the size of the map, and not less than fromIndex.
     * @param entryDelimiter the delimiter that separates each entry. It can be empty.
     * @param keyValueDelimiter the delimiter that separates the key and value within each entry. It can be empty.
     * @param prefix the prefix to be added at the beginning. It can be empty.
     * @param suffix the suffix to be added at the end. It can be empty.
     * @param trim if {@code true}, leading and trailing whitespace of each key and value will be removed.
     * @return the concatenated string with prefix and suffix, or just prefix+suffix if the range is empty.
     * @throws IndexOutOfBoundsException if fromIndex or toIndex is out of range.
     */
    public static String joinEntries(final Map<?, ?> m, final int fromIndex, final int toIndex, final String entryDelimiter, final String keyValueDelimiter,
            final String prefix, final String suffix, final boolean trim) throws IndexOutOfBoundsException {
        N.checkFromToIndex(fromIndex, toIndex, N.size(m));

        if (N.isEmpty(m) || fromIndex == toIndex) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final StringBuilder sb = Objectory.createStringBuilder(
                calculateBufferSize(toIndex - fromIndex, 32 + N.len(entryDelimiter) + N.len(keyValueDelimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            int i = 0;
            boolean isFirst = true;

            for (final Map.Entry<?, ?> entry : m.entrySet()) {
                if (i >= fromIndex && i < toIndex) {
                    if (!isFirst) {
                        sb.append(entryDelimiter);
                    }
                    isFirst = false;

                    if (trim) {
                        sb.append(N.toString(entry.getKey()).trim());
                        sb.append(keyValueDelimiter);
                        sb.append(N.toString(entry.getValue()).trim());
                    } else {
                        sb.append(N.toString(entry.getKey()));
                        sb.append(keyValueDelimiter);
                        sb.append(N.toString(entry.getValue()));
                    }
                }

                i++;

                if (i >= toIndex) {
                    break;
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Joins the entries of the provided Iterable into a single String using the specified delimiters.
     *
     * <p>This method is designed to handle collections of objects that can be transformed into key-value pairs.
     * Each element in the iterable is processed using the provided key and value extractor functions,
     * formatted as "key[keyValueDelimiter]value", and joined together with the entry delimiter.
     * The iteration order depends on the Iterable implementation.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty iterables.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Person> people = Arrays.asList(
     *     new Person("John", 25),
     *     new Person("Jane", 30)
     * );
     * 
     * Strings.joinEntries(people, ", ", "=", 
     *     person -> person.getName(), 
     *     person -> person.getAge());                // returns "John=25, Jane=30"
     * 
     * Strings.joinEntries(people, " AND ", " IS ", 
     *     person -> person.getName(), 
     *     person -> person.getAge());                // returns "John IS 25 AND Jane IS 30"
     * 
     * List<Person> emptyList = new ArrayList<>();
     * Strings.joinEntries(emptyList, ", ", "=", 
     *     Person::getName, Person::getAge);          // returns ""
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable whose elements are to be joined, may be {@code null} or empty
     * @param entryDelimiter the delimiter to use between entries
     * @param keyValueDelimiter the delimiter to use between keys and values
     * @param keyExtractor function to extract keys from elements. Must not be {@code null}.
     * @param valueExtractor function to extract values from elements. Must not be {@code null}.
     * @return a string representation of the iterable's elements, or an empty string if the iterable is {@code null} or empty.
     * @throws IllegalArgumentException if keyExtractor or valueExtractor is null
     */
    public static <T> String joinEntries(final Iterable<? extends T> c, final String entryDelimiter, final String keyValueDelimiter,
            final Function<? super T, ?> keyExtractor, final Function<? super T, ?> valueExtractor) throws IllegalArgumentException {
        return joinEntries(c, entryDelimiter, keyValueDelimiter, EMPTY, EMPTY, false, keyExtractor, valueExtractor);
    }

    /**
     * Joins the entries of the provided Iterable into a single String with full control over formatting.
     *
     * <p>This method is designed to handle collections of objects that can be transformed into key-value pairs.
     * Each element in the iterable is processed using the provided key and value extractor functions,
     * formatted as "key[keyValueDelimiter]value", joined together with the entry delimiter,
     * and wrapped with prefix and suffix strings.
     * If trim is {@code true}, the string representations of extracted keys and values will be trimmed.
     * The iteration order depends on the Iterable implementation.</p>
     *
     * <p>If the iterable is {@code null} or empty, the method returns only the concatenated prefix and suffix 
     * (or empty string if both are empty).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Map.Entry<String, Integer>> entries = Arrays.asList(
     *     Map.entry(" name ", 1),
     *     Map.entry(" age ", 25)
     * );
     * 
     * Strings.joinEntries(entries, ", ", "=", "[", "]", false,
     *     Map.Entry::getKey, Map.Entry::getValue);   // returns "[ name =1,  age =25]"
     * 
     * Strings.joinEntries(entries, ", ", "=", "[", "]", true,
     *     Map.Entry::getKey, Map.Entry::getValue);   // returns "[name=1, age=25]"
     * 
     * List<Product> products = Arrays.asList(
     *     new Product("Apple", 1.99),
     *     new Product("Banana", 0.99)
     * );
     * 
     * Strings.joinEntries(products, " + ", " costs $", "Total: ", "", false,
     *     Product::getName, Product::getPrice);   // returns "Total: Apple costs $1.99 + Banana costs $0.99"
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable whose elements are to be joined, may be {@code null} or empty
     * @param entryDelimiter the delimiter to use between entries
     * @param keyValueDelimiter the delimiter to use between keys and values
     * @param prefix the string to place at the start of the result. It can be empty.
     * @param suffix the string to place at the end of the result. It can be empty.
     * @param trim if {@code true}, trims the string representations of extracted keys and values.
     * @param keyExtractor function to extract keys from elements. Must not be {@code null}.
     * @param valueExtractor function to extract values from elements. Must not be {@code null}.
     * @return a string representation of the iterable's elements with prefix and suffix, or just prefix+suffix if the iterable is {@code null} or empty.
     * @throws IllegalArgumentException if keyExtractor or valueExtractor is null
     * 
     * @see #join(Iterable)
     * @see #join(Iterable, String)
     * @see #joinEntries(Map, String, String)
     */
    public static <T> String joinEntries(final Iterable<? extends T> c, final String entryDelimiter, final String keyValueDelimiter, final String prefix,
            final String suffix, final boolean trim, final Function<? super T, ?> keyExtractor, final Function<? super T, ?> valueExtractor)
            throws IllegalArgumentException {
        N.checkArgNotNull(keyExtractor, cs.keyExtractor);
        N.checkArgNotNull(valueExtractor, cs.valueExtractor);

        if (N.isEmpty(c)) {
            if (isEmpty(prefix) && isEmpty(suffix)) {
                return EMPTY;
            } else if (isEmpty(prefix)) {
                return suffix;
            } else if (isEmpty(suffix)) {
                return prefix;
            } else {
                return concat(prefix, suffix);
            }
        }

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(c instanceof Collection coll ? coll.size() : 16,
                32 + N.len(entryDelimiter) + N.len(keyValueDelimiter), N.len(prefix), N.len(suffix)));

        try {
            if (isNotEmpty(prefix)) {
                sb.append(prefix);
            }

            int i = 0;

            for (T e : c) {
                if (i++ > 0) {
                    sb.append(entryDelimiter);
                }

                if (trim) {
                    sb.append(N.toString(keyExtractor.apply(e)).trim());
                    sb.append(keyValueDelimiter);
                    sb.append(N.toString(valueExtractor.apply(e)).trim());
                } else {
                    sb.append(N.toString(keyExtractor.apply(e)));
                    sb.append(keyValueDelimiter);
                    sb.append(N.toString(valueExtractor.apply(e)));
                }
            }

            if (isNotEmpty(suffix)) {
                sb.append(suffix);
            }

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Concatenates two strings into a single string.
     *
     * <p>This method concatenates the two given strings efficiently. If either string is {@code null} or empty,
     * it is treated as an empty string before concatenation. The method optimizes for cases where one or both
     * strings are empty to avoid unnecessary string operations.</p>
     *
     * <p>The method returns an empty string if both input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", "World");   // returns "HelloWorld"
     * Strings.concat("Hello", null);      // returns "Hello"
     * Strings.concat(null, "World");      // returns "World"
     * Strings.concat("", "World");        // returns "World"
     * Strings.concat(null, null);         // returns ""
     * Strings.concat("", "");             // returns ""
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if both inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b) {
        if (N.isEmpty(a)) {
            return N.isEmpty(b) ? Strings.EMPTY : b;
        } else {
            return N.isEmpty(b) ? a : a.concat(b);
        }
    }

    /**
     * Concatenates three strings into a single string.
     *
     * <p>This method concatenates the three given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", " ", "World");    // returns "Hello World"
     * Strings.concat("A", "B", "C");            // returns "ABC"
     * Strings.concat("Hello", null, "World");   // returns "HelloWorld"
     * Strings.concat(null, null, null);         // returns ""
     * Strings.concat("", "", "");               // returns ""
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c));
    }

    /**
     * Concatenates four strings into a single string.
     *
     * <p>This method concatenates the four given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", " ", "World", "!");     // returns "Hello World!"
     * Strings.concat("A", "B", "C", "D");             // returns "ABCD"
     * Strings.concat("Hello", null, "World", null);   // returns "HelloWorld"
     * Strings.concat(null, null, null, null);         // returns ""
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d));
    }

    /**
     * Concatenates five strings into a single string.
     *
     * <p>This method concatenates the five given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", " ", "World", "!", "!");   // returns "Hello World!!"
     * Strings.concat("A", "B", "C", "D", "E");           // returns "ABCDE"
     * Strings.concat("1", null, "2", null, "3");         // returns "123"
     * Strings.concat(null, null, null, null, null);      // returns ""
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @param e the fifth string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e));
    }

    /**
     * Concatenates six strings into a single string.
     *
     * <p>This method concatenates the six given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F");         // returns "ABCDEF"
     * Strings.concat("1", "2", "3", "4", "5", "6");         // returns "123456"
     * Strings.concat("H", "e", "l", "l", "o", "!");         // returns "Hello!"
     * Strings.concat(null, null, null, null, null, null);   // returns ""
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @param e the fifth string to concatenate, may be {@code null} or empty
     * @param f the sixth string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f));
    }

    /**
     * Concatenates seven strings into a single string.
     *
     * <p>This method concatenates the seven given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G");   // returns "ABCDEFG"
     * Strings.concat("1", "2", "3", "4", "5", "6", "7");   // returns "1234567"
     * Strings.concat("H", "e", "l", "l", "o", " ", "7");   // returns "Hello 7"
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @param e the fifth string to concatenate, may be {@code null} or empty
     * @param f the sixth string to concatenate, may be {@code null} or empty
     * @param g the seventh string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g));
    }

    /**
     * Concatenates eight strings into a single string.
     *
     * <p>This method concatenates the eight given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G", "H");   // returns "ABCDEFGH"
     * Strings.concat("1", "2", "3", "4", "5", "6", "7", "8");   // returns "12345678"
     * Strings.concat("H", "e", "l", "l", "o", " ", "8", "!");   // returns "Hello 8!"
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @param e the fifth string to concatenate, may be {@code null} or empty
     * @param f the sixth string to concatenate, may be {@code null} or empty
     * @param g the seventh string to concatenate, may be {@code null} or empty
     * @param h the eighth string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g,
            final String h) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g),
                nullToEmpty(h));
    }

    /**
     * Concatenates nine strings into a single string.
     *
     * <p>This method concatenates the nine given strings in the order they are provided.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * uses {@code String.join} internally for efficient concatenation.</p>
     *
     * <p>The method returns an empty string if all input strings are {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G", "H", "I");   // returns "ABCDEFGHI"
     * Strings.concat("1", "2", "3", "4", "5", "6", "7", "8", "9");   // returns "123456789"
     * Strings.concat("H", "e", "l", "l", "o", " ", "9", "!", "!");   // returns "Hello 9!!"
     * }</pre>
     *
     * @param a the first string to concatenate, may be {@code null} or empty
     * @param b the second string to concatenate, may be {@code null} or empty
     * @param c the third string to concatenate, may be {@code null} or empty
     * @param d the fourth string to concatenate, may be {@code null} or empty
     * @param e the fifth string to concatenate, may be {@code null} or empty
     * @param f the sixth string to concatenate, may be {@code null} or empty
     * @param g the seventh string to concatenate, may be {@code null} or empty
     * @param h the eighth string to concatenate, may be {@code null} or empty
     * @param i the ninth string to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if all inputs are {@code null} or empty.
     */
    public static String concat(final String a, final String b, final String c, final String d, final String e, final String f, final String g, final String h,
            final String i) {
        return String.join(Strings.EMPTY, nullToEmpty(a), nullToEmpty(b), nullToEmpty(c), nullToEmpty(d), nullToEmpty(e), nullToEmpty(f), nullToEmpty(g),
                nullToEmpty(h), nullToEmpty(i));
    }

    /**
     * Concatenates the given array of strings into a single string.
     *
     * <p>This method concatenates all strings in the provided array in the order they appear.
     * {@code null} strings are converted to empty strings before concatenation. The method
     * optimizes for different array lengths, using specialized implementations for arrays
     * with up to 7 elements for better performance.</p>
     *
     * <p>The method returns an empty string if the array is {@code null}, empty, or contains only {@code null} elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat(new String[] {"Hello", " ", "World"});    // returns "Hello World"
     * Strings.concat(new String[] {"A", "B", "C", "D"});       // returns "ABCD"
     * Strings.concat(new String[] {"Hello", null, "World"});   // returns "HelloWorld"
     * Strings.concat(new String[] {null, null});               // returns ""
     * Strings.concat(new String[0]);                           // returns ""
     * Strings.concat((String[]) null);                         // returns ""
     * }</pre>
     *
     * @param a the array of strings to concatenate, may be {@code null} or empty
     * @return the concatenated string. Returns an empty string if the array is {@code null} or empty.
     */
    public static String concat(final String... a) {
        final int len = N.len(a);

        switch (len) {
            case 0:
                return EMPTY;

            case 1:
                return nullToEmpty(a[0]);

            case 2:
                return concat(a[0], a[1]);

            case 3:
                return concat(a[0], a[1], a[2]);

            case 4:
                return concat(a[0], a[1], a[2], a[3]);

            case 5:
                return concat(a[0], a[1], a[2], a[3], a[4]);

            case 6:
                return concat(a[0], a[1], a[2], a[3], a[4], a[5]);

            case 7:
                return concat(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);

            default: {
                final String[] b = N.copyThenReplaceAll(a, Fn.nullToEmpty());

                return String.join(Strings.EMPTY, b);
            }
        }
    }

    /**
     * Concatenates the string representations of two objects into a single string.
     *
     * <p>This method converts both objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if both objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", 123);           // returns "Hello123"
     * Strings.concat(42, " is the answer");   // returns "42 is the answer"
     * Strings.concat(null, "World");          // returns "World"
     * Strings.concat("Hello", null);          // returns "Hello"
     * Strings.concat(null, null);             // returns ""
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     */
    public static String concat(final Object a, final Object b) {
        return Strings.concat(N.toString(a), N.toString(b));
    }

    /**
     * Concatenates the string representations of three objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("Hello", " ", "World");   // returns "Hello World"
     * Strings.concat(1, 2, 3);                 // returns "123"
     * Strings.concat("Value: ", 42, "!");      // returns "Value: 42!"
     * Strings.concat(null, null, null);        // returns ""
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c));
    }

    /**
     * Concatenates the string representations of four objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D");               // returns "ABCD"
     * Strings.concat(1, "+", 2, "=3");                  // returns "1+2=3"
     * Strings.concat("Result: ", 10, " out of ", 20);   // returns "Result: 10 out of 20"
     * Strings.concat(null, null, null, null);           // returns ""
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d));
    }

    /**
     * Concatenates the string representations of five objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E");        // returns "ABCDE"
     * Strings.concat(1, " ", 2, " ", 3);              // returns "1 2 3"
     * Strings.concat("Sum of ", 1, "+", 2, "=3");     // returns "Sum of 1+2=3"
     * Strings.concat(null, null, null, null, null);   // returns ""
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @param e the fifth object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e));
    }

    /**
     * Concatenates the string representations of six objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F");   // returns "ABCDEF"
     * Strings.concat(1, 2, 3, 4, 5, 6);               // returns "123456"
     * Strings.concat("H", "e", "l", "l", "o", "!");   // returns "Hello!"
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @param e the fifth object to concatenate, may be {@code null}
     * @param f the sixth object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f));
    }

    /**
     * Concatenates the string representations of seven objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G");   // returns "ABCDEFG"
     * Strings.concat(1, 2, 3, 4, 5, 6, 7);                 // returns "1234567"
     * Strings.concat("H", "e", "l", "l", "o", " ", 7);     // returns "Hello 7"
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @param e the fifth object to concatenate, may be {@code null}
     * @param f the sixth object to concatenate, may be {@code null}
     * @param g the seventh object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g));
    }

    /**
     * Concatenates the string representations of eight objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G", "H");   // returns "ABCDEFGH"
     * Strings.concat(1, 2, 3, 4, 5, 6, 7, 8);                   // returns "12345678"
     * Strings.concat("H", "e", "l", "l", "o", " ", 8, "!");     // returns "Hello 8!"
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @param e the fifth object to concatenate, may be {@code null}
     * @param f the sixth object to concatenate, may be {@code null}
     * @param g the seventh object to concatenate, may be {@code null}
     * @param h the eighth object to concatenate, may be {@code null}
     * @return the concatenated string representation of the objects.
     * @see #concat(Object, Object)
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g,
            final Object h) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g), N.toString(h));
    }

    /**
     * Concatenates the string representations of nine objects into a single string.
     *
     * <p>This method converts all objects to their string representations using {@code N.toString}
     * and then concatenates them. {@code null} objects are converted to empty strings before concatenation.
     * The actual concatenation is delegated to the string-based {@code concat} method.</p>
     *
     * <p>The method returns an empty string if all objects are {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.concat("A", "B", "C", "D", "E", "F", "G", "H", "I");   // returns "ABCDEFGHI"
     * Strings.concat(1, 2, 3, 4, 5, 6, 7, 8, 9);                     // returns "123456789"
     * Strings.concat("H", "e", "l", "l", "o", " ", 9, "!", "!");     // returns "Hello 9!!"
     * }</pre>
     *
     * @param a the first object to concatenate, may be {@code null}
     * @param b the second object to concatenate, may be {@code null}
     * @param c the third object to concatenate, may be {@code null}
     * @param d the fourth object to concatenate, may be {@code null}
     * @param e the fifth object to concatenate, may be {@code null}
     * @param f the sixth object to concatenate, may be {@code null}
     * @param g the seventh object to concatenate, may be {@code null}
     * @param h the eighth object to concatenate, may be {@code null}
     * @param i the ninth object to concatenate, may be {@code null}
     * @return the concatenated string. Returns an empty string if all input objects are {@code null} or empty.
     */
    public static String concat(final Object a, final Object b, final Object c, final Object d, final Object e, final Object f, final Object g, final Object h,
            final Object i) {
        return Strings.concat(N.toString(a), N.toString(b), N.toString(c), N.toString(d), N.toString(e), N.toString(f), N.toString(g), N.toString(h),
                N.toString(i));
    }

    private static String toString(final Object e, final boolean trim) {
        if (e == null) {
            return NULL;
        }

        if (trim) {
            return N.toString(e).trim();
        } else {
            return N.toString(e);
        }
    }

    /**
     * <p>Note: It's copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * Returns a formatted string using the specified template string and arguments (Copied from Google Guava).
     *
     * <p>This method replaces each occurrence of {@code "%s"} in the template with the corresponding argument value.
     * If there are more placeholders than arguments, the extra placeholders remain unchanged. If there are more
     * arguments than placeholders, the extra arguments are appended to the end in square brackets.</p>
     *
     * <p>This method is designed for lenient formatting, particularly useful for debugging and logging where
     * exception handling during formatting would be counterproductive. Unlike {@code String.format}, this method
     * will not throw exceptions for mismatched arguments.</p>
     *
     * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
     * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
     * full range of <a
     * href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax">format
     * specifiers</a>, and alert you to usage errors by throwing {@link
     * java.util.IllegalFormatException}.</p>
     *
     * <p>In certain cases, such as outputting debugging information or constructing a message to be
     * used for another unchecked exception, an exception during string formatting would serve little
     * purpose except to supplant the real information you were trying to provide. These are the cases
     * this method is made for; it instead generates a best-effort string with all supplied argument
     * values present. This method is also useful in environments such as GWT where {@code
     * String.format} is not available. As an example, method implementations of the {@code Preconditions} class use this formatter, for both of the reasons just discussed.</p>
     *
     * <p><b>Warning:</b> Only the exact two-character placeholder sequence {@code "%s"} is
     * recognized.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.lenientFormat("Hello %s", "World");             // returns "Hello World"
     * Strings.lenientFormat("Hello %s %s", "New", "World");   // returns "Hello New World"
     * Strings.lenientFormat("Hello %s", "World", "Extra");    // returns "Hello World: [Extra]"
     * Strings.lenientFormat("Hello %s %s", "World");          // returns "Hello World %s"
     * Strings.lenientFormat("Hello", "World");                // returns "Hello: [World]"
     * Strings.lenientFormat(null, "arg1", "arg2");            // returns "null: [arg1, arg2]"
     * }</pre>
     *
     * @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code
     *     null} is treated as the four-character string {@code "null"}.
     * @param args the arguments to be substituted into the message template. The first argument
     *     specified is substituted for the first occurrence of {@code "%s"} in the template, and so
     *     forth. A {@code null} argument is converted to the four-character string {@code "null"};
     *     {@code non-null} values are converted to strings using {@link Object#toString()}.
     * @return the formatted string with placeholders replaced by arguments.
     */
    // TODO(diamondm) consider using Arrays.toString() for array parameters
    public static String lenientFormat(String template, Object... args) {
        template = String.valueOf(template);   // null -> "null"

        if (args == null) {
            args = new Object[] { "(Object[])null" };
        } else {
            for (int i = 0; i < args.length; i++) {
                args[i] = lenientToString(args[i]);
            }
        }

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + 16 * args.length);
        int templateStart = 0;
        int i = 0;
        while (i < args.length) {
            final int placeholderStart = template.indexOf("%s", templateStart);
            if (placeholderStart == -1) {
                break;
            }
            sb.append(template, templateStart, placeholderStart);
            sb.append(args[i++]);
            templateStart = placeholderStart + 2;
        }
        sb.append(template, templateStart, template.length());

        // if we run out of placeholders, append the extra args in square braces
        if (i < args.length) {
            sb.append(": [");
            sb.append(args[i++]);
            while (i < args.length) {
                sb.append(", ");
                sb.append(args[i++]);
            }
            sb.append(']');
        }

        final String result = sb.toString();
        Objectory.recycle(sb);
        return result;
    }

    private static String lenientToString(final Object obj) {
        try {
            return String.valueOf(obj);
        } catch (final Exception e) {
            // Default toString() behavior - see Object.toString()
            final String objectToString = obj.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(obj));
            // Logger is created inline with fixed name to avoid forcing Proguard to create another class.
            // Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);

            LOGGER.warn("Exception during lenientFormat for " + objectToString, e);   //NOSONAR

            return "<" + objectToString + " threw " + e.getClass().getName() + ">";
        }
    }

    /**
     * Reverses the characters in the given string.
     *
     * <p>This method creates a new string with all characters in reverse order. It uses
     * {@code StringBuilder.reverse()} internally for efficient reversal. If the input string
     * is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p>The method properly handles Unicode characters and maintains character pairs.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.reverse("Hello");   // returns "olleH"
     * Strings.reverse("12345");   // returns "54321"
     * Strings.reverse("A");       // returns "A"
     * Strings.reverse("");        // returns ""
     * Strings.reverse(null);      // returns null
     * }</pre>
     *
     * @param str the string to be reversed. May be {@code null} or empty.
     * @return a new string with the characters reversed. If the input string is {@code null} or empty or its length &lt;= 1, the input string is returned.
     */
    public static String reverse(final String str) {
        if (N.len(str) <= 1) {
            return str;
        }

        final StringBuilder sb = Objectory.createStringBuilder(str.length());

        try {
            sb.append(str);

            return sb.reverse().toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    /**
     * Reverses a string that is delimited by a specific character.
     *
     * <p>This method splits the string by the specified delimiter character, reverses the order
     * of the resulting segments, and then joins them back together using the same delimiter.
     * The individual segments themselves are not reversed - only their order is changed.</p>
     *
     * <p>If the delimiter is not found in the string, the original string is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.reverseDelimited(null, '*');                 // returns null
     * Strings.reverseDelimited("", '*');                   // returns ""
     * Strings.reverseDelimited("a.b.c", 'x');              // returns "a.b.c"
     * Strings.reverseDelimited("a.b.c", '.');              // returns "c.b.a"
     * Strings.reverseDelimited("java.lang.String", '.');   // returns "String.lang.java"
     * }</pre>
     *
     * @param str the string to reverse, which may be {@code null}.
     * @param delimiter the delimiter character to use for splitting and joining.
     * @return the string with its delimited segments reversed. If the input string is {@code null} or empty or its length &lt;= 1, the input string is returned.
     */
    public static String reverseDelimited(final String str, final char delimiter) {
        if (N.len(str) <= 1) {
            return str;
        }

        // could implement manually, but simple way is to reuse other,
        // probably slower, methods.
        final String[] strs = split(str, delimiter);

        N.reverse(strs);

        return join(strs, String.valueOf(delimiter));
    }

    /**
     * Reverses the order of delimited elements in a string.
     *
     * <p>This method splits the string by the specified delimiter string, reverses the order
     * of the resulting segments, and then joins them back together using the same delimiter.
     * The individual segments themselves are not reversed - only their order is changed.</p>
     *
     * <p>If the delimiter is not found in the string, the original string is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.reverseDelimited(null, " ");                 // returns null
     * Strings.reverseDelimited("", " ");                   // returns ""
     * Strings.reverseDelimited("Hello World", "xyz");      // returns "Hello World"
     * Strings.reverseDelimited("Hello World Java", " ");   // returns "Java World Hello"
     * Strings.reverseDelimited("A::B::C", "::");           // returns "C::B::A"
     * }</pre>
     *
     * @param str the string to be reversed. May be {@code null} or empty.
     * @param delimiter the delimiter that separates the elements in the string.
     * @return the reversed string. If the input string is {@code null} or empty or its length &lt;= 1, the input string is returned.
     */
    public static String reverseDelimited(final String str, final String delimiter) {
        if (N.len(str) <= 1) {
            return str;
        }

        // could implement manually, but simple way is to reuse other,
        // probably slower, methods.
        final String[] strs = split(str, delimiter);

        N.reverse(strs);

        return join(strs, delimiter);
    }

    /**
     * Sorts the characters in the given string in ascending order.
     *
     * <p>This method creates a new string with all characters sorted according to their natural
     * ordering (Unicode values). The sorting is performed by converting the string to a character
     * array, sorting the array, and then creating a new string from the sorted array.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.sort("dcba");    // returns "abcd"
     * Strings.sort("54321");   // returns "12345"
     * Strings.sort("Hello");   // returns "Helo" (duplicate 'l' preserved)
     * Strings.sort("a");       // returns "a"
     * Strings.sort("");        // returns ""
     * Strings.sort(null);      // returns null
     * }</pre>
     *
     * @param str the string whose characters are to be sorted. May be {@code null} or empty.
     * @return a new sorted string if the specified {@code str} is not {@code null} or empty, otherwise the specified {@code str} is returned. If the input string is {@code null} or empty or its length &lt;= 1, the input string is returned.
     */
    public static String sort(final String str) {
        if (N.len(str) <= 1) {
            return str;
        }

        final char[] chs = str.toCharArray();
        N.sort(chs);
        return String.valueOf(chs);
    }

    // Rotating (circular shift)
    //-----------------------------------------------------------------------

    /**
     * Rotates (circular shift) a string by the specified number of positions.
     *
     * <p>This method performs a circular shift on the string characters. A positive shift value
     * rotates the string to the right (characters from the end move to the beginning), while
     * a negative shift value rotates to the left (characters from the beginning move to the end).</p>
     *
     * <p>The shift value is normalized using modulo operation, so shifts larger than the string
     * length will wrap around appropriately.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.rotate(null, *);         // returns null
     * Strings.rotate("", *);           // returns ""
     * Strings.rotate("abcdefg", 0);    // returns "abcdefg"
     * Strings.rotate("abcdefg", 2);    // returns "fgabcde"
     * Strings.rotate("abcdefg", -2);   // returns "cdefgab"
     * Strings.rotate("abcdefg", 7);    // returns "abcdefg"
     * Strings.rotate("abcdefg", -7);   // returns "abcdefg"
     * Strings.rotate("abcdefg", 9);    // returns "fgabcde"
     * Strings.rotate("abcdefg", -9);   // returns "cdefgab"
     * }</pre>
     *
     * @param str the String to rotate, may be {@code null}
     * @param shift number of time to shift (positive : right shift, negative : left shift)
     * @return the rotated String,
     *          or the original String if {@code shift == 0},
     *          or {@code null} if {@code null} String input
     */
    public static String rotate(final String str, final int shift) {
        final int strLen = N.len(str);

        if (strLen <= 1 || shift == 0 || shift % strLen == 0) {
            return str;
        }

        int offset = -(shift % strLen);

        if (offset < 0) {
            offset = str.length() + offset;
        }

        if (offset < 0) {
            offset = 0;
        }

        return substring(str, offset) + Strings.substring(str, 0, offset);
    }

    /**
     * Shuffles the characters in the given string using a default random number generator.
     *
     * <p>This method randomly rearranges the characters in the string using the Fisher-Yates
     * shuffle algorithm. Each possible permutation of the characters has equal probability
     * of being produced. The shuffling uses the default {@code Random} instance.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.shuffle("Hello");   // might return "leHol", "olleH", etc.
     * Strings.shuffle("12345");   // might return "31524", "45213", etc.
     * Strings.shuffle("a");       // returns "a"
     * Strings.shuffle("");        // returns ""
     * Strings.shuffle(null);      // returns null
     * }</pre>
     *
     * @param str the string to be shuffled. May be {@code null} or empty.
     * @return a new string with the characters shuffled. If the input string is {@code null} or empty, the input string is returned.
     */
    public static String shuffle(final String str) {
        return shuffle(str, N.RAND);
    }

    /**
     * Shuffles the characters in the given string using the provided Random instance.
     *
     * <p>This method randomly rearranges the characters in the string using the Fisher-Yates
     * shuffle algorithm with the specified Random instance. This allows for reproducible
     * shuffling when using a Random instance with a fixed seed.</p>
     *
     * <p>If the input string is {@code null}, empty, or has a length of 1 or less, it is returned unchanged.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Random rnd = new Random(42);
     * Strings.shuffle("Hello", rnd);   // returns a deterministic shuffle
     * Strings.shuffle("12345", rnd);   // returns another deterministic shuffle
     * Strings.shuffle("a", rnd);       // returns "a"
     * Strings.shuffle("", rnd);        // returns ""
     * Strings.shuffle(null, rnd);      // returns null
     * }</pre>
     *
     * @param str the string to be shuffled. May be {@code null} or empty.
     * @param rnd the Random instance used to shuffle the characters.
     * @return a new string with the characters shuffled. If the input string is {@code null} or empty, the input string is returned.
     */
    public static String shuffle(final String str, final Random rnd) {
        final int strLen = N.len(str);

        if (strLen <= 1) {
            return str;
        }

        final char[] chars = str.toCharArray();

        N.shuffle(chars, rnd);

        return String.valueOf(chars);
    }

    // Overlay
    //-----------------------------------------------------------------------

    /**
     * Overlays part of a String with another String.
     *
     * <p>This method replaces a portion of the original string (from {@code start} to {@code end - 1})
     * with the overlay string. The characters before {@code start} and from {@code end} onwards
     * remain unchanged. This is functionally equivalent to {@code Strings.replace(str, start, end, overlay)}.</p>
     *
     * <p>If the overlay string is {@code null} or empty, the specified portion is simply removed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.overlay(null, "abc", 0, 0);        // returns "abc"
     * Strings.overlay("", "abc", 0, 0);          // returns "abc"
     * Strings.overlay("abcdef", null, 2, 4);     // returns "abef"
     * Strings.overlay("abcdef", "", 2, 4);       // returns "abef"
     * Strings.overlay("abcdef", "zzzz", 2, 4);   // returns "abzzzzef"
     * }</pre>
     *
     * @param str the String to do overlaying in, may be {@code null}
     * @param overlay the String to overlay, may be {@code null}
     * @param start the position to start overlaying at; must be valid index
     * @param end the position to stop overlaying before; must be valid
     * @return overlayed String, or {@code overlay} if {@code null} String input
     * @throws IndexOutOfBoundsException if start or end is negative, or end is greater than the length of str, or indices are invalid
     * @deprecated replaced by {@code Strings.replace(String, int, int, String)}
     * @see #replace(String, int, int, String)
     * @see N#replaceRange(String, int, int, String)
     */
    @Deprecated
    public static String overlay(final String str, final String overlay, final int start, final int end) throws IndexOutOfBoundsException {
        return replace(str, start, end, overlay);
    }

    /**
     * Parses the string argument as a boolean.
     *
     * <p>This method returns {@code true} if and only if the string is not {@code null},
     * not empty, and is equal, ignoring case, to the string "true". This differs from
     * {@code Boolean.parseBoolean} which returns {@code false} for empty strings.</p>
     *
     * <p>The method provides a more strict parsing than {@code Boolean.parseBoolean}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseBoolean("true");    // returns true
     * Strings.parseBoolean("True");    // returns true
     * Strings.parseBoolean("TRUE");    // returns true
     * Strings.parseBoolean("false");   // returns false
     * Strings.parseBoolean("yes");     // returns false
     * Strings.parseBoolean("");        // returns false
     * Strings.parseBoolean(null);      // returns false
     * }</pre>
     *
     * @param str the string to be parsed. May be {@code null}.
     * @return the boolean represented by the string argument.
     * @see Boolean#parseBoolean(String)
     */
    public static boolean parseBoolean(final String str) {
        return !Strings.isEmpty(str) && Boolean.parseBoolean(str);
    }

    /**
     * Parses the string argument as a char.
     *
     * <p>This method handles three cases:
     * <ul>
     *   <li>If the string is {@code null} or empty, returns {@code '\0'} (the {@code null} character)</li>
     *   <li>If the string has exactly one character, returns that character</li>
     *   <li>Otherwise, parses the string as an integer and casts it to char</li>
     * </ul>
     *
     * <p>This allows for both direct character representation and numeric character codes.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseChar("A");    // returns 'A'
     * Strings.parseChar("65");   // returns 'A' (ASCII code 65)
     * Strings.parseChar("$");    // returns '$'
     * Strings.parseChar("36");   // returns '$' (ASCII code 36)
     * Strings.parseChar("");     // returns '\0'
     * Strings.parseChar(null);   // returns '\0'
     * }</pre>
     *
     * @param str the string to be parsed. May be {@code null}.
     * @return the char represented by the string argument.
     * @throws NumberFormatException if the string has more than one character and cannot be parsed as an integer
     * @throws IllegalArgumentException if the string represents an integer outside the valid char range [0, 65535]
     */
    public static char parseChar(final String str) {
        if (Strings.isEmpty(str)) {
            return CHAR_ZERO;
        } else if (str.length() == 1) {
            return str.charAt(0);
        } else {
            int intValue = Integer.parseInt(str);
            if (intValue < Character.MIN_VALUE || intValue > Character.MAX_VALUE) {
                throw new IllegalArgumentException("Integer value out of char range: " + intValue);
            }
            return (char) intValue;
        }
    }

    /**
     * Returns the value by calling {@code Byte.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code byte} is
     * returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseByte("123");   // returns 123
     * Strings.parseByte(null);    // returns 0
     * }</pre>
     *
     * @param str the string to parse, may be {@code null}
     * @return the parsed byte value, or 0 if the string is {@code null}
     * @throws NumberFormatException if the string is not a parsable {@code byte}.
     * @see Numbers#toByte(String)
     * @deprecated replaced by {@code Numbers.toByte(String)}
     */
    @Deprecated
    public static byte parseByte(final String str) throws NumberFormatException {
        return Numbers.toByte(str);
    }

    /**
     * Returns the value by calling {@code Short.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code short} is
     * returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseShort("123");   // returns 123
     * Strings.parseShort(null);    // returns 0
     * }</pre>
     *
     * @param str the string to parse, may be {@code null}
     * @return the parsed short value, or 0 if the string is {@code null}
     * @throws NumberFormatException if the string is not a parsable {@code short}.
     * @see Numbers#toShort(String)
     * @deprecated replaced by {@code Numbers.toShort(String)}
     */
    @Deprecated
    public static short parseShort(final String str) throws NumberFormatException {
        return Numbers.toShort(str);
    }

    /**
     * Converts the given string to an integer value.
     *
     * <p>This method attempts to convert the provided string to an integer. If the string is {@code null} or empty,
     * default value {@code 0} is returned. Otherwise, the method attempts to parse the string as an integer.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseInt("123");   // returns 123
     * Strings.parseInt(null);    // returns 0
     * }</pre>
     *
     * @param str the string to convert. This can be any instance of String.
     * @return the integer representation of the provided string, or {@code 0} if the object is {@code null} or empty.
     * @throws NumberFormatException if the string cannot be parsed as an integer.
     * @see Numbers#toInt(String)
     * @deprecated replaced by {@code Numbers.toInt(String)}
     */
    @Deprecated
    public static int parseInt(final String str) throws NumberFormatException {
        return Numbers.toInt(str);
    }

    /**
     * Returns the value by calling {@code Long.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0 for {@code long} is
     * returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseLong("123");   // returns 123
     * Strings.parseLong(null);    // returns 0
     * }</pre>
     *
     * @param str the string to parse, may be {@code null}
     * @return the parsed long value, or 0 if the string is {@code null}
     * @throws NumberFormatException if the string is not a parsable {@code long}.
     * @see Numbers#toLong(String)
     * @deprecated replaced by {@code Numbers.toLong(String)}
     */
    @Deprecated
    public static long parseLong(final String str) throws NumberFormatException {
        return Numbers.toLong(str);
    }

    /**
     * Returns the value by calling {@code Float.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0f for {@code float} is
     * returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseFloat("123.45");   // returns 123.45f
     * Strings.parseFloat(null);       // returns 0.0f
     * }</pre>
     *
     * @param str the string to parse, may be {@code null}
     * @return the parsed float value, or 0f if the string is {@code null}
     * @throws NumberFormatException if the string is not a parsable {@code float}.
     * @see Numbers#toFloat(String)
     * @deprecated replaced by {@code Numbers.toFloat(String)}
     */
    @Deprecated
    public static float parseFloat(final String str) throws NumberFormatException {
        return Numbers.toFloat(str);
    }

    /**
     * Returns the value by calling {@code Double.valueOf(String)} if {@code str}
     * is not {@code null}, otherwise, the default value 0d for {@code double} is
     * returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.parseDouble("123.45");   // returns 123.45d
     * Strings.parseDouble(null);       // returns 0.0d
     * }</pre>
     *
     * @param str the string to parse, may be {@code null}
     * @return the parsed double value, or 0d if the string is {@code null}
     * @throws NumberFormatException if the string is not a parsable {@code double}.
     * @see Numbers#toDouble(String)
     * @deprecated replaced by {@code Numbers.toDouble(String)}
     */
    @Deprecated
    public static double parseDouble(final String str) throws NumberFormatException {
        return Numbers.toDouble(str);
    }

    /**
     * Encodes the given binary data into a Base64 encoded string.
     *
     * <p>This method converts a byte array to its Base64 string representation using standard
     * Base64 encoding. The encoding uses the standard Base64 alphabet as specified in RFC 4648.</p>
     *
     * <p>If the input byte array is {@code null} or empty, an empty string is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.base64Encode("Hello".getBytes());   // returns "SGVsbG8="
     * Strings.base64Encode(new byte[] {1,2,3});   // returns "AQID"
     * Strings.base64Encode(new byte[0]);          // returns ""
     * Strings.base64Encode(null);                 // returns ""
     * }</pre>
     *
     * @param binaryData the byte array to be encoded.
     * @return the Base64 encoded string, or an empty String {@code ""} if the input byte array is {@code null} or empty.
     */
    public static String base64Encode(final byte[] binaryData) {
        if (N.isEmpty(binaryData)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(binaryData);
    }

    /**
     * Encodes the given string into a Base64 encoded string using the platform's default charset.
     *
     * <p>This method converts a string to its Base64 representation by first converting the string
     * to bytes using the platform's default charset, then encoding those bytes using standard
     * Base64 encoding.</p>
     *
     * <p>If the input string is {@code null} or empty, an empty string is returned.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Strings.base64EncodeString("Hello");         // returns "SGVsbG8="
     * Strings.base64EncodeString("Hello World");   // returns "SGVsbG8gV29ybGQ="
     * Strings.base64EncodeString("");              // returns ""
     * Strings.base64EncodeString(null);            // returns ""
     * }</pre>
     *
     * @param str the string to be encoded.
     * @return the Base64 encoded string, or an empty String {@code ""} if the input string is {@code null} or empty
     */
    public static String base64EncodeString(final String str) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(str.getBytes());   // NOSONAR
    }

    /**
     * Encodes the given string into a Base64 encoded string using UTF-8 encoding.
     *
     * <p>This method converts the input string to bytes using UTF-8 encoding and then encodes
     * these bytes to Base64 format. Base64 encoding is commonly used to encode binary data
     * as ASCII text, making it suitable for transmission over text-based protocols.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Basic encoding
     * Strings.base64EncodeUtf8String("Hello World");        // returns "SGVsbG8gV29ybGQ="
     * Strings.base64EncodeUtf8String("test@123");           // returns "dGVzdEAxMjM="
     * Strings.base64EncodeUtf8String("UTF-8 chars: √±");     // returns "VVRGLTggY2hhcnM6IMOx"
     * 
     * // Edge cases
     * Strings.base64EncodeUtf8String(null);   // returns ""
     * Strings.base64EncodeUtf8String("");     // returns ""
     * }</pre>
     *
     * @param str the string to be encoded.
     * @return the Base64 encoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     * @see #base64EncodeString(String, Charset)
     */
    public static String base64EncodeUtf8String(final String str) {
        return base64EncodeString(str, Charsets.UTF_8);
    }

    /**
     * Encodes the given string to a Base64 encoded string using the specified charset.
     *
     * <p>This method converts the input string to bytes using the specified charset and then encodes
     * these bytes to Base64 format. The charset parameter allows encoding strings that contain
     * characters from different character sets.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Different charset encodings
     * Strings.base64EncodeString("Hello", StandardCharsets.UTF_8);      //returns "SGVsbG8="
     * Strings.base64EncodeString("Hello", StandardCharsets.US_ASCII);   //returns "SGVsbG8="
     * Strings.base64EncodeString("Test123", StandardCharsets.UTF_16);   // returns "/v8AVABlAHMAdAAxADIAMw=="
     * 
     * // Edge cases
     * Strings.base64EncodeString(null, StandardCharsets.UTF_8);   // returns ""
     * Strings.base64EncodeString("", StandardCharsets.UTF_8);     // returns ""
     * }</pre>
     *
     * @param str the string to be encoded.
     * @param charset the charset to be used to encode the input string.
     * @return the Base64 encoded string.
     * @see String#getBytes(Charset)
     */
    public static String base64EncodeString(final String str, final Charset charset) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return BASE64_ENCODER.encodeToString(str.getBytes(charset));   // NOSONAR
    }

    /**
     * Decodes the given Base64 encoded string to a byte array.
     *
     * <p>This method takes a Base64 encoded string and converts it back to its original byte array
     * representation. Base64 decoding is the reverse process of Base64 encoding.</p>
     *
     * <p>The method returns an empty byte array if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Basic decoding
     * Strings.base64Decode("SGVsbG8gV29ybGQ=");   // returns byte array for "Hello World"
     * Strings.base64Decode("dGVzdEAxMjM=");       // returns byte array for "test@123"
     * 
     * // Edge cases
     * Strings.base64Decode(null);                 // returns empty byte array
     * Strings.base64Decode("");                   // returns empty byte array
     * }</pre>
     *
     * @param base64String the Base64 encoded string to be decoded.
     * @return the decoded byte array, or an empty byte array if the input string is {@code null} or empty.
     */
    public static byte[] base64Decode(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        return BASE64_DECODER.decode(base64String);
    }

    /**
     * Decodes the given Base64 encoded string to its original string representation.
     *
     * <p>This method decodes a Base64 encoded string back to its original string form using
     * the platform's default charset. It combines Base64 decoding with string construction
     * from the resulting byte array.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Basic decoding to string
     * Strings.base64DecodeToString("SGVsbG8gV29ybGQ=");   // returns "Hello World"
     * Strings.base64DecodeToString("dGVzdEAxMjM=");       // returns "test@123"
     * 
     * // Edge cases
     * Strings.base64DecodeToString(null);                 // returns ""
     * Strings.base64DecodeToString("");                   // returns ""
     * }</pre>
     *
     * @param base64String the Base64 encoded string to be decoded.
     * @return the decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64DecodeToString(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(base64Decode(base64String));   // NOSONAR
    }

    /**
     * Decodes the given Base64 encoded string to a UTF-8 string.
     *
     * <p>This method specifically decodes Base64 encoded strings to UTF-8 format, ensuring proper
     * handling of Unicode characters. UTF-8 is the most common encoding for international text.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // UTF-8 specific decoding
     * Strings.base64DecodeToUtf8String("SGVsbG8gV29ybGQ=");       // returns "Hello World"
     * Strings.base64DecodeToUtf8String("VVRGLTggY2hhcnM6IMOx");   // returns "UTF-8 chars: √±"
     *
     * // Edge cases
     * Strings.base64DecodeToUtf8String(null);                     // returns ""
     * Strings.base64DecodeToUtf8String("");                       // returns ""
     * }</pre>
     *
     * @param base64String the Base64 encoded string to be decoded.
     * @return the decoded UTF-8 string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64DecodeToUtf8String(final String base64String) {
        return base64DecodeToString(base64String, Charsets.UTF_8);
    }

    /**
     * Decodes the given Base64 encoded string to a string using the specified charset.
     *
     * <p>This method allows decoding Base64 encoded strings with a specific charset, providing
     * flexibility for handling strings encoded with different character sets. The charset parameter
     * determines how the decoded bytes are interpreted as characters.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Different charset decoding
     * Strings.base64DecodeToString("SGVsbG8=", StandardCharsets.UTF_8);        // returns "Hello"
     * Strings.base64DecodeToString("SGVsbG8=", StandardCharsets.US_ASCII);     // returns "Hello"
     * Strings.base64DecodeToString("base64String", StandardCharsets.UTF_16);   // charset-specific decoding
     * 
     * // Edge cases
     * Strings.base64DecodeToString(null, StandardCharsets.UTF_8);              // returns ""
     * Strings.base64DecodeToString("", StandardCharsets.UTF_8);                // returns ""
     * }</pre>
     *
     * @param base64String the Base64 encoded string to be decoded.
     * @param charset the charset to be used to decode the resulting byte array.
     * @return the decoded string.
     * @see String#String(byte[], Charset)
     */
    public static String base64DecodeToString(final String base64String, final Charset charset) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(base64Decode(base64String), charset);   // NOSONAR
    }

    /**
     * Encodes the given byte array to a Base64 URL encoded string.
     *
     * <p>Base64 URL encoding is a variant of Base64 encoding that uses URL-safe characters.
     * It replaces '+' with '-' and '/' with '_', and typically omits padding characters '='.
     * This makes it suitable for use in URLs and filenames.</p>
     *
     * <p>The method returns an empty string if the input byte array is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // URL-safe encoding
     * Strings.base64UrlEncode("Hello World".getBytes());     // returns URL-safe Base64 string
     * Strings.base64UrlEncode("test/data+123".getBytes());   // returns string with - and _ instead of / and +
     * 
     * // Edge cases
     * Strings.base64UrlEncode(null);                         // returns ""
     * Strings.base64UrlEncode(new byte[0]);                  // returns ""
     * }</pre>
     *
     * @param binaryData the byte array to be encoded.
     * @return the Base64 URL encoded string, or an empty String {@code ""} if the input byte array is {@code null} or empty.
     */
    public static String base64UrlEncode(final byte[] binaryData) {
        if (N.isEmpty(binaryData)) {
            return Strings.EMPTY;
        }

        return BASE64_URL_ENCODER.encodeToString(binaryData);
    }

    /**
     * Decodes the given Base64 URL encoded string to a byte array.
     *
     * <p>This method decodes URL-safe Base64 encoded strings back to their original byte array
     * representation. It handles the URL-safe variants where '+' is replaced with '-' and '/'
     * is replaced with '_'.</p>
     *
     * <p>The method returns an empty byte array if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // URL-safe decoding
     * Strings.base64UrlDecode("SGVsbG8gV29ybGQ");      // returns byte array for "Hello World"
     * Strings.base64UrlDecode("dGVzdC1kYXRhXzEyMw");   // handles URL-safe characters
     * 
     * // Edge cases
     * Strings.base64UrlDecode(null);                   // returns empty byte array
     * Strings.base64UrlDecode("");                     // returns empty byte array
     * }</pre>
     *
     * @param base64String the Base64 URL encoded string to be decoded.
     * @return the decoded byte array, an empty byte array if the input string is {@code null} or empty.
     */
    public static byte[] base64UrlDecode(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return N.EMPTY_BYTE_ARRAY;
        }

        return BASE64_URL_DECODER.decode(base64String);
    }

    /**
     * Decodes the given Base64 URL encoded string to a regular string.
     *
     * <p>This method combines Base64 URL decoding with string construction, converting a URL-safe
     * Base64 encoded string directly to its original string representation using the platform's
     * default charset.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // URL-safe decoding to string
     * Strings.base64UrlDecodeToString("SGVsbG8gV29ybGQ");   // returns "Hello World"
     * Strings.base64UrlDecodeToString("dGVzdEAxMjM");       // returns "test@123"
     * 
     * // Edge cases
     * Strings.base64UrlDecodeToString(null);                // returns ""
     * Strings.base64UrlDecodeToString("");                  // returns ""
     * }</pre>
     *
     * @param base64String the Base64 URL encoded string to be decoded.
     * @return the decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     * @throws  IllegalArgumentException if {@code base64String} is not in valid Base64 scheme
     */
    public static String base64UrlDecodeToString(final String base64String) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(BASE64_URL_DECODER.decode(base64String));   // NOSONAR
    }

    /**
     * Decodes the given Base64 URL encoded string to a UTF-8 string.
     *
     * <p>This method specifically decodes URL-safe Base64 encoded strings to UTF-8 format,
     * combining the URL-safe decoding with UTF-8 charset interpretation. This is useful
     * for handling international text that was Base64 URL encoded.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // URL-safe UTF-8 decoding
     * Strings.base64UrlDecodeToUtf8String("SGVsbG8gV29ybGQ");        // returns "Hello World"
     * Strings.base64UrlDecodeToUtf8String("VVRGLTggY2hhcnM6IMOx");   // returns "UTF-8 chars: √±"
     * 
     * // Edge cases
     * Strings.base64UrlDecodeToUtf8String(null);                     // returns ""
     * Strings.base64UrlDecodeToUtf8String("");                       // returns ""
     * }</pre>
     *
     * @param base64String the Base64 URL encoded string to be decoded.
     * @return the decoded UTF-8 string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64UrlDecodeToUtf8String(final String base64String) {
        return base64UrlDecodeToString(base64String, Charsets.UTF_8);
    }

    /**
     * Decodes the given Base64 URL encoded string to a string using the specified charset.
     *
     * <p>This method provides full control over the decoding process, allowing specification
     * of both URL-safe Base64 decoding and the charset to be used for interpreting the
     * resulting bytes. This is the most flexible decoding method for Base64 URL encoded data.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Different charset URL-safe decoding
     * Strings.base64UrlDecodeToString("SGVsbG8", StandardCharsets.UTF_8);      // returns "Hello"
     * Strings.base64UrlDecodeToString("SGVsbG8", StandardCharsets.US_ASCII);   // returns "Hello"
     * Strings.base64UrlDecodeToString("base64Url", StandardCharsets.UTF_16);   // charset-specific decoding
     * 
     * // Edge cases
     * Strings.base64UrlDecodeToString(null, StandardCharsets.UTF_8);           // returns ""
     * Strings.base64UrlDecodeToString("", StandardCharsets.UTF_8);             // returns ""
     * }</pre>
     *
     * @param base64String the Base64 URL encoded string to be decoded.
     * @param charset the charset to be used to decode the based decoded {@code bytes}
     * @return the decoded string, or an empty String {@code ""} if the input string is {@code null} or empty.
     */
    public static String base64UrlDecodeToString(final String base64String, final Charset charset) {
        if (Strings.isEmpty(base64String)) {
            return Strings.EMPTY;
        }

        return new String(BASE64_URL_DECODER.decode(base64String), charset);
    }

    /**
     * Encodes the given parameters into a URL-encoded string.
     *
     * <p>This method converts an object (typically a Map or JavaBean) into a URL-encoded string
     * suitable for use in HTTP requests. The encoding follows the application/x-www-form-urlencoded
     * format where key-value pairs are separated by '&amp;' and spaces are encoded as '+'.</p>
     *
     * <p>The method handles various object types including Maps, JavaBeans, and collections.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Encoding a Map
     * Map<String, String> params = new HashMap<>();
     * params.put("name", "John Doe");
     * params.put("age", "30");
     * Strings.urlEncode(params);   // returns "name=John+Doe&age=30"
     * 
     * // Encoding with special characters
     * Map<String, String> data = new HashMap<>();
     * data.put("email", "test@example.com");
     * data.put("info", "hello world!");
     * Strings.urlEncode(data);   // returns "email=test%40example.com&info=hello+world%21"
     * 
     * Strings.urlEncode(null);   // returns ""        
     * }</pre>
     *
     * @param parameters the parameters to be URL-encoded.
     * @return the URL-encoded string representation of the parameters.
     * @see URLEncodedUtil#encode(Object)
     * @see URLEncoder#encode(String, String)
     */
    public static String urlEncode(final Object parameters) {
        return URLEncodedUtil.encode(parameters);
    }

    /**
     * Encodes the given parameters into a URL-encoded string using the specified charset.
     *
     * <p>This method is similar to {@link #urlEncode(Object)} but allows specifying a custom
     * charset for encoding. This is useful when dealing with non-ASCII characters that need
     * to be encoded using a specific character set.</p>
     *
     * <p>The method handles various object types and encodes them according to the specified charset.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Encoding with UTF-8
     * Map<String, String> params = new HashMap<>();
     * params.put("name", "Jos√©");
     * params.put("city", "S√£o Paulo");
     * Strings.urlEncode(params, StandardCharsets.UTF_8);        // returns properly encoded UTF-8 string
     * 
     * // Encoding with different charset
     * Strings.urlEncode(params, StandardCharsets.ISO_8859_1);   // returns ISO-8859-1 encoded string
     * }</pre>
     *
     * @param parameters the parameters to be URL-encoded.
     * @param charset the charset to be used for encoding.
     * @return the URL-encoded string representation of the parameters.
     * @see URLEncodedUtil#encode(Object, Charset)
     * @see URLEncoder#encode(String, Charset)
     */
    public static String urlEncode(final Object parameters, final Charset charset) {
        return URLEncodedUtil.encode(parameters, charset);
    }

    /**
     * Decodes the given URL query string into a map of key-value pairs.
     *
     * <p>This method parses a URL-encoded query string and converts it back into a Map where
     * keys are parameter names and values are parameter values. The decoding handles special
     * characters and converts '+' back to spaces.</p>
     *
     * <p>The method returns an empty map if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Basic decoding
     * Strings.urlDecode("name=John+Doe&age=30");       // returns "{name=John Doe, age=30}"
     * Strings.urlDecode("email=test%40example.com");   // returns "{email=test@example.com}"
     * 
     * // Multiple values
     * Strings.urlDecode("key1=value1&key2=value2&key3=");   //returns: "{key1=value1, key2=value2, key3=}"
     * 
     * // Edge cases
     * Strings.urlDecode(null);    // returns empty map
     * Strings.urlDecode("");      // returns empty map
     * }</pre>
     *
     * @param urlQuery the URL query string to be decoded.
     * @return a map containing the decoded key-value pairs from the URL query string.
     * @see URLEncodedUtil#decode(String)
     * @see URLDecoder#decode(String)
     */
    public static Map<String, String> urlDecode(final String urlQuery) {
        return URLEncodedUtil.decode(urlQuery);
    }

    /**
     * Decodes the given URL query string into a map of key-value pairs using the specified charset.
     *
     * <p>This method is similar to {@link #urlDecode(String)} but allows specifying a custom
     * charset for decoding. This ensures proper handling of characters encoded with a specific
     * character set.</p>
     *
     * <p>The method returns an empty map if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // UTF-8 decoding
     * Strings.urlDecode("name=Jos%C3%A9&city=S%C3%A3o+Paulo", StandardCharsets.UTF_8);   // returns "{name=Jos√©, city=S√£o Paulo}"
     * 
     * // Different charset
     * Strings.urlDecode("data=test%20data", StandardCharsets.ISO_8859_1);   // returns "{data=test data}"
     * }</pre>
     *
     * @param urlQuery the URL query string to be decoded.
     * @param charset the charset to be used for decoding.
     * @return a map containing the decoded key-value pairs from the URL query string.
     * @see URLEncodedUtil#decode(String, Charset)
     * @see URLDecoder#decode(String, Charset)
     */
    public static Map<String, String> urlDecode(final String urlQuery, final Charset charset) {
        return URLEncodedUtil.decode(urlQuery, charset);
    }

    /**
     * Decodes the given URL query string into an object of the specified type.
     *
     * <p>This method parses a URL-encoded query string and maps it to an instance of the
     * specified class. The class should have properties that match the parameter names in
     * the query string. This is useful for directly converting URL parameters to Java objects.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Define a class
     * public class UserParams {
     *     private String name;
     *     private int age;
     *     // getters and setters
     * }
     * 
     * // Decode to object
     * UserParams params = urlDecode("name=John+Doe&age=30", UserParams.class);
     * // params.getName();   // returns "John Doe"
     * // params.getAge();   // returns 30
     * }</pre>
     *
     * @param <T> the type of the object to be returned.
     * @param urlQuery the URL query string to be decoded.
     * @param targetType the class of the object to be returned.
     * @return an object of the specified type containing the decoded data from the URL query string.
     * @see URLEncodedUtil#decode(String, Class)
     */
    public static <T> T urlDecode(final String urlQuery, final Class<? extends T> targetType) {
        return URLEncodedUtil.decode(urlQuery, targetType);
    }

    /**
     * Decodes a URL query string into an object of the specified type.
     * The query string is expected to be in <i>application/x-www-form-urlencoded</i> format.
     *
     * <p>This method combines URL decoding with object mapping, allowing specification of
     * both the charset for decoding and the target class for mapping. This provides full
     * control over the decoding and mapping process.</p>
     *
     * <p>The method returns {@code null} if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Define a class
     * public class Product {
     *     private String name;
     *     private String description;
     *     // getters and setters
     * }
     * 
     * // Decode with specific charset
     * Product product = urlDecode("name=Caf%C3%A9&description=Delicious+coffee", 
     *                            StandardCharsets.UTF_8, Product.class);
     * // product.getName();   // returns "Caf√©"
     * // product.getDescription();   // returns "Delicious coffee"
     * }</pre>
     *
     * @param <T> the type of the object to be returned.
     * @param urlQuery the URL query string to be decoded.
     * @param charset the charset to be used for decoding.
     * @param targetType the class of the object to be returned.
     * @return an object of type T that represents the decoded URL query string.
     * @see URLEncodedUtil#decode(String, Charset, Class)
     */
    public static <T> T urlDecode(final String urlQuery, final Charset charset, final Class<? extends T> targetType) {
        return URLEncodedUtil.decode(urlQuery, charset, targetType);
    }

    /**
     * This array is a lookup table that translates Unicode characters drawn from the "Base64 Alphabet" (as specified
     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
     * alphabet but fall within the bounds of the array are translated to -1.
     * <p>
     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both
     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).
     * </p>
     * <p>
     * Thanks to "commons" project in ws.apache.org for this code.
     * <a href="http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/">commons</a>
     * </p>
     */
    private static final byte[] DECODE_TABLE = {
            //   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, // 20-2f + - /
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
            -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // 40-4f A-O
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, // 50-5f P-Z _
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // 60-6f a-o
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 // 70-7a p-z
    };

    /**
     * Byte used to pad output.
     */
    protected static final byte PAD_DEFAULT = '='; // Allow static access to default

    /**
     * Returns whether the {@code octet} is in the base 64 alphabet.
     *
     * <p>This method checks if a given byte value is a valid Base64 character according to
     * the Base64 alphabet. Valid characters include A-Z, a-z, 0-9, +, /, and the padding
     * character '='. This is useful for validating individual bytes in Base64 operations.</p>
     *
     * <p>The method uses a lookup table for efficient validation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid Base64 characters
     * Strings.isBase64((byte)'A');   // returns true
     * Strings.isBase64((byte)'z');   // returns true
     * Strings.isBase64((byte)'0');   // returns true
     * Strings.isBase64((byte)'+');   // returns true
     * Strings.isBase64((byte)'/');   // returns true
     * Strings.isBase64((byte)'=');   // returns {@code true} (padding)
     * 
     * // Invalid Base64 characters
     * Strings.isBase64((byte)'!');   // returns false
     * Strings.isBase64((byte)' ');   // returns false
     * Strings.isBase64((byte)'@');   // returns false
     * }</pre>
     *
     * @param octet the value to test
     * @return {@code true} if the value is defined in the base 64 alphabet, {@code false} otherwise.
     */
    public static boolean isBase64(final byte octet) {
        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * <p>This method validates an entire byte array to ensure all bytes are valid Base64 characters
     * or whitespace. Currently the method treats whitespace as valid, which allows for Base64
     * strings that may contain line breaks or spaces for formatting purposes.</p>
     *
     * <p>The method returns {@code true} for empty arrays and {@code false} for {@code null} array</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid Base64 byte arrays
     * Strings.isBase64("SGVsbG8=".getBytes());    // returns true
     * Strings.isBase64("SGVs bG8=".getBytes());   // returns {@code true} (whitespace allowed)
     * Strings.isBase64(new byte[0]);              // returns {@code true} (empty array)
     * 
     * // Invalid Base64 byte arrays
     * Strings.isBase64("Hello!".getBytes());      // returns {@code false} (contains '!')
     * Strings.isBase64("SGVs@G8=".getBytes());    // returns {@code false} (contains '@')
     * Strings.isBase64((byte[]) null);            // returns false
     * }</pre>
     *
     * @param arrayOctet byte array to test
     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
     *         {@code false} otherwise
     */
    public static boolean isBase64(final byte[] arrayOctet) {
        if (arrayOctet == null) {
            return false;
        }

        for (final byte element : arrayOctet) {
            if (!isBase64(element) && !Character.isWhitespace(element)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Tests a given String to see if it contains only valid characters within the Base64 alphabet.
     *
     * <p>This method validates a string to ensure it contains only valid Base64 characters.
     * Like the byte array version, this method currently treats whitespace as valid, allowing
     * for formatted Base64 strings with line breaks or spaces.</p>
     *
     * <p>The method returns {@code true} for empty strings. and {@code false} for {@code null} string</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid Base64 strings
     * Strings.isBase64("SGVsbG8gV29ybGQ=");      // returns true
     * Strings.isBase64("SGVs bG8g V29y bGQ=");   // returns {@code true} (whitespace allowed)
     * Strings.isBase64("");                      // returns {@code true} (empty string)
     * 
     * // Invalid Base64 strings
     * Strings.isBase64("Hello World!");          // returns false
     * Strings.isBase64("SGVs!G8=");              // returns {@code false} (contains '!')
     * Strings.isBase64("test@123");              // returns {@code false} (contains '@')
     * Strings.isBase64((String) null);           // returns {@code false}
     * }</pre>
     *
     * @param base64 string to test
     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
     *         the String is empty; {@code false} otherwise
     */
    public static boolean isBase64(final String base64) {
        if (base64 == null) {
            return false;
        }

        return isBase64(getBytes(base64, Charsets.DEFAULT));
    }

    /**
     * Searches for the first occurrence of an email address within the given CharSequence.
     *
     * <p>This method uses a regular expression to find an email address in the input CharSequence.
     * The regex follows RFC 5322 standards for email address validation. If an email address is
     * found, it is returned; otherwise, the method returns {@code null}.</p>
     *
     * <p>The method returns {@code null} for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Finding email addresses
     * Strings.findFirstEmailAddress("Contact: john@example.com");       // returns "john@example.com"
     * Strings.findFirstEmailAddress("Email: test.user@domain.co.uk");   // returns "test.user@domain.co.uk"
     * Strings.findFirstEmailAddress("Multiple: a@b.com and c@d.com");   // returns "a@b.com" (first only)
     * 
     * // No email found
     * Strings.findFirstEmailAddress("No email here");                   // returns null
     * Strings.findFirstEmailAddress(null);                              // returns null
     * Strings.findFirstEmailAddress("");                                // returns null
     * }</pre>
     *
     * @param cs the CharSequence to be searched, may be {@code null} or empty
     * @return the first email address found in the CharSequence, or {@code null} if no email address is found.
     * @see #isValidEmailAddress(CharSequence)
     * @see #findAllEmailAddresses(CharSequence)
     */
    @MayReturnNull
    public static String findFirstEmailAddress(final CharSequence cs) {
        if (isEmpty(cs)) {
            return null;
        }

        final Matcher matcher = RegExUtil.EMAIL_ADDRESS_RFC_5322_FINDER.matcher(cs);

        // ^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$"
        // Matcher matcher = Pattern.compile("[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+").matcher(str);

        if (matcher.find()) {
            return matcher.group();
        }

        return null;
    }

    /**
     * Finds all the email addresses in the given CharSequence.
     *
     * <p>This method uses a regular expression to find all occurrences of email addresses in the
     * input CharSequence. The regex follows RFC 5322 standards for email address validation.
     * It returns a list of all found email addresses. If no email address is found, it returns
     * an empty list.</p>
     *
     * <p>The method never returns {@code null}, always returning at least an empty list.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Finding multiple email addresses
     * Strings.findAllEmailAddresses("Contact: john@example.com and jane@test.org");
     * // returns ["john@example.com", "jane@test.org"]
     * 
     * Strings.findAllEmailAddresses("Emails: a@b.com, c@d.net, e@f.org");
     * // returns ["a@b.com", "c@d.net", "e@f.org"]
     * 
     * // No emails found
     * Strings.findAllEmailAddresses("No emails here");   // returns []
     * Strings.findAllEmailAddresses(null);               // returns []
     * Strings.findAllEmailAddresses("");                 // returns []
     * }</pre>
     *
     * @param cs the CharSequence to be searched, may be {@code null} or empty
     * @return a list of all found email addresses, or an empty list if no email address is found.
     * @see #isValidEmailAddress(CharSequence)
     * @see #findFirstEmailAddress(CharSequence)
     */
    public static List<String> findAllEmailAddresses(final CharSequence cs) {
        if (isEmpty(cs)) {
            return new ArrayList<>();
        }

        final Matcher matcher = RegExUtil.EMAIL_ADDRESS_RFC_5322_FINDER.matcher(cs);

        final List<String> result = new ArrayList<>();

        while (matcher.find()) {
            result.add(matcher.group());
        }

        return result;
    }

    /**
     * Creates a copy of the given array of strings and trims each string in the array.
     *
     * <p>Trimming a string removes any leading or trailing whitespace characters. This method
     * creates a new array to avoid modifying the original array. Each string in the new array
     * will have its leading and trailing whitespace removed.</p>
     *
     * <p>The method returns {@code null} if the input array is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Trimming strings
     * String[] input  = {"  hello  ", " world ", "test"};
     * String[] result = copyThenTrim(input);    // returns ["hello", "world", "test"]
     * 
     * // Handling null and empty strings
     * String[] mixed   = {"  ", "text", null, " value "};
     * String[] trimmed = copyThenTrim(mixed);   // returns ["", "text", null, "value"]
     * 
     * // Edge cases
     * Strings.copyThenTrim(null);            // returns null
     * Strings.copyThenTrim(new String[0]);   // returns empty array
     * }</pre>
     *
     * @param strs the array of strings to be copied and trimmed. May be {@code null}.
     * @return a new array with the trimmed strings. Returns {@code null} if the input array is {@code null}.
     * @see N#copyThenReplaceAll(Object[], java.util.function.UnaryOperator)
     * @see Fn#trim()
     * @see Fn#trimToEmpty()
     * @see Fn#trimToNull()
     */
    @Beta
    @MayReturnNull
    public static String[] copyThenTrim(final String[] strs) {
        return N.copyThenReplaceAll(strs, Fn.trim());
    }

    /**
     * Creates a copy of the given array of strings and strips each string in the array.
     *
     * <p>Stripping a string removes any leading or trailing whitespace characters, including
     * Unicode whitespace. This method is similar to {@link #copyThenTrim(String[])} but uses
     * the strip operation which handles Unicode whitespace characters.</p>
     *
     * <p>The method returns {@code null} if the input array is {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Stripping strings
     * String[] input  = {"  hello  ", " world ", "test"};
     * String[] result = copyThenStrip(input);        // returns ["hello", "world", "test"]
     * 
     * // Unicode whitespace handling
     * String[] unicode  = {"\u2000text\u2000", " normal "};
     * String[] stripped = copyThenStrip(unicode);    // strips Unicode whitespace too
     * 
     * // Edge cases
     * Strings.copyThenStrip(null);            // returns null
     * Strings.copyThenStrip(new String[0]);   // returns empty array
     * }</pre>
     *
     * @param strs the array of strings to be copied and stripped, may be {@code null}.
     * @return a new array with the stripped strings. Returns {@code null} if the input array is {@code null}.
     * @see N#copyThenReplaceAll(Object[], java.util.function.UnaryOperator)
     * @see Fn#strip()
     * @see Fn#stripToEmpty()
     * @see Fn#stripToNull()
     */
    @Beta
    @MayReturnNull
    public static String[] copyThenStrip(final String[] strs) {
        return N.copyThenReplaceAll(strs, Fn.strip());
    }

    /**
     * Extracts the first occurrence of an integer from the given string.
     *
     * <p>This method searches for the first sequence of digits (optionally preceded by a minus sign
     * for negative numbers) in the input string and returns it as a string. The method uses regular
     * expressions to find integer patterns.</p>
     *
     * <p>The method returns {@code null} if no integer is found or if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extracting integers
     * Strings.extractFirstInteger("Price: $123");               // returns "123"
     * Strings.extractFirstInteger("Temperature: -5 degrees");   // returns "-5"
     * Strings.extractFirstInteger("Room 404, Floor 2");         // returns "404" (first integer)
     * 
     * // No integer found
     * Strings.extractFirstInteger("No numbers here");           // returns null
     * Strings.extractFirstInteger(null);                        // returns null
     * Strings.extractFirstInteger("");                          // returns null
     * }</pre>
     *
     * @param str the string to extract the integer from, may be {@code null} or empty
     * @return the extracted integer as a string, or {@code null} if no integer is found, or the input string is {@code null} or empty.
     * @see #replaceFirstInteger(String, String)
     * @see Numbers#extractFirstInt(String)
     * @see Numbers#extractFirstLong(String)
     * @see RegExUtil#findFirst(String, Pattern)
     * @see RegExUtil#findLast(String, Pattern)
     * @see RegExUtil#INTEGER_FINDER
     */
    @MayReturnNull
    public static String extractFirstInteger(final String str) {
        if (Strings.isEmpty(str)) {
            return null;
        }

        final Matcher matcher = RegExUtil.INTEGER_FINDER.matcher(str);
        if (matcher.find()) {
            return matcher.group(1);
        }

        return null;
    }

    /**
     * Extracts the first occurrence of a double from the given string.
     *
     * <p>This method searches for the first number (integer or decimal) in the input string
     * and returns it as a string. It handles both integer and floating-point numbers with
     * decimal points. Scientific notation is not included by default.</p>
     *
     * <p>The method returns {@code null} if no number is found or the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Extracting doubles
     * Strings.extractFirstDouble("Price: $12.99");         // returns "12.99"
     * Strings.extractFirstDouble("Temperature: -5.5¬∞C");   // returns "-5.5"
     * Strings.extractFirstDouble("Value: 42");             // returns "42"
     * 
     * // No double found
     * Strings.extractFirstDouble("No numbers");            // returns null
     * Strings.extractFirstDouble(null);                    // returns null
     * Strings.extractFirstDouble("");                      // returns null
     * }</pre>
     *
     * @param str the string to extract the double from, may be {@code null} or empty
     * @return the extracted double as a string, or {@code null} if no double is found, or the input string is {@code null} or empty.
     * @see #extractFirstInteger(String)
     * @see #replaceFirstDouble(String, String)
     * @see Numbers#extractFirstDouble(String)
     * @see RegExUtil#findFirst(String, Pattern)
     * @see RegExUtil#findLast(String, Pattern)
     * @see RegExUtil#NUMBER_FINDER
     * @see RegExUtil#SCIENTIFIC_NUMBER_FINDER
     */
    public static String extractFirstDouble(final String str) {
        return extractFirstDouble(str, false);
    }

    /**
     * Extracts the first occurrence of a double from the given string.
     *
     * <p>This method searches for the first number in the input string with an option to include
     * scientific notation. When scientific notation is enabled, it can extract numbers like
     * "1.23e10" or "5E-3". Otherwise, it only extracts regular decimal numbers.</p>
     *
     * <p>The method returns {@code null} if no number is found or if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Regular number extraction
     * Strings.extractFirstDouble("Value: 3.14159", false);    // returns "3.14159"
     * Strings.extractFirstDouble("Count: -42.0", false);      // returns "-42.0"
     * 
     * // Scientific notation
     * Strings.extractFirstDouble("Result: 1.23e10", true);    // returns "1.23e10"
     * Strings.extractFirstDouble("Small: 5E-3", true);        // returns "5E-3"
     * Strings.extractFirstDouble("Result: 1.23e10", false);   // returns "1.23" (no scientific)
     * 
     * // No double found
     * Strings.extractFirstDouble("No numbers", true);         // returns null
     * Strings.extractFirstDouble(null, true);                 // returns null
     * Strings.extractFirstDouble("", true);                   // returns null
     * }</pre>
     *
     * @param str the string to extract the double from, may be {@code null} or empty
     * @param includingScientificNumber if {@code true}, it will also include scientific numbers in the search.
     * @return the extracted double as a string, or {@code null} if no double is found, or the input string is {@code null} or empty.
     * @see #extractFirstInteger(String)
     * @see #extractFirstDouble(String)
     * @see #replaceFirstDouble(String, String)
     * @see Numbers#extractFirstDouble(String, boolean)
     * @see RegExUtil#findFirst(String, Pattern)
     * @see RegExUtil#findLast(String, Pattern)
     * @see RegExUtil#NUMBER_FINDER
     * @see RegExUtil#SCIENTIFIC_NUMBER_FINDER
     */
    @MayReturnNull
    public static String extractFirstDouble(final String str, final boolean includingScientificNumber) {
        if (Strings.isEmpty(str)) {
            return null;
        }

        final Matcher matcher = (includingScientificNumber ? RegExUtil.SCIENTIFIC_NUMBER_FINDER : RegExUtil.NUMBER_FINDER).matcher(str);

        if (matcher.find()) {
            return matcher.group(1);
        }

        return null;
    }

    /**
     * Replaces the first occurrence of an integer in the given string with the specified replacement string.
     *
     * <p>This method finds the first integer (sequence of digits optionally preceded by a minus sign)
     * in the input string and replaces it with the provided replacement string. Only the first
     * occurrence is replaced.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Replacing integers
     * Strings.replaceFirstInteger("Room 404, Floor 2", "X");   // returns "Room X, Floor 2"
     * Strings.replaceFirstInteger("Price: $123", "[NUM]");     // returns "Price: $[NUM]"
     * Strings.replaceFirstInteger("Temp: -5¬∞C", "0");          // returns "Temp: 0¬∞C"
     * 
     * // No integer to replace
     * Strings.replaceFirstInteger("No numbers", "X");          // returns "No numbers"
     * Strings.replaceFirstInteger(null, "X");                  // returns ""
     * Strings.replaceFirstInteger("", "X");                    // returns ""
     * }</pre>
     *
     * @param str the string to be modified, may be {@code null} or empty
     * @param replacement the string to replace the integer with.
     * @return the modified string with the first integer replaced by the specified replacement string, or an empty string if the input is {@code null} or empty.
     * @see #extractFirstInteger(String)
     * @see RegExUtil#replaceFirst(String, Pattern, String)
     * @see RegExUtil#replaceLast(String, Pattern, String)
     * @see RegExUtil#INTEGER_FINDER
     */
    public static String replaceFirstInteger(final String str, final String replacement) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return RegExUtil.INTEGER_FINDER.matcher(str).replaceFirst(replacement);
    }

    /**
     * Replaces the first occurrence of a double in the given string with the specified replacement string.
     *
     * <p>This method finds the first number (integer or decimal) in the input string and replaces
     * it with the provided replacement string. It handles both integer and floating-point numbers
     * but does not include scientific notation by default.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Replacing doubles
     * Strings.replaceFirstDouble("Price: $12.99 (was $15.99)", "X");   // returns "Price: $X (was $15.99)"
     * Strings.replaceFirstDouble("Temp: -5.5¬∞C", "0.0");               // returns "Temp: 0.0¬∞C"
     * Strings.replaceFirstDouble("Count: 42", "[NUM]");                // returns "Count: [NUM]"
     * 
     * // No number to replace
     * Strings.replaceFirstDouble("No numbers", "X");                   // returns "No numbers"
     * Strings.replaceFirstDouble(null, "X");                           // returns ""
     * }</pre>
     *
     * @param str the string to be modified, may be {@code null} or empty
     * @param replacement the string to replace the double with.
     * @return the modified string with the first double replaced by the specified replacement string, or an empty string if the input is {@code null} or empty.
     * @see #extractFirstDouble(String)
     * @see RegExUtil#replaceFirst(String, Pattern, String)
     * @see RegExUtil#replaceLast(String, Pattern, String)
     * @see RegExUtil#NUMBER_FINDER
     */
    public static String replaceFirstDouble(final String str, final String replacement) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return RegExUtil.NUMBER_FINDER.matcher(str).replaceFirst(replacement);
    }

    /**
     * Replaces the first occurrence of a double in the given string with the specified replacement string.
     *
     * <p>This method finds the first number in the input string and replaces it with the provided
     * replacement string. When scientific notation is enabled, it can match and replace numbers
     * in scientific format (e.g., "1.23e10"). Otherwise, it only matches regular decimal numbers.</p>
     *
     * <p>The method returns an empty string if the input is {@code null} or empty.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Regular number replacement
     * Strings.replaceFirstDouble("Value: 3.14, Pi", "X", false);        // returns "Value: X, Pi"
     * 
     * // Scientific notation replacement
     * Strings.replaceFirstDouble("Result: 1.23e10 units", "X", true);   // returns "Result: X units"
     * Strings.replaceFirstDouble("Normal: 5.0, Sci: 2E3", "X", true);   // returns "Normal: X, Sci: 2E3"
     * Strings.replaceFirstDouble("Result: 1.23e10", "X", false);        // returns "Result: Xe10" (partial)
     * }</pre>
     *
     * @param str the string to be modified, may be {@code null} or empty
     * @param replacement the string to replace the double with.
     * @param includingScientificNumber if {@code true}, it will also include scientific numbers in the search.
     * @return the modified string with the first double replaced by the specified replacement string, or an empty string if the input is {@code null} or empty.
     * @see #extractFirstDouble(String, boolean)
     * @see RegExUtil#replaceFirst(String, Pattern, String)
     * @see RegExUtil#replaceLast(String, Pattern, String)
     * @see RegExUtil#NUMBER_FINDER
     * @see RegExUtil#SCIENTIFIC_NUMBER_FINDER
     */
    public static String replaceFirstDouble(final String str, final String replacement, final boolean includingScientificNumber) {
        if (Strings.isEmpty(str)) {
            return Strings.EMPTY;
        }

        return (includingScientificNumber ? RegExUtil.SCIENTIFIC_NUMBER_FINDER : RegExUtil.NUMBER_FINDER).matcher(str).replaceFirst(replacement);
    }

    static void checkInputChars(final char[] chs, final String parameterName, final boolean canBeNullOrEmpty) {
        if (!canBeNullOrEmpty && N.isEmpty(chs)) {
            throw new IllegalArgumentException("Input char array or String parameter '" + parameterName + "' can't be null or empty");
        }

        for (final char ch : chs) {
            if (Character.isLowSurrogate(ch) || Character.isHighSurrogate(ch)) {
                throw new IllegalArgumentException("Element char in the input char array or String parameter '" + parameterName
                        + "' can't be low-surrogate or high-surrogate code unit. Please consider using String or String array instead if input parameter is char array");
            }
        }
    }

    static int calculateBufferSize(final int len, final int elementPlusDelimiterLen) {
        return len > Integer.MAX_VALUE / elementPlusDelimiterLen ? Integer.MAX_VALUE : len * elementPlusDelimiterLen;
    }

    static int calculateBufferSize(final int len, final int elementPlusDelimiterLen, final int prefixLen, final int suffixLen) {
        return len > (Integer.MAX_VALUE - prefixLen - suffixLen) / elementPlusDelimiterLen ? Integer.MAX_VALUE
                : len * elementPlusDelimiterLen + prefixLen + suffixLen;
    }

    /**
     * Enum defining different strategies for extracting substrings between delimiters.
     *
     * <p>This enum provides various approaches for handling nested delimiters when extracting
     * substrings. Each strategy offers different behavior for dealing with complex nested
     * structures in strings.</p>
     */
    public enum ExtractStrategy {
        /**
         * Default strategy used to extract substring between two delimiters.
         * <p>
         * {@code Strings.substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.DEFAULT) = ["a2[c", "a"]}.
         * </p>
         */
        DEFAULT,

        /**
         * Stack-based approach strategy used to extract substring between two delimiters.
         * <p>
         * {@code Strings.substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.STACK_BASED) = ["c", "a2[c]", "a"]}.
         * </p>
         */
        STACK_BASED,

        /**
         * Stack-based approach strategy used to extract substring between two delimiters but nested substrings are ignored.
         * <p>
         * {@code Strings.substringsBetween("3[a2[c]]2[a]", '[', ']', ExtractStrategy.IGNORE_NESTED) = ["a2[c]", "a"]}.
         * </p>
         */
        IGNORE_NESTED
    }

    /**
     * A utility class providing additional string manipulation methods.
     * This class contains helper methods for string operations that complement
     * the main Strings class functionality.
     *
     * <p>This class cannot be instantiated.
     */
    public static final class StrUtil {
        private StrUtil() {
            // Utility class.
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the index is negative or greater than or equal to the string length, or if the string is {@code null}, 
         * an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substring("hello", 0);    // returns Optional.of("hello")
         * StrUtil.substring("hello", 2);    // returns Optional.of("llo")
         * StrUtil.substring("hello", 5);    // returns Optional.empty()
         * StrUtil.substring("hello", -1);   // returns Optional.empty()
         * StrUtil.substring(null, 0);       // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @return an {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified inclusive begin index 
         * and ending at the exclusive end index. If the indices are invalid (negative, begin &gt;= end, or out of bounds), 
         * or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substring("hello", 0, 5);   // returns Optional.of("hello")
         * StrUtil.substring("hello", 1, 4);   // returns Optional.of("ell")
         * StrUtil.substring("hello", 2, 2);   // returns Optional.empty() (begin == end)
         * StrUtil.substring("hello", 3, 1);   // returns Optional.empty() (begin > end)
         * StrUtil.substring(null, 0, 5);      // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return an {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int, int)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string starting at the specified inclusive begin index.
         * The exclusive end index is calculated by applying the provided function to the string length.
         * If the resulting indices are invalid or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substring("hello", 1, len -> len - 1);   // returns Optional.of("ell") (from 1 to 4)
         * StrUtil.substring("hello", 0, len -> len);       // returns Optional.of("hello")
         * StrUtil.substring("hello", 2, len -> 3);         // returns Optional.of("l")
         * StrUtil.substring("hello", 5, len -> len);       // returns Optional.empty() (invalid begin)
         * StrUtil.substring(null, 0, len -> len);          // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex a function that takes the string length and returns the exclusive end index.
         * @return an {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        public static Optional<String> substring(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring from the given string where the inclusive begin index is calculated 
         * by applying the provided function to the exclusive end index. If the resulting indices are invalid 
         * or if the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substring("hello", end -> 0, 5);         // returns Optional.of("hello")
         * StrUtil.substring("hello", end -> end - 3, 4);   // returns Optional.of("el") (from 1 to 4)
         * StrUtil.substring("hello", end -> end, 3);       // returns Optional.empty() (begin == end)
         * StrUtil.substring("hello", end -> 5, 3);         // returns Optional.empty() (begin > end)
         * StrUtil.substring(null, end -> 0, 5);            // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param funcOfInclusiveBeginIndex a function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return an {@code Optional<String>} containing the substring if valid, otherwise empty.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        public static Optional<String> substring(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the substring cannot be extracted (due to invalid index or {@code null} string), the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElse("hello", 0, "default");    // returns "hello"
         * StrUtil.substringOrElse("hello", 2, "default");    // returns "llo"
         * StrUtil.substringOrElse("hello", 10, "default");   // returns "default"
         * StrUtil.substringOrElse(null, 0, "default");       // returns "default"
         * StrUtil.substringOrElse("hello", 2, null);         // returns "llo"
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param defaultStr the default string to return if substring extraction fails, can be {@code null}.
         * @return the substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring from the given string between the specified indices.
         * If the substring cannot be extracted (due to invalid indices or {@code null} string), the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElse("hello", 0, 5, "default");    // returns "hello"
         * StrUtil.substringOrElse("hello", 1, 4, "default");    // returns "ell"
         * StrUtil.substringOrElse("hello", 5, 10, "default");   // returns "default"
         * StrUtil.substringOrElse(null, 0, 5, "default");       // returns "default"
         * StrUtil.substringOrElse("hello", 1, 4, null);         // returns "ell"
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @param defaultStr the default string to return if substring extraction fails, can be {@code null}.
         * @return the substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, int, int)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring where the end index is calculated by the provided function.
         * If the substring cannot be extracted, the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElse("hello", 1, len -> len - 1, "default");   // returns "ell"
         * StrUtil.substringOrElse("hello", 0, len -> len, "default");       // returns "hello"
         * StrUtil.substringOrElse("hello", 10, len -> len, "default");      // returns "default"
         * StrUtil.substringOrElse(null, 0, len -> len, "default");          // returns "default"
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex a function that takes the string length and returns the exclusive end index.
         * @param defaultStr the default string to return if substring extraction fails, can be {@code null}.
         * @return the substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        @Beta
        public static String substringOrElse(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex,
                final String defaultStr) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code defaultStr}.
         *
         * <p>This method extracts a substring where the begin index is calculated by the provided function.
         * If the substring cannot be extracted, the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElse("hello", end -> 0, 5, "default");         // returns "hello"
         * StrUtil.substringOrElse("hello", end -> end - 3, 4, "default");   // returns "el"
         * StrUtil.substringOrElse("hello", end -> 10, 3, "default");        // returns "default"
         * StrUtil.substringOrElse(null, end -> 0, 5, "default");            // returns "default"
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param funcOfInclusiveBeginIndex a function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @param defaultStr the default string to return if substring extraction fails, can be {@code null}.
         * @return the substring if it exists, otherwise {@code defaultStr}.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        @Beta
        public static String substringOrElse(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex,
                final String defaultStr) {
            final String ret = Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring from the given string starting at the specified index to the end of the string.
         * If the substring cannot be extracted (due to invalid index), the original string is returned.
         * If the string is {@code null}, {@code null} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElseItself("hello", 0);    // returns "hello"
         * StrUtil.substringOrElseItself("hello", 2);    // returns "llo"
         * StrUtil.substringOrElseItself("hello", 10);   // returns "hello"
         * StrUtil.substringOrElseItself("hello", -1);   // returns "hello"
         * StrUtil.substringOrElseItself(null, 0);       // returns null
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @return the substring if it exists, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring from the given string between the specified indices.
         * If the substring cannot be extracted (due to invalid indices), the original string is returned.
         * If the string is {@code null}, {@code null} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElseItself("hello", 0, 5);    // returns "hello"
         * StrUtil.substringOrElseItself("hello", 1, 4);    // returns "ell"
         * StrUtil.substringOrElseItself("hello", 5, 10);   // returns "hello"
         * StrUtil.substringOrElseItself("hello", 2, 1);    // returns "hello"
         * StrUtil.substringOrElseItself(null, 0, 5);       // returns null
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return the substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, int, int)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring where the end index is calculated by the provided function.
         * If the substring cannot be extracted, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElseItself("hello", 1, len -> len - 1);   // returns "ell"
         * StrUtil.substringOrElseItself("hello", 0, len -> len);       // returns "hello"
         * StrUtil.substringOrElseItself("hello", 10, len -> len);      // returns "hello"
         * StrUtil.substringOrElseItself(null, 0, len -> len);          // returns null
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param inclusiveBeginIndex the starting index (inclusive) of the substring.
         * @param funcOfExclusiveEndIndex a function that takes the string length and returns the exclusive end index.
         * @return the substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, int, IntUnaryOperator)
         */
        @Beta
        public static String substringOrElseItself(final String str, final int inclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            final String ret = Strings.substring(str, inclusiveBeginIndex, funcOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring if it exists, otherwise returns {@code str} itself.
         *
         * <p>This method extracts a substring where the begin index is calculated by the provided function.
         * If the substring cannot be extracted, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringOrElseItself("hello", end -> 0, 5);         // returns "hello"
         * StrUtil.substringOrElseItself("hello", end -> end - 3, 4);   // returns "el"
         * StrUtil.substringOrElseItself("hello", end -> 10, 3);        // returns "hello"
         * StrUtil.substringOrElseItself(null, end -> 0, 5);            // returns null
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param funcOfInclusiveBeginIndex a function that takes the exclusive end index and returns the inclusive begin index.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return the substring if it exists, otherwise {@code str} itself.
         * @see Strings#substring(String, IntUnaryOperator, int)
         */
        @Beta
        public static String substringOrElseItself(final String str, final IntUnaryOperator funcOfInclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substring(str, funcOfInclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfter("hello.world", '.');   // returns Optional.of("world")
         * StrUtil.substringAfter("hello", '.');         // returns Optional.empty()
         * StrUtil.substringAfter("hello.", '.');        // returns Optional.of("")
         * StrUtil.substringAfter("", '.');              // returns Optional.empty()
         * StrUtil.substringAfter(null, '.');            // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter character after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the delimiter, or empty if not found.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final char delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfter("hello world", " ");     // returns Optional.of("world")
         * StrUtil.substringAfter("hello::world", "::");   // returns Optional.of("world")
         * StrUtil.substringAfter("hello", " ");           // returns Optional.empty()
         * StrUtil.substringAfter("hello ", " ");          // returns Optional.of("")
         * StrUtil.substringAfter(null, " ");              // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter string after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the delimiter, or empty if not found.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final String delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of the specified delimiter string
         * and before the specified exclusive end index. If the delimiter is not found, the end index is invalid, 
         * or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfter("hello world", " ", 8);      // returns Optional.of("wor")
         * StrUtil.substringAfter("hello::world", "::", 10);   // returns Optional.of("world")
         * StrUtil.substringAfter("hello", " ", 5);            // returns Optional.empty()
         * StrUtil.substringAfter("hello ", " ", 6);           // returns Optional.of("")
         * StrUtil.substringAfter(null, " ", 5);               // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter string after which the substring begins.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return an {@code Optional<String>} containing the substring after the delimiter up to the end index, or empty if not found.
         * @see Strings#substringAfter(String, String, int)
         */
        @Beta
        public static Optional<String> substringAfter(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringAfter(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLast("com.example.Test", '.');   // returns Optional.of("Test")
         * StrUtil.substringAfterLast("hello", '.');              // returns Optional.empty()
         * StrUtil.substringAfterLast("hello.", '.');             // returns Optional.of("")
         * StrUtil.substringAfterLast("a.b.c", '.');              // returns Optional.of("c")
         * StrUtil.substringAfterLast(null, '.');                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter character after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the last occurrence of the delimiter, or empty if not found.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final char delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLast("com.example.Test", ".");      // returns Optional.of("Test")
         * StrUtil.substringAfterLast("hello::world::test", "::");   // returns Optional.of("test")
         * StrUtil.substringAfterLast("hello", " ");                 // returns Optional.empty()
         * StrUtil.substringAfterLast("hello ", " ");                // returns Optional.of("")
         * StrUtil.substringAfterLast(null, ".");                    // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter string after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the last occurrence of the delimiter, or empty if not found.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the last occurrence of the specified delimiter string
         * and before the specified exclusive end index. If the delimiter is not found, the end index is invalid,
         * or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLast("com.example.Test", ".", 15);   // returns Optional.of("Tes")
         * StrUtil.substringAfterLast("a::b::c::d", "::", 12);        // returns Optional.of("d")
         * StrUtil.substringAfterLast("hello", " ", 5);               // returns Optional.empty()
         * StrUtil.substringAfterLast("hello ", " ", 6);              // returns Optional.of("")
         * StrUtil.substringAfterLast(null, ".", 10);                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter string after which the substring begins.
         * @param exclusiveEndIndex the ending index (exclusive) of the substring.
         * @return an {@code Optional<String>} containing the substring after the last delimiter up to the end index, or empty if not found.
         * @see Strings#substringAfterLast(String, String, int)
         */
        @Beta
        public static Optional<String> substringAfterLast(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of any of the specified delimiter characters.
         * If none of the delimiters are found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterAny("hello.world", '.', '!');   // returns Optional.of("world")
         * StrUtil.substringAfterAny("hello!world", '.', '!');   // returns Optional.of("world")
         * StrUtil.substringAfterAny("hello", '.', '!');         // returns Optional.empty()
         * StrUtil.substringAfterAny("hello.", '.', '!');        // returns Optional.of("")
         * StrUtil.substringAfterAny(null, '.', '!');            // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimitersOfExclusiveBeginIndex the delimiter characters after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the first found delimiter, or empty if none found.
         * @see Strings#substringAfterAny(String, char[])
         */
        @Beta
        public static Optional<String> substringAfterAny(final String str, final char... delimitersOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterAny(str, delimitersOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears after the first occurrence of any of the specified delimiter strings.
         * If none of the delimiters are found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterAny("hello world", " ", "::");    // returns Optional.of("world")
         * StrUtil.substringAfterAny("hello::world", " ", "::");   // returns Optional.of("world")
         * StrUtil.substringAfterAny("hello", " ", "::");          // returns Optional.empty()
         * StrUtil.substringAfterAny("hello ", " ", "::");         // returns Optional.of("")
         * StrUtil.substringAfterAny(null, " ", "::");             // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimitersOfExclusiveBeginIndex the delimiter strings after which the substring begins.
         * @return an {@code Optional<String>} containing the substring after the first found delimiter, or empty if none found.
         * @see Strings#substringAfterAny(String, String[])
         */
        @Beta
        public static Optional<String> substringAfterAny(final String str, final String... delimitersOfExclusiveBeginIndex) {
            return Optional.ofNullable(Strings.substringAfterAny(str, delimitersOfExclusiveBeginIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears before the first occurrence of the specified delimiter character.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBefore("hello.world", '.');   // returns Optional.of("hello")
         * StrUtil.substringBefore("hello", '.');         // returns Optional.empty()
         * StrUtil.substringBefore(".hello", '.');        // returns Optional.of("")
         * StrUtil.substringBefore("", '.');              // returns Optional.empty()
         * StrUtil.substringBefore(null, '.');            // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the delimiter character before which the substring ends.
         * @return an {@code Optional<String>} containing the substring before the delimiter, or empty if not found.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns {@code Optional<String>} with value of the substring if it exists, otherwise returns an empty {@code Optional<String>}.
         *
         * <p>This method extracts a substring that appears before the first occurrence of the specified delimiter string.
         * If the delimiter is not found or the string is {@code null}, an empty {@code Optional} is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBefore("hello world", " ");     // returns Optional.of("hello")
         * StrUtil.substringBefore("hello::world", "::");   // returns Optional.of("hello")
         * StrUtil.substringBefore("hello", " ");           // returns Optional.empty()
         * StrUtil.substringBefore(" hello", " ");          // returns Optional.of("")
         * StrUtil.substringBefore(null, " ");              // returns Optional.empty()
         * }</pre>
         *
         * @param str the string from which to extract the substring, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the delimiter string before which the substring ends.
         * @return an {@code Optional<String>} containing the substring before the delimiter, or empty if not found.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the specified delimiter,
         * starting from the given inclusive begin index.
         *
         * <p>This method searches for the delimiter starting from the specified index and returns
         * the substring from that index up to (but not including) the delimiter. If the delimiter
         * is not found after the specified index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBefore("hello.world.java", 0, ".");     // returns Optional.of("hello")
         * StrUtil.substringBefore("hello.world.java", 6, ".");     // returns Optional.of("world")
         * StrUtil.substringBefore("hello.world.java", 0, "xyz");   // returns Optional.empty()
         * StrUtil.substringBefore(null, 0, ".");                   // returns Optional.empty()
         * StrUtil.substringBefore("hello", 0, null);               // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param inclusiveBeginIndex the index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBefore(String, int, String)
         */
        @Beta
        public static Optional<String> substringBefore(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBefore(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified character delimiter.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLast("hello.world.java", '.');   // returns Optional.of("hello.world")
         * StrUtil.substringBeforeLast("hello", '.');              // returns Optional.empty()
         * StrUtil.substringBeforeLast("hello.", '.');             // returns Optional.of("hello")
         * StrUtil.substringBeforeLast(null, '.');                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the character delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified string delimiter.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLast("hello.world.java", ".");      // returns Optional.of("hello.world")
         * StrUtil.substringBeforeLast("hello//world//java", "//");   // returns Optional.of("hello//world")
         * StrUtil.substringBeforeLast("hello", ".");                 // returns Optional.empty()
         * StrUtil.substringBeforeLast(null, ".");                    // returns Optional.empty()
         * StrUtil.substringBeforeLast("hello", null);                // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before the last occurrence
         * of the specified delimiter, starting from the given inclusive begin index.
         *
         * <p>This method searches for the last occurrence of the delimiter starting from the specified
         * index and returns the substring from that index up to (but not including) the delimiter.
         * If the delimiter is not found after the specified index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLast("hello.world.java", 0, ".");    // returns Optional.of("hello.world")
         * StrUtil.substringBeforeLast("hello.world.java", 6, ".");    // returns Optional.of("world")
         * StrUtil.substringBeforeLast("hello.world.java", 13, ".");   // returns Optional.empty()
         * StrUtil.substringBeforeLast(null, 0, ".");                  // returns Optional.empty()
         * StrUtil.substringBeforeLast("hello", 0, null);              // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param inclusiveBeginIndex the index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeLast(String, int, String)
         */
        @Beta
        public static Optional<String> substringBeforeLast(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeLast(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before any of the specified
         * character delimiters.
         *
         * <p>This method searches for the first occurrence of any of the delimiter characters and
         * returns the substring from the beginning up to (but not including) that delimiter. If none
         * of the delimiters are found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or null/empty delimiter array.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeAny("hello.world:java", '.', ':');   // returns Optional.of("hello")
         * StrUtil.substringBeforeAny("hello-world", '.', ':');        // returns Optional.empty()
         * StrUtil.substringBeforeAny("hello:world.java", '.', ':');   // returns Optional.of("hello")
         * StrUtil.substringBeforeAny(null, '.', ':');                 // returns Optional.empty()
         * StrUtil.substringBeforeAny("hello", (char[])null);          // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimitersOfExclusiveEndIndex the character delimiters marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeAny(String, char[])
         */
        @Beta
        public static Optional<String> substringBeforeAny(final String str, final char... delimitersOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeAny(str, delimitersOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring before any of the specified
         * string delimiters.
         *
         * <p>This method searches for the first occurrence of any of the delimiter strings and
         * returns the substring from the beginning up to (but not including) that delimiter. If none
         * of the delimiters are found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or null/empty delimiter array.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeAny("hello.world::java", ".", "::");   // returns Optional.of("hello")
         * StrUtil.substringBeforeAny("hello-world", ".", "::");         // returns Optional.empty()
         * StrUtil.substringBeforeAny("hello::world.java", ".", "::");   // returns Optional.of("hello")
         * StrUtil.substringBeforeAny(null, ".", "::");                  // returns Optional.empty()
         * StrUtil.substringBeforeAny("hello", (String[])null);          // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimitersOfExclusiveEndIndex the string delimiters marking the end of the substring (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBeforeAny(String, String[])
         */
        @Beta
        public static Optional<String> substringBeforeAny(final String str, final String... delimitersOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBeforeAny(str, delimitersOfExclusiveEndIndex));
        }

        /**
         * Returns the substring after the specified delimiter if it exists, otherwise returns the default string.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * after (not including) that delimiter. If the delimiter is not found or the input is {@code null},
         * the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterOrElse("hello.world", ".", "default");   // returns "world"
         * StrUtil.substringAfterOrElse("hello", ".", "default");         // returns "default"
         * StrUtil.substringAfterOrElse(null, ".", "default");            // returns "default"
         * StrUtil.substringAfterOrElse("hello.", ".", "default");        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter marking the beginning of the substring (exclusive).
         * @param defaultStr the default string to return if substring is not found.
         * @return the substring after the delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElse(final String str, final String delimiterOfExclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified delimiter if it exists,
         * otherwise returns the default string.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * after (not including) that delimiter. If the delimiter is not found or the input is {@code null},
         * the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLastOrElse("hello.world.java", ".", "default");   // returns "java"
         * StrUtil.substringAfterLastOrElse("hello", ".", "default");              // returns "default"
         * StrUtil.substringAfterLastOrElse(null, ".", "default");                 // returns "default"
         * StrUtil.substringAfterLastOrElse("hello.world.", ".", "default");       // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter marking the beginning of the substring (exclusive).
         * @param defaultStr the default string to return if substring is not found.
         * @return the substring after the last delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElse(final String str, final String delimiterOfExclusiveBeginIndex, final String defaultStr) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring before the specified delimiter if it exists, otherwise returns the default string.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * from the beginning up to (but not including) that delimiter. If the delimiter is not found
         * or the input is {@code null}, the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeOrElse("hello.world", ".", "default");   // returns "hello"
         * StrUtil.substringBeforeOrElse("hello", ".", "default");         // returns "default"
         * StrUtil.substringBeforeOrElse(null, ".", "default");            // returns "default"
         * StrUtil.substringBeforeOrElse(".world", ".", "default");        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @param defaultStr the default string to return if substring is not found.
         * @return the substring before the delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElse(final String str, final String delimiterOfExclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified delimiter if it exists,
         * otherwise returns the default string.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * from the beginning up to (but not including) that delimiter. If the delimiter is not found
         * or the input is {@code null}, the default string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLastOrElse("hello.world.java", ".", "default");   // returns "hello.world"
         * StrUtil.substringBeforeLastOrElse("hello", ".", "default");              // returns "default"
         * StrUtil.substringBeforeLastOrElse(null, ".", "default");                 // returns "default"
         * StrUtil.substringBeforeLastOrElse("hello.", ".", "default");             // returns "hello"
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @param defaultStr the default string to return if substring is not found.
         * @return the substring before the last delimiter if found, otherwise {@code defaultStr}.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElse(final String str, final String delimiterOfExclusiveEndIndex, final String defaultStr) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? defaultStr : ret;
        }

        /**
         * Returns the substring after the specified character delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter character and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterOrElseItself("hello.world", '.');   // returns "world"
         * StrUtil.substringAfterOrElseItself("hello", '.');         // returns "hello"
         * StrUtil.substringAfterOrElseItself(null, '.');            // returns null
         * StrUtil.substringAfterOrElseItself("hello.", '.');        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the character delimiter marking the beginning of the substring (exclusive).
         * @return the substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, char)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final char delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the specified string delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter string and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterOrElseItself("hello::world", "::");   // returns "world"
         * StrUtil.substringAfterOrElseItself("hello", "::");          // returns "hello"
         * StrUtil.substringAfterOrElseItself(null, "::");             // returns null
         * StrUtil.substringAfterOrElseItself("hello::", "::");        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning of the substring (exclusive).
         * @return the substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the specified delimiter up to the exclusive end index if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter and returns the substring
         * after (not including) that delimiter up to the specified exclusive end index. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterOrElseItself("hello.world.java", ".", 11);   // returns "world"
         * StrUtil.substringAfterOrElseItself("hello.world.java", ".", 20);   // returns "world.java"
         * StrUtil.substringAfterOrElseItself("hello", ".", 10);              // returns "hello"
         * StrUtil.substringAfterOrElseItself(null, ".", 10);                 // returns null
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter marking the beginning of the substring (exclusive).
         * @param exclusiveEndIndex the index marking the end of the substring (exclusive).
         * @return the substring after the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfter(String, String)
         */
        @Beta
        public static String substringAfterOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substringAfter(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified character delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLastOrElseItself("hello.world.java", '.');   // returns "java"
         * StrUtil.substringAfterLastOrElseItself("hello", '.');              // returns "hello"
         * StrUtil.substringAfterLastOrElseItself(null, '.');                 // returns null
         * StrUtil.substringAfterLastOrElseItself("hello.world.", '.');       // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the character delimiter marking the beginning of the substring (exclusive).
         * @return the substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final char delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified string delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring after (not including) that delimiter. If the delimiter is not found or
         * the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLastOrElseItself("hello::world::java", "::");   // returns "java"
         * StrUtil.substringAfterLastOrElseItself("hello", "::");                // returns "hello"
         * StrUtil.substringAfterLastOrElseItself(null, "::");                   // returns null
         * StrUtil.substringAfterLastOrElseItself("hello::world::", "::");       // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning of the substring (exclusive).
         * @return the substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring after the last occurrence of the specified delimiter up to
         * the exclusive end index if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter and returns the substring
         * after (not including) that delimiter up to the specified exclusive end index. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringAfterLastOrElseItself("hello.world.java", ".", 16);   // returns "java"
         * StrUtil.substringAfterLastOrElseItself("hello.world.java", ".", 14);   // returns "ja"
         * StrUtil.substringAfterLastOrElseItself("hello", ".", 10);              // returns "hello"
         * StrUtil.substringAfterLastOrElseItself(null, ".", 10);                 // returns null
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the delimiter marking the beginning of the substring (exclusive).
         * @param exclusiveEndIndex the index marking the end of the substring (exclusive).
         * @return the substring after the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringAfterLast(String, String)
         */
        @Beta
        public static String substringAfterLastOrElseItself(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            final String ret = Strings.substringAfterLast(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified character delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeOrElseItself("hello.world", '.');   // returns "hello"
         * StrUtil.substringBeforeOrElseItself("hello", '.');         // returns "hello"
         * StrUtil.substringBeforeOrElseItself(null, '.');            // returns null
         * StrUtil.substringBeforeOrElseItself(".world", '.');        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the character delimiter marking the end of the substring (exclusive).
         * @return the substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final char delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified string delimiter if it exists,
         * otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeOrElseItself("hello::world", "::");   // returns "hello"
         * StrUtil.substringBeforeOrElseItself("hello", "::");          // returns "hello"
         * StrUtil.substringBeforeOrElseItself(null, "::");             // returns null
         * StrUtil.substringBeforeOrElseItself("::world", "::");        // returns ""
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end of the substring (exclusive).
         * @return the substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the specified delimiter starting from the given index
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the first occurrence of the delimiter starting from the
         * specified index and returns the substring from that index up to (but not including)
         * the delimiter. If the delimiter is not found or the input is {@code null}, the original string
         * is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeOrElseItself("hello.world.java", 0, ".");    // returns "hello"
         * StrUtil.substringBeforeOrElseItself("hello.world.java", 6, ".");    // returns "world"
         * StrUtil.substringBeforeOrElseItself("hello.world.java", 0, "::");   // returns "hello.world.java"
         * StrUtil.substringBeforeOrElseItself(null, 0, ".");                  // returns null
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param inclusiveBeginIndex the index from which to start searching (inclusive).
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @return the substring before the delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBefore(String, String)
         */
        @Beta
        public static String substringBeforeOrElseItself(final String str, final int inclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBefore(str, inclusiveBeginIndex, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified character delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter character and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLastOrElseItself("hello.world.java", '.');   // returns "hello.world"
         * StrUtil.substringBeforeLastOrElseItself("hello", '.');              // returns "hello"
         * StrUtil.substringBeforeLastOrElseItself(null, '.');                 // returns null
         * StrUtil.substringBeforeLastOrElseItself("hello.", '.');             // returns "hello"
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the character delimiter marking the end of the substring (exclusive).
         * @return the substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final char delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified string delimiter
         * if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter string and returns
         * the substring from the beginning up to (but not including) that delimiter. If the delimiter
         * is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLastOrElseItself("hello::world::java", "::");   // returns "hello::world"
         * StrUtil.substringBeforeLastOrElseItself("hello", "::");                // returns "hello"
         * StrUtil.substringBeforeLastOrElseItself(null, "::");                   // returns null
         * StrUtil.substringBeforeLastOrElseItself("hello::", "::");              // returns "hello"
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end of the substring (exclusive).
         * @return the substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns the substring before the last occurrence of the specified delimiter up to
         * the exclusive end index if it exists, otherwise returns the original string itself.
         *
         * <p>This method searches for the last occurrence of the delimiter before the specified
         * end index and returns the substring from the beginning up to (but not including) that
         * delimiter. If the delimiter is not found or the input is {@code null}, the original string is returned.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBeforeLastOrElseItself("hello.world.java", 16, ".");   // returns "hello.world"
         * StrUtil.substringBeforeLastOrElseItself("hello.world.java", 11, ".");   // returns "hello"
         * StrUtil.substringBeforeLastOrElseItself("hello", 5, ".");               // returns "hello"
         * StrUtil.substringBeforeLastOrElseItself(null, 10, ".");                 // returns null
         * }</pre>
         *
         * @param str the string to search in, can be {@code null}.
         * @param exclusiveEndIndex the index marking the end boundary for searching (exclusive).
         * @param delimiterOfExclusiveEndIndex the delimiter marking the end of the substring (exclusive).
         * @return the substring before the last delimiter if found, otherwise {@code str} itself.
         * @see Strings#substringBeforeLast(String, String)
         */
        @Beta
        public static String substringBeforeLastOrElseItself(final String str, final int exclusiveEndIndex, final String delimiterOfExclusiveEndIndex) {
            final String ret = Strings.substringBeforeLast(str, exclusiveEndIndex, delimiterOfExclusiveEndIndex);

            return ret == null ? str : ret;
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin and end indices.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the exclusive end index. If the indices are invalid (negative, out of bounds,
         * or begin index >= end index), an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello world", 5, 11);   // returns Optional.of("world")
         * StrUtil.substringBetween("hello", 0, 5);          // returns Optional.of("ello")
         * StrUtil.substringBetween("hello", 5, 10);         // returns Optional.empty() (indices out of bounds)
         * StrUtil.substringBetween("hello", 3, 3);          // returns Optional.empty() (begin >= end)
         * StrUtil.substringBetween(null, 0, 5);             // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param exclusiveBeginIndex the starting index (exclusive).
         * @param exclusiveEndIndex the ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin index and the first occurrence of the character delimiter.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the first occurrence of the delimiter character. If the delimiter is not
         * found after the begin index or indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello.world.java", 5, '.');   // returns Optional.of("world")
         * StrUtil.substringBetween("hello.world", 0, '.');        // returns Optional.of("ello")
         * StrUtil.substringBetween("hello", 0, '.');              // returns Optional.empty()
         * StrUtil.substringBetween(null, 0, '.');                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param exclusiveBeginIndex the starting index (exclusive).
         * @param delimiterOfExclusiveEndIndex the character delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, int, char)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified
         * exclusive begin index and the first occurrence of the string delimiter.
         *
         * <p>This method extracts the substring starting after the exclusive begin index and
         * ending before the first occurrence of the delimiter string. If the delimiter is not
         * found after the begin index or indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello::world::java", 5, "::");   // returns Optional.of("world")
         * StrUtil.substringBetween("hello::world", 0, "::");         // returns Optional.of("ello")
         * StrUtil.substringBetween("hello", 0, "::");                // returns Optional.empty()
         * StrUtil.substringBetween(null, 0, "::");                   // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param exclusiveBeginIndex the starting index (exclusive).
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, int, String)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the character delimiter and the specified exclusive end index.
         *
         * <p>This method extracts the substring starting after the first occurrence of the delimiter
         * character and ending before the exclusive end index. If the delimiter is not found or
         * indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello.world.java", '.', 11);   // returns Optional.of("world")
         * StrUtil.substringBetween("hello.world.java", '.', 20);   // returns Optional.of("world.java")
         * StrUtil.substringBetween("hello", '.', 10);              // returns Optional.empty()
         * StrUtil.substringBetween(null, '.', 10);                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the character delimiter marking the beginning (exclusive).
         * @param exclusiveEndIndex the ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, char, int)
         */
        public static Optional<String> substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the string delimiter and the specified exclusive end index.
         *
         * <p>This method extracts the substring starting after the first occurrence of the delimiter
         * string and ending before the exclusive end index. If the delimiter is not found or
         * indices are invalid, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello::world::java", "::", 13);   // returns Optional.of("world")
         * StrUtil.substringBetween("hello::world::java", "::", 20);   // returns Optional.of("world::java")
         * StrUtil.substringBetween("hello", "::", 10);                // returns Optional.empty()
         * StrUtil.substringBetween(null, "::", 10);                   // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param exclusiveEndIndex the ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, String, int)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrences
         * of the two specified character delimiters.
         *
         * <p>This method extracts the substring starting after the first occurrence of the begin
         * delimiter and ending before the first occurrence of the end delimiter (after the begin
         * delimiter). If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello[world]java", '[', ']');   // returns Optional.of("world")
         * StrUtil.substringBetween("hello.world.java", '.', '.');   // returns Optional.of("world")
         * StrUtil.substringBetween("hello[world", '[', ']');        // returns Optional.empty()
         * StrUtil.substringBetween(null, '[', ']');                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the character delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex the character delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, char, char)
         */
        public static Optional<String> substringBetween(final String str, final char delimiterOfExclusiveBeginIndex, final char delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between occurrences
         * of the same tag string.
         *
         * <p>This method extracts the substring between the first occurrence of the tag and
         * the next occurrence of the same tag. This is equivalent to calling
         * {@code StrUtil.substringBetween(str, tag, tag)}.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or tag.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("*hello*world*", "*");   // returns Optional.of("hello")
         * StrUtil.substringBetween("##value##", "##");      // returns Optional.of("value")
         * StrUtil.substringBetween("hello world", "*");     // returns Optional.empty()
         * StrUtil.substringBetween(null, "*");              // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param tag the tag string marking both the beginning and end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, String, String)
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final String tag) {
            return substringBetween(str, tag, tag);
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrences
         * of the two specified string delimiters.
         *
         * <p>This method extracts the substring starting after the first occurrence of the begin
         * delimiter and ending before the first occurrence of the end delimiter (after the begin
         * delimiter). If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiters.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello<start>world</end>java", "<start>", "</end>");   // returns Optional.of("world")
         * StrUtil.substringBetween("hello::world::java", "::", "::");                     // returns Optional.of("world")
         * StrUtil.substringBetween("hello<start>world", "<start>", "</end>");             // returns Optional.empty()
         * StrUtil.substringBetween(null, "<start>", "</end>");                            // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetween(String, String, String)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the specified delimiters,
         * starting the search from the given index.
         *
         * <p>This method searches for the begin delimiter starting from the specified index, then
         * extracts the substring between that delimiter and the first occurrence of the end delimiter
         * after it. If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiters.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetween("hello<a>world</a><a>java</a>", 10, "<a>", "</a>");   // returns Optional.of("java")
         * StrUtil.substringBetween("hello::world::java", 0, "::", "::");                 // returns Optional.of("world")
         * StrUtil.substringBetween("hello::world::java", 10, "::", "::");                // returns Optional.empty()
         * StrUtil.substringBetween(null, 0, "<a>", "</a>");                              // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param fromIndex the index from which to start searching.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, fromIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the exclusive begin index
         * and a dynamically calculated exclusive end index.
         *
         * <p>This method uses a function to calculate the exclusive end index based on the exclusive
         * begin index. The function receives the begin index and should return the corresponding end
         * index. If the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or function.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * // Extract 5 characters after the begin index
         * StrUtil.substringBetween("hello world", 5, beginIdx -> beginIdx + 6);   // returns Optional.of(" world")
         * 
         * // Extract until the end of the string
         * StrUtil.substringBetween("hello", 1, beginIdx -> 5);   // returns Optional.of("ello")
         * 
         * StrUtil.substringBetween(null, 0, idx -> idx + 5);     // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param exclusiveBeginIndex the starting index (exclusive).
         * @param funcOfExclusiveEndIndex function to calculate the ending index based on begin index.
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, int, IntUnaryOperator)
         */
        public static Optional<String> substringBetween(final String str, final int exclusiveBeginIndex, final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, exclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between a dynamically calculated
         * exclusive begin index and the specified exclusive end index.
         *
         * <p>This method uses a function to calculate the exclusive begin index based on the exclusive
         * end index. The function receives the end index and should return the corresponding begin
         * index. If the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or function.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * // Extract 5 characters before the end index
         * StrUtil.substringBetween("hello world", endIdx -> endIdx - 5, 11);   // returns Optional.of("world")
         * 
         * // Extract from the beginning
         * StrUtil.substringBetween("hello", endIdx -> 0, 4);    // returns Optional.of("hell")
         * 
         * StrUtil.substringBetween(null, idx -> idx - 5, 10);   // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param funcOfExclusiveBeginIndex function to calculate the starting index based on end index.
         * @param exclusiveEndIndex the ending index (exclusive).
         * @return {@code Optional<String>} containing the substring if valid indices, otherwise empty.
         * @see Strings#substringBetween(String, IntUnaryOperator, int)
         */
        public static Optional<String> substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex, final int exclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, funcOfExclusiveBeginIndex, exclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the delimiter and a dynamically calculated exclusive end index.
         *
         * <p>This method finds the first occurrence of the delimiter, then uses a function to
         * calculate the exclusive end index based on the position after the delimiter. If the
         * delimiter is not found or the function returns an invalid index, an empty {@code Optional}
         * is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string, delimiter, or function.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * // Extract 5 characters after the delimiter
         * StrUtil.substringBetween("hello::world", "::", idx -> idx + 5);   // returns Optional.of("world")
         * 
         * // Extract to the end of string
         * StrUtil.substringBetween("key=value", "=", idx -> 10);   // returns Optional.of("value")
         * 
         * StrUtil.substringBetween(null, "::", idx -> idx + 5);    // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param funcOfExclusiveEndIndex function to calculate the ending index based on delimiter position.
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final String delimiterOfExclusiveBeginIndex,
                final IntUnaryOperator funcOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, delimiterOfExclusiveBeginIndex, funcOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between a dynamically calculated
         * exclusive begin index and the last occurrence of the delimiter.
         *
         * <p>This method finds the last occurrence of the delimiter, then uses a function to
         * calculate the exclusive begin index based on the delimiter position. The function receives
         * the delimiter position and should return the begin index. If the delimiter is not found
         * or the function returns an invalid index, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string, delimiter, or function.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * // Extract from 5 characters before the last delimiter
         * StrUtil.substringBetween("hello.world.java", idx -> idx - 5, ".");   // returns Optional.of("world")
         * 
         * // Extract from the beginning
         * StrUtil.substringBetween("prefix::value", idx -> 0, "::");   // returns Optional.of("prefix")
         * 
         * StrUtil.substringBetween(null, idx -> idx - 5, ".");         // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param funcOfExclusiveBeginIndex function to calculate the starting index based on delimiter position.
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see #substringBetween(String, int, int)
         */
        public static Optional<String> substringBetween(final String str, final IntUnaryOperator funcOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetween(str, funcOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first and last
         * occurrences of the same delimiter.
         *
         * <p>This method extracts the substring starting after the first occurrence of the delimiter
         * and ending before the last occurrence of the same delimiter. If the delimiter is not found
         * or occurs only once, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiter.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetweenFirstAndLast("a<tag>value<tag>b", "<tag>");   // returns Optional.of("value")
         * StrUtil.substringBetweenFirstAndLast("hello::world::java", "::");     // returns Optional.of("world")
         * StrUtil.substringBetweenFirstAndLast("hello<tag>world", "<tag>");     // returns Optional.empty()
         * StrUtil.substringBetweenFirstAndLast(null, "<tag>");                  // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiter the string delimiter marking both the beginning and end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetweenFirstAndLast(String, String, String)
         */
        public static Optional<String> substringBetweenFirstAndLast(final String str, final String delimiter) {
            return substringBetweenFirstAndLast(str, delimiter, delimiter);
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the begin delimiter and the last occurrence of the end delimiter.
         *
         * <p>This method extracts the substring starting after the first occurrence of the begin
         * delimiter and ending before the last occurrence of the end delimiter. If either delimiter
         * is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiters.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetweenFirstAndLast("a<tag>value</tag>b", "<tag>", "</tag>");    // returns Optional.of("value")
         * StrUtil.substringBetweenFirstAndLast("hello::world::java", "::", "::");           // returns Optional.of("world")
         * StrUtil.substringBetweenFirstAndLast("hello<start>world", "<start>", "</end>");   // returns Optional.empty()
         * StrUtil.substringBetweenFirstAndLast(null, "<start>", "</end>");                  // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetweenFirstAndLast(String, String, String)
         */
        public static Optional<String> substringBetweenFirstAndLast(final String str, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return substringBetweenFirstAndLast(str, 0, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex);
        }

        /**
         * Returns an {@code Optional<String>} containing the substring between the first occurrence
         * of the begin delimiter and the last occurrence of the end delimiter, starting the search
         * from the given index.
         *
         * <p>This method searches for the begin delimiter starting from the specified index, then
         * extracts the substring between that delimiter and the last occurrence of the end delimiter.
         * If either delimiter is not found, an empty {@code Optional} is returned.</p>
         *
         * <p>The method returns an empty {@code Optional} for {@code null} input string or delimiters.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.substringBetweenFirstAndLast("a<tag>value</tag><tag>java</tag>b", 5, "<tag>", "</tag>");   // returns Optional.of("java")
         * StrUtil.substringBetweenFirstAndLast("hello::world::java", 0, "::", "::");                         // returns Optional.of("world")
         * StrUtil.substringBetweenFirstAndLast("hello<start>world", 0, "<start>", "</end>");                 // returns Optional.empty()
         * StrUtil.substringBetweenFirstAndLast(null, 0, "<start>", "</end>");                                // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to extract from, can be {@code null}.
         * @param fromIndex the index from which to start searching.
         * @param delimiterOfExclusiveBeginIndex the string delimiter marking the beginning (exclusive).
         * @param delimiterOfExclusiveEndIndex the string delimiter marking the end (exclusive).
         * @return {@code Optional<String>} containing the substring if found, otherwise empty.
         * @see Strings#substringBetweenFirstAndLast(String, int, String, String)
         */
        public static Optional<String> substringBetweenFirstAndLast(final String str, final int fromIndex, final String delimiterOfExclusiveBeginIndex,
                final String delimiterOfExclusiveEndIndex) {
            return Optional.ofNullable(Strings.substringBetweenFirstAndLast(str, fromIndex, delimiterOfExclusiveBeginIndex, delimiterOfExclusiveEndIndex));
        }

        /**
         * Attempts to parse the given string as an integer and returns an {@code OptionalInt}.
         *
         * <p>This method handles various integer formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It returns an empty {@code OptionalInt} if the string
         * is blank, {@code null}, or cannot be parsed as a valid integer.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createInteger("123");    // returns OptionalInt.of(123)
         * StrUtil.createInteger("-456");   // returns OptionalInt.of(-456)
         * StrUtil.createInteger("0xFF");   // returns OptionalInt.of(255)
         * StrUtil.createInteger("077");    // returns OptionalInt.of(63) - octal
         * StrUtil.createInteger("abc");    // returns OptionalInt.empty()
         * StrUtil.createInteger("");       // returns OptionalInt.empty()
         * StrUtil.createInteger(null);     // returns OptionalInt.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code OptionalInt} containing the parsed integer value, or empty if parsing fails.
         * @see Numbers#createInteger(String)
         */
        @Beta
        public static u.OptionalInt createInteger(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalInt.empty();
            }

            try {
                return u.OptionalInt.of(Numbers.createInteger(str));
            } catch (final NumberFormatException e) {
                return u.OptionalInt.empty();
            }
        }

        /**
         * Attempts to parse the given string as a long and returns an {@code OptionalLong}.
         *
         * <p>This method handles various long formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It returns an empty {@code OptionalLong} if the string
         * is blank, {@code null}, or cannot be parsed as a valid long.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createLong("123456789");     // returns OptionalLong.of(123456789L)
         * StrUtil.createLong("-9876543210");   // returns OptionalLong.of(-9876543210L)
         * StrUtil.createLong("0xFFFFFFFF");    // returns OptionalLong.of(4294967295L)
         * StrUtil.createLong("0777");          // returns OptionalLong.of(511L) - octal
         * StrUtil.createLong("abc");           // returns OptionalLong.empty()
         * StrUtil.createLong("");              // returns OptionalLong.empty()
         * StrUtil.createLong(null);            // returns OptionalLong.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code OptionalLong} containing the parsed long value, or empty if parsing fails.
         * @see Numbers#createLong(String)
         */
        @Beta
        public static u.OptionalLong createLong(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalLong.empty();
            }

            try {
                return u.OptionalLong.of(Numbers.createLong(str));
            } catch (final NumberFormatException e) {
                return u.OptionalLong.empty();
            }
        }

        /**
         * Attempts to parse the given string as a float and returns an {@code OptionalFloat}.
         *
         * <p>This method handles standard floating-point formats including decimal notation
         * and scientific notation. It returns an empty {@code OptionalFloat} if the string
         * is blank, {@code null}, or cannot be parsed as a valid float.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createFloat("123.45");     // returns OptionalFloat.of(123.45f)
         * StrUtil.createFloat("-67.89");     // returns OptionalFloat.of(-67.89f)
         * StrUtil.createFloat("1.23e4");     // returns OptionalFloat.of(12300.0f)
         * StrUtil.createFloat("NaN");        // returns OptionalFloat.of(Float.NaN)
         * StrUtil.createFloat("Infinity");   // returns OptionalFloat.of(Float.POSITIVE_INFINITY)
         * StrUtil.createFloat("abc");        // returns OptionalFloat.empty()
         * StrUtil.createFloat("");           // returns OptionalFloat.empty()
         * StrUtil.createFloat(null);         // returns OptionalFloat.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code OptionalFloat} containing the parsed float value, or empty if parsing fails.
         * @see Numbers#createFloat(String)
         */
        @Beta
        public static u.OptionalFloat createFloat(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalFloat.empty();
            }

            try {
                return u.OptionalFloat.of(Numbers.createFloat(str));
            } catch (final NumberFormatException e) {
                return u.OptionalFloat.empty();
            }
        }

        /**
         * Attempts to parse the given string as a double and returns an {@code OptionalDouble}.
         *
         * <p>This method handles standard floating-point formats including decimal notation
         * and scientific notation. It returns an empty {@code OptionalDouble} if the string
         * is blank, {@code null}, or cannot be parsed as a valid double.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createDouble("123.456789");   // returns OptionalDouble.of(123.456789)
         * StrUtil.createDouble("-67.89012");    // returns OptionalDouble.of(-67.89012)
         * StrUtil.createDouble("1.23456e10");   // returns OptionalDouble.of(1.23456E10)
         * StrUtil.createDouble("NaN");          // returns OptionalDouble.of(Double.NaN)
         * StrUtil.createDouble("Infinity");     // returns OptionalDouble.of(Double.POSITIVE_INFINITY)
         * StrUtil.createDouble("abc");          // returns OptionalDouble.empty()
         * StrUtil.createDouble("");             // returns OptionalDouble.empty()
         * StrUtil.createDouble(null);           // returns OptionalDouble.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code OptionalDouble} containing the parsed double value, or empty if parsing fails.
         * @see Numbers#createDouble(String)
         */
        @Beta
        public static u.OptionalDouble createDouble(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.OptionalDouble.empty();
            }

            try {
                return u.OptionalDouble.of(Numbers.createDouble(str));
            } catch (final NumberFormatException e) {
                return u.OptionalDouble.empty();
            }
        }

        /**
         * Attempts to parse the given string as a BigInteger and returns an {@code Optional<BigInteger>}.
         *
         * <p>This method handles various integer formats including decimal, hexadecimal (0x or #),
         * and octal (leading 0) numbers. It can handle values larger than Long.MAX_VALUE. It returns
         * an empty {@code Optional} if the string is blank, {@code null}, or cannot be parsed as a valid BigInteger.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createBigInteger("123456789012345678901234567890");    // returns Optional of the BigInteger
         * StrUtil.createBigInteger("-999999999999999999999999999999");   // returns Optional of the BigInteger
         * StrUtil.createBigInteger("0xFF");                              // returns Optional.of(BigInteger.valueOf(255))
         * StrUtil.createBigInteger("077");                               // returns Optional.of(BigInteger.valueOf(63))
         * StrUtil.createBigInteger("abc");                               // returns Optional.empty()
         * StrUtil.createBigInteger("");                                  // returns Optional.empty()
         * StrUtil.createBigInteger(null);                                // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code Optional<BigInteger>} containing the parsed BigInteger value, or empty if parsing fails.
         * @see Numbers#createBigInteger(String)
         */
        @Beta
        public static u.Optional<BigInteger> createBigInteger(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createBigInteger(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }

        /**
         * Attempts to parse the given string as a BigDecimal and returns an {@code Optional<BigDecimal>}.
         *
         * <p>This method handles standard decimal notation and scientific notation. It provides
         * arbitrary precision decimal arithmetic. It returns an empty {@code Optional} if the string
         * is blank, {@code null}, or cannot be parsed as a valid BigDecimal.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createBigDecimal("123.456789012345678901234567890");    // returns Optional of the BigDecimal
         * StrUtil.createBigDecimal("-999999999999999999999.999999999");   // returns Optional of the BigDecimal
         * StrUtil.createBigDecimal("1.23456E+10");                        // returns Optional of the BigDecimal
         * StrUtil.createBigDecimal("NaN");                                // returns Optional.empty()
         * StrUtil.createBigDecimal("abc");                                // returns Optional.empty()
         * StrUtil.createBigDecimal("");                                   // returns Optional.empty()
         * StrUtil.createBigDecimal(null);                                 // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code Optional<BigDecimal>} containing the parsed BigDecimal value, or empty if parsing fails.
         * @see Numbers#createBigDecimal(String)
         */
        @Beta
        public static u.Optional<BigDecimal> createBigDecimal(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createBigDecimal(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }

        /**
         * Attempts to parse the given string as a Number and returns an {@code Optional<Number>}.
         *
         * <p>This method automatically determines the most appropriate Number type based on the
         * string format and value. It handles integers, longs, floats, doubles, BigIntegers, and
         * BigDecimals, including hexadecimal and octal formats. It returns an empty {@code Optional}
         * if the string is blank, {@code null}, or cannot be parsed as a valid number.</p>
         *
         * <p>The method performs a quick validation check before attempting to parse the string.</p>
         *
         * <p><b>Usage Examples:</b></p>
         * <pre>{@code
         * StrUtil.createNumber("123");                   // returns Optional.of(Integer 123)
         * StrUtil.createNumber("1234567890123456789");   // returns Optional.of(Long or BigInteger)
         * StrUtil.createNumber("123.45");                // returns Optional.of(Float 123.45)
         * StrUtil.createNumber("123.456789012345");      // returns Optional.of(Double)
         * StrUtil.createNumber("0xFF");                  // returns Optional.of(Integer 255)
         * StrUtil.createNumber("abc");                   // returns Optional.empty()
         * StrUtil.createNumber("");                      // returns Optional.empty()
         * StrUtil.createNumber(null);                    // returns Optional.empty()
         * }</pre>
         *
         * @param str the string to parse, can be {@code null} or blank.
         * @return {@code Optional<Number>} containing the parsed Number value, or empty if parsing fails.
         * @see Numbers#createNumber(String)
         */
        @Beta
        public static u.Optional<Number> createNumber(final String str) {
            if (!Numbers.quickCheckForIsCreatable(str)) {
                return u.Optional.empty();
            }

            try {
                return u.Optional.of(Numbers.createNumber(str));
            } catch (final NumberFormatException e) {
                return u.Optional.empty();
            }
        }
    }
}
