/*
 * Copyright (c) 2015, Haiyang Li.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.landawn.abacus.util;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.SQLException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.AbstractMap;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.RandomAccess;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.Internal;
import com.landawn.abacus.annotation.MayReturnNull;
import com.landawn.abacus.annotation.NotNull;
import com.landawn.abacus.annotation.NullSafe;
import com.landawn.abacus.annotation.SuppressFBWarnings;
import com.landawn.abacus.exception.TooManyElementsException;
import com.landawn.abacus.exception.UncheckedSQLException;
import com.landawn.abacus.parser.ParserUtil;
import com.landawn.abacus.parser.ParserUtil.BeanInfo;
import com.landawn.abacus.parser.ParserUtil.PropInfo;
import com.landawn.abacus.type.Type;
import com.landawn.abacus.util.Builder.ComparisonBuilder;
import com.landawn.abacus.util.u.Nullable;
import com.landawn.abacus.util.u.Optional;
import com.landawn.abacus.util.u.OptionalInt;
import com.landawn.abacus.util.function.ToFloatFunction;

/**
 * A comprehensive Java utility class providing commonly used operations for Object/primitive types,
 * String, Array, Collection, Map, Bean manipulation and more. This class serves as the foundation
 * for the {@code N} class which extends it with additional utility methods.
 *
 * <p><b>Key Features:</b>
 * <ul>
 *   <li><b>Null-Safe Operations:</b> Most methods handle null inputs gracefully without throwing exceptions</li>
 *   <li><b>Type Safety:</b> Extensive use of generics for compile-time type checking</li>
 *   <li><b>Performance Optimized:</b> Efficient algorithms with threshold-based optimizations</li>
 *   <li><b>Comprehensive Coverage:</b> Wide range of utilities for common programming tasks</li>
 *   <li><b>Consistent API:</b> Uniform method naming and parameter conventions</li>
 *   <li><b>Exception Minimization:</b> Designed to avoid unnecessary exceptions when contracts are not broken</li>
 * </ul>
 *
 * <p><b>⚠️ IMPORTANT - Sealed Class:</b>
 * <ul>
 *   <li>This is a <b>sealed class</b> that can only be extended by the {@code N} class</li>
 *   <li>Design ensures controlled inheritance and maintains API stability</li>
 *   <li>All utility methods are designed to be inherited by the {@code N} class</li>
 *   <li>Use the {@code N} class for public API access to these utilities</li>
 * </ul>
 *
 * <p><b>Design Philosophy:</b>
 * <ul>
 *   <li><b>Exception Handling:</b> Designed to avoid throwing unnecessary exceptions if the contract defined
 *       by a method is not broken. For example, reversing a {@code null} or empty String returns the input String.
 *       However, exceptions are thrown when attempting invalid operations like adding elements to a {@code null} array or collection.</li>
 *   <li><b>Return Values:</b> An empty String/Array/Collection/Map/Iterator/Iterable/InputStream/Reader is always
 *       preferred over {@code null} for method return values.</li>
 *   <li><b>Index Parameters:</b> Methods use {@code fromIndex/startIndex} and {@code toIndex/endIndex} parameters
 *       (not {@code offset/count} parameters) for consistency.</li>
 * </ul>
 *
 * <p><b>Core Utility Categories:</b>
 * <ul>
 *   <li><b>Object Utilities:</b> Null checking, equality comparison, hash code generation</li>
 *   <li><b>String Utilities:</b> String manipulation, validation, formatting operations</li>
 *   <li><b>Array Utilities:</b> Array creation, manipulation, searching, sorting operations</li>
 *   <li><b>Collection Utilities:</b> Collection manipulation, filtering, transformation operations</li>
 *   <li><b>Map Utilities:</b> Map creation, manipulation, key-value operations</li>
 *   <li><b>Bean Utilities:</b> Bean property access, reflection-based operations</li>
 *   <li><b>Type Conversion:</b> Safe type casting and conversion operations</li>
 *   <li><b>Primitive Operations:</b> Specialized operations for primitive types</li>
 * </ul>
 *
 * <p><b>Performance Characteristics:</b>
 * <ul>
 *   <li><b>Binary Search Threshold:</b> Uses {@code BINARY_SEARCH_THRESHOLD = 64} for algorithm selection</li>
 *   <li><b>Optimized Algorithms:</b> Threshold-based selection between linear and binary search</li>
 *   <li><b>Memory Efficient:</b> Minimal object allocation in utility operations</li>
 *   <li><b>Cache Friendly:</b> Sequential access patterns where possible</li>
 * </ul>
 *
 * <p><b>Common Usage Patterns:</b>
 * <pre>{@code
 * // Null-safe operations
 * boolean isEmpty = N.isEmpty(collection);
 * String safe = N.defaultIfNull(value, "default");
 * 
 * // Array operations
 * int[] sorted = N.sort(array);
 * boolean contains = N.contains(array, element);
 * 
 * // Collection operations
 * List<String> filtered = N.filter(list, predicate);
 * Map<String, Integer> grouped = N.groupBy(list, classifier);
 * 
 * // String operations
 * boolean valid = N.isNotBlank(text);
 * String trimmed = N.trim(text);
 * 
 * // Type conversions
 * int parsed = Numbers.toInt(value);   // Throws NumberFormatException if invalid
 * List<String> converted = N.map(list, converter);
 * }</pre>
 *
 * <p><b>Thread Safety:</b>
 * <ul>
 *   <li><b>Stateless Design:</b> All utility methods are stateless and thread-safe</li>
 *   <li><b>Immutable Results:</b> Methods typically return new objects rather than modifying inputs</li>
 *   <li><b>No Shared State:</b> No static mutable fields that could cause race conditions</li>
 *   <li><b>Concurrent Access:</b> Safe for concurrent access from multiple threads</li>
 * </ul>
 *
 * <p><b>Error Handling Strategy:</b>
 * <ul>
 *   <li><b>Graceful Degradation:</b> Methods handle edge cases gracefully</li>
 *   <li><b>Null Tolerance:</b> Most methods accept null inputs without throwing exceptions</li>
 *   <li><b>Empty Defaults:</b> Return empty collections/arrays instead of null when possible</li>
 *   <li><b>Clear Contracts:</b> Method documentation clearly specifies when exceptions are thrown</li>
 * </ul>
 *
 * <p><b>Integration with Java Collections Framework:</b>
 * <ul>
 *   <li><b>Collection Compatibility:</b> Seamless integration with standard Java collections</li>
 *   <li><b>Stream API Support:</b> Works well with Java 8+ Stream operations</li>
 *   <li><b>Functional Interface Support:</b> Extensive use of predicates, functions, and suppliers</li>
 *   <li><b>Optional Integration:</b> Support for Optional types for null-safe operations</li>
 * </ul>
 *
 * <p><b>Memory Management:</b>
 * <ul>
 *   <li><b>Minimal Allocation:</b> Designed to minimize object creation</li>
 *   <li><b>Reuse Strategies:</b> Reuses existing collections and arrays where possible</li>
 *   <li><b>Defensive Copying:</b> Creates defensive copies when necessary for safety</li>
 *   <li><b>Large Dataset Handling:</b> Optimized for both small and large datasets</li>
 * </ul>
 *
 * <p><b>Best Practices:</b>
 * <ul>
 *   <li>Use the {@code N} class for public API access rather than accessing this class directly</li>
 *   <li>Prefer these utilities over manual null checking and exception handling</li>
 *   <li>Use the provided conversion methods for safe type casting</li>
 *   <li>Leverage the collection utilities for complex data transformations</li>
 *   <li>Take advantage of the null-safe design for cleaner code</li>
 * </ul>
 *
 * <p><b>Performance Tips:</b>
 * <ul>
 *   <li>Binary search is automatically used for large datasets (>64 elements)</li>
 *   <li>Use bulk operations when working with large collections</li>
 *   <li>Prefer the specialized primitive utilities for numeric operations</li>
 *   <li>Consider the overhead of defensive copying in performance-critical code</li>
 * </ul>
 *
 * <p><b>Common Anti-Patterns to Avoid:</b>
 * <ul>
 *   <li>Manual null checking when null-safe utilities are available</li>
 *   <li>Throwing exceptions for edge cases that utilities handle gracefully</li>
 *   <li>Reinventing common operations that are already provided</li>
 *   <li>Direct instantiation - use static methods instead</li>
 * </ul>
 *
 * <p><b>Related Utility Classes:</b>
 * <ul>
 *   <li><b>{@link com.landawn.abacus.util.N}:</b> Main public utility class extending CommonUtil</li>
 *   <li><b>{@link com.landawn.abacus.util.Comparators}:</b> Specialized comparator utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.Fn}:</b> Functional interface utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.Array}:</b> Advanced array manipulation utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.Strings}:</b> Comprehensive string utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.Maps}:</b> Map-specific utility operations</li>
 *   <li><b>{@link com.landawn.abacus.util.Iterables}:</b> Iterable manipulation utilities</li>
 *   <li><b>{@link com.landawn.abacus.util.IOUtil}:</b> Input/output stream utilities</li>
 * </ul>
 *
 * <p><b>Example: Comprehensive Usage</b>
 * <pre>{@code
 * // Working with collections safely
 * List<String> names = Arrays.asList("Alice", null, "Bob", "", "Charlie");
 * 
 * // Filter out null and empty strings
 * List<String> validNames = N.filter(names, CommonUtil::isNotBlank);
 * 
 * // Safe conversion and transformation
 * List<Integer> lengths = N.map(validNames, String::length);
 * 
 * // Group by length
 * Map<Integer, List<String>> grouped = N.groupBy(validNames, String::length);
 * 
 * // Find maximum length safely
 * OptionalInt maxLength = N.maxInt(lengths);
 * 
 * // Array operations
 * String[] array = validNames.toArray(new String[0]);
 * boolean contains = N.contains(array, "Alice");
 * String[] sorted = N.sort(array);
 * 
 * // Null-safe operations
 * String result = N.defaultIfNull(N.firstOrNull(validNames), "No names");
 * boolean isEmpty = N.isEmpty(validNames);
 * }</pre>
 *
 * <p><b>Attribution:</b>
 * This class includes code adapted from Apache Commons Lang, Google Guava, and other
 * open source projects under the Apache License 2.0. Methods from these libraries may have been
 * modified for consistency, performance optimization, and null-safety enhancement.
 *
 * @see com.landawn.abacus.util.N
 * @see com.landawn.abacus.util.Array
 * @see com.landawn.abacus.util.Iterables
 * @see com.landawn.abacus.util.Iterators
 * @see com.landawn.abacus.util.Strings
 * @see com.landawn.abacus.util.Numbers
 * @see com.landawn.abacus.util.Maps
 * @see com.landawn.abacus.util.Beans
 * @see com.landawn.abacus.util.Comparators
 * @see com.landawn.abacus.util.Index
 * @see com.landawn.abacus.util.Median
 * @see com.landawn.abacus.util.Fn
 * @see com.landawn.abacus.util.Fnn
 * @see com.landawn.abacus.util.IOUtil
 * @see java.lang.reflect.Array
 * @see java.util.Arrays
 * @see java.util.Collections
 *
 * @version $Revision: 0.8 $ 07/03/10
 */
@SuppressWarnings({ "java:S1192", "java:S6539" })
sealed class CommonUtil permits N {
    /**
     * Threshold for using binary search algorithms. Arrays with length less than this threshold
     * use linear search for better performance on small datasets.
     */
    static final int BINARY_SEARCH_THRESHOLD = 64;

    /**
     * Threshold for in-place array reversal. Arrays smaller than this threshold are reversed
     * in place; larger arrays may use alternative strategies.
     */
    static final int REVERSE_THRESHOLD = 18;

    /**
     * Threshold for array fill operations. Determines the strategy used for filling array elements.
     */
    static final int FILL_THRESHOLD = 25;

    /**
     * Threshold for replaceAll operations. Arrays smaller than this use simple iteration;
     * larger arrays may use optimized bulk operations.
     */
    static final int REPLACE_ALL_THRESHOLD = 11;

    /**
     * Minimum size threshold for using copyAll operations. Collections smaller than this
     * may use element-by-element copying instead.
     */
    static final int MIN_SIZE_FOR_COPY_ALL = 9;

    /**
     * Default initial capacity for newly created collections when size is not specified.
     */
    static final int DEFAULT_SIZE_FOR_NEW_COLLECTION = 9;

    /**
     * Shared SecureRandom instance for generating random values throughout the utility class.
     */
    static final Random RAND = new SecureRandom();

    // ... it has to be big enough to make it's safety to add element to
    // ArrayBlockingQueue.
    @SuppressWarnings("deprecation")
    static final int POOL_SIZE = InternalUtil.POOL_SIZE;

    // ...
    /**
     * The index value when an element is not found in a list or array:
     * {@code -1}. This value is returned by methods in this class and can also
     * be used in comparisons with values returned by various method from
     * {@link java.util.List} .
     */
    public static final int INDEX_NOT_FOUND = -1;

    /**
     * An empty immutable {@code boolean} array.
     */
    public static final boolean[] EMPTY_BOOLEAN_ARRAY = {};
    /**
     * An empty immutable {@code char} array.
     */
    public static final char[] EMPTY_CHAR_ARRAY = {};
    /**
     * An empty immutable {@code byte} array.
     */
    public static final byte[] EMPTY_BYTE_ARRAY = {};
    /**
     * An empty immutable {@code short} array.
     */
    public static final short[] EMPTY_SHORT_ARRAY = {};
    /**
     * An empty immutable {@code int} array.
     */
    public static final int[] EMPTY_INT_ARRAY = {};
    /**
     * An empty immutable {@code long} array.
     */
    public static final long[] EMPTY_LONG_ARRAY = {};
    /**
     * An empty immutable {@code float} array.
     */
    public static final float[] EMPTY_FLOAT_ARRAY = {};
    /**
     * An empty immutable {@code double} array.
     */
    public static final double[] EMPTY_DOUBLE_ARRAY = {};
    /**
     * An empty immutable {@code Boolean} array.
     */
    public static final Boolean[] EMPTY_BOOLEAN_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Character} array.
     */
    public static final Character[] EMPTY_CHAR_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Byte} array.
     */
    public static final Byte[] EMPTY_BYTE_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Short} array.
     */
    public static final Short[] EMPTY_SHORT_OBJ_ARRAY = {};

    /**
     * An empty immutable {@code Integer} array.
     */
    public static final Integer[] EMPTY_INT_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Long} array.
     */
    public static final Long[] EMPTY_LONG_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Float} array.
     */
    public static final Float[] EMPTY_FLOAT_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code Double} array.
     */
    public static final Double[] EMPTY_DOUBLE_OBJ_ARRAY = {};
    /**
     * An empty immutable {@code BigInteger} array.
     */
    public static final BigInteger[] EMPTY_BIG_INTEGER_ARRAY = {};
    /**
     * An empty immutable {@code BigDecimal} array.
     */
    public static final BigDecimal[] EMPTY_BIG_DECIMAL_ARRAY = {};
    /**
     * An empty immutable {@code String} array.
     */
    public static final String[] EMPTY_STRING_ARRAY = {};
    /**
     * An empty immutable {@code java.util.Date} array.
     */
    public static final java.util.Date[] EMPTY_JU_DATE_ARRAY = {};

    /**
     * An empty immutable {@code java.sql.Date} array.
     */
    public static final java.sql.Date[] EMPTY_DATE_ARRAY = {};

    /**
     * An empty immutable {@code Time} array.
     */
    public static final java.sql.Time[] EMPTY_TIME_ARRAY = {};

    /**
     * An empty immutable {@code Timestamp} array.
     */
    public static final java.sql.Timestamp[] EMPTY_TIMESTAMP_ARRAY = {};

    /**
     * An empty immutable {@code Calendar} array.
     */
    @SuppressFBWarnings("STCAL_STATIC_CALENDAR_INSTANCE")
    public static final Calendar[] EMPTY_CALENDAR_ARRAY = {};

    /**
     * An empty immutable {@code LocalDate} array.
     */
    public static final LocalDate[] EMPTY_LOCAL_DATE_ARRAY = {};

    /**
     * An empty immutable {@code LocalTime} array.
     */
    public static final LocalTime[] EMPTY_LOCAL_TIME_ARRAY = {};

    /**
     * An empty immutable {@code LocalDateTime} array.
     */
    public static final LocalDateTime[] EMPTY_LOCAL_DATE_TIME_ARRAY = {};

    /**
     * An empty immutable {@code Object} array.
     */
    public static final Object[] EMPTY_OBJECT_ARRAY = {};

    //    /**
    //     * An empty immutable {@code Dataset}.
    //     */
    //    public static final Dataset EMPTY_DATA_SET = RowDataset.EMPTY_DATA_SET;

    /**
     * An empty immutable {@code Class} array.
     */
    static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];

    /**
     * An empty immutable {@code List}.
     */
    @SuppressWarnings("rawtypes")
    static final List EMPTY_LIST = Collections.emptyList();

    /**
     * An empty immutable {@code Set}.
     */
    @SuppressWarnings("rawtypes")
    static final Set EMPTY_SET = Collections.emptySet();

    /**
     * An empty immutable {@code SortedSet}.
     */
    @SuppressWarnings("rawtypes")
    static final SortedSet EMPTY_SORTED_SET = Collections.emptySortedSet();

    /**
     * An empty immutable {@code NavigableSet}.
     */
    @SuppressWarnings("rawtypes")
    static final NavigableSet EMPTY_NAVIGABLE_SET = Collections.emptyNavigableSet();

    /**
     * An empty immutable {@code Map}.
     */
    @SuppressWarnings("rawtypes")
    static final Map EMPTY_MAP = Collections.emptyMap();

    /**
     * An empty immutable {@code SortedMap}.
     */
    @SuppressWarnings("rawtypes")
    static final SortedMap EMPTY_SORTED_MAP = Collections.emptySortedMap();

    /**
     * An empty immutable {@code NavigableMap}.
     */
    @SuppressWarnings("rawtypes")
    static final NavigableMap EMPTY_NAVIGABLE_MAP = Collections.emptyNavigableMap();

    /**
     * An empty immutable iterator.
     */
    @SuppressWarnings("rawtypes")
    static final Iterator EMPTY_ITERATOR = Collections.emptyIterator();

    /**
     * An empty immutable {@code ListIterator}.
     */
    @SuppressWarnings("rawtypes")
    static final ListIterator EMPTY_LIST_ITERATOR = Collections.emptyListIterator();

    @SuppressWarnings("rawtypes")
    static final Comparator NULL_MIN_COMPARATOR = Comparators.NULL_FIRST_COMPARATOR;

    @SuppressWarnings("rawtypes")
    static final Comparator NULL_MAX_COMPARATOR = Comparators.NULL_LAST_COMPARATOR;

    @SuppressWarnings("rawtypes")
    static final Comparator NATURAL_COMPARATOR = Comparators.NATURAL_ORDER;

    @SuppressWarnings("rawtypes")
    static final Comparator REVERSED_COMPARATOR = Comparators.REVERSED_ORDER;

    static final Comparator<Character> CHAR_COMPARATOR = Character::compare;

    static final Comparator<Byte> BYTE_COMPARATOR = Byte::compare;

    static final Comparator<Short> SHORT_COMPARATOR = Short::compare;

    static final Comparator<Integer> INT_COMPARATOR = Integer::compare;

    static final Comparator<Long> LONG_COMPARATOR = Long::compare;

    static final Comparator<Float> FLOAT_COMPARATOR = Float::compare;

    static final Comparator<Double> DOUBLE_COMPARATOR = Double::compare;

    // ...
    static final Object NULL_MASK = ClassUtil.createNullMask();

    // ...
    static final Map<Class<?>, Object> CLASS_EMPTY_ARRAY = new ConcurrentHashMap<>();

    static {
        CLASS_EMPTY_ARRAY.put(boolean.class, EMPTY_BOOLEAN_ARRAY);
        CLASS_EMPTY_ARRAY.put(Boolean.class, EMPTY_BOOLEAN_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(char.class, EMPTY_CHAR_ARRAY);
        CLASS_EMPTY_ARRAY.put(Character.class, EMPTY_CHAR_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(byte.class, EMPTY_BYTE_ARRAY);
        CLASS_EMPTY_ARRAY.put(Byte.class, EMPTY_BYTE_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(short.class, EMPTY_SHORT_ARRAY);
        CLASS_EMPTY_ARRAY.put(Short.class, EMPTY_SHORT_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(int.class, EMPTY_INT_ARRAY);
        CLASS_EMPTY_ARRAY.put(Integer.class, EMPTY_INT_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(long.class, EMPTY_LONG_ARRAY);
        CLASS_EMPTY_ARRAY.put(Long.class, EMPTY_LONG_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(float.class, EMPTY_FLOAT_ARRAY);
        CLASS_EMPTY_ARRAY.put(Float.class, EMPTY_FLOAT_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(double.class, EMPTY_DOUBLE_ARRAY);
        CLASS_EMPTY_ARRAY.put(Double.class, EMPTY_DOUBLE_OBJ_ARRAY);

        CLASS_EMPTY_ARRAY.put(String.class, EMPTY_STRING_ARRAY);
        CLASS_EMPTY_ARRAY.put(Object.class, EMPTY_OBJECT_ARRAY);
    }

    // ...
    static final Map<Class<?>, Integer> CLASS_TYPE_ENUM = new HashMap<>();

    static {
        CLASS_TYPE_ENUM.put(boolean.class, 1);
        CLASS_TYPE_ENUM.put(char.class, 2);
        CLASS_TYPE_ENUM.put(byte.class, 3);
        CLASS_TYPE_ENUM.put(short.class, 4);
        CLASS_TYPE_ENUM.put(int.class, 5);
        CLASS_TYPE_ENUM.put(long.class, 6);
        CLASS_TYPE_ENUM.put(float.class, 7);
        CLASS_TYPE_ENUM.put(double.class, 8);
        CLASS_TYPE_ENUM.put(String.class, 9);
        CLASS_TYPE_ENUM.put(boolean[].class, 11);
        CLASS_TYPE_ENUM.put(char[].class, 12);
        CLASS_TYPE_ENUM.put(byte[].class, 13);
        CLASS_TYPE_ENUM.put(short[].class, 14);
        CLASS_TYPE_ENUM.put(int[].class, 15);
        CLASS_TYPE_ENUM.put(long[].class, 16);
        CLASS_TYPE_ENUM.put(float[].class, 17);
        CLASS_TYPE_ENUM.put(double[].class, 18);
        CLASS_TYPE_ENUM.put(String[].class, 19);

        CLASS_TYPE_ENUM.put(Boolean.class, 21);
        CLASS_TYPE_ENUM.put(Character.class, 22);
        CLASS_TYPE_ENUM.put(Byte.class, 23);
        CLASS_TYPE_ENUM.put(Short.class, 24);
        CLASS_TYPE_ENUM.put(Integer.class, 25);
        CLASS_TYPE_ENUM.put(Long.class, 26);
        CLASS_TYPE_ENUM.put(Float.class, 27);
        CLASS_TYPE_ENUM.put(Double.class, 28);
    }

    // ...
    private static final Map<Class<? extends Enum<?>>, ImmutableList<? extends Enum<?>>> enumListPool = new ObjectPool<>(POOL_SIZE);

    private static final Map<Class<? extends Enum<?>>, ImmutableSet<? extends Enum<?>>> enumSetPool = new ObjectPool<>(POOL_SIZE);

    private static final Map<Class<? extends Enum<?>>, ImmutableBiMap<? extends Enum<?>, String>> enumMapPool = new ObjectPool<>(POOL_SIZE);

    static final String[] charStringCache = new String[128];

    static final int intStringCacheLow = -1001;

    static final int intStringCacheHigh = 10001;

    static final String[] intStringCache = new String[intStringCacheHigh - intStringCacheLow];

    static final Map<String, Integer> stringIntCache = new HashMap<>((int) (intStringCache.length * 1.5));

    static {
        for (int i = 0, j = intStringCacheLow, len = intStringCache.length; i < len; i++, j++) {
            intStringCache[i] = Integer.toString(j);
            stringIntCache.put(intStringCache[i], j);
        }

        for (int i = 0; i < charStringCache.length; i++) {
            charStringCache[i] = String.valueOf((char) i);
        }
    }

    CommonUtil() {
        // Utility class.
    }

    // ================================ Checks argument/parameter, index, state... ====================================

    /**
     * Checks if the specified range starting from {@code fromIndex} (inclusive) and ending with {@code toIndex} (exclusive)
     * is within the bounds of an array, collection, or string with the specified {@code length}.
     * 
     * <p>This method performs three validation checks:
     * <ul>
     *   <li>{@code fromIndex} must not be negative</li>
     *   <li>{@code fromIndex} must not be greater than {@code toIndex}</li>
     *   <li>{@code toIndex} must not exceed the specified {@code length}</li>
     * </ul>
     * 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2, 3, 4, 5};
     * 
     * // Valid range checks - no exception thrown
     * checkFromToIndex(0, 5, array.length);    // Full array
     * checkFromToIndex(1, 4, array.length);    // Partial range
     * checkFromToIndex(2, 2, array.length);    // Empty range (valid)
     * 
     * // Invalid range checks - throw IndexOutOfBoundsException
     * checkFromToIndex(-1, 3, array.length);   // Negative fromIndex
     * checkFromToIndex(3, 2, array.length);    // fromIndex > toIndex  
     * checkFromToIndex(2, 6, array.length);    // toIndex > length
     * }</pre>
     * 
     * @param fromIndex the starting index (inclusive) - must be non-negative and ≤ toIndex
     * @param toIndex the ending index (exclusive) - must be ≥ fromIndex and ≤ length
     * @param length the size of the array/collection/string - must be non-negative
     * @throws IllegalArgumentException if {@code length} is negative
     * @throws IndexOutOfBoundsException if any of the following conditions are true:
     *         <ul>
     *           <li>{@code fromIndex < 0}</li>
     *           <li>{@code fromIndex > toIndex}</li>
     *           <li>{@code toIndex > length}</li>
     *         </ul>
     * @see #checkFromIndexSize(int, int, int)
     */
    public static void checkFromToIndex(final int fromIndex, final int toIndex, final int length) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (length < 0) {
            throw new IllegalArgumentException("negative length/size: " + length);
        }

        if (fromIndex < 0 || fromIndex > toIndex || toIndex > length) {
            throw new IndexOutOfBoundsException("Index range [" + fromIndex + ", " + toIndex + "] is out-of-bounds for length " + length);
        }
    }

    /**
     * Checks if the specified range starting from {@code fromIndex} (inclusive) with the specified {@code size}
     * is within the bounds of an array, collection, or string with the specified {@code length}.
     * 
     * <p>This method performs three validation checks:
     * <ul>
     *   <li>{@code fromIndex} must not be negative</li>
     *   <li>{@code size} must not be negative</li>
     *   <li>The sum of {@code fromIndex} and {@code size} must not exceed the specified {@code length}</li>
     * </ul>
     * 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2, 3, 4, 5};
     * 
     * // Valid range checks - no exception thrown
     * checkFromIndexSize(0, 5, array.length);    // Full array
     * checkFromIndexSize(1, 3, array.length);    // Partial range
     * checkFromIndexSize(2, 0, array.length);    // Size zero (valid)
     * 
     * // Invalid range checks - throw IndexOutOfBoundsException
     * checkFromIndexSize(-1, 3, array.length);   // Negative fromIndex
     * checkFromIndexSize(2, -1, array.length);   // Negative size  
     * checkFromIndexSize(3, 3, array.length);    // fromIndex + size > length
     * }</pre>
     * 
     * @param fromIndex the starting index (inclusive) - must be non-negative
     * @param size the number of elements in the range - must be non-negative
     * @param length the size of the array/collection/string - must be non-negative
     * @throws IllegalArgumentException if {@code size} or {@code length} is negative
     * @throws IndexOutOfBoundsException if any of the following conditions are true:
     *         <ul>
     *           <li>{@code fromIndex < 0}</li>
     *           <li>{@code size < 0}</li>
     *           <li>{@code fromIndex + size > length}</li>
     *         </ul>
     * @see #checkFromToIndex(int, int, int)
     */
    public static void checkFromIndexSize(final int fromIndex, final int size, final int length) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (size < 0) {
            throw new IllegalArgumentException("negative size: " + size);
        }

        if (length < 0) {
            throw new IllegalArgumentException("negative length/size: " + length);
        }

        if (fromIndex < 0 || size > length - fromIndex) {
            throw new IndexOutOfBoundsException("Start Index " + fromIndex + " with size " + size + " is out-of-bounds for length " + length);
        }
    }

    /**
     * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
     * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
     *
     * @param index a user-supplied index identifying an element of an array, list or string
     * @param size the size of that array, list or string
     * @return the value of {@code index}
     * @throws IllegalArgumentException if {@code size} is negative
     * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
     * @deprecated Use {@link #checkElementIndex(int, int)} or {@link #checkPositionIndex(int, int)} instead
     * @see #checkElementIndex(int, int)
     * @see #checkPositionIndex(int, int)
     */
    @Deprecated
    public static int checkIndex(final int index, final int size) throws IllegalArgumentException, IndexOutOfBoundsException {
        return checkElementIndex(index, size);
    }

    /**
     * <p>Copied from Google Guava under Apache License v2.0 and may be modified.</p>
     *
     * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
     * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
     *
     * <p>This method performs two validation checks:
     * <ul>
     *   <li>{@code size} must not be negative</li>
     *   <li>{@code index} must be non-negative and less than {@code size}</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2, 3, 4, 5};
     *
     * // Valid element index checks - no exception thrown
     * checkElementIndex(0, array.length);    // First element
     * checkElementIndex(4, array.length);    // Last element
     * checkElementIndex(2, array.length);    // Middle element
     *
     * // Invalid element index checks - throw exception
     * checkElementIndex(-1, array.length);   // Negative index
     * checkElementIndex(5, array.length);    // Index equals size (out of bounds)
     * checkElementIndex(0, -1);              // Negative size
     * }</pre>
     *
     * @param index a user-supplied index identifying an element of an array, list or string - must be non-negative and less than {@code size}
     * @param size the size of that array, list or string - must be non-negative
     * @return the value of {@code index}
     * @throws IllegalArgumentException if {@code size} is negative
     * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
     * @see #checkPositionIndex(int, int)
     * @see #checkFromToIndex(int, int, int)
     */
    public static int checkElementIndex(final int index, final int size) throws IllegalArgumentException, IndexOutOfBoundsException {
        return checkElementIndex(index, size, "index");
    }

    /**
     * <p>Copied from Google Guava under Apache License v2.0 and may be modified.</p>
     *
     * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
     * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
     *
     * <p>This method performs two validation checks:
     * <ul>
     *   <li>{@code size} must not be negative</li>
     *   <li>{@code index} must be non-negative and less than {@code size}</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2, 3, 4, 5};
     *
     * // Valid element index checks - no exception thrown
     * checkElementIndex(0, array.length, "arrayIndex");    // First element
     * checkElementIndex(4, array.length, "arrayIndex");    // Last element
     *
     * // Invalid element index checks - throw exception with custom description
     * checkElementIndex(-1, array.length, "arrayIndex");   // Negative index
     * checkElementIndex(5, array.length, "arrayIndex");    // Index equals size
     * }</pre>
     *
     * @param index a user-supplied index identifying an element of an array, list or string - must be non-negative and less than {@code size}
     * @param size the size of that array, list or string - must be non-negative
     * @param desc the text to use to describe this index in an error message
     * @return the value of {@code index}
     * @throws IllegalArgumentException if {@code size} is negative
     * @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
     * @see #checkElementIndex(int, int)
     * @see #checkPositionIndex(int, int, String)
     */
    public static int checkElementIndex(final int index, final int size, final String desc) throws IllegalArgumentException, IndexOutOfBoundsException {
        // Carefully optimized for execution by hotspot (explanatory comment above)
        if (size < 0) {
            throw new IllegalArgumentException("negative size: " + size);
        }

        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));
        }

        return index;
    }

    private static String badElementIndex(final int index, final int size, final String desc) {
        if (index < 0) {
            return Strings.lenientFormat("%s (%s) must not be negative", desc, index);
        } else if (size < 0) {
            throw new IllegalArgumentException("negative size: " + size);
        } else { // index >= size
            return Strings.lenientFormat("%s (%s) must be less than size (%s)", desc, index, size);
        }
    }

    /**
     * <p>Copied from Google Guava under Apache License v2.0 and may be modified.</p>
     *
     * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
     * size {@code size}. A position index may range from zero to {@code size}, inclusive.
     *
     * <p>This method performs two validation checks:
     * <ul>
     *   <li>{@code size} must not be negative</li>
     *   <li>{@code index} must be non-negative and not greater than {@code size}</li>
     * </ul>
     *
     * <p><b>Position vs Element Index:</b>
     * <ul>
     *   <li><b>Element index</b> (see {@link #checkElementIndex(int, int)}): Valid range is [0, size) - points to an existing element</li>
     *   <li><b>Position index</b>: Valid range is [0, size] - can point between elements (e.g., for insertion)</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     *
     * // Valid position index checks - no exception thrown
     * checkPositionIndex(0, list.size());    // Beginning position
     * checkPositionIndex(3, list.size());    // End position (valid for insertion)
     * checkPositionIndex(2, list.size());    // Middle position
     *
     * // Invalid position index checks - throw exception
     * checkPositionIndex(-1, list.size());   // Negative index
     * checkPositionIndex(4, list.size());    // Index greater than size
     * checkPositionIndex(0, -1);             // Negative size
     * }</pre>
     *
     * @param index a user-supplied index identifying a position in an array, list or string - must be non-negative and not greater than {@code size}
     * @param size the size of that array, list or string - must be non-negative
     * @return the value of {@code index}
     * @throws IllegalArgumentException if {@code size} is negative
     * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
     * @see #checkElementIndex(int, int)
     * @see #checkFromToIndex(int, int, int)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static int checkPositionIndex(final int index, final int size) throws IllegalArgumentException, IndexOutOfBoundsException {
        return checkPositionIndex(index, size, "index");
    }

    /**
     * <p>Copied from Google Guava under Apache License v2.0 and may be modified.</p>
     *
     * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
     * size {@code size}. A position index may range from zero to {@code size}, inclusive.
     *
     * <p>This method performs two validation checks:
     * <ul>
     *   <li>{@code size} must not be negative</li>
     *   <li>{@code index} must be non-negative and not greater than {@code size}</li>
     * </ul>
     *
     * <p><b>Position vs Element Index:</b>
     * <ul>
     *   <li><b>Element index</b> (see {@link #checkElementIndex(int, int, String)}): Valid range is [0, size) - points to an existing element</li>
     *   <li><b>Position index</b>: Valid range is [0, size] - can point between elements (e.g., for insertion)</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     *
     * // Valid position index checks - no exception thrown
     * checkPositionIndex(0, list.size(), "insertPos");    // Beginning position
     * checkPositionIndex(3, list.size(), "insertPos");    // End position (valid for insertion)
     *
     * // Invalid position index checks - throw exception with custom description
     * checkPositionIndex(-1, list.size(), "insertPos");   // Negative index
     * checkPositionIndex(4, list.size(), "insertPos");    // Index greater than size
     * }</pre>
     *
     * @param index a user-supplied index identifying a position in an array, list or string - must be non-negative and not greater than {@code size}
     * @param size the size of that array, list or string - must be non-negative
     * @param desc the text to use to describe this index in an error message
     * @return the value of {@code index}
     * @throws IllegalArgumentException if {@code size} is negative
     * @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
     * @see #checkPositionIndex(int, int)
     * @see #checkElementIndex(int, int, String)
     */
    public static int checkPositionIndex(final int index, final int size, final String desc) throws IllegalArgumentException, IndexOutOfBoundsException {
        // Carefully optimized for execution by hotspot (explanatory comment above)
        if (size < 0) {
            throw new IllegalArgumentException("negative size: " + size);
        }

        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));
        }

        return index;
    }

    private static String badPositionIndex(final int index, final int size, final String desc) {
        if (index < 0) {
            return Strings.lenientFormat("%s (%s) must not be negative", desc, index);
        } else if (size < 0) {
            throw new IllegalArgumentException("negative size: " + size);
        } else { // index > size
            return Strings.lenientFormat("%s (%s) must not be greater than size (%s)", desc, index, size);
        }
    }

    /**
     * Checks if the specified argument is not {@code null}, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String value = "test";
     * checkArgNotNull(value);   // returns "test"
     *
     * checkArgNotNull(null);    // throws IllegalArgumentException
     * }</pre>
     *
     * @param <T> the type of the argument
     * @param obj the argument to check
     * @return the {@code non-null} argument
     * @throws IllegalArgumentException if the argument is null
     */
    public static <T> T checkArgNotNull(final T obj) throws IllegalArgumentException {
        if (obj == null) {
            throw new IllegalArgumentException();
        }

        return obj;
    }

    /**
     * Checks if the specified argument is not {@code null}, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String value = checkArgNotNull("test", "value");   // returns "test"
     *
     * checkArgNotNull(null, "value");                    // throws IllegalArgumentException: 'value' cannot be null
     * checkArgNotNull(null, "Value must not be null");   // throws IllegalArgumentException: Value must not be null
     * }</pre>
     *
     * @param <T> the type of the argument
     * @param obj the argument to check
     * @param errorMessage the error message to use in the exception
     * @return the {@code non-null} argument
     * @throws IllegalArgumentException if the argument is null
     */
    public static <T> T checkArgNotNull(final T obj, final String errorMessage) throws IllegalArgumentException {
        if (obj == null) {
            if (isArgNameOnly(errorMessage)) {
                throw new IllegalArgumentException("'" + errorMessage + "' cannot be null");
            } else {
                throw new IllegalArgumentException(errorMessage);
            }
        }

        return obj;
    }

    private static boolean isArgNameOnly(final String argNameOrErrorMsg) {
        // shortest message: "it is null"
        return !(argNameOrErrorMsg.length() > 9 && argNameOrErrorMsg.indexOf(WD._SPACE) > 0); //NOSONAR
    }

    /**
     * Checks if the specified charSequence argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A CharSequence is considered empty if its length is 0. Note that whitespace-only strings are NOT considered empty.
     * Use {@link #checkArgNotBlank(CharSequence, String)} to reject whitespace-only strings.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * checkArgNotEmpty("hello", "username");   // Regular string
     * checkArgNotEmpty("  ", "username");      // Whitespace-only (NOT empty)
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty("", "username");        // Empty string
     * checkArgNotEmpty(null, "username");      // Null
     * }</pre>
     *
     * @param <T> the type of the argument, which extends CharSequence
     * @param arg the argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotBlank(CharSequence, String)
     * @see Strings#isEmpty(CharSequence)
     */
    public static <T extends CharSequence> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (Strings.isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified boolean array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new boolean[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");             // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the boolean array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} boolean array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static boolean[] checkArgNotEmpty(final boolean[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified char array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] array = {'a', 'b'};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new char[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");          // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the char array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} char array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static char[] checkArgNotEmpty(final char[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified byte array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] array = {1, 2};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new byte[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");          // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the byte array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} byte array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static byte[] checkArgNotEmpty(final byte[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified short array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] array = {1, 2};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new short[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");           // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the short array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} short array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static short[] checkArgNotEmpty(final short[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified int array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new int[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");         // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the int array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} int array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static int[] checkArgNotEmpty(final int[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified long array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] array = {1L, 2L};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new long[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");          // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the long array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} long array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static long[] checkArgNotEmpty(final long[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified float array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] array = {1.0f, 2.0f};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new float[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");           // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the float array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} float array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static float[] checkArgNotEmpty(final float[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified double array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] array = {1.0, 2.0};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new double[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");            // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the double array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} double array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Object[], String)
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static double[] checkArgNotEmpty(final double[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Object array argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * checkArgNotEmpty(array, "array");   // returns array
     *
     * checkArgNotEmpty(new String[0], "array");   // throws IllegalArgumentException
     * checkArgNotEmpty(null, "array");            // throws IllegalArgumentException
     * }</pre>
     *
     * @param <T> the type of the array elements
     * @param arg the Object array argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Object array argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     * @see #checkArgNotEmpty(Map, String)
     */
    public static <T> T[] checkArgNotEmpty(final T[] arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified collection argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A Collection is considered empty if {@code collection.isEmpty()} returns {@code true} (i.e., size is 0).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * checkArgNotEmpty(Arrays.asList("a", "b"), "items");       // Collection with elements
     * checkArgNotEmpty(Collections.singleton(null), "items");   // Collection containing null (NOT empty)
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Collections.emptyList(), "items");       // Empty collection
     * checkArgNotEmpty(new ArrayList<>(), "items");             // Empty collection
     * checkArgNotEmpty(null, "items");                          // Null
     * }</pre>
     *
     * @param <T> the type of the collection
     * @param arg the collection argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} collection argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see Collection#isEmpty()
     */
    public static <T extends Collection<?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Iterable argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>An Iterable is considered empty if it has no elements when its iterator is queried.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * Iterable<String> iterable = Arrays.asList("a", "b");
     * checkArgNotEmpty(iterable, "iterable");   // Returns iterable
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Collections.emptyList(), "iterable");   // Empty iterable
     * checkArgNotEmpty(null, "iterable");                      // Null
     * }</pre>
     *
     * @param <T> the type of the Iterable
     * @param arg the Iterable argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Iterable argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     * @see #checkArgNotEmpty(Iterator, String)
     */
    @Beta
    public static <T extends Iterable<?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Iterator argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>An Iterator is considered empty if it has no more elements ({@code hasNext()} returns {@code false}).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * Iterator<String> iterator = Arrays.asList("a", "b").iterator();
     * checkArgNotEmpty(iterator, "iterator");   // Returns iterator
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Collections.emptyIterator(), "iterator");   // Empty iterator
     * checkArgNotEmpty(null, "iterator");                          // Null
     * }</pre>
     *
     * @param <T> the type of the Iterator
     * @param arg the Iterator argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Iterator argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     * @see #checkArgNotEmpty(Iterable, String)
     */
    @Beta
    public static <T extends Iterator<?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Map argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * Map<String, String> map = new HashMap<>();
     * map.put("key", "value");
     * checkArgNotEmpty(map, "map");   // Returns map
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Collections.emptyMap(), "map");   // Empty map
     * checkArgNotEmpty(new HashMap<>(), "map");          // Empty map
     * checkArgNotEmpty(null, "map");                     // Null
     * }</pre>
     *
     * @param <T> the type of the Map
     * @param arg the Map argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Map argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     * @see Map#isEmpty()
     */
    public static <T extends Map<?, ?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified PrimitiveList argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A PrimitiveList is considered empty if its size is 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * IntList intList = IntList.of(1, 2, 3);
     * checkArgNotEmpty(intList, "intList");   // Returns intList
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(IntList.empty(), "intList");   // Empty list
     * checkArgNotEmpty(null, "intList");              // Null
     * }</pre>
     *
     * @param <T> the type of the PrimitiveList
     * @param arg the PrimitiveList argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} PrimitiveList argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static <T extends PrimitiveList<?, ?, ?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Multiset argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A Multiset is considered empty if it contains no elements (all element counts are 0).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * Multiset<String> multiset = Multiset.of("a", "b", "a");
     * checkArgNotEmpty(multiset, "multiset");   // Returns multiset
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Multiset.of(), "multiset");   // Empty multiset
     * checkArgNotEmpty(null, "multiset");            // Null
     * }</pre>
     *
     * @param <T> the type of elements in the Multiset
     * @param arg the Multiset argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Multiset argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static <T> Multiset<T> checkArgNotEmpty(final Multiset<T> arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Multimap argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A Multimap is considered empty if it contains no key-value pairs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * ListMultimap<String, Integer> multimap = ListMultimap.of("a", 1, "b", 2);
     * checkArgNotEmpty(multimap, "multimap");   // Returns multimap
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(ListMultimap.of(), "multimap");   // Empty multimap
     * checkArgNotEmpty(null, "multimap");                // Null
     * }</pre>
     *
     * @param <T> the type of the Multimap
     * @param arg the Multimap argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Multimap argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Map, String)
     */
    public static <T extends Multimap<?, ?, ?>> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    /**
     * Checks if the specified Dataset argument is not {@code null} or empty, and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A Dataset is considered empty if it has no rows.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * Dataset dataset = Dataset.builder().column("name", String.class).build();
     * dataset.addRow("Alice");
     * checkArgNotEmpty(dataset, "dataset");   // Returns dataset
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotEmpty(Dataset.builder().build(), "dataset");   // Empty dataset
     * checkArgNotEmpty(null, "dataset");                        // Null
     * }</pre>
     *
     * @param <T> the type of the Dataset
     * @param arg the Dataset argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null} and {@code non-empty} Dataset argument
     * @throws IllegalArgumentException if the argument is {@code null} or empty
     * @see #checkArgNotEmpty(Collection, String)
     */
    public static <T extends Dataset> T checkArgNotEmpty(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(arg)) {
            throwIllegalArgumentExceptionForNullOrEmptyCheck(argNameOrErrorMsg);
        }

        return arg;
    }

    private static void throwIllegalArgumentExceptionForNullOrEmptyCheck(final String errorMessage) {
        if (isArgNameOnly(errorMessage)) {
            throw new IllegalArgumentException("'" + errorMessage + "' cannot be null or empty");
        } else {
            throw new IllegalArgumentException(errorMessage);
        }
    }

    /**
     * Checks if the specified charSequence argument is not {@code null}, empty, or blank (whitespace only), and throws {@code IllegalArgumentException} if it is.
     *
     * <p>A string is considered blank if it contains only whitespace characters as defined by {@link Character#isWhitespace(char)}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Valid - no exception thrown
     * checkArgNotBlank("hello", "username");   // Regular string
     *
     * // Invalid - throws IllegalArgumentException
     * checkArgNotBlank("", "username");      // Empty string
     * checkArgNotBlank("   ", "username");   // Blank (whitespace-only)
     * checkArgNotBlank(null, "username");    // Null
     * }</pre>
     *
     * @param <T> the type of the argument, which extends CharSequence
     * @param arg the argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-null}, {@code non-empty}, and {@code non-blank} argument
     * @throws IllegalArgumentException if the argument is {@code null}, empty, or blank
     */
    // DON'T change 'OrEmptyOrBlank' to 'OrBlank' because of the occurring order in the auto-completed context menu.
    public static <T extends CharSequence> T checkArgNotBlank(final T arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (Strings.isBlank(arg)) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be null or empty or blank");
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified byte argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative((byte) 1, "value");    // returns 1
     * checkArgNotNegative((byte) 0, "value");    // returns 0
     *
     * checkArgNotNegative((byte) -1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the byte argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} byte argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(byte, String)
     */
    public static byte checkArgNotNegative(final byte arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg); //NOSONAR
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified short argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative((short) 1, "value");    // returns 1
     * checkArgNotNegative((short) 0, "value");    // returns 0
     *
     * checkArgNotNegative((short) -1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the short argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} short argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(short, String)
     */
    public static short checkArgNotNegative(final short arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg); //NOSONAR
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified int argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative(1, "value");    // returns 1
     * checkArgNotNegative(0, "value");    // returns 0
     *
     * checkArgNotNegative(-1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the int argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} int argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(int, String)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static int checkArgNotNegative(final int arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg); //NOSONAR
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified long argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative(1L, "value");    // returns 1L
     * checkArgNotNegative(0L, "value");    // returns 0L
     *
     * checkArgNotNegative(-1L, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the long argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} long argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(long, String)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static long checkArgNotNegative(final long arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified float argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative(1.0f, "value");    // returns 1.0f
     * checkArgNotNegative(0.0f, "value");    // returns 0.0f
     *
     * checkArgNotNegative(-1.0f, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the float argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} float argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(float, String)
     */
    public static float checkArgNotNegative(final float arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified double argument is not negative, and throws {@code IllegalArgumentException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgNotNegative(1.0, "value");    // returns 1.0
     * checkArgNotNegative(0.0, "value");    // returns 0.0
     *
     * checkArgNotNegative(-1.0, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the double argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code non-negative} double argument
     * @throws IllegalArgumentException if the specified arg is negative
     * @see #checkArgPositive(double, String)
     */
    public static double checkArgNotNegative(final double arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg < 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified byte argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive((byte) 1, "value");   // returns 1
     *
     * checkArgPositive((byte) 0, "value");    // throws IllegalArgumentException
     * checkArgPositive((byte) -1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the byte argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} byte argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(byte, String)
     */
    public static byte checkArgPositive(final byte arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified short argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive((short) 1, "value");   // returns 1
     *
     * checkArgPositive((short) 0, "value");    // throws IllegalArgumentException
     * checkArgPositive((short) -1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the short argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} short argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(short, String)
     */
    public static short checkArgPositive(final short arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified int argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive(1, "value");   // returns 1
     *
     * checkArgPositive(0, "value");    // throws IllegalArgumentException
     * checkArgPositive(-1, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the int argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} int argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(int, String)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static int checkArgPositive(final int arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified long argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive(1L, "value");   // returns 1L
     *
     * checkArgPositive(0L, "value");    // throws IllegalArgumentException
     * checkArgPositive(-1L, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the long argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} long argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(long, String)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static long checkArgPositive(final long arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified float argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive(1.0f, "value");   // returns 1.0f
     *
     * checkArgPositive(0.0f, "value");    // throws IllegalArgumentException
     * checkArgPositive(-1.0f, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the float argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} float argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(float, String)
     */
    public static float checkArgPositive(final float arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified double argument is positive, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgPositive(1.0, "value");   // returns 1.0
     *
     * checkArgPositive(0.0, "value");    // throws IllegalArgumentException
     * checkArgPositive(-1.0, "value");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param arg the double argument to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @return the {@code positive} double argument
     * @throws IllegalArgumentException if the specified arg is not positive
     * @see #checkArgNotNegative(double, String)
     */
    @SuppressWarnings("UnusedReturnValue")
    public static double checkArgPositive(final double arg, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (arg <= 0) {
            if (isArgNameOnly(argNameOrErrorMsg)) {
                throw new IllegalArgumentException("'" + argNameOrErrorMsg + "' cannot be zero or negative: " + arg);
            } else {
                throw new IllegalArgumentException(argNameOrErrorMsg);
            }
        }

        return arg;
    }

    /**
     * Checks if the specified array does not contain any {@code null} element, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * checkElementNotNull(array);   // Valid
     *
     * String[] arrayWithNull = {"a", null};
     * checkElementNotNull(arrayWithNull);   // throws IllegalArgumentException
     * }</pre>
     *
     * @param a the array to check
     * @throws IllegalArgumentException if a {@code null} element is found in the array
     */
    public static void checkElementNotNull(final Object[] a) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return;
        }

        for (final Object e : a) {
            if (e == null) {
                throw new IllegalArgumentException("null element is found in array");
            }
        }
    }

    /**
     * Checks if the specified array does not contain any {@code null} element, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * checkElementNotNull(array, "array");   // Valid
     *
     * String[] arrayWithNull = {"a", null};
     * checkElementNotNull(arrayWithNull, "array");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param a the array to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @throws IllegalArgumentException if a {@code null} element is found in the array
     */
    public static void checkElementNotNull(final Object[] a, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return;
        }

        for (final Object e : a) {
            if (e == null) {
                if (isArgNameOnly(argNameOrErrorMsg)) {
                    throw new IllegalArgumentException("null element is found in " + argNameOrErrorMsg);
                } else {
                    throw new IllegalArgumentException(argNameOrErrorMsg);
                }
            }
        }
    }

    /**
     * Checks if the specified {@code Collection} does not contain any {@code null} element, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b");
     * checkElementNotNull(list);   // Valid
     *
     * List<String> listWithNull = Arrays.asList("a", null);
     * checkElementNotNull(listWithNull);   // throws IllegalArgumentException
     * }</pre>
     *
     * @param c the collection to check
     * @throws IllegalArgumentException if {@code null} element found in {@code c}
     */
    public static void checkElementNotNull(final Collection<?> c) throws IllegalArgumentException {
        if (isEmpty(c)) {
            return;
        }

        for (final Object e : c) {
            if (e == null) {
                throw new IllegalArgumentException("null element is found in collection");
            }
        }
    }

    /**
     * Checks if the specified {@code Collection} does not contain any {@code null} element, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b");
     * checkElementNotNull(list, "list");   // Valid
     *
     * List<String> listWithNull = Arrays.asList("a", null);
     * checkElementNotNull(listWithNull, "list");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param c the collection to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @throws IllegalArgumentException if {@code null} element found in {@code c}
     */
    public static void checkElementNotNull(final Collection<?> c, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(c)) {
            return;
        }

        for (final Object e : c) {
            if (e == null) {
                if (isArgNameOnly(argNameOrErrorMsg)) {
                    throw new IllegalArgumentException("null element is found in " + argNameOrErrorMsg);
                } else {
                    throw new IllegalArgumentException(argNameOrErrorMsg);
                }
            }
        }
    }

    /**
     * Checks if the specified {@code Map} does not contain any {@code null} key, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new HashMap<>();
     * map.put("key", "value");
     * checkKeyNotNull(map);   // Valid
     *
     * Map<String, String> mapWithNullKey = new HashMap<>();
     * mapWithNullKey.put(null, "value");
     * checkKeyNotNull(mapWithNullKey);   // throws IllegalArgumentException
     * }</pre>
     *
     * @param m the map to check
     * @throws IllegalArgumentException if {@code null} key found in {@code m}
     */
    public static void checkKeyNotNull(final Map<?, ?> m) throws IllegalArgumentException {
        if (isEmpty(m)) {
            return;
        }

        for (final Object e : m.keySet()) {
            if (e == null) {
                throw new IllegalArgumentException("null key is found in Map");
            }
        }
    }

    /**
     * Checks if the specified {@code Map} does not contain any {@code null} key, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new HashMap<>();
     * map.put("key", "value");
     * checkKeyNotNull(map, "map");   // Valid
     *
     * Map<String, String> mapWithNullKey = new HashMap<>();
     * mapWithNullKey.put(null, "value");
     * checkKeyNotNull(mapWithNullKey, "map");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param m the map to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @throws IllegalArgumentException if {@code null} key found in {@code m}
     */
    public static void checkKeyNotNull(final Map<?, ?> m, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(m)) {
            return;
        }

        for (final Object e : m.keySet()) {
            if (e == null) {
                if (isArgNameOnly(argNameOrErrorMsg)) {
                    throw new IllegalArgumentException("null key is found in " + argNameOrErrorMsg);
                } else {
                    throw new IllegalArgumentException(argNameOrErrorMsg);
                }
            }
        }
    }

    /**
     * Checks if the specified {@code Map} does not contain any {@code null} value, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new HashMap<>();
     * map.put("key", "value");
     * checkValueNotNull(map);   // Valid
     *
     * Map<String, String> mapWithNullValue = new HashMap<>();
     * mapWithNullValue.put("key", null);
     * checkValueNotNull(mapWithNullValue);   // throws IllegalArgumentException
     * }</pre>
     *
     * @param m the map to check
     * @throws IllegalArgumentException if {@code null} value found in {@code m}
     */
    public static void checkValueNotNull(final Map<?, ?> m) throws IllegalArgumentException {
        if (isEmpty(m)) {
            return;
        }

        for (final Object e : m.values()) {
            if (e == null) {
                throw new IllegalArgumentException("null value is found in Map");
            }
        }
    }

    /**
     * Checks if the specified {@code Map} does not contain any {@code null} value, and throws {@code IllegalArgumentException} if it does.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> map = new HashMap<>();
     * map.put("key", "value");
     * checkValueNotNull(map, "map");   // Valid
     *
     * Map<String, String> mapWithNullValue = new HashMap<>();
     * mapWithNullValue.put("key", null);
     * checkValueNotNull(mapWithNullValue, "map");   // throws IllegalArgumentException
     * }</pre>
     *
     * @param m the map to check
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @throws IllegalArgumentException if {@code null} value found in {@code m}
     */
    public static void checkValueNotNull(final Map<?, ?> m, final String argNameOrErrorMsg) throws IllegalArgumentException {
        if (isEmpty(m)) {
            return;
        }

        for (final Object e : m.values()) {
            if (e == null) {
                if (isArgNameOnly(argNameOrErrorMsg)) {
                    throw new IllegalArgumentException("null value is found in " + argNameOrErrorMsg);
                } else {
                    throw new IllegalArgumentException(argNameOrErrorMsg);
                }
            }
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(count > 0);   // Valid if count > 0
     * checkArgument(false);       // throws IllegalArgumentException
     * }</pre>
     *
     * @param b a boolean expression
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(count > 0, "Count must be positive");
     * }</pre>
     *
     * @param b a boolean expression
     * @param argNameOrErrorMsg the name of the argument or an error message to be used in the exception
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final Object argNameOrErrorMsg) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(String.valueOf(argNameOrErrorMsg));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(i >= 0, "Argument was %s but expected nonnegative", i);
     * checkArgument(i < j, "Expected i < j, but %s >= %s", i, j);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param errorMessageArgs the arguments to be substituted into the message template. Arguments are converted to strings using {@link String#valueOf(Object)}.
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object... errorMessageArgs) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(c == 'a', "Expected 'a' but got %s", c);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(count > 0, "Count must be positive: %s", count);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(count > 0, "Count must be positive: %s", count);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(val > 0.0, "Value must be positive: %s", val);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(obj != null, "Object must not be null: %s", obj);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(c1 != c2, "Chars must be different: %s, %s", c1, c2);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p1, final char p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(c != i, "Char and int must be different: %s, %s", c, i);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p1, final int p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(c != l, "Char and long must be different: %s, %s", c, l);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p1, final long p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkArgument(c != d, "Char %s must not equal double %s", c, d);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p1, final double p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final char p1, final Object p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p1, final char p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p1, final int p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p1, final long p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p1, final double p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final int p1, final Object p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p1, final char p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p1, final int p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p1, final long p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p1, final double p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final long p1, final Object p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p1, final char p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p1, final int p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p1, final long p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p1, final double p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final double p1, final Object p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final char p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final int p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final long p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final double p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @param p3 the third parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2, final Object p3)
            throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @param p3 the third parameter to be used in the exception message
     * @param p4 the fourth parameter to be used in the exception message
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2, final Object p3, final Object p4)
            throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
        }
    }

    /**
     * Checks if the specified {@code expression} involving one or more parameters of the calling method is {@code true}, and throws {@code IllegalArgumentException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageSupplier a supplier of the exception message to use if the check fails; will not be invoked if the check passes
     * @throws IllegalArgumentException if {@code expression} is false
     */
    public static void checkArgument(final boolean b, final Supplier<String> errorMessageSupplier) throws IllegalArgumentException {
        if (!b) {
            throw new IllegalArgumentException(errorMessageSupplier.get());
        }
    }

    /**
     * Formats a template string by substituting the first {@code {}} or {@code %s} placeholder with the provided argument.
     * If no placeholder is found, the argument is appended to the template in square brackets.
     *
     * @param template the template string containing 0 or 1 placeholder
     * @param arg the argument to be substituted into the template
     * @return the formatted string with the placeholder replaced, or the template with the argument appended if no placeholder found
     */
    static String format(String template, final Object arg) {
        template = String.valueOf(template); // null -> "null"
        final String stringArg = toString(arg);

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + stringArg.length() + 4);

        String placeholder = "{}";
        int placeholderStart = template.indexOf(placeholder);

        if (placeholderStart < 0) {
            placeholder = "%s";
            placeholderStart = template.indexOf(placeholder);
        }

        if (placeholderStart >= 0) {
            sb.append(template, 0, placeholderStart).append(stringArg).append(template, placeholderStart + 2, template.length());
        } else {
            sb.append(template).append(": [").append(stringArg).append(']');
        }

        final String result = sb.toString();

        Objectory.recycle(sb);

        return result;
    }

    /**
     * Formats a template string by substituting {@code {}} or {@code %s} placeholders with the provided arguments.
     * Arguments are matched by position. If there are more arguments than placeholders,
     * unmatched arguments are appended in square brackets.
     *
     * @param template the template string containing 0 or more placeholders
     * @param arg1 the first argument to be substituted
     * @param arg2 the second argument to be substituted
     * @return the formatted string with placeholders replaced
     */
    static String format(String template, final Object arg1, final Object arg2) {
        template = String.valueOf(template); // null -> "null"
        final String stringArg1 = toString(arg1);
        final String stringArg2 = toString(arg2);

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + (stringArg1.length() + stringArg2.length()) + 8);

        String placeholder = "{}";
        int placeholderStart = template.indexOf(placeholder);

        if (placeholderStart < 0) {
            placeholder = "%s";
            placeholderStart = template.indexOf(placeholder);
        }

        int templateStart = 0;
        int placeholderCount = 0;

        if (placeholderStart >= 0) {
            placeholderCount++;
            sb.append(template, templateStart, placeholderStart);
            sb.append(stringArg1);
            templateStart = placeholderStart + 2;
            placeholderStart = template.indexOf(placeholder, templateStart);

            if (placeholderStart >= 0) {
                placeholderCount++;
                sb.append(template, templateStart, placeholderStart);
                sb.append(stringArg2);
                templateStart = placeholderStart + 2;
            }

            sb.append(template, templateStart, template.length());
        } else {
            sb.append(template);
        }

        if (placeholderCount == 0) {
            sb.append(": [");
            sb.append(stringArg1);
            sb.append(", ");
            sb.append(stringArg2);
            sb.append(']');
        } else if (placeholderCount == 1) {
            sb.append(": [");
            sb.append(stringArg2);
            sb.append(']');
        }

        final String result = sb.toString();

        Objectory.recycle(sb);

        return result;
    }

    /**
     * Formats a template string by substituting {@code {}} or {@code %s} placeholders with the provided arguments.
     * Arguments are matched by position. If there are more arguments than placeholders,
     * unmatched arguments are appended in square brackets.
     *
     * @param template the template string containing 0 or more placeholders
     * @param arg1 the first argument to be substituted
     * @param arg2 the second argument to be substituted
     * @param arg3 the third argument to be substituted
     * @return the formatted string with placeholders replaced
     */
    static String format(String template, final Object arg1, final Object arg2, final Object arg3) {
        template = String.valueOf(template); // null -> "null"
        String stringArg1 = toString(arg1);
        String stringArg2 = toString(arg2);
        String stringArg3 = toString(arg3);

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + (stringArg1.length() + stringArg2.length() + stringArg3.length()) + 12);

        String placeholder = "{}";
        int placeholderStart = template.indexOf(placeholder);

        if (placeholderStart < 0) {
            placeholder = "%s";
            placeholderStart = template.indexOf(placeholder);
        }

        int templateStart = 0;
        int placeholderCount = 0;

        if (placeholderStart >= 0) {
            placeholderCount++;
            sb.append(template, templateStart, placeholderStart);
            sb.append(stringArg1);
            templateStart = placeholderStart + 2;
            placeholderStart = template.indexOf(placeholder, templateStart);

            if (placeholderStart >= 0) {
                placeholderCount++;
                sb.append(template, templateStart, placeholderStart);
                sb.append(stringArg2);
                templateStart = placeholderStart + 2;
                placeholderStart = template.indexOf(placeholder, templateStart);

                if (placeholderStart >= 0) {
                    placeholderCount++;
                    sb.append(template, templateStart, placeholderStart);
                    sb.append(stringArg3);
                    templateStart = placeholderStart + 2;
                }
            }

            sb.append(template, templateStart, template.length());
        } else {
            sb.append(template);
        }

        if (placeholderCount == 0) {
            sb.append(": [");
            sb.append(stringArg1);
            sb.append(", ");
            sb.append(stringArg2);
            sb.append(", ");
            sb.append(stringArg3);
            sb.append(']');
        } else if (placeholderCount == 1) {
            sb.append(": [");
            sb.append(stringArg2);
            sb.append(", ");
            sb.append(stringArg3);
            sb.append(']');
        } else if (placeholderCount == 2) {
            sb.append(": [");
            sb.append(stringArg3);
            sb.append(']');
        }

        final String result = sb.toString();

        Objectory.recycle(sb);

        return result;
    }

    /**
     * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
     * position: the first {@code %s} gets {@code args[0]}, etc. If there are more arguments than
     * placeholders, the unmatched arguments will be appended to the end of the formatted message in
     * square braces.
     *
     * @param template a {@code non-null} string containing 0 or more {@code %s} placeholders.
     * @param args the arguments to be substituted into the message template. Arguments are converted
     *     to strings using {@link String#valueOf(Object)}. Arguments can be {@code null}.
     * @return the formatted string with placeholders replaced by arguments
     */
    // Note that this is somewhat-improperly used from Verify.java as well.
    static String format(String template, final Object... args) {
        template = String.valueOf(template); // null -> "null"

        if (isEmpty(args)) {
            return template;
        }

        // start substituting the arguments into the '%s' placeholders
        final StringBuilder sb = Objectory.createStringBuilder(template.length() + 16 * args.length);
        int templateStart = 0;
        int i = 0;

        String placeholder = "{}";
        int placeholderStart = template.indexOf(placeholder);

        if (placeholderStart < 0) {
            placeholder = "%s";
            placeholderStart = template.indexOf(placeholder);
        }

        while (placeholderStart >= 0 && i < args.length) {
            sb.append(template, templateStart, placeholderStart);
            sb.append(toString(args[i++]));
            templateStart = placeholderStart + 2;
            placeholderStart = template.indexOf(placeholder, templateStart);
        }

        sb.append(template, templateStart, template.length());

        // if we run out of placeholders, append the extra args in square braces
        if (i < args.length) {
            sb.append(" [");
            sb.append(toString(args[i++]));
            while (i < args.length) {
                sb.append(", ");
                sb.append(toString(args[i++]));
            }
            sb.append(']');
        }

        final String result = sb.toString();

        Objectory.recycle(sb);

        return result;
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(initialized);   // Valid if initialized is true
     * checkState(false);         // throws IllegalStateException
     * }</pre>
     *
     * @param b a boolean expression
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException();
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(initialized, "Not initialized");
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessage the name of the argument or an error message to be used in the exception
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final Object errorMessage) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(String.valueOf(errorMessage));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(initialized, "Not initialized: %s", this);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param errorMessageArgs the arguments to be substituted into the message template. Arguments are converted to strings using {@link String#valueOf(Object)}.
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object... errorMessageArgs) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(status == 'A', "Status must be 'A' but was %s", status);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(size > 0, "Size must be positive: %s", size);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(count > 0, "Count must be positive: %s", count);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(val > 0.0, "Value must be positive: %s", val);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(obj != null, "Object must not be null: %s", obj);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p the parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * checkState(c1 != c2, "Characters must be different: %s and %s", c1, c2);
     * }</pre>
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p1, final char p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p1, final int p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p1, final long p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p1, final double p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final char p1, final Object p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p1, final char p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p1, final int p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p1, final long p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p1, final double p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final int p1, final Object p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p1, final char p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p1, final int p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p1, final long p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p1, final double p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final long p1, final Object p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p1, final char p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p1, final int p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p1, final long p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p1, final double p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final double p1, final Object p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final char p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final int p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final long p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final double p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * <p>This overload accepts specific primitive parameter types for performance optimization, avoiding autoboxing overhead.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @param p3 the third parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2, final Object p3)
            throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * @param b a boolean expression
     * @param errorMessageTemplate a template for the exception message should the check fail. The message is formed by replacing each <i>{}</i> or <i>%s</i> placeholder in the template with an argument.
     * @param p1 the parameter to be used in the exception message
     * @param p2 the second parameter to be used in the exception message
     * @param p3 the third parameter to be used in the exception message
     * @param p4 the fourth parameter to be used in the exception message
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final String errorMessageTemplate, final Object p1, final Object p2, final Object p3, final Object p4)
            throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3, p4));
        }
    }

    /**
     * Checks if the specified {@code expression} involving the state check of the calling instance is {@code true}, and throws {@code IllegalStateException} if it is not.
     *
     * @param b a boolean expression
     * @param errorMessageSupplier a supplier of the exception message to use if the check fails; will not be invoked if the check passes
     * @throws IllegalStateException if {@code expression} is false
     */
    public static void checkState(final boolean b, final Supplier<String> errorMessageSupplier) throws IllegalStateException {
        if (!b) {
            throw new IllegalStateException(errorMessageSupplier.get());
        }
    }

    /**
     * Checks if the specified object reference is not {@code null}, and throws {@code NullPointerException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * requireNonNull("not null");   // Returns "not null"
     * requireNonNull(null);         // Throws NullPointerException
     * }</pre>
     *
     * @param <T> the type of the object
     * @param obj the object reference to check for nullity
     * @return the {@code non-null} object reference that was validated
     * @see Objects#requireNonNull(Object)
     * @see Objects#requireNonNull(Object, Supplier)
     * @see Objects#requireNonNullElse(Object, Object)
     * @see Objects#requireNonNullElseGet(Object, Supplier)
     */
    @Beta
    public static <T> T requireNonNull(final T obj) throws NullPointerException {
        if (obj == null) {
            throw new NullPointerException();
        }

        return obj;
    }

    /**
     * Checks if the specified object reference is not {@code null}, and throws {@code NullPointerException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * requireNonNull(null, "Object cannot be null");   // Throws NullPointerException
     * }</pre>
     *
     * @param <T> the type of the object
     * @param obj the object reference to check for nullity
     * @param errorMessage the detail message to be used in the event that a {@code NullPointerException} is thrown
     * @return the {@code non-null} object reference that was validated
     * @see Objects#requireNonNull(Object, String)
     * @see Objects#requireNonNull(Object, Supplier)
     * @see Objects#requireNonNullElse(Object, Object)
     * @see Objects#requireNonNullElseGet(Object, Supplier)
     */
    @Beta
    public static <T> T requireNonNull(final T obj, final String errorMessage) throws NullPointerException {
        if (obj == null) {
            if (isArgNameOnly(errorMessage)) {
                throw new NullPointerException("'" + errorMessage + "' cannot be null");
            } else {
                throw new NullPointerException(errorMessage);
            }
        }

        return obj;
    }

    /**
     * Checks if the specified object reference is not {@code null}, and throws {@code NullPointerException} if it is.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * requireNonNull(null, () -> "Object cannot be null");   // Throws NullPointerException
     * }</pre>
     *
     * @param <T> the type of the object
     * @param obj the object reference to check for nullity
     * @param errorMessageSupplier the supplier of the detail message to be used in the event that a {@code NullPointerException} is thrown
     * @return the {@code non-null} object reference that was validated
     * @see Objects#requireNonNull(Object, String)
     * @see Objects#requireNonNull(Object, Supplier)
     * @see Objects#requireNonNullElse(Object, Object)
     * @see Objects#requireNonNullElseGet(Object, Supplier)
     */
    @Beta
    public static <T> T requireNonNull(final T obj, final Supplier<String> errorMessageSupplier) throws NullPointerException {
        if (obj == null) {
            final String errorMessage = errorMessageSupplier.get();

            if (isArgNameOnly(errorMessage)) {
                throw new NullPointerException("'" + errorMessage + "' cannot be null");
            } else {
                throw new NullPointerException(errorMessage);
            }
        }

        return obj;
    }

    // ================================ Checks argument/parameter, index, state... ====================================

    // ================================ equals/hashCode/toString... ===================================================

    /**
     * Compares two boolean values for equality.
     *
     * @param a the first boolean value
     * @param b the second boolean value
     * @return {@code true} if the boolean values are equal, {@code false} otherwise
     * @see #equals(boolean[], boolean[])
     */
    public static boolean equals(final boolean a, final boolean b) {
        return a == b;
    }

    /**
     * Compares two char values for equality.
     *
     * @param a the first char value
     * @param b the second char value
     * @return {@code true} if the char values are equal, {@code false} otherwise
     * @see Character#compare(char, char)
     * @see #equals(char[], char[])
     */
    public static boolean equals(final char a, final char b) {
        return a == b;
    }

    /**
     * Compares two byte values for equality.
     *
     * @param a the first byte value
     * @param b the second byte value
     * @return {@code true} if the byte values are equal, {@code false} otherwise
     * @see Byte#compare(byte, byte)
     * @see #equals(byte[], byte[])
     */
    public static boolean equals(final byte a, final byte b) {
        return a == b;
    }

    /**
     * Compares two short values for equality.
     *
     * @param a the first short value
     * @param b the second short value
     * @return {@code true} if the short values are equal, {@code false} otherwise
     * @see Short#compare(short, short)
     * @see #equals(short[], short[])
     */
    public static boolean equals(final short a, final short b) {
        return a == b;
    }

    /**
     * Compares two int values for equality.
     *
     * @param a the first int value
     * @param b the second int value
     * @return {@code true} if the int values are equal, {@code false} otherwise
     * @see Integer#compare(int, int)
     * @see #equals(int[], int[])
     */
    public static boolean equals(final int a, final int b) {
        return a == b;
    }

    /**
     * Compares two long values for equality.
     *
     * @param a the first long value
     * @param b the second long value
     * @return {@code true} if the long values are equal, {@code false} otherwise
     * @see Long#compare(long, long)
     * @see #equals(long[], long[])
     */
    public static boolean equals(final long a, final long b) {
        return a == b;
    }

    /**
     * Compares two float values for equality using {@link Float#compare(float, float)}.
     * <p>This method treats {@code NaN} as equal to itself and distinguishes between
     * positive and negative zero, unlike the {@code ==} operator.
     *
     * @param a the first float value
     * @param b the second float value
     * @return {@code true} if the float values are equal, {@code false} otherwise
     * @see Float#compare(float, float)
     * @see #equals(float[], float[])
     */
    public static boolean equals(final float a, final float b) {
        return Float.compare(a, b) == 0;
    }

    /**
     * Compares two double values for equality using {@link Double#compare(double, double)}.
     * <p>This method treats {@code NaN} as equal to itself and distinguishes between
     * positive and negative zero, unlike the {@code ==} operator.
     *
     * @param a the first double value
     * @param b the second double value
     * @return {@code true} if the double values are equal, {@code false} otherwise
     * @see Double#compare(double, double)
     * @see #equals(double[], double[])
     */
    public static boolean equals(final double a, final double b) {
        return Double.compare(a, b) == 0;
    }

    /**
     * Compares two strings for equality.
     *
     * @param a the first string
     * @param b the second string
     * @return {@code true} if the strings are equal, {@code false} otherwise
     */
    public static boolean equals(final String a, final String b) {
        return (a == null) ? b == null : (b != null && a.length() == b.length() && a.equals(b));
    }

    /**
     * Compares two strings for equality, ignoring case.
     *
     * @param a the first string
     * @param b the second string
     * @return {@code true} if the strings are equal, {@code false} otherwise
     */
    public static boolean equalsIgnoreCase(final String a, final String b) {
        return (a == null) ? b == null : (a.equalsIgnoreCase(b));
    }

    /**
     * Compares two objects for equality. If the objects are arrays, the appropriate {@code Arrays.equals} method will be used.
     *
     * @param a the first object
     * @param b the second object
     * @return {@code true} if the objects are equal, {@code false} otherwise
     */
    public static boolean equals(final Object a, final Object b) {
        if (Objects.equals(a, b)) {
            return true;
        }

        if ((a != null) && (b != null)) {
            final Type<Object> typeA = typeOf(a.getClass());

            if (typeA.isPrimitiveArray()) {
                final Type<Object> typeB = typeOf(b.getClass());

                return typeA.clazz().equals(typeB.clazz()) && typeA.equals(a, b);
            } else if (typeA.isObjectArray()) {
                final Type<Object> typeB = typeOf(b.getClass());

                return typeB.isObjectArray() && typeA.equals(a, b);
            }
        }

        return false;
    }

    /**
     * Compares two arrays for equality.
     * <p>Two arrays are considered equal if:
     * <ul>
     *   <li>Both are {@code null}, or</li>
     *   <li>Both reference the same array object, or</li>
     *   <li>Both have the same length and all corresponding elements are equal</li>
     * </ul>
     *
     * @param a the first array, may be {@code null}
     * @param b the second array, may be {@code null}
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(boolean[], boolean[])
     * @see #hashCode(boolean[])
     */
    public static boolean equals(final boolean[] a, final boolean[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two boolean arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * boolean[] b = {true, false, false};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first boolean array; must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second boolean array; must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(boolean[], boolean[])
     */
    public static boolean equals(final boolean[] a, final int fromIndexA, final boolean[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(char[], char[])
     */
    public static boolean equals(final char[] a, final char[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two char arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'a', 'b', 'd'};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first char array; must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second char array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(char[], char[])
     */
    public static boolean equals(final char[] a, final int fromIndexA, final char[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(byte[], byte[])
     */
    public static boolean equals(final byte[] a, final byte[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two byte arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {1, 2, 4};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first byte array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second byte array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(byte[], byte[])
     */
    public static boolean equals(final byte[] a, final int fromIndexA, final byte[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(short[], short[])
     */
    public static boolean equals(final short[] a, final short[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two short arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 3};
     * short[] b = {1, 2, 4};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first short array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second short array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(short[], short[])
     */
    public static boolean equals(final short[] a, final int fromIndexA, final short[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(int[], int[])
     */
    public static boolean equals(final int[] a, final int[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two int arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 3};
     * int[] b = {1, 2, 4};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first int array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second int array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(int[], int[])
     */
    public static boolean equals(final int[] a, final int fromIndexA, final int[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(long[], long[])
     */
    public static boolean equals(final long[] a, final long[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two long arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1L, 2L, 3L};
     * long[] b = {1L, 2L, 4L};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first long array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second long array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(long[], long[])
     */
    public static boolean equals(final long[] a, final int fromIndexA, final long[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(float[], float[])
     */
    public static boolean equals(final float[] a, final float[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two float arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {1.0f, 2.0f, 4.0f};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first float array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second float array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(float[], float[])
     */
    public static boolean equals(final float[] a, final int fromIndexA, final float[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (Float.compare(a[i], b[j]) != 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two float arrays for equality within a specified delta.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {1.01f, 2.01f, 3.01f};
     * equals(a, b, 0.02f);    // returns true
     * equals(a, b, 0.001f);   // returns false
     * }</pre>
     *
     * @param a the first float array, must not be null
     * @param b the second float array, must not be null
     * @param delta the maximum difference allowed for equality
     * @return {@code true} if the arrays are equal within the specified delta, {@code false} otherwise
     */
    public static boolean equals(final float[] a, final float[] b, final float delta) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        for (int i = 0; i < len; i++) {
            if (!Numbers.fuzzyEquals(a[i], b[i], delta)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(double[], double[])
     */
    public static boolean equals(final double[] a, final double[] b) {
        return Arrays.equals(a, b);
    }

    /**
     * Compares two double arrays for equality within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * double[] b = {1.0, 2.0, 4.0};
     * equals(a, 0, b, 0, 2);   // returns true
     * equals(a, 0, b, 0, 3);   // returns false
     * }</pre>
     *
     * @param a the first double array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second double array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(double[], double[])
     */
    public static boolean equals(final double[] a, final int fromIndexA, final double[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (Double.compare(a[i], b[j]) != 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two double arrays for equality within a specified delta.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * double[] b = {1.01, 2.01, 3.01};
     * equals(a, b, 0.02);    // returns true
     * equals(a, b, 0.001);   // returns false
     * }</pre>
     *
     * @param a the first double array, must not be null
     * @param b the second double array, must not be null
     * @param delta the maximum difference allowed for equality
     * @return {@code true} if the arrays are equal within the specified delta, {@code false} otherwise
     */
    public static boolean equals(final double[] a, final double[] b, final double delta) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        for (int i = 0; i < len; i++) {
            if (!Numbers.fuzzyEquals(a[i], b[i], delta)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays for equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#equals(Object[], Object[])
     */
    public static boolean equals(final Object[] a, final Object[] b) {
        return a == b || (a != null && b != null && a.length == b.length && equals(a, 0, b, 0, a.length));
    }

    /**
     * Compares two arrays for equality within the specified range.
     *
     * @param a the first array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#equals(Object[], Object[])
     */
    public static boolean equals(final Object[] a, final int fromIndexA, final Object[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        } else if (!a.getClass().equals(b.getClass())) {
            return false;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (!equals(a[i], b[j])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two objects for deep equality. If the objects are arrays, the appropriate {@code Arrays.deepEquals} method will be used.
     * <p><b>Deep vs Shallow Equality:</b>
     * <ul>
     *   <li><b>Shallow equality</b> (see {@link #equals(Object, Object)}):
     *       Arrays are compared by reference or first-level elements only</li>
     *   <li><b>Deep equality</b>: Arrays are compared recursively, descending
     *       into nested arrays to compare all elements at all levels</li>
     * </ul>
     * If the objects are arrays, this method uses recursive comparison to check
     * all nested elements.
     *
     * @param a the first object to compare, which may be null
     * @param b the second object to compare, which may be null
     * @return {@code true} if the objects are deeply equal, {@code false} otherwise
     * @see Arrays#deepEquals(Object[], Object[])
     * @see #equals(Object, Object)
     */
    public static boolean deepEquals(final Object a, final Object b) {
        if (Objects.equals(a, b)) {
            return true;
        }

        final Class<?> cls = a == null ? null : a.getClass();

        if ((a != null) && (b != null) && cls.isArray() && cls.equals(b.getClass())) {
            final Integer enumInt = CLASS_TYPE_ENUM.get(cls);

            if (enumInt == null) {
                return deepEquals((Object[]) a, (Object[]) b);
            }

            switch (enumInt) {
                case 11:
                    return equals((boolean[]) a, (boolean[]) b);

                case 12:
                    return equals((char[]) a, (char[]) b);

                case 13:
                    return equals((byte[]) a, (byte[]) b);

                case 14:
                    return equals((short[]) a, (short[]) b);

                case 15:
                    return equals((int[]) a, (int[]) b);

                case 16:
                    return equals((long[]) a, (long[]) b);

                case 17:
                    return equals((float[]) a, (float[]) b);

                case 18:
                    return equals((double[]) a, (double[]) b);

                case 19:
                    return equals((String[]) a, (String[]) b);

                default:
                    return deepEquals((Object[]) a, (Object[]) b);
            }

        }

        return false;
    }

    /**
     * Compares two arrays for deep equality.
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays are equal, {@code false} otherwise
     * @see Arrays#deepEquals(Object[], Object[])
     */
    public static boolean deepEquals(final Object[] a, final Object[] b) {
        return a == b || (a != null && b != null && a.length == b.length && deepEquals(a, 0, b, 0, a.length));
    }

    /**
     * Compares two arrays for deep equality within the specified range.
     *
     * @param a the first array, must not be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second array, must not be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#deepEquals(Object[], Object[])
     */
    public static boolean deepEquals(final Object[] a, final int fromIndexA, final Object[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        } else if (!a.getClass().equals(b.getClass())) {
            return false;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (!deepEquals(a[i], b[j])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two arrays of Strings, ignoring case considerations.
     *
     * @param a the first array of Strings to compare, which may be null
     * @param b the second array of Strings to compare, which may be null
     * @return {@code true} if the arrays are equal, ignoring case considerations, or both are null; {@code false} otherwise
     */
    public static boolean equalsIgnoreCase(final String[] a, final String[] b) {
        return (a == null || b == null) ? a == b : (a.length == b.length && equalsIgnoreCase(a, 0, b, 0, a.length));
    }

    /**
     * Compares two arrays of Strings, ignoring case considerations, within the specified range.
     *
     * @param a the first array of Strings to compare, which may be null
     * @param fromIndexA the starting index in the first array, inclusive
     * @param b the second array of Strings to compare, which may be null
     * @param fromIndexB the starting index in the second array, inclusive
     * @param len the number of elements to compare
     * @return {@code true} if the specified range of elements in both arrays are equal, ignoring case considerations, or both are null; {@code false} otherwise
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean equalsIgnoreCase(final String[] a, final int fromIndexA, final String[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return true;
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (((a[i] == null || b[j] == null) ? (a[i] != b[j]) : !a[i].equalsIgnoreCase(b[j]))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares two maps for equality based on the specified keys.
     *
     * @param <K> the type of keys in the maps
     * @param map1 the first map to compare, it can be null
     * @param map2 the second map to compare, it can be null
     * @param keysToCompare the collection of keys to compare, it must not be null
     * @return {@code true} if the values associated with the specified keys in both maps are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the {@code keysToCompare} is empty
     */
    public static <K> boolean equalsByKeys(final Map<? extends K, ?> map1, final Map<? extends K, ?> map2, final Collection<K> keysToCompare)
            throws IllegalArgumentException {
        N.checkArgNotEmpty(keysToCompare, cs.keysToCompare);

        if (map1 == map2) {
            return true;
        } else if ((map1 == null || map2 == null)) {
            return false;
        }

        Object value1 = null;
        Object value2 = null;

        for (K key : keysToCompare) {
            value1 = map1.get(key);
            value2 = map2.get(key);

            if (!equals(value1, value2) || (value1 == null && value2 == null && (map1.containsKey(key) != map2.containsKey(key)))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Compares the properties of two beans to determine if they are equal.
     *
     * @param bean1 the first bean to compare, must not be null
     * @param bean2 the second bean to compare, must not be null
     * @param propNamesToCompare the collection of property names to compare, must not be {@code null} or empty
     * @return {@code true} if all the specified properties of the beans are equal, {@code false} otherwise
     * @throws IllegalArgumentException if the {@code propNamesToCompare} is empty
     * @deprecated Use {@link Beans#equalsByProps(Object,Object,Collection<String>)} instead
     */
    @Deprecated
    public static boolean equalsByProps(final Object bean1, final Object bean2, final Collection<String> propNamesToCompare) throws IllegalArgumentException {
        return Beans.equalsByProps(bean1, bean2, propNamesToCompare);
    }

    /**
     * Compares the properties of two beans to determine if they are equal by common properties.
     *
     * @param bean1 the first bean to compare, must not be null
     * @param bean2 the second bean to compare, must not be null
     * @return {@code true} if all the common properties of the beans are equal, {@code false} otherwise
     * @throws IllegalArgumentException if no common property is found
     * @deprecated Use {@link Beans#equalsByCommonProps(Object,Object)} instead
     */
    @Deprecated
    public static boolean equalsByCommonProps(@NotNull final Object bean1, @NotNull final Object bean2) throws IllegalArgumentException {
        return Beans.equalsByCommonProps(bean1, bean2);
    }

    /** 
     * Returns {@code true} if the given {@link Collection}s contain exactly the same elements with exactly the same cardinalities.
     *
     * @param a the first collection to compare, which may be null
     * @param b the second collection to compare, which may be null
     * @return {@code true} if the collections are equal, {@code false} otherwise
     * @throws UnsupportedOperationException if this method is called
     * @deprecated Use {@link N#isEqualCollection(Collection, Collection)} instead.
     * @see N#isEqualCollection(Collection, Collection)
     */
    @Deprecated
    @SuppressWarnings("unused")
    public static boolean equalsCollection(final Collection<?> a, final Collection<?> b) throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Please use N.isEqualCollection(Collection, Collection)");
    }

    /**
     * Returns the hash code for a boolean value.
     *
     * @param value the boolean value
     * @return the hash code
     * @see Boolean#hashCode(boolean)
     * @see #hashCode(boolean[])
     */
    public static int hashCode(final boolean value) {
        return value ? 1231 : 1237;
    }

    /**
     * Returns the hash code for a char value.
     *
     * @param value the char value
     * @return the hash code
     * @see Character#hashCode(char)
     * @see #hashCode(char[])
     */
    public static int hashCode(final char value) {
        return value;
    }

    /**
     * Returns the hash code for a byte value.
     *
     * @param value the byte value
     * @return the hash code
     * @see Byte#hashCode(byte)
     * @see #hashCode(byte[])
     */
    public static int hashCode(final byte value) {
        return value;
    }

    /**
     * Returns the hash code for a short value.
     *
     * @param value the short value
     * @return the hash code
     * @see Short#hashCode(short)
     * @see #hashCode(short[])
     */
    public static int hashCode(final short value) {
        return value;
    }

    /**
     * Returns the hash code for an int value.
     *
     * @param value the int value
     * @return the hash code
     * @see Integer#hashCode(int)
     * @see #hashCode(int[])
     */
    public static int hashCode(final int value) {
        return value;
    }

    /**
     * Returns the hash code for a long value.
     *
     * @param value the long value
     * @return the hash code
     * @see Long#hashCode(long)
     * @see #hashCode(long[])
     */
    public static int hashCode(final long value) {
        return Long.hashCode(value);
    }

    /**
     * Returns the hash code for a float value.
     *
     * @param value the float value
     * @return the hash code
     * @see Float#hashCode(float)
     * @see #hashCode(float[])
     */
    public static int hashCode(final float value) {
        return Float.floatToIntBits(value);
    }

    /**
     * Returns the hash code for a double value.
     *
     * @param value the double value
     * @return the hash code
     * @see Double#hashCode(double)
     * @see #hashCode(double[])
     */
    public static int hashCode(final double value) {

        return Double.hashCode(value);
    }

    /**
     * Returns the hash code for an object. If the object is an array, the appropriate {@code Arrays.hashCode} method will be used
     *
     * @param obj the object for which the hash code is to be calculated
     * @return the hash code of the object, or 0 if the object is null
     */
    public static int hashCode(final Object obj) {
        if (obj == null) {
            return 0;
        }

        if (obj.getClass().isArray()) {
            return typeOf(obj.getClass()).hashCode(obj);
        }

        return obj.hashCode();
    }

    /**
     * Returns the hash code for an array of booleans.
     *
     * @param a the array of booleans, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(boolean[])
     * @see #equals(boolean[], boolean[])
     */
    public static int hashCode(final boolean[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a boolean array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * int hash = hashCode(a, 0, 2);   // hash code for {true, false}
     * }</pre>
     *
     * @param a the array of booleans
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + (a[i] ? 1231 : 1237);
        }

        return result;
    }

    /**
     * Returns the hash code for an array of chars.
     *
     * @param a the array of chars, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(char[])
     */
    public static int hashCode(final char[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a char array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * int hash = hashCode(a, 0, 2);   // hash code for {'a', 'b'}
     * }</pre>
     *
     * @param a the array of chars
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + a[i];
        }

        return result;
    }

    /**
     * Returns the hash code for an array of bytes.
     *
     * @param a the array of bytes, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(byte[])
     */
    public static int hashCode(final byte[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a byte array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * int hash = hashCode(a, 0, 2);   // hash code for {1, 2}
     * }</pre>
     *
     * @param a the array of bytes
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + a[i];
        }

        return result;
    }

    /**
     * Returns the hash code for an array of shorts.
     *
     * @param a the array of shorts, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(short[])
     */
    public static int hashCode(final short[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a short array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 3};
     * int hash = hashCode(a, 0, 2);   // hash code for {1, 2}
     * }</pre>
     *
     * @param a the array of shorts
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + a[i];
        }

        return result;
    }

    /**
     * Returns the hash code for an array of ints.
     *
     * @param a the array of ints, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(int[])
     */
    public static int hashCode(final int[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in an int array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 3};
     * int hash = hashCode(a, 0, 2);   // hash code for {1, 2}
     * }</pre>
     *
     * @param a the array of ints
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + a[i];
        }

        return result;
    }

    /**
     * Returns the hash code for an array of longs.
     *
     * @param a the array of longs, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(long[])
     */
    public static int hashCode(final long[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a long array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1L, 2L, 3L};
     * int hash = hashCode(a, 0, 2);   // hash code for {1L, 2L}
     * }</pre>
     *
     * @param a the array of longs
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + Long.hashCode(a[i]);
        }

        return result;
    }

    /**
     * Returns the hash code for an array of floats.
     *
     * @param a the array of floats, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(float[])
     */
    public static int hashCode(final float[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a float array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * int hash = hashCode(a, 0, 2);   // hash code for {1.0f, 2.0f}
     * }</pre>
     *
     * @param a the array of floats
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + Float.floatToIntBits(a[i]);
        }

        return result;
    }

    /**
     * Returns the hash code for an array of doubles.
     *
     * @param a the array of doubles, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(double[])
     */
    public static int hashCode(final double[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in a double array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * int hash = hashCode(a, 0, 2);   // hash code for {1.0, 2.0}
     * }</pre>
     *
     * @param a the array of doubles
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + Double.hashCode(a[i]);
        }

        return result;
    }

    /**
     * Returns the hash code for an array of Objects.
     *
     * @param a the array of Objects, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#hashCode(Object[])
     */
    public static int hashCode(final Object[] a) {
        return a == null ? 0 : hashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in an Object array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"a", "b", "c"};
     * int hash = hashCode(a, 0, 2);   // hash code for {"a", "b"}
     * }</pre>
     *
     * @param a the array of Objects
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static int hashCode(final Object[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + (a[i] == null ? 0 : a[i].hashCode());
        }

        return result;
    }

    /**
     * Returns the hash code for the specified object. If the object is an array, the appropriate {@code Arrays.deepHashCode} method will be used.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2};
     * int deepHash = deepHashCode(array);   // deep hash code of array
     * int hash = deepHashCode("string");    // hash code of string
     * }</pre>
     *
     * @param obj the object for which the hash code is to be calculated
     * @return the hash code of the object, or 0 if the object is null
     * @see Arrays#deepHashCode(Object[])
     */
    public static int deepHashCode(final Object obj) {
        if (obj == null) {
            return 0;
        }

        final Class<?> cls = obj.getClass();

        if (cls.isArray()) {
            final Integer enumInt = CLASS_TYPE_ENUM.get(cls);

            if (enumInt == null) {
                return deepHashCode((Object[]) obj);
            }

            switch (enumInt) {
                case 11:
                    return hashCode((boolean[]) obj);

                case 12:
                    return hashCode((char[]) obj);

                case 13:
                    return hashCode((byte[]) obj);

                case 14:
                    return hashCode((short[]) obj);

                case 15:
                    return hashCode((int[]) obj);

                case 16:
                    return hashCode((long[]) obj);

                case 17:
                    return hashCode((float[]) obj);

                case 18:
                    return hashCode((double[]) obj);

                case 19:
                    return hashCode((String[]) obj);

                default:
                    return deepHashCode((Object[]) obj);
            }
        }

        return obj.hashCode();
    }

    /**
     * Returns the hash code for an array of Objects.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * int deepHash = deepHashCode(array);   // deep hash code of array
     * }</pre>
     *
     * @param a the array of Objects, may be {@code null}
     * @return the hash code of the array
     * @see Arrays#deepHashCode(Object[])
     */
    public static int deepHashCode(final Object[] a) {
        return a == null ? 0 : deepHashCode(a, 0, a.length);
    }

    /**
     * Returns the hash code for a range of elements in an Object array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b", "c"};
     * int deepHash = deepHashCode(array, 0, 2);   // deep hash code of {"a", "b"}
     * }</pre>
     *
     * @param a the array of Objects
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the hash code for the specified range of the array
     * @throws IndexOutOfBoundsException if the indices are out of range
     * @see Arrays#deepHashCode(Object[])
     */
    public static int deepHashCode(final Object[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return 0;
        }

        int result = 1;

        for (int i = fromIndex; i < toIndex; i++) {
            result = 31 * result + (a[i] == null ? 0 : deepHashCode(a[i]));
        }

        return result;
    }

    /**
     * Calculates a comprehensive hash code by recursively traversing the entire object graph.
     *
     * <p>This method walks through common container types to incorporate nested content into the result:</p>
     * <ul>
     *   <li>Arrays (primitive or object): each element is processed recursively</li>
     *   <li>{@link Iterable} and {@link Iterator}: each element is processed recursively</li>
     *   <li>{@link Map}: both keys and values are processed recursively</li>
     *   <li>JavaBean objects: each property is processed recursively</li>
     *   <li>Other objects: delegated to {@link N#hashCode(Object)}</li>
     * </ul>
     * <p>A {@code null} input returns {@code 0}. This is more exhaustive than {@link #hashCode(Object)} or
     * {@link #deepHashCode(Object)} but can be expensive for large or deeply nested structures.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Map<String, Object[]>> complexObject = ...
     * long hashCode = hashCodeEverything(complexObject);
     * }</pre>
     *
     * @param obj the object whose full structure should be hashed, may be {@code null}
     * @return a long hash code representing the complete object graph, or {@code 0} for {@code null}
     * @see #hashCode(Object[])
     * @see #deepHashCode(Object[])
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static long hashCodeEverything(final Object obj) {
        if (obj == null) {
            return 0;
        }

        long hash = 1;

        if (obj instanceof Iterable iter) {
            for (final Object e : iter) {
                hash = 31 * hash + hashCodeEverything(e);
            }
        } else if (obj instanceof Map) {
            final Map<Object, Object> map = (Map) obj;

            for (final Map.Entry<Object, Object> entry : map.entrySet()) {
                hash = 31 * hash + hashCodeEverything(entry.getKey());
                hash = 31 * hash + hashCodeEverything(entry.getValue());
            }
        } else if (obj.getClass().isArray()) {
            if (obj instanceof Object[] a) {
                for (final Object e : a) {
                    hash = 31 * hash + hashCodeEverything(e);
                }
            } else {
                hash = 31 * hash + N.deepHashCode(obj);
            }
        } else if (obj instanceof Iterator iter) {
            while (iter.hasNext()) {
                hash = 31 * hash + hashCodeEverything(iter.next());
            }
        } else if (Beans.isBeanClass(obj.getClass())) {
            final BeanInfo beanInfo = ParserUtil.getBeanInfo(obj.getClass());

            for (final PropInfo propInfo : beanInfo.propInfoList) {
                hash = 31 * hash + N.hashCode(propInfo.name);
                hash = 31 * hash + hashCodeEverything(propInfo.getPropValue(obj));
            }
        } else {
            hash = 31 * hash + N.hashCode(obj);
        }

        return hash;
    }

    /**
     * Returns a string representation of the specified boolean value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(true);    // returns "true"
     * toString(false);   // returns "false"
     * }</pre>
     *
     * @param value the boolean value to be represented as a string
     * @return the String representation of the boolean value
     */
    public static String toString(final boolean value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified char value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString('a');   // returns "a"
     * }</pre>
     *
     * @param value the char value to be represented as a string
     * @return the String representation of the char value
     */
    public static String toString(final char value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified byte value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString((byte) 1);   // returns "1"
     * }</pre>
     *
     * @param value the byte value to be represented as a string
     * @return the String representation of the byte value
     */
    public static String toString(final byte value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified short value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString((short) 1);   // returns "1"
     * }</pre>
     *
     * @param value the short value to be represented as a string
     * @return the String representation of the short value
     */
    public static String toString(final short value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified int value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1);   // returns "1"
     * }</pre>
     *
     * @param value the int value to be represented as a string
     * @return the String representation of the int value
     */
    public static String toString(final int value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified long value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1L);   // returns "1"
     * }</pre>
     *
     * @param value the long value to be represented as a string
     * @return the String representation of the long value
     */
    public static String toString(final long value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified float value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1.0f);   // returns "1.0"
     * }</pre>
     *
     * @param value the float value to be represented as a string
     * @return the String representation of the float value
     */
    public static String toString(final float value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified double value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1.0);   // returns "1.0"
     * }</pre>
     *
     * @param value the double value to be represented as a string
     * @return the String representation of the double value
     */
    public static String toString(final double value) {
        return stringOf(value);
    }

    /**
     * Returns a string representation of the specified object.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1);      // returns "1"
     * toString(null);   // returns "null"
     * }</pre>
     *
     * @param obj the object to be represented as a string
     * @return the String representation of the object. If the object is {@code null}, the string {@code "null"} is returned.
     */
    public static String toString(final Object obj) {
        if (obj == null) {
            return Strings.NULL;
        } else if (obj instanceof CharSequence) {
            return obj.toString();
        }

        if (obj.getClass().isArray()) {
            return typeOf(obj.getClass()).toString(obj);
        }
        if (obj instanceof final Iterator<?> iter) { // NOSONAR
            return Strings.join(iter, ", ", "[", "]");
        }
        if (obj instanceof final Iterable<?> iter) { // NOSONAR
            return Strings.join(iter, ", ", "[", "]");
        }

        final Integer typeIdx = CLASS_TYPE_ENUM.get(obj.getClass());

        if (typeIdx == null) {
            return obj.toString();
        }

        switch (typeIdx) {
            case 21:
                return toString(((Boolean) obj).booleanValue());

            case 22:
                return toString(((Character) obj).charValue());

            case 23:
                return toString(((Byte) obj).byteValue());

            case 24:
                return toString(((Short) obj).shortValue());

            case 25:
                return toString(((Integer) obj).intValue());

            case 26:
                return toString(((Long) obj).longValue());

            //    case 27:
            //        return toString(((Float) obj).floatValue());
            //
            //    case 28:
            //        return toString(((Double) obj).doubleValue());

            default:
                return obj.toString();
        }
    }

    /**
     * Returns a string representation of the specified object. If the object is {@code null}, the specified default value is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * toString(1, "default");      // returns "1"
     * toString(null, "default");   // returns "default"
     * }</pre>
     *
     * @param obj the object to be represented as a string
     * @param defaultIfNull the default value to be returned if the object is null
     * @return the String representation of the object, or the default value if the object is null
     */
    public static String toString(final Object obj, final String defaultIfNull) {
        return obj == null ? defaultIfNull : toString(obj);
    }

    /**
     * Returns a string representation of the specified boolean array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false};
     * toString(array);   // returns "[true, false]"
     * }</pre>
     *
     * @param a the boolean array to be represented as a string, may be {@code null}
     * @return the String representation of the boolean array
     * @see Arrays#toString(boolean[])
     */
    public static String toString(final boolean[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a boolean array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false, true};
     * toString(array, 0, 2);   // returns "[true, false]"
     * }</pre>
     *
     * @param a the boolean array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the boolean array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final boolean[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final boolean[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified char array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] array = {'a', 'b'};
     * toString(array);   // returns "[a, b]"
     * }</pre>
     *
     * @param a the char array to be represented as a string, may be {@code null}
     * @return the String representation of the char array
     * @see Arrays#toString(char[])
     */
    public static String toString(final char[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a char array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] array = {'a', 'b', 'c'};
     * toString(array, 0, 2);   // returns "[a, b]"
     * }</pre>
     *
     * @param a the char array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the char array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);

        // return String.valueOf(a, fromIndex, toIndex - fromIndex);   // NOSONAR)
    }

    static void toString(final StringBuilder sb, final char[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final char[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified byte array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] array = {1, 2};
     * toString(array);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the byte array to be represented as a string, may be {@code null}
     * @return the String representation of the byte array
     * @see Arrays#toString(byte[])
     */
    public static String toString(final byte[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a byte array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] array = {1, 2, 3};
     * toString(array, 0, 2);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the byte array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the byte array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final byte[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final byte[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified short array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] array = {1, 2};
     * toString(array);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the short array to be represented as a string, may be {@code null}
     * @return the String representation of the short array
     * @see Arrays#toString(short[])
     */
    public static String toString(final short[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a short array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] array = {1, 2, 3};
     * toString(array, 0, 2);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the short array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the short array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final short[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final short[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified int array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2};
     * toString(array);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the int array to be represented as a string, may be {@code null}
     * @return the String representation of the int array
     * @see Arrays#toString(int[])
     */
    public static String toString(final int[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in an int array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2, 3};
     * toString(array, 0, 2);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the int array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the int array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final int[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final int[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified long array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] array = {1L, 2L};
     * toString(array);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the long array to be represented as a string, may be {@code null}
     * @return the String representation of the long array
     * @see Arrays#toString(long[])
     */
    public static String toString(final long[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a long array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] array = {1L, 2L, 3L};
     * toString(array, 0, 2);   // returns "[1, 2]"
     * }</pre>
     *
     * @param a the long array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the long array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final long[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final long[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified float array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] array = {1.0f, 2.0f};
     * toString(array);   // returns "[1.0, 2.0]"
     * }</pre>
     *
     * @param a the float array to be represented as a string, may be {@code null}
     * @return the String representation of the float array
     * @see Arrays#toString(float[])
     */
    public static String toString(final float[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a float array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] array = {1.0f, 2.0f, 3.0f};
     * toString(array, 0, 2);   // returns "[1.0, 2.0]"
     * }</pre>
     *
     * @param a the float array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the float array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    static void toString(final StringBuilder sb, final float[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    static void toString(final StringBuilder sb, final float[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified double array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] array = {1.0, 2.0};
     * toString(array);   // returns "[1.0, 2.0]"
     * }</pre>
     *
     * @param a the double array to be represented as a string, may be {@code null}
     * @return the String representation of the double array
     * @see Arrays#toString(double[])
     */
    public static String toString(final double[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in a double array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] array = {1.0, 2.0, 3.0};
     * toString(array, 0, 2);   // returns "[1.0, 2.0]"
     * }</pre>
     *
     * @param a the double array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the double array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R);
    }

    /**
     * Appends the string representation of the double array to the provided StringBuilder.
     * If the array is {@code null}, appends "null". If empty, appends "[]".
     *
     * @param sb the StringBuilder to append to
     * @param a the double array to convert to string representation
     */
    static void toString(final StringBuilder sb, final double[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    /**
     * Appends the string representation of the specified range of the double array to the provided StringBuilder.
     * Elements are formatted as "[element1, element2, ...]".
     *
     * @param sb the StringBuilder to append to
     * @param a the double array to convert to string representation
     * @param fromIndex the starting index (inclusive) of the range to convert
     * @param toIndex the ending index (exclusive) of the range to convert
     */
    static void toString(final StringBuilder sb, final double[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(a[i]);
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the specified Object array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * toString(array);   // returns "[a, b]"
     * }</pre>
     *
     * @param a the Object array to be represented as a string, may be {@code null}
     * @return the String representation of the Object array
     * @see Arrays#toString(Object[])
     */
    public static String toString(final Object[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return toString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the specified range of elements in an Object array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b", "c"};
     * toString(array, 0, 2);   // returns "[a, b]"
     * }</pre>
     *
     * @param a the Object array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the Object array
     * @throws IndexOutOfBoundsException if the indices are out of range
     */
    public static String toString(final Object[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return Strings.join(a, fromIndex, toIndex, Strings.ELEMENT_SEPARATOR, WD.BRACKET_L, WD.BRACKET_R, false);
    }

    /**
     * Appends the string representation of the Object array to the provided StringBuilder.
     * If the array is {@code null}, appends "null". If empty, appends "[]".
     *
     * @param sb the StringBuilder to append to
     * @param a the Object array to convert to string representation
     */
    static void toString(final StringBuilder sb, final Object[] a) {
        if (a == null) {
            sb.append(Strings.NULL);
        } else if (a.length == 0) {
            sb.append(Strings.STR_FOR_EMPTY_ARRAY);
        } else {
            toString(sb, a, 0, a.length);
        }
    }

    /**
     * Appends the string representation of the specified range of the Object array to the provided StringBuilder.
     * Elements are formatted as "[element1, element2, ...]".
     *
     * @param sb the StringBuilder to append to
     * @param a the Object array to convert to string representation
     * @param fromIndex the starting index (inclusive) of the range to convert
     * @param toIndex the ending index (exclusive) of the range to convert
     */
    static void toString(final StringBuilder sb, final Object[] a, final int fromIndex, final int toIndex) {
        sb.append(WD._BRACKET_L);

        for (int i = fromIndex; i < toIndex; i++) {
            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            sb.append(toString(a[i]));
        }

        sb.append(WD._BRACKET_R);
    }

    /**
     * Returns a string representation of the "deep contents" of the specified object. If the object is an array, the appropriate {@code Arrays.toString(array)} method will be used.
     * This method recursively converts the object and its nested objects to a string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {1, 2};
     * deepToString(array);      // returns "[1, 2]"
     * deepToString("string");   // returns "string"
     * }</pre>
     *
     * @param obj the object to be represented as a string
     * @return the string representation of the object
     */
    public static String deepToString(final Object obj) {
        if (obj == null) {
            return Strings.NULL;
        }

        final Class<?> cls = obj.getClass();

        if (cls.isArray()) {
            final Integer enumInt = CLASS_TYPE_ENUM.get(cls);

            if (enumInt == null) {
                return deepToString((Object[]) obj);
            }

            switch (enumInt) {
                case 11:
                    return toString((boolean[]) obj);

                case 12:
                    return toString((char[]) obj);

                case 13:
                    return toString((byte[]) obj);

                case 14:
                    return toString((short[]) obj);

                case 15:
                    return toString((int[]) obj);

                case 16:
                    return toString((long[]) obj);

                case 17:
                    return toString((float[]) obj);

                case 18:
                    return toString((double[]) obj);

                case 19:
                    return toString((String[]) obj);

                default:
                    return deepToString((Object[]) obj);
            }
        }

        return obj.toString();
    }

    /**
     * Returns a string representation of the "deep contents" of the specified array. If the object is {@code null}, the specified default value is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"a", "b"};
     * deepToString(array);   // returns "[a, b]"
     * }</pre>
     *
     * @param a the object array to be represented as a string, may be {@code null}
     * @return the String representation of the object, or the default value if the object is null
     * @see Arrays#deepToString(Object[])
     */
    public static String deepToString(final Object[] a) {
        if (a == null) {
            return Strings.NULL;
        } else if (a.length == 0) {
            return Strings.STR_FOR_EMPTY_ARRAY;
        }

        return deepToString(a, 0, a.length);
    }

    /**
     * Returns a string representation of the "deep contents" of the specified range of elements in an Object array.
     * This method recursively converts the object and its nested objects to a string.
     *
     * @param a the Object array to be represented as a string
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return the String representation of the specified range of the Object array
     * @throws IndexOutOfBoundsException if the indices are out of range
     * @see Arrays#deepToString(Object[])
     */
    public static String deepToString(final Object[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final StringBuilder sb = Objectory.createStringBuilder(calculateBufferSize(toIndex - fromIndex, 32));
        final Set<Object> set = newSetFromMap(newIdentityHashMap(len(a)));

        try {
            deepToString(sb, a, fromIndex, toIndex, set);

            return sb.toString();
        } finally {
            Objectory.recycle(sb);
        }
    }

    static int calculateBufferSize(final int len, final int elementPlusDelimiterLen) {
        return len > Integer.MAX_VALUE / elementPlusDelimiterLen ? Integer.MAX_VALUE : len * elementPlusDelimiterLen;
    }

    /**
     * Appends the deep string representation of the Object array to the provided StringBuilder.
     * This method recursively converts nested arrays and objects to their string representations.
     * The processedElements set is used to detect and handle circular references.
     *
     * @param sb the StringBuilder to append to
     * @param a the Object array to convert to deep string representation
     * @param processedElements the set of already processed elements to detect circular references
     */
    static void deepToString(final StringBuilder sb, final Object[] a, final Set<Object> processedElements) {
        deepToString(sb, a, 0, a.length, processedElements);
    }

    /**
     * Appends the deep string representation of the specified range of the Object array to the provided StringBuilder.
     * This method recursively converts nested arrays and objects to their string representations.
     * The processedElements set is used to detect and handle circular references, which are represented as "[...]".
     *
     * @param sb the StringBuilder to append to
     * @param a the Object array to convert to deep string representation
     * @param fromIndex the starting index (inclusive) of the range to convert
     * @param toIndex the ending index (exclusive) of the range to convert
     * @param processedElements the set of already processed elements to detect circular references
     */
    static void deepToString(final StringBuilder sb, final Object[] a, final int fromIndex, final int toIndex, final Set<Object> processedElements) {
        processedElements.add(a);

        sb.append(WD._BRACKET_L);

        Object element = null;
        Class<?> eClass = null;
        for (int i = fromIndex; i < toIndex; i++) {
            element = a[i];

            if (i > fromIndex) {
                sb.append(Strings.ELEMENT_SEPARATOR);
            }

            if (element == null) {
                sb.append(Strings.NULL_CHAR_ARRAY);

                continue;
            }

            eClass = element.getClass();

            if (eClass.isArray()) {
                final Integer enumInt = CLASS_TYPE_ENUM.get(eClass);

                final int num = enumInt == null ? 0 : enumInt;

                switch (num) {
                    case 11:
                        toString(sb, (boolean[]) element);
                        break;

                    case 12:
                        toString(sb, (char[]) element);
                        break;

                    case 13:
                        toString(sb, (byte[]) element);
                        break;

                    case 14:
                        toString(sb, (short[]) element);
                        break;

                    case 15:
                        toString(sb, (int[]) element);
                        break;

                    case 16:
                        toString(sb, (long[]) element);
                        break;

                    case 17:
                        toString(sb, (float[]) element);
                        break;

                    case 18:
                        toString(sb, (double[]) element);
                        break;

                    case 19:
                        toString(sb, (String[]) element);
                        break;

                    default:
                        if (processedElements.contains(element)) {
                            sb.append("[...]");
                        } else {
                            deepToString(sb, (Object[]) element, processedElements);
                        }
                }
            } else { // element is non-null and not an array
                //noinspection UnnecessaryToStringCall
                sb.append(element.toString());
            }
        }

        sb.append(WD._BRACKET_R);

        processedElements.remove(a);
    }

    /**
     * Returns a string representation of the "deep contents" of the specified array. If the object is {@code null}, the specified default value is returned.
     *
     * @param a the Object array to be represented as a string
     * @param defaultIfNull the default value to be returned if the object is null
     * @return the String representation of the object, or the default value if the object is null
     * @see Arrays#deepToString(Object[])
     */
    public static String deepToString(final Object[] a, final String defaultIfNull) {
        return a == null ? defaultIfNull : deepToString(a);
    }

    // ================================ equals/hashCode/toString... ===================================================

    // ================================ length/size, isNull/Empty/Blank... ============================================

    /**
     * Returns the length of the specified {@code CharSequence}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len(null);    // returns 0
     * len("");      // returns 0
     * len("abc");   // returns 3
     * }</pre>
     *
     * @param s the CharSequence to check
     * @return the length of the CharSequence, or 0 if the CharSequence is null
     */
    public static int len(final CharSequence s) {
        return s == null ? 0 : s.length();
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((boolean[]) null);              // returns 0
     * len(new boolean[0]);                // returns 0
     * len(new boolean[] {true, false});   // returns 2
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final boolean[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((char[]) null);           // returns 0
     * len(new char[0]);             // returns 0
     * len(new char[] {'a', 'b'});   // returns 2
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final char[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((byte[]) null);          // returns 0
     * len(new byte[0]);            // returns 0
     * len(new byte[] {1, 2, 3});   // returns 3
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final byte[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((short[]) null);          // returns 0
     * len(new short[0]);            // returns 0
     * len(new short[] {1, 2, 3});   // returns 3
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final short[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((int[]) null);          // returns 0
     * len(new int[0]);            // returns 0
     * len(new int[] {1, 2, 3});   // returns 3
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final int[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((long[]) null);             // returns 0
     * len(new long[0]);               // returns 0
     * len(new long[] {1L, 2L, 3L});   // returns 3
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final long[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((float[]) null);             // returns 0
     * len(new float[0]);               // returns 0
     * len(new float[] {1.0f, 2.0f});   // returns 2
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final float[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((double[]) null);           // returns 0
     * len(new double[0]);             // returns 0
     * len(new double[] {1.0, 2.0});   // returns 2
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final double[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the length/size of the specified {@code Array/Collection/Map}, or {@code 0} if it's empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * len((Object[]) null);   // returns 0
     * len(new String[0]);     // returns 0
     * len(new String[3]);     // returns 3
     * }</pre>
     *
     * @param a the array to check
     * @return the length of the array, or 0 if the array is null
     */
    public static int len(final Object[] a) {
        return a == null ? 0 : a.length;
    }

    /**
     * Returns the size of the specified collection, or {@code 0} if the collection is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * size(null);                      // returns 0
     * size(Collections.emptyList());   // returns 0
     * size(Arrays.asList("a", "b"));   // returns 2
     * }</pre>
     *
     * @param c the collection to check, may be {@code null}
     * @return the collection size, or {@code 0} if the collection is {@code null}
     */
    public static int size(final Collection<?> c) {
        return c == null ? 0 : c.size();
    }

    /**
     * Returns the size of the specified map, or {@code 0} if the map is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * size(null);                                 // returns 0
     * size(Collections.emptyMap());               // returns 0
     * size(Collections.singletonMap("k", "v"));   // returns 1
     * }</pre>
     *
     * @param m the map to check, may be {@code null}
     * @return the map size, or {@code 0} if the map is {@code null}
     */
    public static int size(final Map<?, ?> m) {
        return m == null ? 0 : m.size();
    }

    /**
     * Returns the size of the specified {@code PrimitiveList}, or {@code 0} if it is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * size((PrimitiveList) null);   // returns 0
     * size(IntList.of(1, 2, 3));    // returns 3
     * }</pre>
     *
     * @param c the {@code PrimitiveList} to check, may be {@code null}
     * @return the {@code PrimitiveList} size, or {@code 0} if it is {@code null}
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static int size(final PrimitiveList c) {
        return c == null ? 0 : c.size();
    }

    /**
     * Checks if the specified {@code CharSequence} is {@code null} or empty.
     *
     * <p>A CharSequence is considered empty if it has zero length. This method provides
     * a null-safe way to check for empty strings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty(null);                  // returns true
     * isEmpty("");                    // returns true
     * isEmpty("   ");                 // returns {@code false} (contains spaces)
     * isEmpty("abc");                 // returns false
     * isEmpty(new StringBuilder());   // returns true
     * }</pre>
     *
     * @param cs the CharSequence to be checked, may be {@code null}
     * @return {@code true} if the CharSequence is {@code null} or has zero length, {@code false} otherwise
     * @see Strings#isEmpty(CharSequence)
     * @see #isBlank(CharSequence)
     */
    public static boolean isEmpty(final CharSequence cs) {
        return (cs == null) || (cs.isEmpty());
    }

    /**
     * Checks if the specified boolean array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((boolean[]) null);   // returns true
     * isEmpty(new boolean[0]);     // returns true
     * isEmpty(new boolean[1]);     // returns false
     * }</pre>
     *
     * @param a the boolean array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final boolean[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified char array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((char[]) null);   // returns true
     * isEmpty(new char[0]);     // returns true
     * isEmpty(new char[1]);     // returns false
     * }</pre>
     *
     * @param a the char array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final char[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified byte array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((byte[]) null);   // returns true
     * isEmpty(new byte[0]);     // returns true
     * isEmpty(new byte[1]);     // returns false
     * }</pre>
     *
     * @param a the byte array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final byte[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified short array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((short[]) null);   // returns true
     * isEmpty(new short[0]);     // returns true
     * isEmpty(new short[1]);     // returns false
     * }</pre>
     *
     * @param a the short array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final short[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified int array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((int[]) null);   // returns true
     * isEmpty(new int[0]);     // returns true
     * isEmpty(new int[1]);     // returns false
     * }</pre>
     *
     * @param a the int array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final int[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified long array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((long[]) null);   // returns true
     * isEmpty(new long[0]);     // returns true
     * isEmpty(new long[1]);     // returns false
     * }</pre>
     *
     * @param a the long array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final long[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified float array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((float[]) null);   // returns true
     * isEmpty(new float[0]);     // returns true
     * isEmpty(new float[1]);     // returns false
     * }</pre>
     *
     * @param a the float array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final float[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified double array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((double[]) null);   // returns true
     * isEmpty(new double[0]);     // returns true
     * isEmpty(new double[1]);     // returns false
     * }</pre>
     *
     * @param a the double array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final double[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified object array is {@code null} or empty.
     *
     * <p>An array is considered empty if it has zero length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Object[]) null);   // returns true
     * isEmpty(new Object[0]);     // returns true
     * isEmpty(new Object[1]);     // returns false
     * }</pre>
     *
     * @param a the object array to be checked, may be {@code null}
     * @return {@code true} if the array is {@code null} or has zero length, {@code false} otherwise
     */
    public static boolean isEmpty(final Object[] a) {
        return (a == null) || (a.length == 0);
    }

    /**
     * Checks if the specified {@code Collection} is {@code null} or empty.
     *
     * <p>A Collection is considered empty if it contains no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Collection) null);    // returns true
     * isEmpty(new ArrayList<>());    // returns true
     * isEmpty(Arrays.asList("a"));   // returns false
     * }</pre>
     *
     * @param c the Collection to be checked, may be {@code null}
     * @return {@code true} if the Collection is {@code null} or empty, {@code false} otherwise
     */
    public static boolean isEmpty(final Collection<?> c) {
        return (c == null) || (c.isEmpty());
    }

    /**
     * Checks if the specified {@code Iterable} is {@code null} or empty.
     *
     * <p>An Iterable is considered empty if it has no elements. For Collection instances,
     * this uses their {@code isEmpty()} method for efficiency. For other Iterables, this
     * checks if the iterator has any elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Iterable) null);      // returns true
     * isEmpty(Arrays.asList());      // returns true
     * isEmpty(Arrays.asList("a"));   // returns false
     * }</pre>
     *
     * @param c the Iterable to be checked, may be {@code null}
     * @return {@code true} if the Iterable is {@code null} or empty, {@code false} otherwise
     */
    @Beta
    public static boolean isEmpty(final Iterable<?> c) {
        if (c == null) {
            return true;
        }

        if (c instanceof Collection<?> coll) {
            return coll.isEmpty();
        } else {
            return isEmpty(c.iterator());
        }
    }

    /**
     * Checks if the specified iterable is a {@code null} or empty collection.
     *
     * @param c the iterable to check
     * @return {@code true} if the specified iterable is a {@code null} or empty collection, otherwise {@code false}
     */
    static boolean isEmptyCollection(final Iterable<?> c) {
        if (c == null) {
            return true;
        }

        if (c instanceof Collection) {
            return isEmpty((Collection<?>) c);
        }

        return false;
    }

    /**
     * Checks if the specified {@code Iterator} is {@code null} or empty.
     *
     * <p>An Iterator is considered empty if it has no more elements ({@code hasNext()} returns {@code false}).</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Iterator) null);                 // returns true
     * isEmpty(Collections.emptyIterator());     // returns true
     * isEmpty(Arrays.asList("a").iterator());   // returns false
     * }</pre>
     *
     * @param iter the Iterator to be checked, may be {@code null}
     * @return {@code true} if the Iterator is {@code null} or has no more elements, {@code false} otherwise
     */
    @Beta
    public static boolean isEmpty(final Iterator<?> iter) {
        return iter == null || (!iter.hasNext());
    }

    /**
     * Checks if the specified {@code Map} is {@code null} or empty.
     *
     * <p>A Map is considered empty if it contains no key-value mappings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Map) null);                           // returns true
     * isEmpty(Collections.emptyMap());               // returns true
     * isEmpty(Collections.singletonMap("k", "v"));   // returns false
     * }</pre>
     *
     * @param m the Map to be checked, may be {@code null}
     * @return {@code true} if the Map is {@code null} or empty, {@code false} otherwise
     */
    public static boolean isEmpty(final Map<?, ?> m) {
        return (m == null) || (m.isEmpty());
    }

    /**
     * Checks if the specified {@code PrimitiveList} is {@code null} or empty.
     *
     * <p>A PrimitiveList is considered empty if it contains no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((PrimitiveList) null);   // returns true
     * isEmpty(IntList.of());           // returns true
     * isEmpty(IntList.of(1));          // returns false
     * }</pre>
     *
     * @param list the PrimitiveList to be checked, may be {@code null}
     * @return {@code true} if the PrimitiveList is {@code null} or empty, {@code false} otherwise
     */
    @SuppressWarnings("rawtypes")
    public static boolean isEmpty(final PrimitiveList list) {
        return (list == null) || (list.isEmpty());
    }

    /**
     * Checks if the specified {@code Multiset} is {@code null} or empty.
     *
     * <p>A Multiset is considered empty if it contains no elements.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Multiset) null);   // returns true
     * Multiset<String> multiset = new Multiset<>();
     * isEmpty(multiset);   // returns true
     * multiset.add("a");
     * isEmpty(multiset);   // returns false
     * }</pre>
     *
     * @param s the Multiset to be checked, may be {@code null}
     * @return {@code true} if the Multiset is {@code null} or empty, {@code false} otherwise
     */
    public static boolean isEmpty(final Multiset<?> s) {
        return (s == null) || (s.isEmpty());
    }

    /**
     * Checks if the specified {@code Multimap} is {@code null} or empty.
     *
     * <p>A Multimap is considered empty if it contains no key-value mappings.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Multimap) null);   // returns true
     * Multimap<String, String> multimap = new ListMultimap<>();
     * isEmpty(multimap);   // returns true
     * multimap.put("k", "v");
     * isEmpty(multimap);   // returns false
     * }</pre>
     *
     * @param m the Multimap to be checked, may be {@code null}
     * @return {@code true} if the Multimap is {@code null} or empty, {@code false} otherwise
     */
    public static boolean isEmpty(final Multimap<?, ?, ?> m) {
        return (m == null) || (m.isEmpty());
    }

    /**
     * Checks if the specified {@code Dataset} is {@code null} or empty.
     *
     * <p>A Dataset is considered empty if it contains no rows.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isEmpty((Dataset) null);   // returns true
     * // Dataset ds = ...
     * // isEmpty(ds);
     * }</pre>
     *
     * @param ds the Dataset to be checked, may be {@code null}
     * @return {@code true} if the Dataset is {@code null} or empty, {@code false} otherwise
     */
    public static boolean isEmpty(final Dataset ds) {
        return (ds == null) || (ds.isEmpty());
    }

    /**
     * Checks if the specified {@code CharSequence} is {@code null}, empty, or contains only whitespace characters.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isBlank(null);    // returns true
     * isBlank("");      // returns true
     * isBlank("   ");   // returns true
     * isBlank("abc");   // returns false
     * }</pre>
     *
     * @param cs the CharSequence to check
     * @return {@code true} if the CharSequence is {@code null}, empty, or contains only whitespace characters, otherwise {@code false}
     * @see Strings#isBlank(CharSequence)
     */
    public static boolean isBlank(final CharSequence cs) {
        if (isEmpty(cs)) {
            return true;
        }

        for (int i = 0, len = cs.length(); i < len; i++) {
            if (!Character.isWhitespace(cs.charAt(i))) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if the specified {@code boolean} is {@code Boolean.TRUE}, not {@code null} or {@code Boolean.FALSE}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isTrue(Boolean.TRUE);    // returns true
     * isTrue(Boolean.FALSE);   // returns false
     * isTrue(null);            // returns false
     * }</pre>
     *
     * @param bool the Boolean to check
     * @return {@code true} if the Boolean is {@code Boolean.TRUE}, {@code false} otherwise
     * @see #isFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #negate(Boolean)
     */
    @Beta
    public static boolean isTrue(final Boolean bool) {
        return Boolean.TRUE.equals(bool);
    }

    /**
     * Returns {@code true} if the specified {@code boolean} is {@code null} or {@code Boolean.FALSE}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isNotTrue(Boolean.FALSE);   // returns true
     * isNotTrue(null);            // returns true
     * isNotTrue(Boolean.TRUE);    // returns false
     * }</pre>
     *
     * @param bool the Boolean to check
     * @return {@code true} if the Boolean is {@code null} or {@code Boolean.FALSE}, {@code false} otherwise
     * @see #isNotFalse(Boolean)
     * @see #isTrue(Boolean)
     * @see #isFalse(Boolean)
     * @see #negate(Boolean)
     */
    @Beta
    public static boolean isNotTrue(final Boolean bool) {
        return bool == null || !bool;
    }

    /**
     * Returns {@code true} if the specified {@code boolean} is {@code Boolean.FALSE}, not {@code null} or {@code Boolean.TRUE}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isFalse(Boolean.FALSE);   // returns true
     * isFalse(Boolean.TRUE);    // returns false
     * isFalse(null);            // returns false
     * }</pre>
     *
     * @param bool the Boolean to check
     * @return {@code true} if the Boolean is {@code Boolean.FALSE}, {@code false} otherwise
     * @see #isNotFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #negate(Boolean)
     */
    @Beta
    public static boolean isFalse(final Boolean bool) {
        return Boolean.FALSE.equals(bool);
    }

    /**
     * Returns {@code true} if the specified {@code boolean} is {@code null} or {@code Boolean.TRUE}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * isNotFalse(Boolean.TRUE);    // returns true
     * isNotFalse(null);            // returns true
     * isNotFalse(Boolean.FALSE);   // returns false
     * }</pre>
     *
     * @param bool the Boolean to check
     * @return {@code true} if the Boolean is {@code null} or {@code Boolean.TRUE}, {@code false} otherwise
     * @see #isFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #negate(Boolean)
     */
    @Beta
    public static boolean isNotFalse(final Boolean bool) {
        return bool == null || bool;
    }

    /**
     * Checks if the specified {@code CharSequence} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty("abc");   // returns true
     * notEmpty("");      // returns false
     * notEmpty(null);    // returns false
     * }</pre>
     *
     * @param cs the CharSequence to check
     * @return {@code true} if the CharSequence is not {@code null} and not empty, otherwise {@code false}
     * @see Strings#isNotEmpty(CharSequence)
     */
    public static boolean notEmpty(final CharSequence cs) {
        return (cs != null) && (!cs.isEmpty());
    }

    /**
     * Checks if the specified boolean array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new boolean[] {true});   // returns true
     * notEmpty(new boolean[0]);         // returns false
     * notEmpty(null);                   // returns false
     * }</pre>
     *
     * @param a the boolean array to check
     * @return {@code true} if the boolean array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final boolean[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified char array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new char[] {'a'});   // returns true
     * notEmpty(new char[0]);        // returns false
     * notEmpty(null);               // returns false
     * }</pre>
     *
     * @param a the char array to check
     * @return {@code true} if the char array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final char[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified byte array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new byte[] {1});   // returns true
     * notEmpty(new byte[0]);      // returns false
     * notEmpty(null);             // returns false
     * }</pre>
     *
     * @param a the byte array to check
     * @return {@code true} if the byte array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final byte[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified short array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new short[] {1});   // returns true
     * notEmpty(new short[0]);      // returns false
     * notEmpty(null);              // returns false
     * }</pre>
     *
     * @param a the short array to check
     * @return {@code true} if the short array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final short[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified int array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new int[] {1});   // returns true
     * notEmpty(new int[0]);      // returns false
     * notEmpty(null);            // returns false
     * }</pre>
     *
     * @param a the int array to check
     * @return {@code true} if the int array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final int[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified long array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new long[] {1L});   // returns true
     * notEmpty(new long[0]);       // returns false
     * notEmpty(null);              // returns false
     * }</pre>
     *
     * @param a the long array to check
     * @return {@code true} if the long array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final long[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified float array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new float[] {1.0f});   // returns true
     * notEmpty(new float[0]);         // returns false
     * notEmpty(null);                 // returns false
     * }</pre>
     *
     * @param a the float array to check
     * @return {@code true} if the float array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final float[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified double array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new double[] {1.0});   // returns true
     * notEmpty(new double[0]);        // returns false
     * notEmpty(null);                 // returns false
     * }</pre>
     *
     * @param a the double array to check
     * @return {@code true} if the double array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final double[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified object array is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(new Object[] {1});   // returns true
     * notEmpty(new Object[0]);      // returns false
     * notEmpty(null);               // returns false
     * }</pre>
     *
     * @param a the object array to check
     * @return {@code true} if the object array is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Object[] a) {
        return (a != null) && (a.length > 0);
    }

    /**
     * Checks if the specified {@code Collection} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(Arrays.asList("a"));   // returns true
     * notEmpty(new ArrayList<>());    // returns false
     * notEmpty(null);                 // returns false
     * }</pre>
     *
     * @param c the Collection to check
     * @return {@code true} if the Collection is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Collection<?> c) {
        return (c != null) && (c.size() > 0);
    }

    /**
     * Checks if the specified iterable is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(Arrays.asList("a"));   // returns true
     * notEmpty(Arrays.asList());      // returns false
     * notEmpty(null);                 // returns false
     * }</pre>
     *
     * @param iter the Iterable to check
     * @return {@code true} if the Iterable is not {@code null} and not empty, otherwise {@code false}
     */
    @Beta
    public static boolean notEmpty(final Iterable<?> iter) {
        if (iter == null) {
            return false;
        }

        if (iter instanceof Collection) {
            return notEmpty((Collection<?>) iter);
        } else {
            return notEmpty(iter.iterator());
        }
    }

    /**
     * Checks if the specified iterator is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(Arrays.asList("a").iterator());   // returns true
     * notEmpty(Collections.emptyIterator());     // returns false
     * notEmpty(null);                            // returns false
     * }</pre>
     *
     * @param iter the Iterator to check
     * @return {@code true} if the Iterator is not {@code null} and not empty, otherwise {@code false}
     */
    @Beta
    public static boolean notEmpty(final Iterator<?> iter) {
        return (iter != null) && (iter.hasNext());
    }

    /**
     * Checks if the specified {@code Map} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(Collections.singletonMap("k", "v"));   // returns true
     * notEmpty(Collections.emptyMap());               // returns false
     * notEmpty(null);                                 // returns false
     * }</pre>
     *
     * @param m the Map to check
     * @return {@code true} if the Map is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Map<?, ?> m) {
        return (m != null) && (!m.isEmpty());
    }

    /**
     * Checks if the specified {@code PrimitiveList} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notEmpty(IntList.of(1));          // returns true
     * notEmpty(IntList.of());           // returns false
     * notEmpty((PrimitiveList) null);   // returns false
     * }</pre>
     *
     * @param list the PrimitiveList to check
     * @return {@code true} if the PrimitiveList is not {@code null} and not empty, otherwise {@code false}
     */
    @SuppressWarnings("rawtypes")
    public static boolean notEmpty(final PrimitiveList list) {
        return (list != null) && (!list.isEmpty());
    }

    /**
     * Checks if the specified {@code Multiset} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Multiset<String> multiset = new Multiset<>();
     * multiset.add("a");
     * notEmpty(multiset);           // returns true
     * notEmpty(new Multiset<>());   // returns false
     * notEmpty((Multiset) null);    // returns false
     * }</pre>
     *
     * @param s the Multiset to check
     * @return {@code true} if the Multiset is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Multiset<?> s) {
        return (s != null) && (s.size() > 0);
    }

    /**
     * Checks if the specified {@code Multimap} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Multimap<String, String> multimap = new ListMultimap<>();
     * multimap.put("k", "v");
     * notEmpty(multimap);               // returns true
     * notEmpty(new ListMultimap<>());   // returns false
     * notEmpty((Multimap) null);        // returns false
     * }</pre>
     *
     * @param m the Multimap to check
     * @return {@code true} if the Multimap is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Multimap<?, ?, ?> m) {
        return (m != null) && (!m.isEmpty());
    }

    /**
     * Checks if the specified {@code Dataset} is not {@code null} and not empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Dataset ds = ...
     * // notEmpty(ds);
     * notEmpty((Dataset) null);   // returns false
     * }</pre>
     *
     * @param dataset the Dataset to check
     * @return {@code true} if the Dataset is not {@code null} and not empty, otherwise {@code false}
     */
    public static boolean notEmpty(final Dataset dataset) {
        return (dataset != null) && (!dataset.isEmpty());
    }

    /**
     * Checks if the specified {@code CharSequence} is not {@code null}, not empty, and does not contain only whitespace characters.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * notBlank("abc");   // returns true
     * notBlank("");      // returns false
     * notBlank("   ");   // returns false
     * notBlank(null);    // returns false
     * }</pre>
     *
     * @param cs the CharSequence to check
     * @return {@code true} if the CharSequence is not {@code null}, not empty, and does not contain only whitespace characters, otherwise {@code false}
     * @see Strings#isNotBlank(CharSequence)
     */
    public static boolean notBlank(final CharSequence cs) {
        return !isBlank(cs);
    }

    /**
     * Checks if it's not {@code null} or default. {@code null} is default value for all reference types, {@code false} is default value for primitive boolean, {@code 0} is the default value for primitive number type.
     *
     * @param value the value to check
     * @return {@code true}, if it's not {@code null} or default
     * @deprecated DO NOT call the methods defined in this class. it's for internal use only.
     */
    @Deprecated
    static boolean notNullOrDefault(final Object value) {
        return (value != null) && !equals(value, defaultValueOf(value.getClass()));
    }

    /**
     * Checks if any of the specified objects is {@code null}.
     *
     * @param a the first object to check
     * @param b the second object to check
     * @return {@code true} if any of the objects is {@code null}, otherwise {@code false}
     */
    public static boolean anyNull(final Object a, final Object b) {
        return a == null || b == null;
    }

    /**
     * Checks if any of the specified objects is {@code null}.
     *
     * @param a the first object to check
     * @param b the second object to check
     * @param c the third object to check
     * @return {@code true} if any of the objects is {@code null}, otherwise {@code false}
     */
    public static boolean anyNull(final Object a, final Object b, final Object c) {
        return a == null || b == null || c == null;
    }

    /**
     * Checks if any element in the specified array is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyNull("a", null);         // returns true
     * anyNull("a", "b");          // returns false
     * anyNull((Object[]) null);   // returns false (empty array check)
     * }</pre>
     *
     * @param a the array of objects to check
     * @return {@code true} if any element in the specified array is {@code null}, otherwise {@code false}
     */
    public static boolean anyNull(final Object... a) {
        if (isEmpty(a)) {
            return false;
        }

        for (final Object e : a) {
            if (e == null) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any element in the specified collection is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyNull(Arrays.asList("a", null));   // returns true
     * anyNull(Arrays.asList("a", "b"));    // returns false
     * anyNull(Collections.emptyList());    // returns false
     * }</pre>
     *
     * @param c the collection of objects to check
     * @return {@code true} if any element in the specified collection is {@code null}, otherwise {@code false}
     */
    public static boolean anyNull(final Iterable<?> c) {
        if (isEmpty(c)) {
            return false;
        }

        for (final Object e : c) {
            if (e == null) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the specified CharSequences is empty ("") or {@code null}.
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return {@code true} if any of the CharSequences is empty, otherwise {@code false}
     * @see Strings#isAnyEmpty(CharSequence, CharSequence)
     */
    public static boolean anyEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) || isEmpty(b);
    }

    /**
     * Checks if any of the specified CharSequences is empty ("") or {@code null}.
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return {@code true} if any of the CharSequences is empty, otherwise {@code false}
     * @see Strings#isAnyEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static boolean anyEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) || isEmpty(b) || isEmpty(c);
    }

    /**
     * <p>Checks if any of the CharSequences is empty ("") or {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty((String) null)       = true
     * anyEmpty((String[]) null)     = false
     * anyEmpty(null, "foo")         = true
     * anyEmpty("", "bar")           = true
     * anyEmpty("bob", "")           = true
     * anyEmpty("  bob  ", null)     = true
     * anyEmpty(" ", "bar")          = false
     * anyEmpty("foo", "bar")        = false
     * anyEmpty(new String[] {})     = false
     * anyEmpty(new String[] {""})   = true
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or null
     * @see Strings#isAnyEmpty(CharSequence...)
     */
    public static boolean anyEmpty(final CharSequence... css) {
        return Strings.isAnyEmpty(css);
    }

    /**
     * Checks if any of the specified CharSequence objects in the collection is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(Arrays.asList("a", ""));    // returns true
     * anyEmpty(Arrays.asList("a", "b"));   // returns false
     * anyEmpty(Collections.emptyList());   // returns false
     * }</pre>
     *
     * @param css the collection of CharSequence objects to check
     * @return {@code true} if any of the CharSequence objects is empty, otherwise {@code false}
     * @see Strings#isAnyEmpty(Iterable)
     */
    public static boolean anyEmpty(final Iterable<? extends CharSequence> css) {
        return Strings.isAnyEmpty(css);
    }

    /**
     * Checks if any of the specified arrays is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new Object[0], new Object[]{1});     // returns true
     * anyEmpty(new Object[]{1}, new Object[]{2});   // returns false
     * }</pre>
     *
     * @param a the first array to check
     * @param b the second array to check
     * @return {@code true} if any of the arrays is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Object[] a, final Object[] b) {
        return a == null || a.length == 0 || b == null || b.length == 0;
    }

    /**
     * Checks if any of the specified arrays is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new Object[0], new Object[]{1}, new Object[]{2});     // returns true
     * anyEmpty(new Object[]{1}, new Object[]{2}, new Object[]{3});   // returns false
     * }</pre>
     *
     * @param a the first array to check
     * @param b the second array to check
     * @param c the third array to check
     * @return {@code true} if any of the arrays is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Object[] a, final Object[] b, final Object[] c) {
        return a == null || a.length == 0 || b == null || b.length == 0 || c == null || c.length == 0;
    }

    /**
     * Checks if any of the specified collections is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new ArrayList<>(), Arrays.asList("a"));    // returns true
     * anyEmpty(Arrays.asList("a"), Arrays.asList("b"));   // returns false
     * }</pre>
     *
     * @param a the first collection to check
     * @param b the second collection to check
     * @return {@code true} if any of the collections is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Collection<?> a, final Collection<?> b) {
        return a == null || a.size() == 0 || b == null || b.size() == 0;
    }

    /**
     * Checks if any of the specified collections is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new ArrayList<>(), Arrays.asList("a"), Arrays.asList("b"));    // returns true
     * anyEmpty(Arrays.asList("a"), Arrays.asList("b"), Arrays.asList("c"));   // returns false
     * }</pre>
     *
     * @param a the first collection to check
     * @param b the second collection to check
     * @param c the third collection to check
     * @return {@code true} if any of the collections is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Collection<?> a, final Collection<?> b, final Collection<?> c) {
        return a == null || a.size() == 0 || b == null || b.size() == 0 || c == null || c.size() == 0;
    }

    /**
     * Checks if any of the specified maps is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new HashMap<>(), Collections.singletonMap("k", "v"));                          // returns true
     * anyEmpty(Collections.singletonMap("k1", "v1"), Collections.singletonMap("k2", "v2"));   // returns false
     * }</pre>
     *
     * @param a the first map to check
     * @param b the second map to check
     * @return {@code true} if any of the maps is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Map<?, ?> a, final Map<?, ?> b) {
        return a == null || a.isEmpty() || b == null || b.isEmpty();
    }

    /**
     * Checks if any of the specified maps is empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyEmpty(new HashMap<>(), Collections.singletonMap("k", "v"), Collections.singletonMap("k2", "v2"));                          // returns true
     * anyEmpty(Collections.singletonMap("k1", "v1"), Collections.singletonMap("k2", "v2"), Collections.singletonMap("k3", "v3"));   // returns false
     * }</pre>
     *
     * @param a the first map to check
     * @param b the second map to check
     * @param c the third map to check
     * @return {@code true} if any of the maps is empty, otherwise {@code false}
     */
    public static boolean anyEmpty(final Map<?, ?> a, final Map<?, ?> b, final Map<?, ?> c) {
        return a == null || a.isEmpty() || b == null || b.isEmpty() || c == null || c.isEmpty();
    }

    /**
     * Checks if any of the specified CharSequences is blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyBlank(" ", "abc");     // returns true
     * anyBlank("abc", "def");   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return {@code true} if any of the CharSequences is blank, otherwise {@code false}
     * @see Strings#isAnyBlank(CharSequence, CharSequence)
     */
    public static boolean anyBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) || isBlank(b);
    }

    /**
     * Checks if any of the specified CharSequences is blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyBlank(" ", "abc", "def");     // returns true
     * anyBlank("abc", "def", "ghi");   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return {@code true} if any of the CharSequences is blank, otherwise {@code false}
     * @see Strings#isAnyBlank(CharSequence, CharSequence, CharSequence)
     */
    public static boolean anyBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) || isBlank(b) || isBlank(c);
    }

    /**
     * <p>Checks if any of the CharSequences are empty ("") or {@code null} or whitespace only.</p>
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyBlank((String) null)       = true
     * anyBlank((String[]) null)     = false
     * anyBlank(null, "foo")         = true
     * anyBlank(null, null)          = true
     * anyBlank("", "bar")           = true
     * anyBlank("bob", "")           = true
     * anyBlank("  bob  ", null)     = true
     * anyBlank(" ", "bar")          = true
     * anyBlank(new String[] {})     = false
     * anyBlank(new String[] {""})   = true
     * anyBlank("foo", "bar")        = false
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if any of the CharSequences are empty or {@code null} or whitespace only
     * @see Strings#isAnyBlank(CharSequence...)
     */
    public static boolean anyBlank(final CharSequence... css) {
        if (isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if any of the specified CharSequences in the collection is blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * anyBlank(Arrays.asList(" ", "abc"));     // returns true
     * anyBlank(Arrays.asList("abc", "def"));   // returns false
     * anyBlank(Collections.emptyList());       // returns false
     * }</pre>
     *
     * @param css the collection of CharSequences to check
     * @return {@code true} if any of the CharSequences is blank, otherwise {@code false}
     * @see Strings#isAnyBlank(Iterable)
     */
    public static boolean anyBlank(final Iterable<? extends CharSequence> css) {
        if (isEmpty(css)) {
            return false;
        }

        for (final CharSequence cs : css) {
            if (isBlank(cs)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if both specified objects are {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allNull(null, null);   // returns true
     * allNull("a", null);    // returns false
     * }</pre>
     *
     * @param a the first object to check
     * @param b the second object to check
     * @return {@code true} if both objects are {@code null}, otherwise {@code false}
     */
    public static boolean allNull(final Object a, final Object b) {
        return a == null && b == null;
    }

    /**
     * Checks if all specified objects are {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allNull(null, null, null);   // returns true
     * allNull("a", null, null);    // returns false
     * }</pre>
     *
     * @param a the first object to check
     * @param b the second object to check
     * @param c the third object to check
     * @return {@code true} if all objects are {@code null}, otherwise {@code false}
     */
    public static boolean allNull(final Object a, final Object b, final Object c) {
        return a == null && b == null && c == null;
    }

    /**
     * Checks if all specified objects are {@code null}.
     * <p><strong>Note:</strong> Returns {@code true} if the array itself is {@code null} or empty,
     * following the principle of <i>vacuous truth</i> (all elements of an empty set satisfy any predicate).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allNull(null, null);        // returns true
     * allNull("a", null);         // returns false
     * allNull((Object[]) null);   // returns true
     * }</pre>
     *
     * @param a the objects to check, may be {@code null}
     * @return {@code true} if all objects are {@code null}, or if the array is {@code null} or empty; {@code false} otherwise
     */
    public static boolean allNull(final Object... a) {
        if (isEmpty(a)) {
            return true;
        }

        for (final Object e : a) {
            if (e != null) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all elements in the specified collection are {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allNull(Arrays.asList(null, null));   // returns true
     * allNull(Arrays.asList("a", null));    // returns false
     * allNull(Collections.emptyList());     // returns true
     * }</pre>
     *
     * @param c the collection of objects to check
     * @return {@code true} if all elements in the specified collection are {@code null}, otherwise {@code false}
     */
    public static boolean allNull(final Iterable<?> c) {
        if (isEmpty(c)) {
            return true;
        }

        for (final Object e : c) {
            if (e != null) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if both specified CharSequences are empty ("") or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty("", null);   // returns true
     * allEmpty("a", "");    // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return {@code true} if both CharSequences are empty, otherwise {@code false}
     * @see Strings#isAllEmpty(CharSequence, CharSequence)
     */
    public static boolean allEmpty(final CharSequence a, final CharSequence b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all the specified CharSequences are empty ("") or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty("", null, "");    // returns true
     * allEmpty("a", "", null);   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return {@code true} if all the CharSequences are empty, otherwise {@code false}
     * @see Strings#isAllEmpty(CharSequence, CharSequence, CharSequence)
     */
    public static boolean allEmpty(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * <p>Checks if all the CharSequences are empty ("") or {@code null}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(null)              = true
     * allEmpty(null, "")          = true
     * allEmpty(new String[] {})   = true
     * allEmpty(null, "foo")       = false
     * allEmpty("", "bar")         = false
     * allEmpty("bob", "")         = false
     * allEmpty("  bob  ", null)   = false
     * allEmpty(" ", "bar")        = false
     * allEmpty("foo", "bar")      = false
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or null
     * @see Strings#isAllEmpty(CharSequence...)
     */
    public static boolean allEmpty(final CharSequence... css) {
        if (isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (notEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all specified CharSequences in the collection are empty or {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(Arrays.asList("", null));   // returns true
     * allEmpty(Arrays.asList("a", ""));    // returns false
     * allEmpty(Collections.emptyList());   // returns true
     * }</pre>
     *
     * @param css the collection of CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all CharSequences in the collection are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Iterable<? extends CharSequence> css) {
        if (isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (notEmpty(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all specified object arrays are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(new Object[0], new Object[0]);     // returns true
     * allEmpty(new Object[]{1}, new Object[0]);   // returns false
     * }</pre>
     *
     * @param a the first object array to check, which may be null
     * @param b the second object array to check, which may be null
     * @return {@code true} if both object arrays are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Object[] a, final Object[] b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all specified object arrays are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(new Object[0], new Object[0], new Object[0]);     // returns true
     * allEmpty(new Object[]{1}, new Object[0], new Object[0]);   // returns false
     * }</pre>
     *
     * @param a the first object array to check, which may be null
     * @param b the second object array to check, which may be null
     * @param c the third object array to check, which may be null
     * @return {@code true} if all object arrays are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Object[] a, final Object[] b, final Object[] c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * Checks if all specified collections are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(Collections.emptyList(), new HashSet<>());      // returns true
     * allEmpty(Arrays.asList("a"), Collections.emptyList());   // returns false
     * }</pre>
     *
     * @param a the first collection to check, which may be null
     * @param b the second collection to check, which may be null
     * @return {@code true} if both collections are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Collection<?> a, final Collection<?> b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all specified collections are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(Collections.emptyList(), new HashSet<>(), new ArrayList<>());            // returns true
     * allEmpty(Arrays.asList("a"), Collections.emptyList(), Collections.emptyList());   // returns false
     * }</pre>
     *
     * @param a the first collection to check, which may be null
     * @param b the second collection to check, which may be null
     * @param c the third collection to check, which may be null
     * @return {@code true} if all collections are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Collection<?> a, final Collection<?> b, final Collection<?> c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * Checks if all specified maps are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(Collections.emptyMap(), new HashMap<>());                      // returns true
     * allEmpty(Collections.singletonMap("k", "v"), Collections.emptyMap());   // returns false
     * }</pre>
     *
     * @param a the first map to check, which may be null
     * @param b the second map to check, which may be null
     * @return {@code true} if both maps are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Map<?, ?> a, final Map<?, ?> b) {
        return isEmpty(a) && isEmpty(b);
    }

    /**
     * Checks if all specified maps are empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allEmpty(Collections.emptyMap(), new HashMap<>(), new TreeMap<>());                             // returns true
     * allEmpty(Collections.singletonMap("k", "v"), Collections.emptyMap(), Collections.emptyMap());   // returns false
     * }</pre>
     *
     * @param a the first map to check, which may be null
     * @param b the second map to check, which may be null
     * @param c the third map to check, which may be null
     * @return {@code true} if all maps are empty or {@code null}, otherwise {@code false}
     */
    public static boolean allEmpty(final Map<?, ?> a, final Map<?, ?> b, final Map<?, ?> c) {
        return isEmpty(a) && isEmpty(b) && isEmpty(c);
    }

    /**
     * Checks if both specified CharSequences are blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allBlank("  ", null);   // returns true
     * allBlank("a", "  ");    // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return {@code true} if both CharSequences are blank, otherwise {@code false}
     * @see Strings#isAllBlank(CharSequence, CharSequence)
     */
    public static boolean allBlank(final CharSequence a, final CharSequence b) {
        return isBlank(a) && isBlank(b);
    }

    /**
     * Checks if all the specified CharSequences are blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allBlank("  ", null, "");    // returns true
     * allBlank("a", "  ", null);   // returns false
     * }</pre>
     *
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return {@code true} if all the CharSequences are blank, otherwise {@code false}
     * @see Strings#isAllBlank(CharSequence, CharSequence, CharSequence)
     */
    public static boolean allBlank(final CharSequence a, final CharSequence b, final CharSequence c) {
        return isBlank(a) && isBlank(b) && isBlank(c);
    }

    /**
     * <p>Checks if all the CharSequences are empty (""), {@code null} or whitespace only.</p>
     *
     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allBlank(null)              = true
     * allBlank(null, "foo")       = false
     * allBlank(null, null)        = true
     * allBlank("", "bar")         = false
     * allBlank("bob", "")         = false
     * allBlank("  bob  ", null)   = false
     * allBlank(" ", "bar")        = false
     * allBlank("foo", "bar")      = false
     * allBlank(new String[] {})   = true
     * }</pre>
     *
     * @param css the CharSequences to check, may be {@code null} or empty
     * @return {@code true} if all the CharSequences are empty or {@code null} or whitespace only
     * @see Strings#isAllBlank(CharSequence...)
     */
    public static boolean allBlank(final CharSequence... css) {
        if (isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (notBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if all specified CharSequences in the collection are blank.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * allBlank(Arrays.asList("  ", null));   // returns true
     * allBlank(Arrays.asList("a", "  "));    // returns false
     * allBlank(Collections.emptyList());     // returns true
     * }</pre>
     *
     * @param css the collection of CharSequences to check
     * @return {@code true} if all CharSequences in the collection are blank, otherwise {@code false}
     * @see Strings#isAllBlank(Iterable)
     */
    public static boolean allBlank(final Iterable<? extends CharSequence> css) {
        if (isEmpty(css)) {
            return true;
        }

        for (final CharSequence cs : css) {
            if (notBlank(cs)) {
                return false;
            }
        }

        return true;
    }

    // ================================ length/size, isNull/Empty/Blank... ============================================

    // ================================ nullToEmpty, defaultIfNull/Empty/Blank... =====================================

    /**
     * Converts a {@code null} string to an empty string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty(null);    // returns ""
     * nullToEmpty("abc");   // returns "abc"
     * }</pre>
     *
     * @param str the string to check
     * @return the original string if it is not {@code null}, otherwise an empty string
     * @see Strings#nullToEmpty(String)
     * @see Strings#blankToEmpty(String)
     */
    @Beta
    public static String nullToEmpty(final String str) {
        return str == null ? Strings.EMPTY : str;
    }

    /**
     * Returns an immutable empty list if the specified list is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((List) null);         // returns immutable empty list
     * nullToEmpty(new ArrayList<>());   // returns the original list
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the list to check
     * @return an empty list if the specified list is {@code null}, otherwise the original list
     * @see #emptyList()
     */
    public static <T> List<T> nullToEmpty(final List<T> list) {
        return list == null ? emptyList() : list;
    }

    /**
     * Returns an immutable empty set if the specified Set is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Set) null);        // returns immutable empty set
     * nullToEmpty(new HashSet<>());   // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the set to check
     * @return an empty set if the specified set is {@code null}, otherwise the original set
     * @see #emptySet()
     */
    public static <T> Set<T> nullToEmpty(final Set<T> set) {
        return set == null ? emptySet() : set;
    }

    /**
     * Returns an immutable empty {@code SortedSet} if the specified SortedSet is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((SortedSet) null);   // returns immutable empty sorted set
     * nullToEmpty(new TreeSet<>());    // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the set to check
     * @return an empty {@code SortedSet} if the specified set is {@code null}, otherwise the original set
     * @see #emptySortedSet()
     */
    public static <T> SortedSet<T> nullToEmpty(final SortedSet<T> set) {
        return set == null ? emptySortedSet() : set;
    }

    /**
     * Returns an immutable empty {@code NavigableSet} if the specified NavigableSet is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((NavigableSet) null);   // returns immutable empty navigable set
     * nullToEmpty(new TreeSet<>());       // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the set to check
     * @return an empty {@code NavigableSet} if the specified set is {@code null}, otherwise the original set
     * @see #emptyNavigableSet()
     */
    public static <T> NavigableSet<T> nullToEmpty(final NavigableSet<T> set) {
        return set == null ? emptyNavigableSet() : set;
    }

    /**
     * Returns an immutable empty {@code List} if the specified list is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Collection) null);   // returns immutable empty list
     * nullToEmpty(new ArrayList<>());   // returns the original list
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param c the collection to check
     * @return an empty {@code List} if the specified list is {@code null}, otherwise the original list
     * @see #emptyList()
     */
    public static <T> Collection<T> nullToEmpty(final Collection<T> c) {
        return c == null ? emptyList() : c;
    }

    /**
     * Returns an immutable empty map if the specified Map is {@code null}, otherwise itself is returned.
     * This method can be also used to get keySet, values, entrySet, etc. from a map
     * <p>{@code nullToEmpty(map).keySet()}</p>
     * <p>{@code nullToEmpty(map).values()}</p>
     * <p>{@code nullToEmpty(map).entrySet()}</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Map) null);        // returns immutable empty map
     * nullToEmpty(new HashMap<>());   // returns the original map
     * }</pre>
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map the map to check
     * @return an empty map if the specified map is {@code null}, otherwise the original map
     * @see #emptyMap()
     */
    public static <K, V> Map<K, V> nullToEmpty(final Map<K, V> map) {
        return map == null ? emptyMap() : map;
    }

    /**
     * Returns an immutable empty {@code SortedMap} if the specified SortedMap is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((SortedMap) null);   // returns immutable empty sorted map
     * nullToEmpty(new TreeMap<>());    // returns the original map
     * }</pre>
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map the SortedMap to check
     * @return an empty {@code SortedMap} if the specified SortedMap is {@code null}, otherwise the original SortedMap
     * @see #emptySortedMap()
     */
    public static <K, V> SortedMap<K, V> nullToEmpty(final SortedMap<K, V> map) {
        return map == null ? emptySortedMap() : map;
    }

    /**
     * Returns an immutable empty {@code NavigableMap} if the specified NavigableMap is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((NavigableMap) null);   // returns immutable empty navigable map
     * nullToEmpty(new TreeMap<>());       // returns the original map
     * }</pre>
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map the NavigableMap to check
     * @return an empty {@code NavigableMap} if the specified NavigableMap is {@code null}, otherwise the original NavigableMap
     * @see #emptyNavigableMap()
     */
    public static <K, V> NavigableMap<K, V> nullToEmpty(final NavigableMap<K, V> map) {
        return map == null ? emptyNavigableMap() : map;
    }

    /**
     * Returns an immutable empty iterator if the specified Iterator is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Iterator) null);                      // returns immutable empty iterator
     * nullToEmpty(Arrays.asList("a", "b").iterator());   // returns the original iterator
     * }</pre>
     *
     * @param <T> the type of elements returned by this iterator
     * @param iter the iterator to check
     * @return an empty iterator if the specified Iterator is {@code null}, otherwise the original Iterator
     * @see #emptyIterator()
     */
    public static <T> Iterator<T> nullToEmpty(final Iterator<T> iter) {
        return iter == null ? emptyIterator() : iter;
    }

    /**
     * Returns an immutable empty {@code ListIterator} if the specified ListIterator is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ListIterator) null);                      // returns immutable empty list iterator
     * nullToEmpty(Arrays.asList("a", "b").listIterator());   // returns the original list iterator
     * }</pre>
     *
     * @param <T> the type of elements returned by this list iterator
     * @param iter the list iterator to check
     * @return an empty {@code ListIterator} if the specified ListIterator is {@code null}, otherwise the original ListIterator
     * @see #emptyListIterator()
     */
    public static <T> ListIterator<T> nullToEmpty(final ListIterator<T> iter) {
        return iter == null ? emptyListIterator() : iter;
    }

    /**
     * Returns an empty boolean array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((boolean[]) null);       // returns empty boolean array
     * nullToEmpty(new boolean[] {true});   // returns the original array
     * }</pre>
     *
     * @param a the boolean array to check
     * @return an empty boolean array if the specified array is {@code null}, otherwise the original array
     */
    public static boolean[] nullToEmpty(final boolean[] a) {
        return a == null ? EMPTY_BOOLEAN_ARRAY : a;
    }

    /**
     * Returns an empty char array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((char[]) null);      // returns empty char array
     * nullToEmpty(new char[] {'a'});   // returns the original array
     * }</pre>
     *
     * @param a the char array to check
     * @return an empty char array if the specified array is {@code null}, otherwise the original array
     */
    public static char[] nullToEmpty(final char[] a) {
        return a == null ? EMPTY_CHAR_ARRAY : a;
    }

    /**
     * Returns an empty byte array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((byte[]) null);    // returns empty byte array
     * nullToEmpty(new byte[] {1});   // returns the original array
     * }</pre>
     *
     * @param a the byte array to check
     * @return an empty byte array if the specified array is {@code null}, otherwise the original array
     */
    public static byte[] nullToEmpty(final byte[] a) {
        return a == null ? EMPTY_BYTE_ARRAY : a;
    }

    /**
     * Returns an empty short array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((short[]) null);    // returns empty short array
     * nullToEmpty(new short[] {1});   // returns the original array
     * }</pre>
     *
     * @param a the short array to check
     * @return an empty short array if the specified array is {@code null}, otherwise the original array
     */
    public static short[] nullToEmpty(final short[] a) {
        return a == null ? EMPTY_SHORT_ARRAY : a;
    }

    /**
     * Returns an empty int array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((int[]) null);    // returns empty int array
     * nullToEmpty(new int[] {1});   // returns the original array
     * }</pre>
     *
     * @param a the int array to check
     * @return an empty int array if the specified array is {@code null}, otherwise the original array
     */
    public static int[] nullToEmpty(final int[] a) {
        return a == null ? EMPTY_INT_ARRAY : a;
    }

    /**
     * Returns an empty long array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((long[]) null);     // returns empty long array
     * nullToEmpty(new long[] {1L});   // returns the original array
     * }</pre>
     *
     * @param a the long array to check
     * @return an empty long array if the specified array is {@code null}, otherwise the original array
     */
    public static long[] nullToEmpty(final long[] a) {
        return a == null ? EMPTY_LONG_ARRAY : a;
    }

    /**
     * Returns an empty float array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((float[]) null);       // returns empty float array
     * nullToEmpty(new float[] {1.0f});   // returns the original array
     * }</pre>
     *
     * @param a the float array to check
     * @return an empty float array if the specified array is {@code null}, otherwise the original array
     */
    public static float[] nullToEmpty(final float[] a) {
        return a == null ? EMPTY_FLOAT_ARRAY : a;
    }

    /**
     * Returns an empty double array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((double[]) null);      // returns empty double array
     * nullToEmpty(new double[] {1.0});   // returns the original array
     * }</pre>
     *
     * @param a the double array to check
     * @return an empty double array if the specified array is {@code null}, otherwise the original array
     */
    public static double[] nullToEmpty(final double[] a) {
        return a == null ? EMPTY_DOUBLE_ARRAY : a;
    }

    /**
     * Returns an empty BigInteger array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((BigInteger[]) null);                 // returns empty BigInteger array
     * nullToEmpty(new BigInteger[] {BigInteger.ONE});   // returns the original array
     * }</pre>
     *
     * @param a the BigInteger array to check
     * @return an empty BigInteger array if the specified array is {@code null}, otherwise the original array
     */
    public static BigInteger[] nullToEmpty(final BigInteger[] a) {
        return a == null ? EMPTY_BIG_INTEGER_ARRAY : a;
    }

    /**
     * Returns an empty BigDecimal array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((BigDecimal[]) null);                 // returns empty BigDecimal array
     * nullToEmpty(new BigDecimal[] {BigDecimal.ONE});   // returns the original array
     * }</pre>
     *
     * @param a the BigDecimal array to check
     * @return an empty BigDecimal array if the specified array is {@code null}, otherwise the original array
     */
    public static BigDecimal[] nullToEmpty(final BigDecimal[] a) {
        return a == null ? EMPTY_BIG_DECIMAL_ARRAY : a;
    }

    /**
     * Returns an empty String array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((String[]) null);      // returns empty String array
     * nullToEmpty(new String[] {"a"});   // returns the original array
     * }</pre>
     *
     * @param a the String array to check
     * @return an empty String array if the specified array is {@code null}, otherwise the original array
     * @see Strings#nullToEmpty(String)
     * @see Strings#nullToEmpty(String[])
     */
    public static String[] nullToEmpty(final String[] a) {

        return a == null ? EMPTY_STRING_ARRAY : a;
    }

    /**
     * Converts the specified String array to an empty {@code String[0]} if it's {@code null} and each {@code null} element String to empty String {@code ""}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmptyForEach(null);   // returns empty String array
     * String[] array = {"a", null, "b"};
     * nullToEmptyForEach(array);   // modifies array to {"a", "", "b"} and returns it
     * }</pre>
     *
     * @param a the String array to check
     * @return an empty String array if the specified array is {@code null}, otherwise the original array with each {@code null} element replaced by an empty string
     * @see Strings#nullToEmpty(String)
     * @see Strings#nullToEmpty(String[])
     */
    @Beta
    public static String[] nullToEmptyForEach(final String[] a) { // nullToEmptyForAll is better?
        if (a == null) {
            return EMPTY_STRING_ARRAY;
        }

        for (int i = 0, len = a.length; i < len; i++) {
            a[i] = a[i] == null ? Strings.EMPTY : a[i];
        }

        return a;
    }

    /**
     * Returns an empty Date array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((java.util.Date[]) null);                       // returns empty Date array
     * nullToEmpty(new java.util.Date[] {new java.util.Date()});   // returns the original array
     * }</pre>
     *
     * @param a the Date array to check
     * @return an empty Date array if the specified array is {@code null}, otherwise the original array
     */
    public static java.util.Date[] nullToEmpty(final java.util.Date[] a) {
        return a == null ? EMPTY_JU_DATE_ARRAY : a;
    }

    /**
     * Returns an empty Date array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((java.sql.Date[]) null);                       // returns empty Date array
     * nullToEmpty(new java.sql.Date[] {new java.sql.Date(0)});   // returns the original array
     * }</pre>
     *
     * @param a the Date array to check
     * @return an empty Date array if the specified array is {@code null}, otherwise the original array
     */
    public static java.sql.Date[] nullToEmpty(final java.sql.Date[] a) {
        return a == null ? EMPTY_DATE_ARRAY : a;
    }

    /**
     * Returns an empty Time array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((java.sql.Time[]) null);                       // returns empty Time array
     * nullToEmpty(new java.sql.Time[] {new java.sql.Time(0)});   // returns the original array
     * }</pre>
     *
     * @param a the Time array to check
     * @return an empty Time array if the specified array is {@code null}, otherwise the original array
     */
    public static java.sql.Time[] nullToEmpty(final java.sql.Time[] a) {
        return a == null ? EMPTY_TIME_ARRAY : a;
    }

    /**
     * Returns an empty Timestamp array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((java.sql.Timestamp[]) null);                            // returns empty Timestamp array
     * nullToEmpty(new java.sql.Timestamp[] {new java.sql.Timestamp(0)});   // returns the original array
     * }</pre>
     *
     * @param a the Timestamp array to check
     * @return an empty Timestamp array if the specified array is {@code null}, otherwise the original array
     */
    public static java.sql.Timestamp[] nullToEmpty(final java.sql.Timestamp[] a) {
        return a == null ? EMPTY_TIMESTAMP_ARRAY : a;
    }

    /**
     * Returns an empty Calendar array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Calendar[]) null);                         // returns empty Calendar array
     * nullToEmpty(new Calendar[] {Calendar.getInstance()});   // returns the original array
     * }</pre>
     *
     * @param a the Calendar array to check
     * @return an empty Calendar array if the specified array is {@code null}, otherwise the original array
     */
    public static Calendar[] nullToEmpty(final Calendar[] a) {
        return a == null ? EMPTY_CALENDAR_ARRAY : a;
    }

    /**
     * Returns an empty Object array if the specified array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((Object[]) null);    // returns empty Object array
     * nullToEmpty(new Object[] {1});   // returns the original array
     * }</pre>
     *
     * @param a the Object array to check
     * @return an empty Object array if the specified array is {@code null}, otherwise the original array
     */
    public static Object[] nullToEmpty(final Object[] a) {
        return a == null ? EMPTY_OBJECT_ARRAY : a;
    }

    /**
     * Returns an empty array of the specified type if the given array is {@code null}, otherwise returns the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty(null, String[].class);   // returns empty String array
     * String[] array = {"a"};
     * nullToEmpty(array, String[].class);   // returns the original array
     * }</pre>
     *
     * @param <T> the component type of the array
     * @param a the array to check
     * @param arrayType the class of the array type
     * @return an empty array of the specified type if the given array is {@code null}, otherwise the original array
     */
    public static <T> T[] nullToEmpty(final T[] a, final Class<T[]> arrayType) {
        return a == null ? (T[]) newArray(arrayType.getComponentType(), 0) : a;
    }

    /**
     * Returns an immutable empty Collection if the specified ImmutableCollection is {@code null}, otherwise itself is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableCollection) null);   // returns immutable empty collection
     * nullToEmpty(ImmutableList.of(1));          // returns the original collection
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the ImmutableCollection to check
     * @return an empty ImmutableCollection if the specified collection is {@code null}, otherwise the original collection
     */
    public static <T> ImmutableCollection<T> nullToEmpty(final ImmutableCollection<T> c) {
        return c == null ? ImmutableList.empty() : c;
    }

    /**
     * Returns an immutable empty list if the specified ImmutableList is {@code null}, otherwise returns the original list.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableList) null);   // returns immutable empty list
     * nullToEmpty(ImmutableList.of(1));    // returns the original list
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the ImmutableList to check
     * @return an empty ImmutableList if the specified list is {@code null}, otherwise the original list
     */
    public static <T> ImmutableList<T> nullToEmpty(final ImmutableList<T> list) {
        return list == null ? ImmutableList.empty() : list;
    }

    /**
     * Returns an immutable empty set if the specified ImmutableSet is {@code null}, otherwise returns the original set.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableSet) null);   // returns immutable empty set
     * nullToEmpty(ImmutableSet.of(1));    // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the ImmutableSet to check
     * @return an empty ImmutableSet if the specified set is {@code null}, otherwise the original set
     */
    public static <T> ImmutableSet<T> nullToEmpty(final ImmutableSet<T> set) {
        return set == null ? ImmutableSet.empty() : set;
    }

    /**
     * Returns an immutable empty sorted set if the specified ImmutableSortedSet is {@code null}, otherwise returns the original set.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableSortedSet) null);   // returns immutable empty sorted set
     * nullToEmpty(ImmutableSortedSet.of(1));    // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the ImmutableSortedSet to check
     * @return an empty ImmutableSortedSet if the specified set is {@code null}, otherwise the original set
     */
    public static <T> ImmutableSortedSet<T> nullToEmpty(final ImmutableSortedSet<T> set) {
        return set == null ? ImmutableSortedSet.empty() : set;
    }

    /**
     * Returns an immutable empty navigable set if the specified ImmutableNavigableSet is {@code null}, otherwise returns the original set.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableNavigableSet) null);   // returns immutable empty navigable set
     * nullToEmpty(ImmutableNavigableSet.of(1));    // returns the original set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the ImmutableNavigableSet to check
     * @return an empty ImmutableNavigableSet if the specified set is {@code null}, otherwise the original set
     */
    public static <T> ImmutableNavigableSet<T> nullToEmpty(final ImmutableNavigableSet<T> set) {
        return set == null ? ImmutableNavigableSet.empty() : set;
    }

    /**
     * Returns an immutable empty map if the specified ImmutableMap is {@code null}, otherwise returns the original map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableMap) null);         // returns immutable empty map
     * nullToEmpty(ImmutableMap.of("k", "v"));   // returns the original map
     * }</pre>
     *
     * @param <K> the type of keys in the map
     * @param <V> the type of values in the map
     * @param map the ImmutableMap to check
     * @return an empty ImmutableMap if the specified map is {@code null}, otherwise the original map
     */
    public static <K, V> ImmutableMap<K, V> nullToEmpty(final ImmutableMap<K, V> map) {
        return map == null ? ImmutableMap.empty() : map;
    }

    /**
     * Returns an immutable empty sorted map if the specified ImmutableSortedMap is {@code null}, otherwise returns the original map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableSortedMap) null);         // returns immutable empty sorted map
     * nullToEmpty(ImmutableSortedMap.of("k", "v"));   // returns the original map
     * }</pre>
     *
     * @param <K> the type of keys in the map
     * @param <V> the type of values in the map
     * @param map the ImmutableSortedMap to check
     * @return an empty ImmutableSortedMap if the specified map is {@code null}, otherwise the original map
     */
    public static <K, V> ImmutableSortedMap<K, V> nullToEmpty(final ImmutableSortedMap<K, V> map) {
        return map == null ? ImmutableSortedMap.empty() : map;
    }

    /**
     * Returns an immutable empty navigable map if the specified ImmutableNavigableMap is {@code null}, otherwise returns the original map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableNavigableMap) null);         // returns immutable empty navigable map
     * nullToEmpty(ImmutableNavigableMap.of("k", "v"));   // returns the original map
     * }</pre>
     *
     * @param <K> the type of keys in the map
     * @param <V> the type of values in the map
     * @param map the ImmutableNavigableMap to check
     * @return an empty ImmutableNavigableMap if the specified map is {@code null}, otherwise the original map
     */
    public static <K, V> ImmutableNavigableMap<K, V> nullToEmpty(final ImmutableNavigableMap<K, V> map) {
        return map == null ? ImmutableNavigableMap.empty() : map;
    }

    /**
     * Returns an immutable empty bi-map if the specified ImmutableBiMap is {@code null}, otherwise returns the original bi-map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * nullToEmpty((ImmutableBiMap) null);         // returns immutable empty bi-map
     * nullToEmpty(ImmutableBiMap.of("k", "v"));   // returns the original bi-map
     * }</pre>
     *
     * @param <K> the type of keys in the bi-map
     * @param <V> the type of values in the bi-map
     * @param map the ImmutableBiMap to check
     * @return an empty ImmutableBiMap if the specified bi-map is {@code null}, otherwise the original bi-map
     */
    public static <K, V> ImmutableBiMap<K, V> nullToEmpty(final ImmutableBiMap<K, V> map) {
        return map == null ? ImmutableBiMap.empty() : map;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Boolean) null);   // returns false
     * defaultIfNull(Boolean.TRUE);     // returns true
     * }</pre>
     *
     * @param b the Boolean value to check, may be {@code null}
     * @return the primitive boolean value, or {@code false} if {@code b} is {@code null}
     */
    public static boolean defaultIfNull(final Boolean b) {
        if (b == null) {
            return false;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Boolean) null, true);   // returns true
     * defaultIfNull(Boolean.FALSE, true);    // returns false
     * }</pre>
     *
     * @param b the Boolean value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive boolean value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static boolean defaultIfNull(final Boolean b, final boolean defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Character) null);   // returns '\0'
     * defaultIfNull('a');                // returns 'a'
     * }</pre>
     *
     * @param c the Character value to check, may be {@code null}
     * @return the primitive char value, or {@code '\0'} if {@code c} is {@code null}
     */
    public static char defaultIfNull(final Character c) {
        if (c == null) {
            return Strings.CHAR_ZERO;
        }

        return c;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Character) null, 'b');   // returns 'b'
     * defaultIfNull('a', 'b');                // returns 'a'
     * }</pre>
     *
     * @param c the Character value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code c} is {@code null}
     * @return the primitive char value, or {@code defaultForNull} if {@code c} is {@code null}
     */
    public static char defaultIfNull(final Character c, final char defaultForNull) {
        if (c == null) {
            return defaultForNull;
        }

        return c;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Byte) null);   // returns 0
     * defaultIfNull((byte) 1);      // returns 1
     * }</pre>
     *
     * @param b the Byte value to check, may be {@code null}
     * @return the primitive byte value, or {@code 0} if {@code b} is {@code null}
     */
    public static byte defaultIfNull(final Byte b) {
        if (b == null) {
            return (byte) 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Byte) null, (byte) 2);   // returns 2
     * defaultIfNull((byte) 1, (byte) 2);      // returns 1
     * }</pre>
     *
     * @param b the Byte value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive byte value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static byte defaultIfNull(final Byte b, final byte defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Short) null);   // returns 0
     * defaultIfNull((short) 1);      // returns 1
     * }</pre>
     *
     * @param b the Short value to check, may be {@code null}
     * @return the primitive short value, or {@code 0} if {@code b} is {@code null}
     */
    public static short defaultIfNull(final Short b) {
        if (b == null) {
            return (short) 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Short) null, (short) 2);   // returns 2
     * defaultIfNull((short) 1, (short) 2);      // returns 1
     * }</pre>
     *
     * @param b the Short value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive short value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static short defaultIfNull(final Short b, final short defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Integer) null);   // returns 0
     * defaultIfNull(1);                // returns 1
     * }</pre>
     *
     * @param b the Integer value to check, may be {@code null}
     * @return the primitive int value, or {@code 0} if {@code b} is {@code null}
     */
    public static int defaultIfNull(final Integer b) {
        if (b == null) {
            return 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Integer) null, 2);   // returns 2
     * defaultIfNull(1, 2);                // returns 1
     * }</pre>
     *
     * @param b the Integer value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive int value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static int defaultIfNull(final Integer b, final int defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Long) null);   // returns 0L
     * defaultIfNull(1L);            // returns 1L
     * }</pre>
     *
     * @param b the Long value to check, may be {@code null}
     * @return the primitive long value, or {@code 0} if {@code b} is {@code null}
     */
    public static long defaultIfNull(final Long b) {
        if (b == null) {
            return 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Long) null, 2L);   // returns 2L
     * defaultIfNull(1L, 2L);            // returns 1L
     * }</pre>
     *
     * @param b the Long value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive long value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static long defaultIfNull(final Long b, final long defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Float) null);   // returns 0.0f
     * defaultIfNull(1.0f);           // returns 1.0f
     * }</pre>
     *
     * @param b the Float value to check, may be {@code null}
     * @return the primitive float value, or {@code 0} if {@code b} is {@code null}
     */
    public static float defaultIfNull(final Float b) {
        if (b == null) {
            return 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Float) null, 2.0f);   // returns 2.0f
     * defaultIfNull(1.0f, 2.0f);           // returns 1.0f
     * }</pre>
     *
     * @param b the Float value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive float value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static float defaultIfNull(final Float b, final float defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the default value of the given type if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Double) null);   // returns 0.0
     * defaultIfNull(1.0);             // returns 1.0
     * }</pre>
     *
     * @param b the Double value to check, may be {@code null}
     * @return the primitive double value, or {@code 0} if {@code b} is {@code null}
     */
    public static double defaultIfNull(final Double b) {
        if (b == null) {
            return 0;
        }

        return b;
    }

    /**
     * Returns the specified default value if the specified object is {@code null} or itself if the specified object is not {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull((Double) null, 2.0);   // returns 2.0
     * defaultIfNull(1.0, 2.0);             // returns 1.0
     * }</pre>
     *
     * @param b the Double value to check, may be {@code null}
     * @param defaultForNull the default value to return if {@code b} is {@code null}
     * @return the primitive double value, or {@code defaultForNull} if {@code b} is {@code null}
     */
    public static double defaultIfNull(final Double b, final double defaultForNull) {
        if (b == null) {
            return defaultForNull;
        }

        return b;
    }

    /**
     * Returns the specified default value if the given object is {@code null}, otherwise returns the object itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull(null, "default");      // returns "default"
     * defaultIfNull("value", "default");   // returns "value"
     * }</pre>
     *
     * @param <T> the type of the object
     * @param obj the object to check for {@code null}
     * @param defaultForNull the default value to return if {@code obj} is {@code null}
     * @return {@code obj} if it is not {@code null}, otherwise {@code defaultForNull}
     * @throws IllegalArgumentException if the specified default value is {@code null}.
     * @see Strings#defaultIfNull(CharSequence, CharSequence)
     */
    public static <T> T defaultIfNull(final T obj, final T defaultForNull) throws IllegalArgumentException {
        checkArgNotNull(defaultForNull, cs.defaultValue);

        return obj == null ? defaultForNull : obj;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified object is {@code null}, otherwise returns the object itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfNull(null, () -> "default");      // returns "default"
     * defaultIfNull("value", () -> "default");   // returns "value"
     * }</pre>
     *
     * @param <T> the type of the object
     * @param obj the object to check, may be {@code null}
     * @param supplierForDefault the supplier that provides the default value if {@code obj} is {@code null}
     * @return {@code obj} if it is not {@code null}, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is {@code null} when the specified object is {@code null}.
     * @see Strings#defaultIfNull(CharSequence, Supplier)
     */
    public static <T> T defaultIfNull(final T obj, final Supplier<? extends T> supplierForDefault) throws IllegalArgumentException {
        if (obj == null) {
            return checkArgNotNull(supplierForDefault.get(), cs.defaultValue);
        }

        return obj;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfEmpty("", "default");        // returns "default"
     * defaultIfEmpty("value", "default");   // returns "value"
     * defaultIfEmpty(null, "default");      // returns "default"
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param str the CharSequence to check, may be {@code null} or empty
     * @param defaultForEmpty the default value to return if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise {@code defaultForEmpty}
     * @throws IllegalArgumentException if the specified default charSequence value is empty.
     * @see Strings#defaultIfEmpty(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultForEmpty) throws IllegalArgumentException {
        checkArgNotEmpty(defaultForEmpty, cs.defaultValue);

        return isEmpty(str) ? defaultForEmpty : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is empty, otherwise returns the {@code charSequence} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfEmpty("", () -> "default");        // returns "default"
     * defaultIfEmpty("value", () -> "default");   // returns "value"
     * defaultIfEmpty(null, () -> "default");      // returns "default"
     * }</pre>
     *
     * @param <T> the type of the CharSequence
     * @param str the CharSequence to check, may be {@code null} or empty
     * @param supplierForDefault the supplier that provides the default value if {@code str} is empty
     * @return {@code str} if it is not empty, otherwise the value provided by {@code supplierForDefault}
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is empty when the specified {@code charSequence} is empty.
     * @see Strings#defaultIfEmpty(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfEmpty(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isEmpty(str)) {
            return checkArgNotEmpty(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfBlank("   ", "default");     // returns "default"
     * defaultIfBlank("value", "default");   // returns "value"
     * defaultIfBlank(null, "default");      // returns "default"
     * }</pre>
     *
     * @param <T> the type of CharSequence
     * @param str the CharSequence to check, may be {@code null}
     * @param defaultForBlank the default value to return if the string is blank
     * @return the string if not blank, or the default value if blank
     * @throws IllegalArgumentException if the specified default charSequence value is blank.
     * @see Strings#defaultIfBlank(CharSequence, CharSequence)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultForBlank) throws IllegalArgumentException {
        checkArgNotBlank(defaultForBlank, cs.defaultValue);

        return isBlank(str) ? defaultForBlank : str;
    }

    /**
     * Returns the default value provided by specified {@code Supplier} if the specified {@code charSequence} is blank, otherwise returns the {@code charSequence} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfBlank("   ", () -> "default");     // returns "default"
     * defaultIfBlank("value", () -> "default");   // returns "value"
     * defaultIfBlank(null, () -> "default");      // returns "default"
     * }</pre>
     *
     * @param <T> the type of CharSequence
     * @param str the CharSequence to check, may be {@code null}
     * @param supplierForDefault the supplier to provide the default value if the string is blank
     * @return the string if not blank, or the value from the supplier if blank
     * @throws IllegalArgumentException if default value provided by specified {@code Supplier} is blank when the specified {@code charSequence} is blank.
     * @see Strings#defaultIfBlank(CharSequence, Supplier)
     */
    public static <T extends CharSequence> T defaultIfBlank(final T str, final Supplier<? extends T> supplierForDefault) {
        if (isBlank(str)) {
            return checkArgNotBlank(supplierForDefault.get(), cs.defaultValue);
        }

        return str;
    }

    /**
     * Returns the specified default value if the specified Collection is empty, otherwise returns the {@code Collection} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfEmpty(Collections.emptyList(), Arrays.asList("default"));   // returns ["default"]
     * defaultIfEmpty(Arrays.asList("a"), Arrays.asList("default"));        // returns ["a"]
     * defaultIfEmpty(null, Arrays.asList("default"));                      // returns ["default"]
     * }</pre>
     *
     * @param <T> the type of Collection
     * @param c the collection to check, may be {@code null}
     * @param defaultForEmpty the default value to return if the collection is empty
     * @return the collection if not empty, or the default value if empty
     * @throws IllegalArgumentException if the specified default collection value is empty.
     */
    public static <T extends Collection<?>> T defaultIfEmpty(final T c, final T defaultForEmpty) throws IllegalArgumentException {
        checkArgNotEmpty(defaultForEmpty, cs.defaultValue);

        return isEmpty(c) ? defaultForEmpty : c;
    }

    /**
     * Returns the specified default value if the specified Map is empty, otherwise returns the {@code Map} itself.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultIfEmpty(Collections.emptyMap(), Collections.singletonMap("k", "v"))               ="v"}
     * defaultIfEmpty(Collections.singletonMap("a", "b"), Collections.singletonMap("k", "v"))   ="b"}
     * defaultIfEmpty(null, Collections.singletonMap("k", "v"))                                 ="v"}
     * }</pre>
     *
     * @param <T> the type of Map
     * @param m the map to check, may be {@code null}
     * @param defaultForEmpty the default value to return if the map is empty
     * @return the map if not empty, or the default value if empty
     * @throws IllegalArgumentException if the specified default map value is empty.
     */
    public static <T extends Map<?, ?>> T defaultIfEmpty(final T m, final T defaultForEmpty) throws IllegalArgumentException {
        checkArgNotEmpty(defaultForEmpty, cs.defaultValue);

        return isEmpty(m) ? defaultForEmpty : m;
    }

    /**
     * Returns the default value of the given class type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultValueOf(int.class);       // returns 0
     * defaultValueOf(boolean.class);   // returns false
     * defaultValueOf(String.class);    // returns null
     * }</pre>
     *
     * @param <T> the type to return the default value for
     * @param cls the class type for which the default value is to be returned.
     * @return the default value of the given class type. For example, for an Integer class type, it will return 0.
     * @throws IllegalArgumentException if the specified class type is {@code null}.
     */
    @SuppressWarnings("unchecked")
    public static <T> T defaultValueOf(final Class<T> cls) throws IllegalArgumentException {
        return (T) typeOf(cls).defaultValue();
    }

    /**
     * Returns the default value of the given class type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * defaultValueOf(Integer.class, true);    // returns 0
     * defaultValueOf(Integer.class, false);   // returns null
     * }</pre>
     *
     * @param <T> the type to return the default value for
     * @param cls the class type for which the default value is to be returned.
     * @param nonNullForPrimitiveWrapper if {@code true}, it will return {@code non-null} value for primitive wrapper types, otherwise it will return {@code null}.
     * @return the default value of the given class type. For example, for an Integer class type, it will return 0.
     * @throws IllegalArgumentException if the specified class type is {@code null}.
     */
    @SuppressWarnings("unchecked")
    public static <T> T defaultValueOf(final Class<T> cls, final boolean nonNullForPrimitiveWrapper) throws IllegalArgumentException {
        if (nonNullForPrimitiveWrapper) {
            return (T) typeOf(ClassUtil.unwrap(cls)).defaultValue();
        } else {
            return (T) typeOf(cls).defaultValue();
        }
    }

    // ================================ nullToEmpty, defaultIfNull/Empty/Blank... =====================================

    // ================================ creation/conversion/get/set... ================================================

    /**
     * Gets a Type by the given type name.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Type<String> type = typeOf("java.lang.String");
     * }</pre>
     *
     * @param <T> the type parameter
     * @param typeName the name of the type to be retrieved.
     * @return the Type corresponding to the given type name.
     * @throws IllegalArgumentException if the specified {@code typeName} is {@code null}.
     * @see Type#of(String)
     */
    @SuppressWarnings("unchecked")
    public static <T> Type<T> typeOf(@NotNull final String typeName) throws IllegalArgumentException {
        return Type.of(typeName);
    }

    /**
     * Gets a Type by the given {@code Class}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Type<String> stringType = typeOf(String.class);
     * Type<Integer> intType = typeOf(Integer.class);
     * Type<List> listType = typeOf(List.class);
     * }</pre>
     *
     * @param <T> the type represented by the class
     * @param cls the name of the type to be retrieved.
     * @return the Type corresponding to the given type name.
     * @throws IllegalArgumentException if the specified {@code Class} is {@code null}.
     * @see Type#of(Class)
     */
    @SuppressWarnings("unchecked")
    public static <T> Type<T> typeOf(@NotNull final Class<?> cls) throws IllegalArgumentException {
        return (Type<T>) Type.of(cls);
    }

    /**
     * Converts the given boolean value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf(true);    // returns "true"
     * stringOf(false);   // returns "false"
     * }</pre>
     *
     * @param val the value to be converted.
     * @return the String representation of the given value. Returns "true" if the value is {@code true}, "false" otherwise.
     */
    public static String stringOf(final boolean val) {
        return val ? Strings.TRUE : Strings.FALSE;
    }

    /**
     * Converts the given char value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf('a');    // returns "a"
     * stringOf('1');    // returns "1"
     * stringOf('\n');   // returns "\n"
     * }</pre>
     *
     * @param val the char value to be converted
     * @return the String representation of the given char value
     */
    public static String stringOf(final char val) {
        if (val < 128) {
            return charStringCache[val];
        }

        return String.valueOf(val);
    }

    /**
     * Converts the given byte value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf((byte) 0);     // returns "0"
     * stringOf((byte) 127);   // returns "127"
     * stringOf((byte) -1);    // returns "-1"
     * }</pre>
     *
     * @param val the byte value to be converted
     * @return the String representation of the given byte value
     */
    @SuppressFBWarnings({ "INT_BAD_COMPARISON_WITH_SIGNED_BYTE", "INT_BAD_COMPARISON_WITH_SIGNED_BYTE" })
    public static String stringOf(final byte val) {

        //noinspection ConstantValue
        if (val > intStringCacheLow && val < intStringCacheHigh) {
            return intStringCache[val - intStringCacheLow];
        }

        return String.valueOf(val);
    }

    /**
     * Converts the given short value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf((short) 0);      // returns "0"
     * stringOf((short) 1000);   // returns "1000"
     * stringOf((short) -500);   // returns "-500"
     * }</pre>
     *
     * @param val the short value to be converted
     * @return the String representation of the given short value
     */
    public static String stringOf(final short val) {
        if (val > intStringCacheLow && val < intStringCacheHigh) {
            return intStringCache[val - intStringCacheLow];
        }

        return String.valueOf(val);
    }

    /**
     * Converts the given int value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf(0);      // returns "0"
     * stringOf(123);    // returns "123"
     * stringOf(-456);   // returns "-456"
     * }</pre>
     *
     * @param val the int value to be converted
     * @return the String representation of the given int value
     */
    public static String stringOf(final int val) {
        if (val > intStringCacheLow && val < intStringCacheHigh) {
            return intStringCache[val - intStringCacheLow];
        }

        return String.valueOf(val);
    }

    /**
     * Converts the given long value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf(0L);            // returns "0"
     * stringOf(123456789L);    // returns "123456789"
     * stringOf(-987654321L);   // returns "-987654321"
     * }</pre>
     *
     * @param val the long value to be converted
     * @return the String representation of the given long value
     */
    public static String stringOf(final long val) {
        if (val > intStringCacheLow && val < intStringCacheHigh) {
            return intStringCache[(int) (val - intStringCacheLow)];
        }

        return String.valueOf(val);
    }

    /**
     * Converts the given float value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf(0.0f);    // returns "0.0"
     * stringOf(3.14f);   // returns "3.14"
     * stringOf(-2.5f);   // returns "-2.5"
     * }</pre>
     *
     * @param val the float value to be converted
     * @return the String representation of the given float value
     */
    public static String stringOf(final float val) {
        return String.valueOf(val);
    }

    /**
     * Converts the given double value to its corresponding String representation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * stringOf(0.0);       // returns "0.0"
     * stringOf(3.14159);   // returns "3.14159"
     * stringOf(-2.718);    // returns "-2.718"
     * }</pre>
     *
     * @param val the double value to be converted
     * @return the String representation of the given double value
     */
    public static String stringOf(final double val) {
        return String.valueOf(val);
    }

    /**
     * Converts the given value to its corresponding String representation by {@code Type.stringOf(Object)}.
     *
     * @param obj the value to be converted.
     * @return the String representation of the given value. {@code null} if the specified object is null
     * @see #valueOf(String, Class)
     * @see Type#stringOf(Object)
     */
    @MayReturnNull
    public static String stringOf(final Object obj) {
        return (obj == null) ? null : typeOf(obj.getClass()).stringOf(obj);
    }

    /**
     * Converts the given string to its corresponding value of the specified target type by {@code typeOf(targetType).valueOf(str)}.
     *
     * @param <T> the type of the target object after conversion.
     * @param str the string to be converted.
     * @param targetType the class of the target type to which the string is to be converted.
     * @return the converted value of the specified target type. If the input string is {@code null}, it returns the default value of the target type.
     * @throws IllegalArgumentException if the specified target type is {@code null}.
     * @see #stringOf(Object)
     * @see Type#valueOf(String)
     */
    @SuppressWarnings("unchecked")
    public static <T> T valueOf(final String str, final Class<? extends T> targetType) {
        return (str == null) ? defaultValueOf(targetType) : (T) typeOf(targetType).valueOf(str);
    }

    // ================================ creation/conversion... =======================================================

    private static final Map<Class<?>, BiFunction<Object, Class<?>, Object>> converterMap = new ConcurrentHashMap<>();

    /**
     * Registers a converter for a specific source class. The converter is a function that takes an object of the source class
     * and a target class, and converts the source object into an instance of the target class.
     *
     * @param srcClass the source class that the converter can convert from. This must not be a built-in class.
     * @param converter the converter function that takes a source object and a target class, and returns an instance of the target class.
     * @return {@code true} if there is no {@code converter} registered with specified {@code srcClass} yet before this call.
     * @throws IllegalArgumentException if the specified {@code srcClass} is a built-in class or if either {@code srcClass} or {@code converter} is {@code null}.
     */
    @SuppressWarnings("rawtypes")
    public static boolean registerConverter(@NotNull final Class<?> srcClass, final BiFunction<?, Class<?>, ?> converter) throws IllegalArgumentException {
        checkArgNotNull(srcClass, cs.srcClass);
        checkArgNotNull(converter, cs.converter);

        if (isBuiltinClass(srcClass)) {
            throw new IllegalArgumentException("Can't register converter with builtin class: " + ClassUtil.getCanonicalClassName(srcClass));
        }

        synchronized (converterMap) {
            if (converterMap.containsKey(srcClass)) {
                return false;
            }

            converterMap.put(srcClass, (BiFunction) converter);

            return true;
        }
    }

    static boolean isBuiltinClass(final Class<?> cls) {
        final Package pkg = cls.getPackage();

        if (pkg == null) {
            if (ClassUtil.isPrimitiveType(cls) || ClassUtil.isPrimitiveArrayType(cls)) {
                return true;
            } else if (cls.isArray()) {
                Class<?> componentType = cls.getComponentType();

                while (componentType.isArray()) {
                    componentType = componentType.getComponentType();
                }

                return ClassUtil.isPrimitiveType(cls) || ClassUtil.isPrimitiveArrayType(cls);
            }

            return false;
        }

        final String pkgName = pkg.getName();

        return Strings.isNotEmpty(pkgName) && (pkgName.startsWith("java.") || pkgName.startsWith("javax.") || pkgName.startsWith("com.landawn.abacus."));
    }

    /**
     * Converts the given source object to the specified target type.
     * If the source object is {@code null}, the default value of the target type is returned.
     * If the source object can be converted to the target type, an instance of the target type is returned.
     *
     * @param <T> the type of the target object after conversion.
     * @param srcObj the source object to be converted. If {@code null}, the default value of the target type is returned.
     * @param targetType the class of the target type to which the source object is to be converted.
     * @return an instance of the target type converted from the source object, or the default value of the target type if the source object is {@code null}.
     * @throws IllegalArgumentException if the source object cannot be converted to the target type.
     * @throws NumberFormatException if string value of the source object cannot be parsed to the target(Number) type.
     * @throws RuntimeException if any other error occurs during the conversion.
     */
    public static <T> T convert(final Object srcObj, final Class<? extends T> targetType)
            throws IllegalArgumentException, NumberFormatException, RuntimeException {
        if (srcObj == null) {
            return defaultValueOf(targetType);
        }

        final Class<?> srcClass = srcObj.getClass();
        BiFunction<Object, Class<?>, Object> converterFunc = null;

        if ((converterFunc = converterMap.get(srcClass)) != null) {
            return (T) converterFunc.apply(srcObj, targetType);
        }

        final Type<T> type = typeOf(targetType);

        return convert(srcObj, srcClass, type);
    }

    /**
     * Converts the given source object to the specified target type using the provided Type instance.
     * If the source object is {@code null}, the default value of the target type is returned.
     * If the source object can be converted to the target type, an instance of the target type is returned.
     *
     * @param <T> the type of the target object after conversion.
     * @param srcObj the source object to be converted.
     * @param targetType the Type instance of the target type to which the source object is to be converted.
     * @return an instance of the target type converted from the source object, or the default value of the target type if the source object is {@code null}.
     * @throws IllegalArgumentException if the source object cannot be converted to the target type.
     * @throws NumberFormatException if string value of the source object cannot be parsed to the target(Number) type.
     * @throws RuntimeException if any other error occurs during the conversion.
     */
    public static <T> T convert(final Object srcObj, final Type<? extends T> targetType)
            throws IllegalArgumentException, NumberFormatException, RuntimeException {
        if (srcObj == null) {
            return targetType.defaultValue();
        }

        final Class<?> srcClass = srcObj.getClass();
        BiFunction<Object, Class<?>, Object> converterFunc = null;

        if ((converterFunc = converterMap.get(srcClass)) != null) {
            return (T) converterFunc.apply(srcObj, targetType.clazz());
        }

        return convert(srcObj, srcClass, targetType);
    }

    @SuppressWarnings({ "rawtypes" })
    private static <T> T convert(final Object srcObj, final Class<?> srcClass, final Type<? extends T> targetType) {
        if (targetType.clazz().isAssignableFrom(srcClass)) {
            return (T) srcObj;
        }

        final Type<Object> srcType = typeOf(srcClass);

        if (targetType.isString()) {
            return (T) srcType.stringOf(srcObj);
        } else if (targetType.isNumber()) {
            if (srcType.isString()) {
                // fall through.
            } else if (srcType.isNumber()) {
                return (T) Numbers.convert((Number) srcObj, (Type) targetType);
            } else if (srcType.clazz().equals(Character.class) && (targetType.clazz().equals(int.class) || targetType.clazz().equals(Integer.class))) {
                return (T) (Integer.valueOf((Character) srcObj)); //NOSONAR
            } else if ((targetType.clazz().equals(long.class) || targetType.clazz().equals(Long.class))
                    && java.util.Date.class.isAssignableFrom(srcType.clazz())) {
                return (T) (Long) ((java.util.Date) srcObj).getTime();
            }

            return targetType.valueOf(srcObj);
        } else if (targetType.isBoolean()) {
            if (srcType.isNumber()) {
                return (T) ((Boolean) (((Number) srcObj).longValue() > 0));
            } else {
                return targetType.valueOf(srcObj);
            }
        } else if ((targetType.clazz().equals(char.class) || targetType.clazz().equals(Character.class))) {
            if (srcType.clazz().equals(Integer.class)) {
                return (T) (Character.valueOf((char) ((Integer) srcObj).intValue()));
            } else {
                return targetType.valueOf(srcObj);
            }
        } else if (srcType.clazz().equals(Long.class)) {
            if (targetType.clazz().equals(java.util.Date.class)) {
                return (T) new java.util.Date((Long) srcObj);
            } else if (targetType.clazz().equals(java.sql.Timestamp.class)) {
                return (T) new java.sql.Timestamp((Long) srcObj);
            } else if (targetType.clazz().equals(java.sql.Date.class)) {
                return (T) new java.sql.Date((Long) srcObj);
            } else if (targetType.clazz().equals(java.sql.Time.class)) {
                return (T) new java.sql.Time((Long) srcObj);
            } else {
                return targetType.valueOf(srcObj);
            }
        }

        if (targetType.isBean()) {
            if (srcType.isBean()) {
                return Beans.copy(srcObj, targetType.clazz());
            } else if (srcType.isMap()) {
                return Beans.map2Bean((Map<String, Object>) srcObj, targetType.clazz());
            }
        } else if (targetType.isMap()) {
            if (srcType.isBean() && targetType.getParameterTypes()[0].clazz().isAssignableFrom(String.class)
                    && Object.class.equals(targetType.getParameterTypes()[1].clazz())) {
                try {
                    final Map<String, Object> result = newMap((Class<Map>) targetType.clazz());
                    Beans.bean2Map(srcObj, result);
                    return (T) result;
                } catch (final Exception e) {
                    // ignore.
                }
            } else if (srcType.isMap()) {
                final Map srcMap = (Map) srcObj;
                final Optional<Object> firstNonNullKeyOp = firstNonNull(srcMap.keySet());
                final Optional<Object> firstNonNullValueOp = firstNonNull(srcMap.values());

                if ((firstNonNullKeyOp.isEmpty() || targetType.getParameterTypes()[0].clazz().isAssignableFrom(firstNonNullKeyOp.get().getClass()))
                        && (firstNonNullValueOp.isEmpty()
                                || targetType.getParameterTypes()[1].clazz().isAssignableFrom(firstNonNullValueOp.get().getClass()))) {
                    final Map result = newMap((Class<Map>) targetType.clazz(), srcMap.size());
                    result.putAll(srcMap);
                    return (T) result;
                }
            }
        }

        if (targetType.isCollection()) {
            if (srcType.isCollection()) {
                final Collection srcColl = (Collection) srcObj;
                final Optional<Object> op = firstNonNull(srcColl);

                if (op.isEmpty() || targetType.getParameterTypes()[0].clazz().isAssignableFrom(op.get().getClass())) {
                    final Collection result = newCollection((Class<Collection>) targetType.clazz(), srcColl.size());
                    result.addAll(srcColl);
                    return (T) result;
                }
            } else if (srcType.isObjectArray() && targetType.getParameterTypes()[0].clazz().isAssignableFrom(srcType.clazz().getComponentType())) {
                final Object[] srcArray = (Object[]) srcObj;
                final Collection result = newCollection((Class<Collection>) targetType.clazz(), srcArray.length);
                result.addAll(Arrays.asList(srcArray));
                return (T) result;
            } else if (targetType.getElementType().clazz().isAssignableFrom(srcType.clazz())) {
                final Collection result = newCollection((Class<Collection>) targetType.clazz(), 1);
                result.add(srcObj);
                return (T) result;
            }
        }

        if (targetType.isObjectArray()) {
            if (srcType.isCollection()) {
                final Collection srcColl = (Collection) srcObj;
                final Optional<Object> op = firstNonNull(srcColl);

                if (op.isEmpty() || targetType.clazz().getComponentType().isAssignableFrom(op.get().getClass())) {
                    try {
                        final Object[] result = newArray(targetType.clazz().getComponentType(), srcColl.size());
                        srcColl.toArray(result);
                        return (T) result;
                    } catch (final Exception e) {
                        // ignore;
                    }
                }
            } else if (targetType.getElementType().clazz().isAssignableFrom(srcType.clazz())) {
                final Object[] result = newArray(targetType.clazz().getComponentType(), 1);
                result[0] = srcObj;
                return (T) result;
            }

        }

        if (targetType.clazz().equals(byte[].class)) {
            if (srcType.clazz().equals(Blob.class)) {
                final Blob blob = (Blob) srcObj;
                UncheckedSQLException primaryException = null;

                try {
                    final long blobLength = blob.length();
                    if (blobLength > Integer.MAX_VALUE) {
                        throw new IllegalArgumentException("Blob size (" + blobLength + ") exceeds maximum array size (" + Integer.MAX_VALUE + ")");
                    }
                    return (T) blob.getBytes(1, (int) blobLength);
                } catch (final SQLException e) {
                    primaryException = new UncheckedSQLException(e);
                    throw primaryException;
                } finally {
                    try {
                        blob.free();
                    } catch (final SQLException e) {
                        final UncheckedSQLException freeException = new UncheckedSQLException(e);
                        if (primaryException != null) {
                            primaryException.addSuppressed(freeException);
                        } else {
                            throw freeException;
                        }
                    }
                }
            } else if (srcType.clazz().equals(InputStream.class)) {
                final InputStream is = (InputStream) srcObj;

                try {
                    return (T) IOUtil.readAllBytes(is);
                } finally {
                    IOUtil.close(is);
                }
            }
        } else if (targetType.clazz().equals(char[].class)) {
            if (srcType.clazz().equals(Clob.class)) {
                final Clob clob = (Clob) srcObj;
                UncheckedSQLException primaryException = null;

                try {
                    final long clobLength = clob.length();
                    if (clobLength > Integer.MAX_VALUE) {
                        throw new IllegalArgumentException("Clob size (" + clobLength + ") exceeds maximum array size (" + Integer.MAX_VALUE + ")");
                    }
                    return (T) clob.getSubString(1, (int) clobLength).toCharArray();
                } catch (final SQLException e) {
                    primaryException = new UncheckedSQLException(e);
                    throw primaryException;
                } finally {
                    try {
                        clob.free();
                    } catch (final SQLException e) {
                        final UncheckedSQLException freeException = new UncheckedSQLException(e);
                        if (primaryException != null) {
                            primaryException.addSuppressed(freeException);
                        } else {
                            throw freeException;
                        }
                    }
                }
            } else if (srcType.clazz().equals(Reader.class)) {
                final Reader reader = (Reader) srcObj;

                try {
                    return (T) IOUtil.readAllChars(reader);
                } finally {
                    IOUtil.close(reader);
                }
            } else if (srcType.clazz().equals(InputStream.class)) {
                final InputStream is = (InputStream) srcObj;

                try {
                    return (T) IOUtil.readAllChars(is);
                } finally {
                    IOUtil.close(is);
                }
            }
        } else if (targetType.clazz().equals(String.class)) {
            if (CharSequence.class.isAssignableFrom(srcType.clazz())) {
                return (T) ((CharSequence) srcObj).toString();
            } else if (srcType.clazz().equals(Clob.class)) {
                final Clob clob = (Clob) srcObj;
                UncheckedSQLException primaryException = null;

                try {
                    final long clobLength = clob.length();
                    if (clobLength > Integer.MAX_VALUE) {
                        throw new IllegalArgumentException("Clob size (" + clobLength + ") exceeds maximum array size (" + Integer.MAX_VALUE + ")");
                    }
                    return (T) clob.getSubString(1, (int) clobLength);
                } catch (final SQLException e) {
                    primaryException = new UncheckedSQLException(e);
                    throw primaryException;
                } finally {
                    try {
                        clob.free();
                    } catch (final SQLException e) {
                        final UncheckedSQLException freeException = new UncheckedSQLException(e);
                        if (primaryException != null) {
                            primaryException.addSuppressed(freeException);
                        } else {
                            throw freeException;
                        }
                    }
                }
            } else if (srcType.clazz().equals(Reader.class)) {
                final Reader reader = (Reader) srcObj;

                try {
                    return (T) IOUtil.readAllToString(reader);
                } finally {
                    IOUtil.close(reader);
                }
            } else if (srcType.clazz().equals(InputStream.class)) {
                final InputStream is = (InputStream) srcObj;

                try {
                    return (T) IOUtil.readAllToString(is);
                } finally {
                    IOUtil.close(is);
                }
            }
        } else if (targetType.clazz().equals(InputStream.class) && srcType.clazz().equals(byte[].class)) {
            return (T) new ByteArrayInputStream((byte[]) srcObj);
        } else if (targetType.clazz().equals(Reader.class) && CharSequence.class.isAssignableFrom(srcType.clazz())) {
            return (T) new StringReader(srcObj.toString());
        }

        if (srcObj instanceof final AutoCloseable closeable) {
            try {
                return targetType.valueOf(srcObj);
            } finally {
                IOUtil.closeQuietly(closeable);
            }
        } else {
            return targetType.valueOf(srcObj);
        }
    }

    /**
     * Casts the given object to the specified target type if possible.
     * If the object is {@code null} or cannot be assigned to the target type, an empty {@code Nullable} is returned.
     * Note that {@code null} can be assigned to any Object type except primitive types: boolean/char/byte/short/int/long/double.
     *
     * @param <T> the type of the target object after casting.
     * @param val the object to be casted.
     * @param targetType the class of the target type to which the object is to be casted.
     * @return a {@code Nullable} containing the casted object if the casting is successful, or an empty {@code Nullable} if the object is {@code null} or cannot be casted to the target type.
     */
    @SuppressWarnings("unchecked")
    @Beta
    public static <T> Nullable<T> castIfAssignable(final Object val, final Class<? extends T> targetType) {
        if (ClassUtil.isPrimitiveType(targetType)) {
            return val != null && ClassUtil.wrap(targetType).isAssignableFrom(val.getClass()) ? Nullable.of((T) val) : Nullable.empty();
        }

        return val == null || targetType.isAssignableFrom(val.getClass()) ? Nullable.of((T) val) : Nullable.empty();
    }

    /**
     * Casts the given object to the specified target type if possible using the provided Type instance.
     * If the object is {@code null} or cannot be assigned to the target type, an empty {@code Nullable} is returned.
     * Note that {@code null} can be assigned to any Object type except primitive types: boolean/char/byte/short/int/long/double.
     *
     * @param <T> the type of the target object after casting.
     * @param val the object to be casted.
     * @param targetType the Type instance of the target type to which the object is to be casted.
     * @return a {@code Nullable} containing the casted object if the casting is successful, or an empty {@code Nullable} if the object is {@code null} or cannot be casted to the target type.
     */
    @Beta
    public static <T> Nullable<T> castIfAssignable(final Object val, final Type<? extends T> targetType) {
        return castIfAssignable(val, targetType.clazz());
    }

    /**
     * <p>Note: copied from Apache commons Lang under Apache license v2.0 </p>
     *
     * <p>Negates the specified boolean.</p>
     *
     * <p>If {@code null} is passed in, {@code null} will be returned.</p>
     *
     * <p>NOTE: This returns {@code null} and will throw a NullPointerException if outboxed to a boolean. </p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.negate(Boolean.TRUE);    // Boolean.FALSE
     * N.negate(Boolean.FALSE);   // Boolean.TRUE
     * N.negate(null);            // null
     * }</pre>
     *
     * @param bool the Boolean to negate, which may be null
     * @return the negated Boolean, or {@code null} if {@code null} input
     * @see #isTrue(Boolean)
     * @see #isFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #isNotFalse(Boolean)
     */
    @SuppressFBWarnings("NP_BOOLEAN_RETURN_NULL")
    @MayReturnNull
    @Beta
    public static Boolean negate(final Boolean bool) {
        if (bool == null) {
            return null; //NOSONAR
        }

        return bool ? Boolean.FALSE : Boolean.TRUE;
    }

    /**
     * Negates all elements in the specified boolean array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] arr = {true, false, true};
     * N.negate(arr);
     * // arr is now {false, true, false}
     * }</pre>
     *
     * @param a the boolean array to negate
     * @see #isTrue(Boolean)
     * @see #isFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #isNotFalse(Boolean)
     */
    @Beta
    public static void negate(final boolean[] a) {
        if (isEmpty(a)) {
            return;
        }

        negate(a, 0, a.length);
    }

    /**
     * Negates all elements in the specified range of the boolean array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] arr = {true, false, true, false, true};
     * N.negate(arr, 1, 4);
     * // arr is now {true, true, false, true, true}
     * }</pre>
     *
     * @param a the boolean array to negate
     * @param fromIndex the starting index (inclusive) of the range to negate
     * @param toIndex the ending index (exclusive) of the range to negate
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see #isTrue(Boolean)
     * @see #isFalse(Boolean)
     * @see #isNotTrue(Boolean)
     * @see #isNotFalse(Boolean)
     */
    @Beta
    public static void negate(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return;
        }

        for (int i = fromIndex; i < toIndex; i++) {
            a[i] = !a[i];
        }
    }

    /**
     * Returns an immutable list of all the enum constants in the specified enum class.
     *
     * This method retrieves all the enum constants defined in the given enum class and returns them as an ImmutableList.
     * The order of the constants in the list is the order in which they're declared in the enum class.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ImmutableList<DayOfWeek> days = N.enumListOf(DayOfWeek.class);
     * // returns [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]
     * }</pre>
     *
     * @param <E> the type of the enum constants. This should be an enum type.
     * @param enumClass the class object of the enum type whose constants are to be listed; must not be {@code null}
     * @return an ImmutableList containing all the enum constants in the order they're declared in the enum class.
     */
    public static <E extends Enum<E>> ImmutableList<E> enumListOf(final Class<E> enumClass) {
        checkArgNotNull(enumClass, cs.enumClass);

        ImmutableList<E> enumList = (ImmutableList<E>) enumListPool.get(enumClass);

        if (enumList == null) {
            enumList = ImmutableList.wrap(asList(enumClass.getEnumConstants()));

            enumListPool.put(enumClass, enumList);
        }

        return enumList;
    }

    /**
     * Returns an immutable set of all the enum constants in the specified enum class.
     *
     * This method retrieves all the enum constants defined in the given enum class and returns them as an ImmutableSet.
     * The order of the constants in the set is the order in which they're declared in the enum class.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ImmutableSet<DayOfWeek> days = N.enumSetOf(DayOfWeek.class);
     * // returns an ImmutableSet containing all DayOfWeek values
     * }</pre>
     *
     * @param <E> the type of the enum constants. This should be an enum type.
     * @param enumClass the class object of the enum type whose constants are to be listed; must not be {@code null}
     * @return an ImmutableSet containing all the enum constants in the order they're declared in the enum class.
     */
    public static <E extends Enum<E>> ImmutableSet<E> enumSetOf(final Class<E> enumClass) {
        checkArgNotNull(enumClass, cs.enumClass);

        ImmutableSet<E> enumSet = (ImmutableSet<E>) enumSetPool.get(enumClass);

        if (enumSet == null) {
            enumSet = ImmutableSet.wrap(EnumSet.allOf(enumClass));

            enumSetPool.put(enumClass, enumSet);
        }

        return enumSet;
    }

    /**
     * Returns an immutable bi-directional map of all the enum constants in the specified enum class to their names.
     *
     * This method retrieves all the enum constants defined in the given enum class and maps them to their names as an ImmutableBiMap.
     * The order of the constants in the map is the order in which they're declared in the enum class.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ImmutableBiMap<DayOfWeek, String> dayMap = N.enumMapOf(DayOfWeek.class);
     * // dayMap.get(DayOfWeek.MONDAY) returns "MONDAY"
     * // dayMap.inversed().get("MONDAY") returns DayOfWeek.MONDAY
     * }</pre>
     *
     * @param <E> the type of the enum constants. This should be an enum type.
     * @param enumClass the class object of the enum type whose constants are to be listed; must not be {@code null}
     * @return an ImmutableBiMap where each key-value pair corresponds to an enum constant and its name.
     */
    public static <E extends Enum<E>> ImmutableBiMap<E, String> enumMapOf(final Class<E> enumClass) {
        checkArgNotNull(enumClass, cs.enumClass);

        ImmutableBiMap<E, String> enumMap = (ImmutableBiMap<E, String>) enumMapPool.get(enumClass);

        if (enumMap == null) {
            final EnumMap<E, String> keyMap = new EnumMap<>(enumClass);
            final Map<String, E> valueMap = new HashMap<>();

            for (final E e : enumClass.getEnumConstants()) {
                keyMap.put(e, e.name());
                valueMap.put(e.name(), e);
            }

            enumMap = ImmutableBiMap.wrap(new BiMap<>(keyMap, valueMap));

            enumMapPool.put(enumClass, enumMap);
        }

        return enumMap;
    }

    private static final Map<Class<?>, Boolean> UNMODIFIABLE_CLASSES = new ConcurrentHashMap<>();

    static {
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableCollection(new ArrayList<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableList(new ArrayList<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableSet(new HashSet<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableSortedSet(new TreeSet<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableNavigableSet(new TreeSet<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.emptyList().getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.emptySet().getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.singleton("value").getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.singletonList("value").getClass(), true);

        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableMap(new HashMap<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableSortedMap(new TreeMap<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.unmodifiableNavigableMap(new TreeMap<>()).getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.emptyMap().getClass(), true);
        UNMODIFIABLE_CLASSES.put(Collections.singletonMap("k", "v").getClass(), true);

        UNMODIFIABLE_CLASSES.put(List.of("a").getClass(), true);
        UNMODIFIABLE_CLASSES.put(Set.of("a").getClass(), true);
        UNMODIFIABLE_CLASSES.put(Map.of("k", "v").getClass(), true);

        UNMODIFIABLE_CLASSES.put(ArrayList.class, false);
        UNMODIFIABLE_CLASSES.put(LinkedList.class, false);
        UNMODIFIABLE_CLASSES.put(HashSet.class, false);
        UNMODIFIABLE_CLASSES.put(LinkedHashSet.class, false);
        UNMODIFIABLE_CLASSES.put(TreeSet.class, false);
        UNMODIFIABLE_CLASSES.put(HashMap.class, false);
        UNMODIFIABLE_CLASSES.put(LinkedHashMap.class, false);
        UNMODIFIABLE_CLASSES.put(TreeMap.class, false);
        UNMODIFIABLE_CLASSES.put(ConcurrentHashMap.class, false);

        UNMODIFIABLE_CLASSES.put(ArrayDeque.class, false);

        // cause initialization issue.
        //    UNMODIFIABLE_CLASSES.put(ImmutableList.of("a").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableSet.of("a").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableSortedSet.of("a").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableNavigableSet.of("a").getClass(), true);
        //
        //    UNMODIFIABLE_CLASSES.put(ImmutableMap.of("k", "v").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableSortedMap.of("k", "v").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableNavigableMap.of("k", "v").getClass(), true);
        //    UNMODIFIABLE_CLASSES.put(ImmutableBiMap.of("k", "v").getClass(), true);
    }

    /**
     * Checks if the specified {@code Collection} is unmodifiable by attempting a mutation operation.
     *
     * <p>This method determines whether a Collection instance is unmodifiable by performing a test
     * mutation: it attempts to add a temporary sentinel element and then remove it. If this operation
     * throws an {@link UnsupportedOperationException}, the Collection is classified as unmodifiable.
     *
     * <p><b>Detection Strategy:</b>
     * <ul>
     *   <li><b>Null Safety:</b> {@code null} collections are considered unmodifiable (returns {@code true})</li>
     *   <li><b>Caching:</b> Results are cached by class type to avoid repeated mutation tests</li>
     *   <li><b>Mutation Test:</b> Attempts {@code add()} and {@code remove()} with a sentinel value</li>
     *   <li><b>Exception Handling:</b> {@code UnsupportedOperationException} indicates unmodifiable</li>
     * </ul>
     *
     * <p><b>Recognized Unmodifiable Collection Types:</b>
     * <ul>
     *   <li>{@link Collections#unmodifiableCollection(Collection)}</li>
     *   <li>{@link Collections#unmodifiableList(List)}</li>
     *   <li>{@link Collections#unmodifiableSet(Set)}</li>
     *   <li>{@link Collections#unmodifiableSortedSet(SortedSet)}</li>
     *   <li>{@link Collections#unmodifiableNavigableSet(NavigableSet)}</li>
     *   <li>{@link Collections#emptyList()}, {@link Collections#emptySet()}</li>
     *   <li>{@link Collections#singleton(Object)}, {@link Collections#singletonList(Object)}</li>
     *   <li>{@link List#of()}, {@link Set#of()} and related factory methods (Java 9+)</li>
     *   <li>Custom unmodifiable Collection implementations throwing {@code UnsupportedOperationException}</li>
     * </ul>
     *
     * <p><b>Important Notes:</b>
     * <ul>
     *   <li><b>Side Effects:</b> Modifiable collections are temporarily mutated during the test (though changes are reverted)</li>
     *   <li><b>Thread Safety:</b> The mutation test is not synchronized; concurrent access may cause issues</li>
     *   <li><b>False Negatives:</b> Collections that throw other exceptions (not {@code UnsupportedOperationException})
     *       during mutation are considered modifiable</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b>
     * <pre>{@code
     * // Null collection
     * isUnmodifiable((Collection) null);   // returns true
     *
     * // Unmodifiable collections
     * isUnmodifiable(Collections.emptyList());                           // returns true
     * isUnmodifiable(Collections.unmodifiableList(new ArrayList<>()));   // returns true
     * isUnmodifiable(List.of("a", "b"));                                 // returns true
     * isUnmodifiable(Collections.singleton("value"));                    // returns true
     *
     * // Modifiable collections
     * isUnmodifiable(new ArrayList<>());                                 // returns false
     * isUnmodifiable(new HashSet<>());                                   // returns false
     * isUnmodifiable(new LinkedList<>());                                // returns false
     *
     * // Cached behavior (second call uses cache)
     * Collection<String> c1 = new ArrayList<>();
     * isUnmodifiable(c1);  // performs mutation test
     * Collection<String> c2 = new ArrayList<>();
     * isUnmodifiable(c2);  // uses cached result from c1's class
     * }</pre>
     *
     * <p><b>Exception Handling:</b>
     * <ul>
     *   <li>{@code UnsupportedOperationException}: Collection is unmodifiable → returns {@code true}</li>
     *   <li>Any other exception: Collection is assumed modifiable → returns {@code false}</li>
     * </ul>
     *
     * @param c the Collection to check, may be {@code null}
     * @return {@code true} if the Collection is {@code null} or unmodifiable (throws {@code UnsupportedOperationException}
     *         on mutation attempts), {@code false} if the Collection is modifiable or throws other exceptions
     * @see #isUnmodifiable(Map)
     * @see #unmodifiableCollection(Collection)
     * @see #unmodifiableList(List)
     * @see #unmodifiableSet(Set)
     * @see Collections#unmodifiableCollection(Collection)
     * @see UnsupportedOperationException
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static boolean isUnmodifiable(final Collection c) {
        if (c == null) {
            return true;
        }

        final Class<?> cls = c.getClass();
        Boolean b = UNMODIFIABLE_CLASSES.get(cls);

        if (b != null) {
            return b;
        }

        if (Immutable.class.isAssignableFrom(cls)) {
            b = true;
            UNMODIFIABLE_CLASSES.put(cls, b);
            return b;
        }

        final int sizeBefore = c.size();

        try {
            final Object obj = null; // N.NULL_MASK; class cast issue with some Collections

            c.add(obj);

            final int sizeAfter = c.size();

            if (sizeAfter > sizeBefore) {
                c.remove(obj);
            }

            b = false;
        } catch (UnsupportedOperationException e) {
            b = true;
        } catch (Exception e) {
            b = false;
        }

        UNMODIFIABLE_CLASSES.put(cls, b);

        return b;
    }

    /**
     * Checks if the specified {@code Map} is unmodifiable by attempting a mutation operation.
     *
     * <p>This method determines whether a Map instance is unmodifiable by performing a test
     * mutation: it attempts to add a temporary entry and then remove it. If this operation
     * throws an {@link UnsupportedOperationException}, the Map is classified as unmodifiable.
     *
     * <p><b>Detection Strategy:</b>
     * <ul>
     *   <li><b>Null Safety:</b> {@code null} maps are considered unmodifiable (returns {@code true})</li>
     *   <li><b>Caching:</b> Results are cached by class type to avoid repeated mutation tests</li>
     *   <li><b>Mutation Test:</b> Attempts {@code put()} and {@code remove()} with a sentinel value</li>
     *   <li><b>Exception Handling:</b> {@code UnsupportedOperationException} indicates unmodifiable</li>
     * </ul>
     *
     * <p><b>Recognized Unmodifiable Map Types:</b>
     * <ul>
     *   <li>{@link Collections#unmodifiableMap(Map)}</li>
     *   <li>{@link Collections#unmodifiableSortedMap(SortedMap)}</li>
     *   <li>{@link Collections#unmodifiableNavigableMap(NavigableMap)}</li>
     *   <li>{@link Collections#emptyMap()}</li>
     *   <li>{@link Collections#singletonMap(Object, Object)}</li>
     *   <li>{@link Map#of()} and related factory methods (Java 9+)</li>
     *   <li>Custom unmodifiable Map implementations throwing {@code UnsupportedOperationException}</li>
     * </ul>
     *
     * <p><b>Important Notes:</b>
     * <ul>
     *   <li><b>Side Effects:</b> Modifiable maps are temporarily mutated during the test (though changes are reverted)</li>
     *   <li><b>Thread Safety:</b> The mutation test is not synchronized; concurrent access may cause issues</li>
     *   <li><b>False Negatives:</b> Maps that throw other exceptions (not {@code UnsupportedOperationException})
     *       during mutation are considered modifiable</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b>
     * <pre>{@code
     * // Null map
     * isUnmodifiable((Map) null);   // returns true
     *
     * // Unmodifiable maps
     * isUnmodifiable(Collections.emptyMap());                         // returns true
     * isUnmodifiable(Collections.unmodifiableMap(new HashMap<>()));   // returns true
     * isUnmodifiable(Map.of("k", "v"));                               // returns true
     *
     * // Modifiable maps
     * isUnmodifiable(new HashMap<>());                                // returns false
     * isUnmodifiable(new TreeMap<>());                                // returns false
     * isUnmodifiable(new LinkedHashMap<>());                          // returns false
     *
     * // Cached behavior (second call uses cache)
     * Map<String, String> map1 = new HashMap<>();
     * isUnmodifiable(map1);  // performs mutation test
     * Map<String, String> map2 = new HashMap<>();
     * isUnmodifiable(map2);  // uses cached result from map1's class
     * }</pre>
     *
     * <p><b>Exception Handling:</b>
     * <ul>
     *   <li>{@code UnsupportedOperationException}: Map is unmodifiable → returns {@code true}</li>
     *   <li>Any other exception: Map is assumed modifiable → returns {@code false}</li>
     * </ul>
     *
     * @param m the Map to check, may be {@code null}
     * @return {@code true} if the Map is {@code null} or unmodifiable (throws {@code UnsupportedOperationException}
     *         on mutation attempts), {@code false} if the Map is modifiable or throws other exceptions
     * @see #isUnmodifiable(Collection)
     * @see #unmodifiableMap(Map)
     * @see Collections#unmodifiableMap(Map)
     * @see UnsupportedOperationException
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static boolean isUnmodifiable(final Map m) {
        if (m == null) {
            return true;
        }

        final Class<?> cls = m.getClass();

        Boolean b = UNMODIFIABLE_CLASSES.get(cls);

        if (b != null) {
            return b;
        }

        if (Immutable.class.isAssignableFrom(cls)) {
            b = true;
            UNMODIFIABLE_CLASSES.put(cls, b);
            return b;
        }

        final int sizeBefore = m.size();

        try {

            final Object key = null; // N.NULL_MASK cause class cast issue with some Maps
            final Object value = null; // N.NULL_MASK class cast issue with some Maps

            final Object oldValue = m.put(key, value);

            final int sizeAfter = m.size();

            if (oldValue != null) {
                m.put(key, oldValue);
            } else if (sizeAfter > sizeBefore) {
                m.remove(key);
            }

            b = false;
        } catch (UnsupportedOperationException e) {
            b = true;
        } catch (Exception e) {
            b = false;
        }

        UNMODIFIABLE_CLASSES.put(cls, b);

        return b;
    }

    /**
     * Returns an unmodifiable view of the specified {@code Collection}.
     * <p>
     * This method optimizes the unmodifiable collection creation by:
     * <ul>
     *   <li>Returning an empty list if the input collection is {@code null}</li>
     *   <li>Returning the original collection if it's already known to be unmodifiable</li>
     *   <li>Returning the original collection if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the collection in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the collection unchanged (already unmodifiable)
     * Collection<String> immutable = List.of("a", "b", "c");
     * Collection<String> result = N.unmodifiableCollection(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * Collection<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
     * Collection<String> unmodifiable = N.unmodifiableCollection(list);
     * // unmodifiable.add("d");  // throws UnsupportedOperationException
     *
     * // Returns empty list for null input
     * N.unmodifiableCollection(null);  // returns empty list
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the {@code Collection} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified collection, or an empty list if {@code null}
     *
     * @see Collections#unmodifiableCollection(Collection)
     * @see #isUnmodifiable(Collection)
     * @see Immutable
     */
    public static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> c) {
        if (c == null) {
            return emptyList();
        }

        final Class<?> cls = c.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (Collection<T>) c;
        }

        return Collections.unmodifiableCollection(c);
    }

    /**
     * Returns an unmodifiable view of the specified {@code List}.
     * <p>
     * This method optimizes the unmodifiable list creation by:
     * <ul>
     *   <li>Returning an empty list if the input list is {@code null}</li>
     *   <li>Returning the original list if it's already known to be unmodifiable</li>
     *   <li>Returning the original list if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the list in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the list unchanged (already unmodifiable)
     * List<String> immutable = List.of("a", "b", "c");
     * List<String> result = N.unmodifiableList(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * List<String> mutableList = new ArrayList<>(Arrays.asList("a", "b", "c"));
     * List<String> unmodifiable = N.unmodifiableList(mutableList);
     * // unmodifiable.add("d");  // throws UnsupportedOperationException
     *
     * // Returns empty list for null input
     * N.unmodifiableList(null);  // returns empty list
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the {@code List} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified list, or an empty list if {@code null}
     *
     * @see Collections#unmodifiableList(List)
     * @see #isUnmodifiable(Collection)
     * @see Immutable
     */
    public static <T> List<T> unmodifiableList(final List<? extends T> list) {
        if (list == null) {
            return emptyList();
        }

        final Class<?> cls = list.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (List<T>) list;
        }

        return Collections.unmodifiableList(list);
    }

    /**
     * Returns an unmodifiable view of the specified {@code Set}.
     * <p>
     * This method optimizes the unmodifiable set creation by:
     * <ul>
     *   <li>Returning an empty set if the input set is {@code null}</li>
     *   <li>Returning the original set if it's already known to be unmodifiable</li>
     *   <li>Returning the original set if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the set in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the set unchanged (already unmodifiable)
     * Set<String> immutable = Set.of("a", "b", "c");
     * Set<String> result = N.unmodifiableSet(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * Set<String> mutableSet = new HashSet<>(Arrays.asList("a", "b", "c"));
     * Set<String> unmodifiable = N.unmodifiableSet(mutableSet);
     * // unmodifiable.add("d");  // throws UnsupportedOperationException
     *
     * // Returns empty set for null input
     * N.unmodifiableSet(null);  // returns empty set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the {@code Set} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified set, or an empty set if {@code null}
     *
     * @see Collections#unmodifiableSet(Set)
     * @see #isUnmodifiable(Collection)
     * @see Immutable
     */
    public static <T> Set<T> unmodifiableSet(final Set<? extends T> set) {
        if (set == null) {
            return emptySet();
        }

        final Class<?> cls = set.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (Set<T>) set;
        }

        return Collections.unmodifiableSet(set);
    }

    /**
     * Returns an unmodifiable view of the specified {@code SortedSet}.
     * <p>
     * This method optimizes the unmodifiable sorted set creation by:
     * <ul>
     *   <li>Returning an empty sorted set if the input set is {@code null}</li>
     *   <li>Returning the original set if it's already known to be unmodifiable</li>
     *   <li>Returning the original set if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the set in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the set unchanged (already unmodifiable)
     * SortedSet<String> immutable = Collections.unmodifiableSortedSet(new TreeSet<>(Arrays.asList("a", "b", "c")));
     * SortedSet<String> result = N.unmodifiableSortedSet(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * SortedSet<String> mutableSet = new TreeSet<>(Arrays.asList("a", "b", "c"));
     * SortedSet<String> unmodifiable = N.unmodifiableSortedSet(mutableSet);
     * // unmodifiable.add("d");  // throws UnsupportedOperationException
     *
     * // Returns empty sorted set for null input
     * N.unmodifiableSortedSet(null);  // returns empty sorted set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the {@code SortedSet} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified sorted set, or an empty sorted set if {@code null}
     *
     * @see Collections#unmodifiableSortedSet(SortedSet)
     * @see #isUnmodifiable(Collection)
     * @see Immutable
     */
    public static <T> SortedSet<T> unmodifiableSortedSet(final SortedSet<T> set) {
        if (set == null) {
            return emptySortedSet();
        }

        final Class<?> cls = set.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return set;
        }

        return Collections.unmodifiableSortedSet(set);
    }

    /**
     * Returns an unmodifiable view of the specified {@code NavigableSet}.
     * <p>
     * This method optimizes the unmodifiable navigable set creation by:
     * <ul>
     *   <li>Returning an empty navigable set if the input set is {@code null}</li>
     *   <li>Returning the original set if it's already known to be unmodifiable</li>
     *   <li>Returning the original set if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the set in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the set unchanged (already unmodifiable)
     * NavigableSet<String> immutable = Collections.unmodifiableNavigableSet(new TreeSet<>(Arrays.asList("a", "b", "c")));
     * NavigableSet<String> result = N.unmodifiableNavigableSet(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * NavigableSet<String> mutableSet = new TreeSet<>(Arrays.asList("a", "b", "c"));
     * NavigableSet<String> unmodifiable = N.unmodifiableNavigableSet(mutableSet);
     * // unmodifiable.add("d");  // throws UnsupportedOperationException
     *
     * // Returns empty navigable set for null input
     * N.unmodifiableNavigableSet(null);  // returns empty navigable set
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param set the {@code NavigableSet} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified navigable set, or an empty navigable set if {@code null}
     *
     * @see Collections#unmodifiableNavigableSet(NavigableSet)
     * @see #isUnmodifiable(Collection)
     * @see Immutable
     */
    public static <T> NavigableSet<T> unmodifiableNavigableSet(final NavigableSet<T> set) {
        if (set == null) {
            return emptyNavigableSet();
        }

        final Class<?> cls = set.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return set;
        }

        return Collections.unmodifiableNavigableSet(set);
    }

    /**
     * Returns an unmodifiable view of the specified {@code Map}.
     * <p>
     * This method optimizes the unmodifiable map creation by:
     * <ul>
     *   <li>Returning an empty map if the input map is {@code null}</li>
     *   <li>Returning the original map if it's already known to be unmodifiable</li>
     *   <li>Returning the original map if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the map in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the map unchanged (already unmodifiable)
     * Map<String, Integer> immutable = Collections.unmodifiableMap(Map.of("a", 1, "b", 2));
     * Map<String, Integer> result = N.unmodifiableMap(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * Map<String, Integer> mutableMap = new HashMap<>();
     * mutableMap.put("a", 1);
     * Map<String, Integer> unmodifiable = N.unmodifiableMap(mutableMap);
     * // unmodifiable.put("c", 3);  // throws UnsupportedOperationException
     *
     * // Returns empty map for null input
     * N.unmodifiableMap(null);  // returns empty map
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param m the {@code Map} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified map, or an empty map if {@code null}
     *
     * @see Collections#unmodifiableMap(Map)
     * @see #isUnmodifiable(Map)
     * @see Immutable
     */
    public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> m) {
        if (m == null) {
            return emptyMap();
        }

        final Class<?> cls = m.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (Map<K, V>) m;
        }

        return Collections.unmodifiableMap(m);
    }

    /**
     * Returns an unmodifiable view of the specified {@code SortedMap}.
     * <p>
     * This method optimizes the unmodifiable sorted map creation by:
     * <ul>
     *   <li>Returning an empty sorted map if the input map is {@code null}</li>
     *   <li>Returning the original map if it's already known to be unmodifiable</li>
     *   <li>Returning the original map if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the map in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the map unchanged (already unmodifiable)
     * SortedMap<String, Integer> immutable = Collections.unmodifiableSortedMap(new TreeMap<>(Map.of("a", 1, "b", 2)));
     * SortedMap<String, Integer> result = N.unmodifiableSortedMap(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * SortedMap<String, Integer> mutableMap = new TreeMap<>();
     * mutableMap.put("a", 1);
     * SortedMap<String, Integer> unmodifiable = N.unmodifiableSortedMap(mutableMap);
     * // unmodifiable.put("c", 3);  // throws UnsupportedOperationException
     *
     * // Returns empty sorted map for null input
     * N.unmodifiableSortedMap(null);  // returns empty sorted map
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param m the {@code SortedMap} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified sorted map, or an empty sorted map if {@code null}
     *
     * @see Collections#unmodifiableSortedMap(SortedMap)
     * @see #isUnmodifiable(Map)
     * @see Immutable
     */
    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> m) {
        if (m == null) {
            return emptySortedMap();
        }

        final Class<?> cls = m.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (SortedMap<K, V>) m;
        }

        return Collections.unmodifiableSortedMap(m);
    }

    /**
     * Returns an unmodifiable view of the specified {@code NavigableMap}.
     * <p>
     * This method optimizes the unmodifiable navigable map creation by:
     * <ul>
     *   <li>Returning an empty navigable map if the input map is {@code null}</li>
     *   <li>Returning the original map if it's already known to be unmodifiable</li>
     *   <li>Returning the original map if it implements the {@code Immutable} interface</li>
     *   <li>Wrapping the map in an unmodifiable wrapper otherwise</li>
     * </ul>
     *
     * <p><b>Examples:</b>
     * <pre>{@code
     * // Returns the map unchanged (already unmodifiable)
     * NavigableMap<String, Integer> immutable = Collections.unmodifiableNavigableMap(new TreeMap<>(Map.of("a", 1, "b", 2)));
     * NavigableMap<String, Integer> result = N.unmodifiableNavigableMap(immutable);  // same instance
     *
     * // Returns an unmodifiable wrapper
     * NavigableMap<String, Integer> mutableMap = new TreeMap<>();
     * mutableMap.put("a", 1);
     * NavigableMap<String, Integer> unmodifiable = N.unmodifiableNavigableMap(mutableMap);
     * // unmodifiable.put("c", 3);  // throws UnsupportedOperationException
     *
     * // Returns empty navigable map for null input
     * N.unmodifiableNavigableMap(null);  // returns empty navigable map
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param m the {@code NavigableMap} to wrap, may be {@code null}
     * @return an unmodifiable view of the specified navigable map, or an empty navigable map if {@code null}
     *
     * @see Collections#unmodifiableNavigableMap(NavigableMap)
     * @see #isUnmodifiable(Map)
     * @see Immutable
     */
    public static <K, V> NavigableMap<K, V> unmodifiableNavigableMap(final NavigableMap<K, ? extends V> m) {
        if (m == null) {
            return emptyNavigableMap();
        }

        final Class<?> cls = m.getClass();

        if (UNMODIFIABLE_CLASSES.getOrDefault(cls, false) || Immutable.class.isAssignableFrom(cls)) {
            return (NavigableMap<K, V>) m;
        }

        return Collections.unmodifiableNavigableMap(m);
    }

    /**
     * Invokes the specified constructor with the provided arguments to create new instances of a class.
     *
     * @param <T> the type of the object to be created.
     * @param c the Constructor object representing the constructor to be invoked; must not be {@code null}
     * @param args the array of arguments to be passed to the constructor. It can be empty if the constructor takes no arguments.
     * @return a new instance of the class that the constructor belongs to.
     * @throws InstantiationException if the class that declares the underlying constructor represents an abstract class.
     * @throws IllegalAccessException if this Constructor object enforces Java language access control and the underlying constructor is inaccessible.
     * @throws IllegalArgumentException if the number of actual and formal parameters differ, or if an unwrapping conversion for primitive arguments fails.
     * @throws InvocationTargetException if the underlying constructor throws an exception.
     */
    @SuppressWarnings({ "deprecation" })
    static <T> T invoke(final Constructor<T> c, final Object... args)
            throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        if (!c.isAccessible()) {
            ClassUtil.setAccessibleQuietly(c, true);
        }

        return c.newInstance(args);
    }

    /**
     * Creates a new proxy instance for the specified interface using the provided invocation handler.
     *
     * This method is a utility for creating dynamic proxies. A dynamic proxy class is a class that implements a list of interfaces specified at runtime such that a method invocation through one of the interfaces on an instance of the class will be encoded and dispatched to another object through a uniform interface.
     * Thus, a dynamic proxy class can be used to create an object that can implement an arbitrary set of interfaces specified at runtime.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * MyInterface proxy = N.newProxyInstance(MyInterface.class, (proxy, method, args) -> {
     *     System.out.println("Method called: " + method.getName());
     *     return null;
     * });
     * proxy.someMethod();   // prints "Method called: someMethod"
     * }</pre>
     *
     * @param <T> the type of the interface for the proxy class to implement.
     * @param interfaceClass the Class object of the interface for the proxy class to implement; must not be {@code null}
     * @param h the invocation handler to dispatch method invocations to. It's an object that implements the InvocationHandler interface.
     * @return a proxy instance that implements the specified interface(s) and dispatches method invocations to the specified invocation handler.
     * @see java.lang.reflect.Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)
     */
    public static <T> T newProxyInstance(final Class<T> interfaceClass, final InvocationHandler h) {
        return newProxyInstance(asArray(interfaceClass), h);
    }

    /**
     * Creates a new proxy instance for the specified interfaces using the provided invocation handler.
     *
     * This method is a utility for creating dynamic proxies. A dynamic proxy class is a class that implements a list of interfaces specified at runtime such that a method invocation through one of the interfaces on an instance of the class will be encoded and dispatched to another object through a uniform interface.
     * Thus, a dynamic proxy class can be used to create an object that can implement an arbitrary set of interfaces specified at runtime.
     *
     * @param <T> the type of the interface for the proxy class to implement.
     * @param interfaceClasses the array of Class objects of the interfaces for the proxy class to implement; must not be {@code null}
     * @param h the invocation handler to dispatch method invocations to. It's an object that implements the InvocationHandler interface.
     * @return a proxy instance that implements the specified interface(s) and dispatches method invocations to the specified invocation handler.
     * @see java.lang.reflect.Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)
     */
    public static <T> T newProxyInstance(final Class<?>[] interfaceClasses, final InvocationHandler h) {
        ClassLoader classLoader = CommonUtil.class.getClassLoader();

        if (interfaceClasses != null && interfaceClasses.length > 0) {
            classLoader = interfaceClasses[0].getClassLoader();

            if (classLoader == null) {
                classLoader = CommonUtil.class.getClassLoader();
            }
        }

        return (T) Proxy.newProxyInstance(classLoader, interfaceClasses, h); // NOSONAR
    }

    /**
     * Creates a new instance of the specified class.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Create a new instance of a simple class
     * MyClass obj = N.newInstance(MyClass.class);
     *
     * // Create a new instance of a collection type
     * List<String> list = N.newInstance(ArrayList.class);
     *
     * // Create a new instance of a map type
     * Map<String, Integer> map = N.newInstance(HashMap.class);
     * }</pre>
     *
     * @param <T> the type of the object to be created
     * @param cls the class of the object to be created
     * @return a new instance of the specified class
     * @throws IllegalArgumentException if the class is abstract or cannot be instantiated
     * @see Suppliers#ofCollection(Class)
     * @see Suppliers#registerForCollection(Class, java.util.function.Supplier)
     * @see Suppliers#ofMap(Class)
     * @see Suppliers#registerForMap(Class, java.util.function.Supplier)
     * @see IntFunctions#ofCollection(Class)
     * @see IntFunctions#registerForCollection(Class, java.util.function.IntFunction)
     * @see IntFunctions#ofMap(Class)
     * @see IntFunctions#registerForMap(Class, java.util.function.IntFunction)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T newInstance(final Class<T> cls) {
        if (Modifier.isAbstract(cls.getModifiers())) {
            if (Collection.class.isAssignableFrom(cls)) {
                return (T) Suppliers.ofCollection((Class<Collection>) cls).get();
            } else if (Map.class.isAssignableFrom(cls)) {
                return (T) Suppliers.ofMap((Class<Map>) cls).get();
            } else {
                throw new IllegalArgumentException("Can't create instance for abstract class: " + cls);
            }
        }

        if (!Modifier.isStatic(cls.getModifiers()) && ClassUtil.isAnonymousOrMemberClass(cls)) {
            try {
                // http://stackoverflow.com/questions/2097982/is-it-possible-to-create-an-instance-of-nested-class-using-java-reflection

                final List<Class<?>> toInstantiate = new ArrayList<>();
                Class<?> parent = cls.getEnclosingClass();

                do {
                    toInstantiate.add(parent);
                    parent = parent.getEnclosingClass();
                } while (parent != null && !Modifier.isStatic(parent.getModifiers()) && ClassUtil.isAnonymousOrMemberClass(parent));

                //    if (parent != null) {
                //        toInstantiate.add(parent);
                //    }

                reverse(toInstantiate);

                Object instance = null;
                for (final Class<?> current : toInstantiate) {
                    instance = instance == null ? invoke(ClassUtil.getDeclaredConstructor(current))
                            : invoke(ClassUtil.getDeclaredConstructor(current, instance.getClass()), instance);
                }

                //noinspection DataFlowIssue
                return invoke(ClassUtil.getDeclaredConstructor(cls, instance.getClass()), instance);
            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                throw ExceptionUtil.toRuntimeException(e, true);
            }
        } else {
            try {
                final Constructor<T> constructor = ClassUtil.getDeclaredConstructor(cls);

                if (constructor == null) {
                    throw new IllegalArgumentException("No default constructor found in class: " + ClassUtil.getCanonicalClassName(cls));
                }

                return invoke(constructor);
            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                throw ExceptionUtil.toRuntimeException(e, true);
            }
        }
    }

    /**
     * Creates a new collection of the specified type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<String> list = N.newCollection(ArrayList.class);
     * Collection<String> set = N.newCollection(HashSet.class);
     * Collection<String> linkedList = N.newCollection(LinkedList.class);
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param targetType the class of the collection to be created
     * @return a new collection of the specified type
     * @see Suppliers#ofCollection(Class)
     * @see Suppliers#registerForCollection(Class, java.util.function.Supplier)
     */
    @SuppressWarnings("rawtypes")
    public static <T> Collection<T> newCollection(final Class<? extends Collection> targetType) {
        return Suppliers.<T> ofCollection(targetType).get();
    }

    /**
     * Creates a new collection of the specified type with the given initial size.
     *
     * @param <T> the type of elements in the collection
     * @param targetType the class of the collection to be created
     * @param size the initial size of the collection
     * @return a new collection of the specified type with the given initial size
     * @see IntFunctions#ofCollection(Class)
     * @see IntFunctions#registerForCollection(Class, java.util.function.IntFunction)
     */
    @SuppressWarnings("rawtypes")
    public static <T> Collection<T> newCollection(final Class<? extends Collection> targetType, final int size) {
        return IntFunctions.<T> ofCollection(targetType).apply(size);
    }

    /**
     * Creates a new map of the specified type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> hashMap = N.newMap(HashMap.class);
     * Map<String, Integer> linkedMap = N.newMap(LinkedHashMap.class);
     * Map<String, Integer> treeMap = N.newMap(TreeMap.class);
     * }</pre>
     *
     * @param <K> the type of keys maintained by the map
     * @param <V> the type of mapped values
     * @param targetType the class of the map to be created
     * @return a new map of the specified type
     * @see Suppliers#ofMap(Class)
     * @see Suppliers#registerForMap(Class, java.util.function.Supplier)
     */
    @SuppressWarnings("rawtypes")
    public static <K, V> Map<K, V> newMap(final Class<? extends Map> targetType) {
        return Suppliers.<K, V> ofMap(targetType).get();
    }

    /**
     * Creates a new map of the specified type with the given initial size.
     *
     * @param <K> the type of keys maintained by the map
     * @param <V> the type of mapped values
     * @param targetType the class of the map to be created
     * @param size the initial size of the map
     * @return a new map of the specified type with the given initial size
     * @see IntFunctions#ofMap(Class)
     * @see IntFunctions#registerForMap(Class, java.util.function.IntFunction)
     */
    @SuppressWarnings("rawtypes")
    public static <K, V> Map<K, V> newMap(final Class<? extends Map> targetType, final int size) {
        return IntFunctions.<K, V> ofMap(targetType).apply(size);
    }

    /**
     * Creates a new array of the specified component type and length.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] strArr = N.newArray(String.class, 5);
     * // strArr is a String array of length 5
     *
     * int[] intArr = N.newArray(int.class, 10);
     * // intArr is an int array of length 10
     * }</pre>
     *
     * @param <T> the type of the array elements
     * @param componentType the class of the component type of the array
     * @param length the length of the new array
     * @return a new array of the specified component type and length
     * @throws NegativeArraySizeException if the specified length is negative
     * @see java.lang.reflect.Array#newInstance(Class, int)
     */
    public static <T> T newArray(final Class<?> componentType, final int length) {
        return Array.newInstance(componentType, length);
    }

    /**
     * Creates a new array of the specified component type and dimensions.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[][] matrix = N.newArray(int.class, 3, 4);
     * // Creates a 3x4 two-dimensional int array
     *
     * String[][][] cube = N.newArray(String.class, 2, 3, 4);
     * // Creates a 2x3x4 three-dimensional String array
     * }</pre>
     *
     * @param <T> the type of the array elements
     * @param componentType the class of the component type of the array
     * @param dimensions the dimensions of the new array
     * @return a new array of the specified component type and dimensions
     * @throws IllegalArgumentException if the specified component type is {@code null} or if the dimensions are invalid
     * @throws NegativeArraySizeException if any of the specified dimensions are negative
     * @see java.lang.reflect.Array#newInstance(Class, int...)
     */
    public static <T> T newArray(final Class<?> componentType, final int... dimensions) throws IllegalArgumentException, NegativeArraySizeException {
        return Array.newInstance(componentType, dimensions);
    }

    @Deprecated
    @Internal
    @Beta
    static int initHashCapacity(final int size) {
        checkArgNotNegative(size, cs.size);

        if (size == 0) {
            return 0;
        }

        final int res = size < MAX_HASH_LENGTH ? (int) (size * 1.25) + 1 : MAX_ARRAY_SIZE;

        return res >= 1024 ? res : (Math.min(res, 256));
    }

    /**
     * Creates a new instance of an ArrayList.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ArrayList<String> list = N.newArrayList();
     * list.add("element");
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @return a new instance of an ArrayList
     */
    public static <T> ArrayList<T> newArrayList() { //NOSONAR
        return new ArrayList<>();
    }

    /**
     * Creates a new instance of an ArrayList with the specified initial capacity.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ArrayList<String> list = N.newArrayList(100);
     * // Creates an ArrayList with initial capacity of 100
     * list.add("element");
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param initialCapacity the initial capacity of the list
     * @return a new instance of an ArrayList with the specified initial capacity
     * @see java.util.ArrayList#ArrayList(int)
     */
    public static <T> ArrayList<T> newArrayList(final int initialCapacity) { //NOSONAR
        return new ArrayList<>(initialCapacity);
    }

    /**
     * Creates a new instance of an ArrayList with the elements from the specified collection.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
     * ArrayList<String> list = N.newArrayList(set);
     * // list contains ["a", "b", "c"] in some order
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param c the collection whose elements are to be placed into this list
     * @return a new instance of an ArrayList containing the elements from the specified collection
     * @see java.util.ArrayList#ArrayList(Collection)
     */
    public static <T> ArrayList<T> newArrayList(final Collection<? extends T> c) { //NOSONAR
        return isEmpty(c) ? new ArrayList<>() : new ArrayList<>(c);
    }

    /**
     * Creates a new instance of a LinkedList.
     *
     * @param <T> the type of elements in the list
     * @return a new instance of a LinkedList
     */
    public static <T> LinkedList<T> newLinkedList() { //NOSONAR
        return new LinkedList<>();
    }

    /**
     * Creates a new instance of a LinkedList with the elements from the specified collection.
     *
     * @param <T> the type of elements in the list
     * @param c the collection whose elements are to be placed into this list
     * @return a new instance of a LinkedList containing the elements from the specified collection
     * @see java.util.LinkedList#LinkedList(Collection)
     */
    public static <T> LinkedList<T> newLinkedList(final Collection<? extends T> c) { //NOSONAR
        return isEmpty(c) ? new LinkedList<>() : new LinkedList<>(c);
    }

    /**
     * Creates a new instance of a HashSet.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> set = N.newHashSet();
     * set.add("element");
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @return a new instance of a HashSet
     */
    public static <T> Set<T> newHashSet() {
        return new HashSet<>();
    }

    /**
     * Creates a new instance of a HashSet with the specified initial capacity.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> set = N.newHashSet(100);
     * // Creates a HashSet with initial capacity of 100
     * set.add("element");
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param initialCapacity the initial capacity of the set
     * @return a new instance of a HashSet with the specified initial capacity
     * @see java.util.HashSet#HashSet(int)
     */
    public static <T> Set<T> newHashSet(final int initialCapacity) {
        return new HashSet<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of a HashSet with the elements from the specified collection.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c", "a");
     * Set<String> set = N.newHashSet(list);
     * // set contains ["a", "b", "c"] - duplicates removed
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @param c the collection whose elements are to be placed into this set
     * @return a new instance of a HashSet containing the elements from the specified collection
     * @see java.util.HashSet#HashSet(Collection)
     */
    public static <T> Set<T> newHashSet(final Collection<? extends T> c) {
        return isEmpty(c) ? new HashSet<>() : new HashSet<>(c);
    }

    /**
     * Creates a new instance of a LinkedHashSet.
     *
     * @param <T> the type of elements in the set
     * @return a new instance of a HashSet
     */
    public static <T> Set<T> newLinkedHashSet() {
        return new LinkedHashSet<>();
    }

    /**
     * Creates a new instance of a LinkedHashSet with the specified initial capacity.
     *
     * @param <T> the type of elements in the set
     * @param initialCapacity the initial capacity of the set
     * @return a new instance of a LinkedHashSet with the specified initial capacity
     * @see java.util.LinkedHashSet#LinkedHashSet(int)
     */
    public static <T> Set<T> newLinkedHashSet(final int initialCapacity) {
        return new LinkedHashSet<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of a LinkedHashSet with the elements from the specified collection.
     *
     * @param <T> the type of elements in the set
     * @param c the collection whose elements are to be placed into this set
     * @return a new instance of a LinkedHashSet containing the elements from the specified collection
     * @see java.util.LinkedHashSet#LinkedHashSet(Collection)
     */
    public static <T> Set<T> newLinkedHashSet(final Collection<? extends T> c) {
        return isEmpty(c) ? new LinkedHashSet<>() : new LinkedHashSet<>(c);
    }

    /**
     * Creates a new instance of a TreeSet.
     *
     * @param <T> the type of elements in the set
     * @return a new instance of a TreeSet
     */
    public static <T extends Comparable<? super T>> TreeSet<T> newTreeSet() { //NOSONAR
        return new TreeSet<>();
    }

    /**
     * Creates a new instance of a TreeSet with the specified comparator.
     *
     * @param <T> the type of elements in the set
     * @param comparator the comparator that will be used to order this set.
     * @return a new instance of a TreeSet
     * @see java.util.TreeSet#TreeSet(Comparator)
     */
    public static <T> TreeSet<T> newTreeSet(final Comparator<? super T> comparator) { //NOSONAR
        return new TreeSet<>(comparator);
    }

    /**
     * Creates a new instance of a TreeSet with the elements from the specified collection.
     *
     * @param <T> the type of elements in the set
     * @param c the collection whose elements are to be placed into this set
     * @return a new instance of a TreeSet containing the elements from the specified collection
     * @see java.util.TreeSet#TreeSet(Collection)
     */
    public static <T extends Comparable<? super T>> TreeSet<T> newTreeSet(final Collection<? extends T> c) { //NOSONAR
        return isEmpty(c) ? new TreeSet<>() : new TreeSet<>(c);
    }

    /**
     * Creates a new instance of a concurrent hash set by {@code ConcurrentHashMap}.
     * This set is thread-safe and suitable for concurrent access.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> concurrentSet = N.newConcurrentHashSet();
     * concurrentSet.add("element");
     * // Safe to use from multiple threads
     * }</pre>
     *
     * @param <T> the type of elements in the set
     * @return a new instance of a concurrent hash set
     * @see Collections#newSetFromMap(Map)
     * @see java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap()
     */
    public static <T> Set<T> newConcurrentHashSet() {
        return newSetFromMap(new ConcurrentHashMap<>());
    }

    /**
     * Creates a new instance of a concurrent hash set with the specified initial capacity.
     *
     * @param <T> the type of elements in the set
     * @param initialCapacity the initial capacity of the set
     * @return a new instance of a concurrent hash set
     * @see Collections#newSetFromMap(Map)
     * @see java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)
     */
    public static <T> Set<T> newConcurrentHashSet(final int initialCapacity) {
        return newSetFromMap(new ConcurrentHashMap<>(initialCapacity));
    }

    /**
     * Creates a new instance of a concurrent hash set with the elements from the specified collection.
     *
     * @param <T> the type of elements in the set
     * @param c the collection whose elements are to be placed into this set
     * @return a new instance of a concurrent hash set containing the elements from the specified collection
     * @see Collections#newSetFromMap(Map)
     * @see java.util.concurrent.ConcurrentHashMap#ConcurrentHashMap(int)
     */
    public static <T> Set<T> newConcurrentHashSet(final Collection<? extends T> c) {
        final int size = size(c);
        final Set<T> ret = newSetFromMap(new ConcurrentHashMap<>(size));

        if (size > 0) {
            ret.addAll(c);
        }

        return ret;
    }

    /**
     * Returns a set backed by the specified map.
     *
     * @param <E> the type of elements in the set
     * @param map the backing map
     * @return a set backed by the specified map
     * @see Collections#newSetFromMap(Map)
     */
    public static <E> Set<E> newSetFromMap(final Map<E, Boolean> map) {
        return Collections.newSetFromMap(map);
    }

    /**
     * Creates a new instance of a Multiset.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Multiset<String> multiset = N.newMultiset();
     * multiset.add("apple");
     * multiset.add("apple");
     * multiset.add("banana");
     * multiset.occurrencesOf("apple");    // returns 2
     * multiset.occurrencesOf("banana");   // returns 1
     * }</pre>
     *
     * @param <T> the type of elements in the multiset
     * @return a new instance of a Multiset
     */
    public static <T> Multiset<T> newMultiset() {
        return new Multiset<>();
    }

    /**
     * Creates a new instance of a Multiset with the specified initial capacity.
     *
     * @param <T> the type of elements in the multiset
     * @param initialCapacity the initial capacity of the multiset
     * @return a new instance of a Multiset with the specified initial capacity
     */
    public static <T> Multiset<T> newMultiset(final int initialCapacity) {
        return new Multiset<>(initialCapacity);
    }

    /**
     * Creates a new instance of a Multiset with the specified backed Map type for storing element/occurrence pairs.
     *
     * @param <T> the type of elements in the multiset
     * @param valueMapType the class of the map to be used to store element/occurrence pairs
     * @return a new instance of a Multiset with the specified value map type
     */
    @SuppressWarnings("rawtypes")
    public static <T> Multiset<T> newMultiset(final Class<? extends Map> valueMapType) {
        return new Multiset<>(valueMapType);
    }

    /**
     * Creates a new instance of a Multiset with the specified {@code Supplier} which provides the map to store element/occurrence pairs.
     *
     * @param <T> the type of elements in the multiset
     * @param mapSupplier the supplier that provides the map to be used to store element/occurrence pairs
     * @return a new instance of a Multiset with the specified value map type
     */
    public static <T> Multiset<T> newMultiset(final Supplier<? extends Map<T, ?>> mapSupplier) {
        return new Multiset<>(mapSupplier);
    }

    /**
     * Creates a new instance of a Multiset with the elements from the specified collection.
     *
     * @param <T> the type of elements in the multiset
     * @param c the collection whose elements are to be placed into this multiset
     * @return a new instance of a Multiset containing the elements from the specified collection
     */
    public static <T> Multiset<T> newMultiset(final Collection<? extends T> c) {
        return new Multiset<>(c);
    }

    /**
     * Creates a new instance of an ArrayDeque.
     *
     * @param <T> the type of elements in the deque
     * @return a new instance of an ArrayDeque
     */
    public static <T> ArrayDeque<T> newArrayDeque() { //NOSONAR
        return new ArrayDeque<>();
    }

    /**
     * Creates a new instance of an ArrayDeque with the specified initial capacity.
     *
     * @param <T> the type of elements in the deque
     * @param numElements the initial capacity of the deque
     * @return a new instance of an ArrayDeque with the specified initial capacity
     */
    public static <T> ArrayDeque<T> newArrayDeque(final int numElements) { //NOSONAR
        return new ArrayDeque<>(numElements);
    }

    /**
     * Creates a new instance of an ArrayDeque with the elements from the specified collection.
     *
     * @param <E> the type of elements in the deque
     * @param c the collection whose elements are to be placed into this deque
     * @return a new instance of an ArrayDeque containing the elements from the specified collection
     */
    public static <E> ArrayDeque<E> newArrayDeque(final Collection<? extends E> c) { //NOSONAR
        return new ArrayDeque<>(c);
    }

    /**
     * Creates a new entry with the specified key and value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map.Entry<String, Integer> entry = N.newEntry("key", 1);
     * entry.getKey();      // returns "key"
     * entry.getValue();    // returns 1
     * entry.setValue(2);   // modifies the value to 2
     * }</pre>
     *
     * @param <K> the type of keys maintained by this entry
     * @param <V> the type of mapped values
     * @param key the key to be associated with the entry
     * @param value the value to be associated with the entry
     * @return a new entry with the specified key and value
     */
    public static <K, V> Map.Entry<K, V> newEntry(final K key, final V value) {
        return new AbstractMap.SimpleEntry<>(key, value);
    }

    /**
     * Creates a new immutable entry with the specified key and value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ImmutableEntry<String, Integer> entry = N.newImmutableEntry("key", 1);
     * entry.getKey();     // returns "key"
     * entry.getValue();   // returns 1
     * // entry.setValue(2);   // throws UnsupportedOperationException
     * }</pre>
     *
     * @param <K> the type of keys maintained by this entry
     * @param <V> the type of mapped values
     * @param key the key to be associated with the entry
     * @param value the value to be associated with the entry
     * @return a new immutable entry with the specified key and value
     */
    public static <K, V> ImmutableEntry<K, V> newImmutableEntry(final K key, final V value) {
        return new ImmutableEntry<>(key, value);
    }

    /**
     * Creates a new instance of a HashMap.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = N.newHashMap();
     * map.put("key", 1);
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @return a new instance of a HashMap
     */
    public static <K, V> Map<K, V> newHashMap() {
        return new HashMap<>();
    }

    /**
     * Creates a new instance of a HashMap with the specified initial capacity.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = N.newHashMap(100);
     * // Creates a HashMap with initial capacity of 100
     * map.put("key", 1);
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @return a new instance of a HashMap with the specified initial capacity
     */
    public static <K, V> Map<K, V> newHashMap(final int initialCapacity) {
        return new HashMap<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of a HashMap with the entries from the specified map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * TreeMap<String, Integer> treeMap = new TreeMap<>();
     * treeMap.put("a", 1);
     * treeMap.put("b", 2);
     * Map<String, Integer> hashMap = N.newHashMap(treeMap);
     * // hashMap contains {"a"=1, "b"=2}
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param m the map whose elements are to be placed into this map
     * @return a new instance of a HashMap containing the entries from the specified map
     */
    public static <K, V> Map<K, V> newHashMap(final Map<? extends K, ? extends V> m) {
        return isEmpty(m) ? new HashMap<>() : new HashMap<>(m);
    }

    /**
     * Creates a new instance of a HashMap with the elements from the specified collection.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param c the collection whose elements are to be placed into this map
     * @param keyExtractor the function to extract a key from a collection element
     * @return a new instance of a HashMap containing the elements from the specified collection
     * @see #toMap(Iterable, Function)
     * @see #toMap(Iterable, Function, Function)
     * @see #toMap(Iterable, Function, Function, IntFunction)
     * @see #toMap(Iterable, Function, Function, BiFunction, IntFunction)
     */
    public static <K, V> Map<K, V> newHashMap(final Collection<? extends V> c, final Function<? super V, ? extends K> keyExtractor)
            throws IllegalArgumentException {
        // checkArgNotNull(keyExtractor);

        if (isEmpty(c)) {
            return new HashMap<>();
        }

        final Map<K, V> result = newHashMap(c.size());

        for (final V v : c) {
            result.put(keyExtractor.apply(v), v);
        }

        return result;
    }

    /**
     * Creates a new instance of a LinkedHashMap.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @return a new instance of a LinkedHashMap
     */
    public static <K, V> Map<K, V> newLinkedHashMap() {
        return new LinkedHashMap<>();
    }

    /**
     * Creates a new instance of a LinkedHashMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @return a new instance of a LinkedHashMap with the specified initial capacity
     */
    public static <K, V> Map<K, V> newLinkedHashMap(final int initialCapacity) {
        return new LinkedHashMap<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of a LinkedHashMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param m the map whose elements are to be placed into this map
     * @return a new instance of a LinkedHashMap containing the entries from the specified map
     */
    public static <K, V> Map<K, V> newLinkedHashMap(final Map<? extends K, ? extends V> m) {
        return isEmpty(m) ? new LinkedHashMap<>() : new LinkedHashMap<>(m);
    }

    /**
     * Creates a new instance of a LinkedHashMap with the elements from the specified collection.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param c the collection whose elements are to be placed into this map
     * @param keyExtractor the function to extract a key from a collection element
     * @return a new instance of a LinkedHashMap containing the elements from the specified collection
     * @see #toMap(Iterable, Function)
     * @see #toMap(Iterable, Function, Function)
     * @see #toMap(Iterable, Function, Function, IntFunction)
     * @see #toMap(Iterable, Function, Function, BiFunction, IntFunction)
     */
    public static <K, V> Map<K, V> newLinkedHashMap(final Collection<? extends V> c, final Function<? super V, ? extends K> keyExtractor)
            throws IllegalArgumentException {
        if (isEmpty(c)) {
            return newLinkedHashMap();
        }

        final Map<K, V> result = newLinkedHashMap(c.size());

        for (final V v : c) {
            result.put(keyExtractor.apply(v), v);
        }

        return result;
    }

    /**
     * Creates a new instance of a TreeMap.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <V> the type of mapped values
     * @return a new instance of a TreeMap
     */
    public static <K extends Comparable<? super K>, V> TreeMap<K, V> newTreeMap() { //NOSONAR
        return new TreeMap<>();
    }

    /**
     * Creates a new instance of a TreeMap with the specified comparator.
     *
     * @param <C> the type of the comparator
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param comparator the comparator that will be used to order this map
     * @return a new instance of a TreeMap with the specified comparator
     */
    public static <C, K extends C, V> TreeMap<K, V> newTreeMap(final Comparator<C> comparator) { //NOSONAR
        return new TreeMap<>(comparator);
    }

    /**
     * Creates a new instance of a TreeMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <V> the type of mapped values
     * @param m the map whose elements are to be placed into this map
     * @return a new instance of a TreeMap containing the entries from the specified map
     */
    public static <K extends Comparable<? super K>, V> TreeMap<K, V> newTreeMap(final Map<? extends K, ? extends V> m) { //NOSONAR
        return isEmpty(m) ? new TreeMap<>() : new TreeMap<>(m);
    }

    /**
     * Creates a new instance of an IdentityHashMap.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @return a new instance of an IdentityHashMap
     */
    public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() { //NOSONAR
        return new IdentityHashMap<>();
    }

    /**
     * Creates a new instance of an IdentityHashMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @return a new instance of an IdentityHashMap with the specified initial capacity
     */
    public static <K, V> IdentityHashMap<K, V> newIdentityHashMap(final int initialCapacity) { //NOSONAR
        return new IdentityHashMap<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of an IdentityHashMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param m the map whose elements are to be placed into this map
     * @return a new instance of an IdentityHashMap containing the entries from the specified map
     */
    public static <K, V> IdentityHashMap<K, V> newIdentityHashMap(final Map<? extends K, ? extends V> m) { //NOSONAR
        return isEmpty(m) ? new IdentityHashMap<>() : new IdentityHashMap<>(m);
    }

    /**
     * Creates a new instance of a ConcurrentHashMap.
     * This map is thread-safe and suitable for concurrent access.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ConcurrentHashMap<String, Integer> map = N.newConcurrentHashMap();
     * map.put("key", 1);
     * // Safe to use from multiple threads
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @return a new instance of a ConcurrentHashMap
     */
    public static <K, V> ConcurrentHashMap<K, V> newConcurrentHashMap() { //NOSONAR
        return new ConcurrentHashMap<>();
    }

    /**
     * Creates a new instance of a ConcurrentHashMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @return a new instance of a ConcurrentHashMap with the specified initial capacity
     */
    public static <K, V> ConcurrentHashMap<K, V> newConcurrentHashMap(final int initialCapacity) { //NOSONAR
        return new ConcurrentHashMap<>(initHashCapacity(initialCapacity));
    }

    /**
     * Creates a new instance of a ConcurrentHashMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param m the map whose elements are to be placed into this map
     * @return a new instance of a ConcurrentHashMap containing the entries from the specified map
     */
    public static <K, V> ConcurrentHashMap<K, V> newConcurrentHashMap(final Map<? extends K, ? extends V> m) { //NOSONAR
        return isEmpty(m) ? new ConcurrentHashMap<>() : new ConcurrentHashMap<>(m);
    }

    /**
     * Creates a new instance of a BiMap.
     * A BiMap is a bidirectional map that maintains the uniqueness of both keys and values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * BiMap<String, Integer> biMap = N.newBiMap();
     * biMap.put("one", 1);
     * biMap.put("two", 2);
     * biMap.get("one");          // returns 1
     * biMap.inversed().get(1);   // returns "one"
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @return a new instance of a BiMap
     */
    public static <K, V> BiMap<K, V> newBiMap() {
        return new BiMap<>();
    }

    /**
     * Creates a new instance of a BiMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @return a new instance of a BiMap with the specified initial capacity
     */
    public static <K, V> BiMap<K, V> newBiMap(final int initialCapacity) {
        return new BiMap<>(initialCapacity);
    }

    /**
     * Creates a new instance of a BiMap with the specified initial capacity and load factor.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param initialCapacity the initial capacity of the map
     * @param loadFactor the load factor of the map
     * @return a new instance of a BiMap with the specified initial capacity and load factor
     */
    public static <K, V> BiMap<K, V> newBiMap(final int initialCapacity, final float loadFactor) {
        return new BiMap<>(initialCapacity, loadFactor);
    }

    /**
     * Creates a new instance of a BiMap with the specified key map type which is used to create map to store <i>key/value</i> pairs and value map type which is used to create map to store <i>value/key</i> pairs.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param keyMapType the class of the map to be used to store <i>key/value</i> pairs
     * @param valueMapType the class of the map to be used to store <i>value/key</i> pairs
     * @return a new instance of a BiMap with the specified key and value map types
     */
    @SuppressWarnings("rawtypes")
    public static <K, V> BiMap<K, V> newBiMap(final Class<? extends Map> keyMapType, final Class<? extends Map> valueMapType) {
        return new BiMap<>(keyMapType, valueMapType);
    }

    /**
     * Creates a new instance of a BiMap with the specified key map supplier which provides the map to store <i>key/value</i> pairs and value map supplier which provides the map to store <i>value/key</i> pairs.
     *
     * @param <K> the type of keys maintained by this map
     * @param <V> the type of mapped values
     * @param keyMapSupplier the supplier that provides the map to store <i>key/value</i> pairs
     * @param valueMapSupplier the supplier that provides the map to store <i>value/key</i> pairs
     * @return a new instance of a BiMap with the specified key and value map suppliers
     */
    public static <K, V> BiMap<K, V> newBiMap(final Supplier<? extends Map<K, V>> keyMapSupplier, final Supplier<? extends Map<V, K>> valueMapSupplier) {
        return new BiMap<>(keyMapSupplier, valueMapSupplier);
    }

    /**
     * Creates a new instance of a Multimap with the specified map which provides the map to store <i>key/value</i> pairs and value supplier which provides the collection to store <i>values</i>.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param <V> the type of collection that holds the elements
     * @param mapSupplier the supplier that provides the map to store <i>key/value</i> pairs
     * @param valueSupplier the supplier that provides the collection to store values
     * @return a new instance of a Multimap with the specified map and value suppliers
     */
    public static <K, E, V extends Collection<E>> Multimap<K, E, V> newMultimap(final Supplier<? extends Map<K, V>> mapSupplier,
            final Supplier<? extends V> valueSupplier) {
        return new Multimap<>(mapSupplier, valueSupplier);
    }

    /**
     * Creates a new instance of a ListMultimap.
     * A ListMultimap is a multimap that can store multiple values for a single key, with values stored in a List.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ListMultimap<String, Integer> multimap = N.newListMultimap();
     * multimap.put("key", 1);
     * multimap.put("key", 2);
     * multimap.put("key", 1);   // duplicates allowed
     * multimap.get("key");      // returns [1, 2, 1]
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @return a new instance of a ListMultimap
     */
    public static <K, E> ListMultimap<K, E> newListMultimap() {
        return new ListMultimap<>();
    }

    /**
     * Creates a new instance of a ListMultimap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param initialCapacity the initial capacity of the ListMultimap
     * @return a new instance of a ListMultimap with the specified initial capacity
     */
    public static <K, E> ListMultimap<K, E> newListMultimap(final int initialCapacity) {
        return new ListMultimap<>(initialCapacity);
    }

    /**
     * Creates a new instance of a ListMultimap with the specified map type which is used to create the backed map for storing entries.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapType the class of the map to be used to store entries
     * @return a new instance of a ListMultimap with the specified map type
     */
    @SuppressWarnings("rawtypes")
    public static <K, E> ListMultimap<K, E> newListMultimap(final Class<? extends Map> mapType) {
        return new ListMultimap<>(mapType, ArrayList.class);
    }

    /**
     * Creates a new instance of a ListMultimap with the specified map type which is used to create the backed map for storing entries and value type which is used to create the backed list for storing values.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapType the class of the map to be used to store entries
     * @param valueType the class of the list to be used to store values
     * @return a new instance of a ListMultimap with the specified map type and value type
     */
    @SuppressWarnings("rawtypes")
    public static <K, E> ListMultimap<K, E> newListMultimap(final Class<? extends Map> mapType, final Class<? extends List> valueType) {
        return new ListMultimap<>(mapType, valueType);
    }

    /**
     * Creates a new instance of a ListMultimap with the specified map and value suppliers.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapSupplier the supplier that provides the map to store entries
     * @param valueSupplier the supplier that provides the list to store values
     * @return a new instance of a ListMultimap with the specified map and value suppliers
     */
    public static <K, E> ListMultimap<K, E> newListMultimap(final Supplier<? extends Map<K, List<E>>> mapSupplier,
            final Supplier<? extends List<E>> valueSupplier) {
        return new ListMultimap<>(mapSupplier, valueSupplier);
    }

    /**
     * Creates a new instance of a ListMultimap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this ListMultimap
     * @return a new instance of a ListMultimap containing the entries from the specified map
     */
    public static <K, E> ListMultimap<K, E> newListMultimap(final Map<? extends K, ? extends E> m) {
        final ListMultimap<K, E> multiMap = newListMultimap(size(m));

        multiMap.put(m);

        return multiMap;
    }

    /**
     * Creates a new instance of a ListMultimap with the keys extracted from the specified collection by the specified {@code Function} and values from the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys maintained by this map
     * @param c the collection whose elements are to be placed into this ListMultimap
     * @param keyExtractor the function to extract keys from the specified collection elements
     * @return a new instance of a ListMultimap with the keys extracted from the specified collection elements
     */
    public static <T, K> ListMultimap<K, T> newListMultimap(final Collection<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return ListMultimap.create(c, keyExtractor);
    }

    /**
     * Creates a new instance of a ListMultimap with the keys and values extracted from the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param c the collection whose elements are to be placed into this ListMultimap
     * @param keyExtractor the function to extract keys from the collection elements
     * @param valueExtractor the function to extract values from the collection elements
     * @return a new instance of a ListMultimap with the keys and values extracted from the specified collection
     */
    public static <T, K, E> ListMultimap<K, E> newListMultimap(final Collection<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends E> valueExtractor) {
        return ListMultimap.create(c, keyExtractor, valueExtractor);
    }

    /**
     * Creates a new instance of a ListMultimap backed by a LinkedHashMap.
     * A LinkedHashMap maintains insertion order, so keys will be iterated in the order they were first added.
     * Values for each key are stored in an ArrayList, preserving the order they were added.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ListMultimap<String, Integer> multimap = N.newLinkedListMultimap();
     * multimap.put("key1", 1);
     * multimap.put("key2", 2);
     * multimap.put("key1", 3);
     * multimap.get("key1");  // returns [1, 3] in insertion order
     * // Keys iterated in order: key1, key2
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @return a new instance of a ListMultimap backed by a LinkedHashMap
     */
    public static <K, E> ListMultimap<K, E> newLinkedListMultimap() {
        return new ListMultimap<>(LinkedHashMap.class, ArrayList.class);
    }

    /**
     * Creates a new instance of a ListMultimap backed by a LinkedHashMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param initialCapacity the initial capacity of the ListMultimap
     * @return a new instance of a ListMultimap backed by a LinkedHashMap with the specified initial capacity
     */
    public static <K, E> ListMultimap<K, E> newLinkedListMultimap(final int initialCapacity) {
        return new ListMultimap<>(newLinkedHashMap(initialCapacity), ArrayList.class);
    }

    /**
     * Creates a new instance of a ListMultimap backed by a LinkedHashMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this ListMultimap
     * @return a new instance of a ListMultimap containing the entries from the specified map
     */
    public static <K, E> ListMultimap<K, E> newLinkedListMultimap(final Map<? extends K, ? extends E> m) {
        final ListMultimap<K, E> multiMap = new ListMultimap<>(newLinkedHashMap(size(m)), ArrayList.class);

        multiMap.put(m);

        return multiMap;
    }

    /**
     * Creates a new instance of a ListMultimap backed by a SortedMap.
     * The keys in the map will be sorted according to their natural ordering.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <E> the type of elements in the collection
     * @return a new instance of a ListMultimap backed by a SortedMap
     */
    public static <K extends Comparable<? super K>, E> ListMultimap<K, E> newSortedListMultimap() {
        return new ListMultimap<>(new TreeMap<>(), ArrayList.class);
    }

    /**
     * Creates a new instance of a ListMultimap backed by a SortedMap with the entries from the specified map.
     * The keys in the map will be sorted according to their natural ordering.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this ListMultimap
     * @return a new instance of a ListMultimap containing the entries from the specified map
     */
    public static <K extends Comparable<? super K>, E> ListMultimap<K, E> newSortedListMultimap(final Map<? extends K, ? extends E> m) {
        final ListMultimap<K, E> multiMap = new ListMultimap<>(new TreeMap<>(), ArrayList.class);

        multiMap.put(m);

        return multiMap;
    }

    /**
     * Creates a new instance of a SetMultimap.
     * A SetMultimap is a multimap that can store multiple values for a single key, with values stored in a Set (no duplicates).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * SetMultimap<String, Integer> multimap = N.newSetMultimap();
     * multimap.put("key", 1);
     * multimap.put("key", 2);
     * multimap.put("key", 1);   // duplicate ignored
     * multimap.get("key");      // returns Set containing [1, 2]
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @return a new instance of a SetMultimap
     */
    public static <K, E> SetMultimap<K, E> newSetMultimap() {
        return new SetMultimap<>();
    }

    /**
     * Creates a new instance of a SetMultimap with the specified initial capacity.
     * Specifying an appropriate initial capacity can reduce rehashing and improve performance.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Pre-size for expected number of keys
     * SetMultimap<String, Integer> multimap = N.newSetMultimap(100);
     * // Efficiently handles up to ~100 keys without rehashing
     * }</pre>
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param initialCapacity the initial capacity of the SetMultimap. Must be non-negative.
     * @return a new instance of a SetMultimap with the specified initial capacity
     */
    public static <K, E> SetMultimap<K, E> newSetMultimap(final int initialCapacity) {
        return new SetMultimap<>(initialCapacity);
    }

    /**
     * Creates a new instance of a SetMultimap with the specified map type which is used to create the backed map for storing entries.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapType the class of the map to be used to store entries
     * @return a new instance of a SetMultimap with the specified map type
     */
    @SuppressWarnings("rawtypes")
    public static <K, E> SetMultimap<K, E> newSetMultimap(final Class<? extends Map> mapType) {
        return new SetMultimap<>(mapType, HashSet.class);
    }

    /**
     * Creates a new instance of a SetMultimap with the specified map type which is used to create the backed map for storing entries and value type which is used to create the backed Set for storing values.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapType the class of the map to be used to store entries
     * @param valueType the class of the set to be used to store values
     * @return a new instance of a SetMultimap with the specified map type and value type
     */
    @SuppressWarnings("rawtypes")
    public static <K, E> SetMultimap<K, E> newSetMultimap(final Class<? extends Map> mapType, final Class<? extends Set> valueType) {
        return new SetMultimap<>(mapType, valueType);
    }

    /**
     * Creates a new instance of a SetMultimap with the specified map and value suppliers.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param mapSupplier the supplier that provides the map to store entries
     * @param valueSupplier the supplier that provides the set to store values
     * @return a new instance of a SetMultimap with the specified map and value suppliers
     */
    public static <K, E> SetMultimap<K, E> newSetMultimap(final Supplier<? extends Map<K, Set<E>>> mapSupplier,
            final Supplier<? extends Set<E>> valueSupplier) {
        return new SetMultimap<>(mapSupplier, valueSupplier);
    }

    /**
     * Creates a new instance of a SetMultimap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this SetMultimap
     * @return a new instance of a SetMultimap containing the entries from the specified map
     */
    public static <K, E> SetMultimap<K, E> newSetMultimap(final Map<? extends K, ? extends E> m) {
        final SetMultimap<K, E> multiMap = newSetMultimap(size(m));

        multiMap.put(m);

        return multiMap;
    }

    /**
     * Creates a new instance of a SetMultimap with the keys extracted from the specified collection by the specified {@code Function} and values from the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys maintained by this map
     * @param c the collection whose elements are to be placed into this SetMultimap
     * @param keyExtractor the function to extract keys from the specified collection elements
     * @return a new instance of a SetMultimap with the keys extracted from the specified collection elements
     */
    public static <T, K> SetMultimap<K, T> newSetMultimap(final Collection<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return SetMultimap.create(c, keyExtractor);
    }

    /**
     * Creates a new instance of a SetMultimap with the keys and values extracted from the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param c the collection whose elements are to be placed into this SetMultimap
     * @param keyExtractor the function to extract keys from the collection elements
     * @param valueExtractor the function to extract values from the collection elements
     * @return a new instance of a SetMultimap with the keys and values extracted from the specified collection
     */
    public static <T, K, E> SetMultimap<K, E> newSetMultimap(final Collection<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends E> valueExtractor) {
        return SetMultimap.create(c, keyExtractor, valueExtractor);
    }

    /**
     * Creates a new instance of a SetMultimap backed by a LinkedHashMap.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @return a new instance of a SetMultimap backed by a LinkedHashMap
     */
    public static <K, E> SetMultimap<K, E> newLinkedSetMultimap() {
        return new SetMultimap<>(LinkedHashMap.class, HashSet.class);
    }

    /**
     * Creates a new instance of a SetMultimap backed by a LinkedHashMap with the specified initial capacity.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param initialCapacity the initial capacity of the SetMultimap
     * @return a new instance of a SetMultimap backed by a LinkedHashMap with the specified initial capacity
     */
    public static <K, E> SetMultimap<K, E> newLinkedSetMultimap(final int initialCapacity) {
        return new SetMultimap<>(newLinkedHashMap(initialCapacity), HashSet.class);
    }

    /**
     * Creates a new instance of a SetMultimap backed by a LinkedHashMap with the entries from the specified map.
     *
     * @param <K> the type of keys maintained by this map
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this SetMultimap
     * @return a new instance of a SetMultimap containing the entries from the specified map
     */
    public static <K, E> SetMultimap<K, E> newLinkedSetMultimap(final Map<? extends K, ? extends E> m) {
        final SetMultimap<K, E> multiMap = new SetMultimap<>(newLinkedHashMap(size(m)), HashSet.class);

        multiMap.put(m);

        return multiMap;
    }

    /**
     * Creates a new instance of a SetMultimap backed by a SortedMap.
     * The keys in the map will be sorted according to their natural ordering.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <E> the type of elements in the collection
     * @return a new instance of a SetMultimap backed by a SortedMap
     */
    public static <K extends Comparable<? super K>, E> SetMultimap<K, E> newSortedSetMultimap() {
        return new SetMultimap<>(new TreeMap<>(), HashSet.class);
    }

    /**
     * Creates a new instance of a SetMultimap backed by a SortedMap with the entries from the specified map.
     * The keys in the map will be sorted according to their natural ordering.
     *
     * @param <K> the type of keys maintained by this map, which must be comparable
     * @param <E> the type of elements in the collection
     * @param m the map whose elements are to be placed into this SetMultimap
     * @return a new instance of a SetMultimap containing the entries from the specified map
     */
    public static <K extends Comparable<? super K>, E> SetMultimap<K, E> newSortedSetMultimap(final Map<? extends K, ? extends E> m) {
        final SetMultimap<K, E> multiMap = new SetMultimap<>(new TreeMap<>(), HashSet.class);

        multiMap.put(m);

        return multiMap;
    }

    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    static final int MAX_HASH_LENGTH = (int) (MAX_ARRAY_SIZE / 1.25) - 1;

    /**
     * Creates a new empty Dataset.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * This method creates a Dataset with no rows or columns.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Dataset ds = N.newEmptyDataset();
     * // ds.columnNameList() returns empty list
     * // ds.size() returns 0
     * }</pre>
     *
     * @return a new empty Dataset.
     * @see Dataset#empty()
     */
    public static Dataset newEmptyDataset() {
        return new RowDataset(new ArrayList<>(), new ArrayList<>());
    }

    /**
     * Creates a new empty Dataset with the specified properties.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * This method creates a Dataset with no rows or columns, but with the specified properties.
     *
     * @param properties a map representing the properties of the Dataset. The keys are property names and the values are the corresponding property values.
     * @return a new empty Dataset with the specified properties.
     * @see Dataset#empty()
     */
    static Dataset newEmptyDataset(final Map<String, Object> properties) {
        return new RowDataset(new ArrayList<>(), new ArrayList<>(), properties);
    }

    /**
     * Creates a new empty Dataset with the specified column names.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * This method creates a Dataset with no rows, but with the specified column names.
     *
     * @param columnNames a collection of strings representing the names of the columns in the Dataset.
     * @return a new empty Dataset with the specified column names.
     * @see Dataset#empty()
     */
    public static Dataset newEmptyDataset(final Collection<String> columnNames) {
        return newEmptyDataset(columnNames, null);
    }

    /**
     * Creates a new empty Dataset with the specified column names and properties.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * This method creates a Dataset with no rows, but with the specified column names and properties.
     *
     * @param columnNames a collection of strings representing the names of the columns in the Dataset.
     * @param properties a map representing the properties of the Dataset. The keys are property names and the values are the corresponding property values.
     * @return a new empty Dataset with the specified column names and properties.
     * @see Dataset#empty()
     */
    public static Dataset newEmptyDataset(final Collection<String> columnNames, final Map<String, Object> properties) {
        if (isEmpty(columnNames)) {
            return newEmptyDataset(properties);
        }

        final List<List<Object>> columnList = new ArrayList<>(columnNames.size());

        for (int i = 0, size = columnNames.size(); i < size; i++) {
            columnList.add(new ArrayList<>());
        }

        return new RowDataset(new ArrayList<>(columnNames), columnList, properties);
    }

    /**
     * Creates a new Dataset with the specified rows.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * The <i>rows</i> parameter is a collection where each item represents a row in the Dataset.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Using Maps as rows
     * List<Map<String, Object>> rows = new ArrayList<>();
     * rows.add(N.asMap("name", "John", "age", 25));
     * rows.add(N.asMap("name", "Jane", "age", 30));
     * Dataset ds = N.newDataset(rows);
     * // ds.columnNameList() returns ["name", "age"]
     *
     * // Using Beans as rows
     * List<Person> people = Arrays.asList(new Person("John", 25), new Person("Jane", 30));
     * Dataset ds2 = N.newDataset(people);
     * }</pre>
     *
     * @param rows a collection of objects representing the data in the Dataset. Each object is a row which can be: Map/Bean.
     * @return a new Dataset with the specified rows.
     * @throws IllegalArgumentException if the provided rows do not align properly.
     * @see Dataset#rows(Collection, Object[][])
     * @see Dataset#rows(Collection, Collection)
     * @see Dataset#columns(Collection, Object[][])
     * @see Dataset#columns(Collection, Collection)
     */
    public static Dataset newDataset(final Collection<?> rows) throws IllegalArgumentException {
        return newDataset(rows, null);
    }

    /**
     * Creates a new Dataset with the specified rows and properties.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * The <i>rows</i> parameter is a collection where each item represents a row in the Dataset.
     * The <i>properties</i> parameter is a map where each entry represents a property of the Dataset.
     *
     * @param rows a collection of objects representing the data in the Dataset. Each object is a row which can be: Map/Bean.
     * @param properties a map of properties for the Dataset. Each key is a property name and each value is the property value.
     * @return a new Dataset with the specified rows and properties.
     * @throws IllegalArgumentException if the provided rows and properties do not align properly.
     * @see Dataset#rows(Collection, Object[][])
     * @see Dataset#rows(Collection, Collection)
     * @see Dataset#columns(Collection, Object[][])
     * @see Dataset#columns(Collection, Collection)
     */
    public static Dataset newDataset(final Collection<?> rows, final Map<String, Object> properties) throws IllegalArgumentException {
        if (isEmpty(rows)) {
            return newEmptyDataset(properties);
        }

        final Object firstElement = firstOrNullIfEmpty(rows);

        if (firstElement == null) {
            throw new IllegalArgumentException("Column name list cannot be obtained from row list because its first element is null");
        }

        final Class<?> cls = firstElement.getClass();

        if (Beans.isBeanClass(cls)) {
            final List<String> columnNames = Beans.getPropNameList(cls);
            return newDataset(columnNames, rows, properties);
        } else if (firstElement instanceof Map) {
            final List<String> columnNames = newArrayList(((Map<String, Object>) firstElement).keySet());
            return newDataset(columnNames, rows, properties);
        } else {
            throw new IllegalArgumentException("Unsupported row type: " + cls.getName());
        }
    }

    /**
     * Creates a new Dataset with the specified column names and rows.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * Each item in the <i>columnNames</i> collection represents a column in the Dataset.
     * The <i>rows</i> parameter is a collection where each item represents a row in the Dataset.
     * The order of elements in each row should correspond to the order of column names.
     *
     * @param columnNames a collection of strings representing the names of the columns in the Dataset.
     * @param rows a collection of objects representing the data in the Dataset. Each object is a row which can be: Map/Bean/Array/List.
     * @return a new Dataset with the specified column names and rows.
     * @throws IllegalArgumentException if the length of <i>columnNames</i> is zero or not align with row list.
     * @see Dataset#rows(Collection, Object[][])
     * @see Dataset#rows(Collection, Collection)
     * @see Dataset#columns(Collection, Object[][])
     * @see Dataset#columns(Collection, Collection)
     */
    public static Dataset newDataset(final Collection<String> columnNames, final Collection<?> rows) throws IllegalArgumentException {
        return newDataset(columnNames, rows, null);
    }

    /**
     * Creates a new Dataset with the specified column names, rows, and properties.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * Each item in the <i>columnNames</i> collection represents a column in the Dataset.
     * The <i>rows</i> parameter is a collection where each item represents a row in the Dataset.
     * The order of elements in each row should correspond to the order of column names.
     * The <i>properties</i> parameter is a map where each entry represents a property of the Dataset.
     *
     * @param columnNames a collection of strings representing the names of the columns in the Dataset.
     * @param rows a collection of objects representing the data in the Dataset. Each object is a row which can be: Map/Bean/Array/List.
     * @param properties a map of properties for the Dataset. Each key is a property name and each value is the property value.
     * @return a new Dataset with the specified column names, rows, and properties.
     * @throws IllegalArgumentException if the length of <i>columnNames</i> is zero or not align with row list.
     * @see Dataset#rows(Collection, Object[][])
     * @see Dataset#rows(Collection, Collection)
     * @see Dataset#columns(Collection, Object[][])
     * @see Dataset#columns(Collection, Collection)
     */
    public static Dataset newDataset(final Collection<String> columnNames, final Collection<?> rows, final Map<String, Object> properties)
            throws IllegalArgumentException {
        checkArgNotEmpty(columnNames, cs.columnNames);

        //    if (isEmpty(columnNames) && isEmpty(rows)) {
        //        // throw new IllegalArgumentException("Column name list and row list cannot be both null or empty");
        //        return newEmptyDataset(properties);
        //    }

        if (isEmpty(rows)) {
            return newEmptyDataset(columnNames, properties);
        }

        // int startRowIndex = 0;

        // final int rowCount = rows.size() - startRowIndex;
        final int rowCount = rows.size();
        final int columnCount = columnNames.size();
        final List<String> columnNameList = new ArrayList<>(columnNames);
        final List<List<Object>> columnList = new ArrayList<>(columnCount);

        for (int i = 0; i < columnCount; i++) {
            columnList.add(new ArrayList<>(rowCount));
        }

        Type<?> type = null;

        for (final Object row : rows) {
            //    if (startRowIndex-- > 0) {
            //        // skip
            //        continue;
            //    }

            if (row == null) {
                for (int i = 0; i < columnCount; i++) {
                    columnList.get(i).add(null);
                }

                continue;
            }

            final Class<?> cls = row.getClass();
            type = typeOf(cls);

            if (type.isMap()) {
                final Map<String, Object> props = (Map<String, Object>) row;

                for (int i = 0; i < columnCount; i++) {
                    columnList.get(i).add(props.get(columnNameList.get(i)));
                }
            } else if (type.isBean()) {
                final BeanInfo beanInfo = ParserUtil.getBeanInfo(cls);
                PropInfo propInfo = null;

                for (int i = 0; i < columnCount; i++) {
                    propInfo = beanInfo.getPropInfo(columnNameList.get(i));

                    if (propInfo == null) {
                        columnList.get(i).add(null);
                    } else {
                        columnList.get(i).add(propInfo.getPropValue(row));
                    }
                }
            } else if (type.isArray()) {
                if (Array.getLength(row) != columnCount) {
                    throw new IllegalArgumentException(
                            "The length of row array (" + Array.getLength(row) + ") does not match the length of column name list (" + columnCount + ")");
                }

                if (type.isPrimitiveArray()) {
                    for (int i = 0; i < columnCount; i++) {
                        columnList.get(i).add(Array.get(row, i));
                    }
                } else {
                    final Object[] array = (Object[]) row;

                    for (int i = 0; i < columnCount; i++) {
                        columnList.get(i).add(array[i]);
                    }
                }
            } else if (type.isCollection()) {
                final Collection<Object> c = (Collection<Object>) row;
                if (c.size() != columnCount) {
                    throw new IllegalArgumentException(
                            "The size of row collection (" + c.size() + ") does not match the length of column name list (" + columnCount + ")");
                }

                final Iterator<Object> it = c.iterator();

                for (int i = 0; i < columnCount; i++) {
                    columnList.get(i).add(it.next());
                }
            } else if (columnNames.size() == 1) {
                columnList.get(0).add(row); // single column case 
            } else {
                throw new IllegalArgumentException(
                        "Unsupported row type: " + ClassUtil.getCanonicalClassName(row.getClass()) + ". Only array, collection, map and bean are supported");
            }
        }

        return new RowDataset(columnNameList, columnList, properties);
    }

    /**
     * Creates a new Dataset with the specified column names and rows.
     *
     * The Dataset is a data structure that stores data in a tabular format, similar to a table in a database.
     * Each item in the <i>columnNames</i> collection represents a column in the Dataset.
     * The <i>rowList</i> parameter is a two-dimensional array where each subarray represents a row in the Dataset.
     * The order of elements in each row should correspond to the order of column names.
     *
     * @param columnNames a collection of strings representing the names of the columns in the Dataset.
     * @param rows a two-dimensional array of objects representing the data in the Dataset. Each subarray is a row.
     * @return a new Dataset with the specified column names and rows.
     * @throws IllegalArgumentException if the length of <i>columnNames</i> is zero or not equal to the length of the subarrays in <i>rowList</i>.
     * @see Dataset#rows(Collection, Object[][])
     * @see Dataset#rows(Collection, Collection)
     * @see Dataset#columns(Collection, Object[][])
     * @see Dataset#columns(Collection, Collection)
     */
    public static Dataset newDataset(final Collection<String> columnNames, final Object[][] rows) throws IllegalArgumentException {
        checkArgNotEmpty(columnNames, cs.columnNames);

        //    if (isEmpty(columnNames) && isEmpty(rowList)) {
        //        // throw new IllegalArgumentException("Column name list and row list cannot be both null or empty");
        //        return newEmptyDataset();
        //    }

        if (isEmpty(rows)) {
            return newEmptyDataset(columnNames);
        }

        final int coumnCount = size(columnNames);

        for (int i = 0; i < rows.length; i++) {
            if (len(rows[i]) != coumnCount) {
                throw new IllegalArgumentException(
                        "The length of column name list (" + coumnCount + ") does not match the length of rowList[" + i + "] (" + len(rows[i]) + ")");
            }
        }

        return newDataset(columnNames, asList(rows));
    }

    /**
     * Creates a new Dataset from the provided Map.
     * The Dataset will have two columns: one for keys and one for values from the Map.
     * Each entry in the map becomes a row in the dataset.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> scores = N.asMap("Alice", 95, "Bob", 87);
     * Dataset ds = N.newDataset("Name", "Score", scores);
     * // ds has columns ["Name", "Score"] with rows:
     * // Row 0: Name=Alice, Score=95
     * // Row 1: Name=Bob, Score=87
     *
     * // Null map creates empty dataset
     * Dataset empty = N.newDataset("key", "value", null);
     * }</pre>
     *
     * @param keyColumnName the name of the column for the keys from the Map. Cannot be {@code null} or empty.
     * @param valueColumnName the name of the column for the values from the Map. Cannot be {@code null} or empty.
     * @param m the Map to convert into a Dataset. Can be {@code null} or empty.
     * @return a new Dataset with two columns: one for keys and one for values from the Map.
     *         Returns an empty Dataset if {@code m} is {@code null} or empty.
     */
    public static Dataset newDataset(final String keyColumnName, final String valueColumnName, final Map<?, ?> m) {
        final List<Object> keyColumn = new ArrayList<>(m.size());
        final List<Object> valueColumn = new ArrayList<>(m.size());

        for (final Map.Entry<?, ?> entry : m.entrySet()) {
            keyColumn.add(entry.getKey());
            valueColumn.add(entry.getValue());
        }

        final List<String> columnNameList = asList(keyColumnName, valueColumnName);
        final List<List<Object>> columnList = asList(keyColumn, valueColumn);

        return new RowDataset(columnNameList, columnList);
    }

    /**
     * Creates a new Dataset from the provided Map of column names to Collections.
     *
     * The Dataset will have as many columns as there are entries in the Map.
     * The column names are the keys from the Map.
     * Each column corresponds to a Collection in the Map.
     * If a column has fewer rows than the maximum number of rows, the missing rows will be filled with {@code null} values.
     * Eventually all the columns will have the same number of rows.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, List<Object>> data = N.asLinkedHashMap(
     *     "Name", N.asList("Alice", "Bob", "Charlie"),
     *     "Age", N.asList(25, 30, 35),
     *     "City", N.asList("NYC", "LA")  // shorter column
     * );
     * Dataset ds = N.newDataset(data);
     * // ds has 3 rows (max collection size) and 3 columns
     * // City column has null for row 2
     *
     * // Empty map creates empty dataset
     * Dataset empty = N.newDataset(N.newLinkedHashMap());
     * }</pre>
     *
     * @param <C> the type of the Collection values in the Map.
     * @param map the Map to convert into a Dataset. The keys of the map represent the column names and the values (which are collections) represent the data in the columns.
     *             Can be {@code null} or empty.
     * @return a new Dataset with columns created from the Map. Returns an empty Dataset if {@code map} is {@code null} or empty.
     *         All columns will have the same number of rows, with shorter columns padded with {@code null}.
     */
    public static <C extends Collection<?>> Dataset newDataset(final Map<String, C> map) {
        if (isEmpty(map)) {
            return newEmptyDataset();
        }

        int maxColumnLen = 0;

        for (final C v : map.values()) {
            maxColumnLen = N.max(maxColumnLen, size(v));
        }

        final List<String> columnNameList = new ArrayList<>(map.keySet());
        final List<List<Object>> columnList = new ArrayList<>(columnNameList.size());
        List<Object> column = null;

        for (final C v : map.values()) {
            column = new ArrayList<>(maxColumnLen);

            if (notEmpty(v)) {
                column.addAll(v);
            }

            if (column.size() < maxColumnLen) {
                fill(column, column.size(), maxColumnLen, null);
            }

            columnList.add(column);
        }

        return new RowDataset(columnNameList, columnList);
    }

    /**
     * Creates a new Dataset with a single column from the provided Collection.
     * The Dataset will have one column with the provided column name.
     * The data in the column is the data from the provided Collection.
     * Each element in the Collection becomes a row in the Dataset.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = N.asList("Alice", "Bob", "Charlie");
     * Dataset ds = N.newDataset("Name", names);
     * // ds has 1 column "Name" with 3 rows: Alice, Bob, Charlie
     *
     * // Empty collection creates dataset with column but no rows
     * Dataset empty = N.newDataset("Value", N.asList());
     * // empty has column "Value" but 0 rows
     * }</pre>
     *
     * @param columnName the name of the column in the Dataset. Cannot be {@code null} or empty.
     * @param column the Collection to convert into a Dataset column. Can be {@code null} or empty.
     * @return a new Dataset with one column containing the data from the provided Collection.
     *         If {@code column} is {@code null} or empty, returns a Dataset with the column name but no rows.
     * @throws IllegalArgumentException if the provided columnName is {@code null} or empty.
     */
    public static Dataset newDataset(final String columnName, final Collection<?> column) throws IllegalArgumentException {
        checkArgNotEmpty(columnName, cs.columnName);

        final List<String> columnNameList = asList(columnName);
        final List<List<Object>> columnList = new ArrayList<>(1);
        columnList.add(newArrayList(column));

        return new RowDataset(columnNameList, columnList);
    }

    /**
     * Merges two given Datasets into a new single Dataset.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Dataset ds1 = N.newDataset(Arrays.asList("name", "age"),
     *                 Arrays.asList(new Object[]{"John", 25}));
     * Dataset ds2 = N.newDataset(Arrays.asList("name", "age"),
     *                 Arrays.asList(new Object[]{"Jane", 30}));
     * Dataset merged = N.merge(ds1, ds2);
     * // merged contains both rows: [John, 25] and [Jane, 30]
     * }</pre>
     *
     * @param a the first Dataset to be merged.
     * @param b the second Dataset to be merged.
     * @return a new Dataset which is the result of merging Dataset <i>a</i> and Dataset <i>b</i>.
     * @throws IllegalArgumentException if either <i>a</i> or <i>b</i> is {@code null}.
     */
    public static Dataset merge(@NotNull final Dataset a, @NotNull final Dataset b) throws IllegalArgumentException {
        checkArgNotNull(a);
        checkArgNotNull(b);

        final Dataset ret = a.copy();
        ret.merge(b);
        return ret;
    }

    /**
     * Merges three given Datasets into a new single Dataset.
     *
     * @param a the first Dataset to be merged.
     * @param b the second Dataset to be merged.
     * @param c the third Dataset to be merged.
     * @return a new Dataset which is the result of merging Dataset <i>a</i>, <i>b</i> and <i>c</i>.
     * @throws IllegalArgumentException if either <i>a</i>, <i>b</i> or <i>c</i> is {@code null}.
     */
    public static Dataset merge(@NotNull final Dataset a, @NotNull final Dataset b, @NotNull final Dataset c) throws IllegalArgumentException {
        checkArgNotNull(a);
        checkArgNotNull(b);
        checkArgNotNull(c);

        return merge(asList(a, b, c));
    }

    /**
     * Merges a collection of Datasets into a new single Dataset.
     *
     * @param dss the collection of Datasets to be merged.
     * @return a new Dataset which is the result of merging all the Datasets in the provided collection.
     * @throws IllegalArgumentException if the provided collection is {@code null} or empty.
     */
    public static Dataset merge(final Collection<? extends Dataset> dss) throws IllegalArgumentException {
        return merge(dss, false);
    }

    /**
     * Merges a collection of Datasets into a new single Dataset.
     *
     * @param dss the collection of Datasets to be merged.
     * @param requiresSameColumns a boolean flag that indicates whether the Datasets in the collection should have the same columns.
     *                            If set to {@code true}, all Datasets in the collection must have the same columns.
     *                            If set to {@code false}, the Datasets in the collection can have different columns.
     * @return a new Dataset which is the result of merging all the Datasets in the provided collection.
     * @throws IllegalArgumentException if the provided collection is {@code null} or empty or {@code requiresSameColumns} is {@code true} and the {@code Datasets} in {@code dss} don't have the same the same column names.
     */
    public static Dataset merge(final Collection<? extends Dataset> dss, final boolean requiresSameColumns) throws IllegalArgumentException {
        checkArgNotEmpty(dss, cs.datasets);

        if (requiresSameColumns && size(dss) > 1) {
            final Iterator<? extends Dataset> iter = dss.iterator();
            final Dataset firstDataset = iter.next();

            if (iter.hasNext()) {
                checkIfColumnNamesAreSame(firstDataset, iter.next());
            }
        }

        if (isEmpty(dss)) {
            return newEmptyDataset();
        } else if (dss.size() == 1) {
            return dss.iterator().next().copy();
        } else if (dss.size() == 2) {
            final Iterator<? extends Dataset> iter = dss.iterator();
            return merge(iter.next(), iter.next());
        } else {
            final Set<String> columnNameSet = newLinkedHashSet();
            final Map<String, Object> props = new HashMap<>();
            int totalSize = 0;

            for (final Dataset ds : dss) {
                columnNameSet.addAll(ds.columnNameList());
                totalSize += ds.size();

                if (notEmpty(ds.getProperties())) {
                    props.putAll(ds.getProperties());
                }
            }

            final int newColumnCount = columnNameSet.size();
            final List<String> newColumnNameList = new ArrayList<>(columnNameSet);
            final List<List<Object>> newColumnList = new ArrayList<>(newColumnCount);

            for (int i = 0; i < newColumnCount; i++) {
                newColumnList.add(new ArrayList<>(totalSize));
            }

            for (final Dataset ds : dss) {
                if (ds.isEmpty()) {
                    continue;
                }

                List<Object> column = null;

                for (int i = 0; i < newColumnCount; i++) {
                    column = newColumnList.get(i);

                    if (ds.containsColumn(newColumnNameList.get(i))) {
                        column.addAll(ds.getColumn(newColumnNameList.get(i)));
                    } else {
                        fill(column, column.size(), column.size() + ds.size(), null);
                    }
                }
            }

            return new RowDataset(newColumnNameList, newColumnList, props);
        }
    }

    private static void checkIfColumnNamesAreSame(final Dataset a, final Dataset b) {
        if (!(a.columnNameList().size() == b.columnNameList().size() && a.columnNameList().containsAll(b.columnNameList())
                && b.columnNameList().containsAll(a.columnNameList()))) {
            throw new IllegalArgumentException("These two Datasets do not have the same column names: " + a.columnNameList() + ", " + b.columnNameList());
        }
    }

    /**
     * Converts the specified collection to an array of Objects.
     * Returns an empty array if the specified collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = N.asList("a", "b", "c");
     * Object[] array = N.toArray(list);
     * // array is ["a", "b", "c"]
     *
     * // Handles null input safely
     * Object[] empty = N.toArray(null);
     * // empty is an empty array []
     * }</pre>
     *
     * @param c the collection to be converted to an array. Can be {@code null}.
     * @return an array containing all the elements in the specified collection, or an empty array if {@code c} is {@code null} or empty
     */
    public static Object[] toArray(final Collection<?> c) {
        if (isEmpty(c)) {
            return EMPTY_OBJECT_ARRAY;
        }

        return c.toArray(new Object[0]);
    }

    /**
     * Converts the specified range in the specified collection into an array.
     *
     * @param c the collection to be converted into an array.
     * @param fromIndex the starting (inclusive) index of the range to be converted.
     * @param toIndex the ending (exclusive) index of the range to be converted.
     * @return an array containing the elements of the specified range of the collection.
     * @throws IndexOutOfBoundsException if the provided indices are out of the collection's range.
     */
    @SuppressWarnings("rawtypes")
    public static Object[] toArray(final Collection<?> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return EMPTY_OBJECT_ARRAY;
        } else if (fromIndex == 0 && toIndex == c.size()) {
            return c.toArray(new Object[0]);
        } else if (c instanceof List) {
            return ((List) c).subList(fromIndex, toIndex).toArray(new Object[toIndex - fromIndex]);
        } else {
            final Object[] res = new Object[toIndex - fromIndex];
            final Iterator<?> iter = c.iterator();
            int idx = 0;

            while (idx < fromIndex && iter.hasNext()) {
                iter.next();
                idx++;
            }

            while (idx < toIndex && iter.hasNext()) {
                res[idx - fromIndex] = iter.next();
                idx++;
            }

            return res;
        }
    }

    /**
     * Converts a collection into an array. If the provided array is large enough to hold the elements of the collection,
     * it is filled with the collection's elements, otherwise, a new array of the same runtime type is allocated for this purpose.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param a the array into which the elements of the collection are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose.
     * @return the array containing the elements of the collection. If the provided array was large enough to hold the collection's elements, it is the same as the provided array.
     * @throws IllegalArgumentException if the specified {@code Array} is {@code null}.
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, @NotNull final A[] a)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotNull(a);

        if (isEmpty(c)) {
            // be consistent with Collection.toArray(Object[])
            if (a.length > 0) {
                a[0] = null;
            }

            return a;
        }

        return c.toArray(a);
    }

    /**
     * Converts the specified range in the specified collection into an array. If the provided array is large enough to hold the elements of the collection,
     * it is filled with the collection's elements, otherwise, a new array of the same runtime type is allocated for this purpose.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param fromIndex the starting (inclusive) index of the range to be converted.
     * @param toIndex the ending (exclusive) index of the range to be converted.
     * @param a the array into which the elements of the collection are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose.
     * @return the array containing the elements of the specified portion of the collection. If the provided array was large enough to hold the collection's elements, it is the same as the provided array.
     * @throws IllegalArgumentException if the specified {@code Array} is {@code null}.
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, final int fromIndex, final int toIndex, @NotNull final A[] a)
            throws IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, size(c));
        checkArgNotNull(a);

        if (isEmpty(c)) {
            if (a.length > 0) {
                a[0] = null;
            }

            return a;
        } else if (fromIndex == 0 && toIndex == c.size()) {
            return c.toArray(a);
        } else if (c instanceof List) {
            return ((List<T>) c).subList(fromIndex, toIndex).toArray(a);
        } else {
            final int size = toIndex - fromIndex;
            final A[] res = a.length >= size ? a : (A[]) newArray(a.getClass().getComponentType(), size);
            final Iterator<? extends T> iter = c.iterator();
            int idx = 0;

            while (idx < fromIndex && iter.hasNext()) {
                iter.next();
                idx++;
            }

            while (idx < toIndex && iter.hasNext()) {
                res[idx - fromIndex] = iter.next();
                idx++;
            }

            // be consistent with Collection.toArray(Object[])
            if (a.length > size) {
                a[size] = null;
            }

            return res;
        }
    }

    /**
     * Converts a collection into an array using a provided array supplier function.
     * The array supplier function is responsible for creating a new array of the appropriate type and size.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param arraySupplier the function to generate a new array of the appropriate type and size.
     * @return an array containing the elements of the collection
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, final IntFunction<A[]> arraySupplier) {
        if (isEmpty(c)) {
            return arraySupplier.apply(0);
        }

        return toArray(c, 0, c.size(), arraySupplier);
    }

    /**
     * Converts the specified range in the specified collection into an array using a provided array supplier function.
     * The array supplier function is responsible for creating a new array of the appropriate type and size.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param fromIndex the starting (inclusive) index of the portion to be converted.
     * @param toIndex the ending (exclusive) index of the portion to be converted.
     * @param arraySupplier the function to generate a new array of the appropriate type and size.
     * @return the array containing the elements of the specified portion of the collection.
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of the collection's range.
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, final int fromIndex, final int toIndex, final IntFunction<A[]> arraySupplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return arraySupplier.apply(0);
        } else if (fromIndex == 0 && toIndex == c.size()) {
            return c.toArray(arraySupplier.apply(c.size()));
        } else if (c instanceof List) {
            return ((List<T>) c).subList(fromIndex, toIndex).toArray(arraySupplier.apply(toIndex - fromIndex));
        } else {
            final A[] res = arraySupplier.apply(toIndex - fromIndex);
            final Iterator<? extends T> iter = c.iterator();
            int idx = 0;

            while (idx < fromIndex && iter.hasNext()) {
                iter.next();
                idx++;
            }

            while (idx < toIndex && iter.hasNext()) {
                res[idx - fromIndex] = iter.next();
                idx++;
            }

            return res;
        }
    }

    /**
     * Converts a collection into an array of a specified type.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param targetType the Class object representing the type of the array to be returned.
     * @return the array containing the elements of the collection.
     * @throws IllegalArgumentException if the specified {@code Class} is {@code null}.
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, @NotNull final Class<A[]> targetType)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotNull(targetType);

        if (isEmpty(c)) {
            return newArray(targetType.getComponentType(), 0);
        }

        return c.toArray((A[]) newArray(targetType.getComponentType(), c.size()));
    }

    /**
     * Converts the specified range in the specified collection into an array of a specified type.
     *
     * @param <A> the type of the array.
     * @param <T> the type of the elements in the collection. It must extend or be the same as the type of the array.
     * @param c the collection to be converted into an array.
     * @param fromIndex the starting (inclusive) index of the range to be converted.
     * @param toIndex the ending (exclusive) index of the range to be converted.
     * @param targetType the Class object representing the type of the array to be returned.
     * @return the array containing the elements of the specified portion of the collection.
     * @throws IllegalArgumentException if the specified {@code Class} is {@code null}.
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of the collection's range.
     */
    public static <A, T extends A> A[] toArray(final Collection<? extends T> c, final int fromIndex, final int toIndex, @NotNull final Class<A[]> targetType)
            throws IllegalArgumentException {
        checkArgNotNull(targetType);
        checkFromToIndex(fromIndex, toIndex, size(c));

        final A[] res = newArray(targetType.getComponentType(), toIndex - fromIndex);

        if (isEmpty(c)) {
            return res;
        } else if (fromIndex == 0 && toIndex == c.size()) {
            return c.toArray(res);
        } else if (c instanceof List) {
            return ((List<T>) c).subList(fromIndex, toIndex).toArray(res);
        } else {
            final Iterator<? extends T> iter = c.iterator();
            int idx = 0;

            while (idx < fromIndex && iter.hasNext()) {
                iter.next();
                idx++;
            }

            while (idx < toIndex && iter.hasNext()) {
                res[idx - fromIndex] = iter.next();
                idx++;
            }

            return res;
        }
    }

    /**
     * Converts a collection of Boolean objects to a boolean primitive array.
     * Null elements in the collection are converted to {@code false} by default.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Boolean> list = N.asList(true, false, true);
     * boolean[] array = N.toBooleanArray(list);
     * // array is [true, false, true]
     *
     * // Null elements become false
     * List<Boolean> listWithNull = N.asList(true, null, false);
     * boolean[] arrayWithNull = N.toBooleanArray(listWithNull);
     * // arrayWithNull is [true, false, false]
     * }</pre>
     *
     * @param c the collection of Boolean objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a boolean array containing the primitive boolean values from the collection. Null elements are converted to {@code false}.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static boolean[] toBooleanArray(final Collection<Boolean> c) {
        return toBooleanArray(c, false);
    }

    /**
     * Converts the specified range of the specified Boolean collection to a boolean array.
     *
     * @param c the collection of Boolean objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a boolean array containing the primitive boolean values from the specified range of the collection
     */
    public static boolean[] toBooleanArray(final Collection<Boolean> c, final int fromIndex, final int toIndex) {
        return toBooleanArray(c, fromIndex, toIndex, false);
    }

    /**
     * Converts a collection of Boolean objects to a boolean array.
     *
     * @param c the collection of Boolean objects to be converted
     * @param defaultForNull the default boolean value to use if a Boolean object in the collection is null
     * @return a boolean array containing the primitive boolean values from the collection
     */
    public static boolean[] toBooleanArray(final Collection<Boolean> c, final boolean defaultForNull) {
        return toBooleanArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Boolean collection to a boolean array.
     *
     * @param c the collection of Boolean objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default boolean value to use if a Boolean object in the collection is null
     * @return a boolean array containing the primitive boolean values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static boolean[] toBooleanArray(final Collection<Boolean> c, final int fromIndex, final int toIndex, final boolean defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final boolean[] result = new boolean[len];

        if (c instanceof final List<Boolean> list && c instanceof RandomAccess) {
            Boolean val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val;
                }
            }
        } else {
            final Iterator<Boolean> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Boolean val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val;
                }
            }
        }

        return result;
    }

    /**
     * Converts a byte array to a boolean array.
     * Each byte with positive value ({@code > 0}) is converted to {@code true}, {@code 0} and negative values are converted to {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] bytes = {1, 0, -1, 5, 0};
     * boolean[] bools = N.toBooleanArray(bytes);
     * // bools is [true, false, false, true, false]
     *
     * // Null or empty returns empty array
     * boolean[] empty = N.toBooleanArray((byte[]) null);
     * // empty is an empty boolean array
     * }</pre>
     *
     * @param a the byte array to be converted. Can be {@code null}.
     * @return a boolean array with the same length as the input array, or an empty boolean array if the input array is {@code null} or empty.
     *         Positive bytes become {@code true}, zero and negative bytes become {@code false}.
     */
    public static boolean[] toBooleanArray(final byte[] a) {
        if ((a == null) || (a.length == 0)) {
            return EMPTY_BOOLEAN_ARRAY; // return null; // NOSONAR
        } else {
            final int len = a.length;
            final boolean[] result = new boolean[len];

            for (int i = 0; i < len; i++) {
                result[i] = a[i] > Numbers.BYTE_ZERO;
            }

            return result;
        }
    }

    /**
     * Converts an integer array to a boolean array.
     * Each integer with positive value({@code > 0}) is converted to a boolean value {@code true}, {@code 0} and negative value to {@code false}.
     *
     * @param a the integer array to be converted
     * @return a boolean array with the same length as the input array, or an empty boolean array if the input array is {@code null} or empty
     */
    public static boolean[] toBooleanArray(final int[] a) {
        if ((a == null) || (a.length == 0)) {
            return EMPTY_BOOLEAN_ARRAY; // return null; // NOSONAR
        } else {
            final int len = a.length;
            final boolean[] result = new boolean[len];

            for (int i = 0; i < len; i++) {
                result[i] = a[i] > 0;
            }

            return result;
        }
    }

    /**
     * Converts a collection of Character objects to a char array.
     * Null elements in the collection are converted to '\0' (null character) by default.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Character> list = N.asList('a', 'b', 'c');
     * char[] array = N.toCharArray(list);
     * // array is ['a', 'b', 'c']
     *
     * // Null elements become '\0'
     * List<Character> listWithNull = N.asList('x', null, 'z');
     * char[] arrayWithNull = N.toCharArray(listWithNull);
     * // arrayWithNull is ['x', '\0', 'z']
     * }</pre>
     *
     * @param c the collection of Character objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a char array containing the primitive char values from the collection. Null elements are converted to '\0'.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static char[] toCharArray(final Collection<Character> c) {
        return toCharArray(c, (char) 0);
    }

    /**
     * Converts the specified range of the specified character collection to a char array.
     *
     * @param c the collection of Character objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a char array containing the primitive char values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static char[] toCharArray(final Collection<Character> c, final int fromIndex, final int toIndex) {
        return toCharArray(c, fromIndex, toIndex, (char) 0);
    }

    /**
     * Converts a collection of Character objects to a char array.
     *
     * @param c the collection of Character objects to be converted
     * @param defaultForNull the default char value to use if a Character object in the collection is null
     * @return a char array containing the primitive char values from the collection
     */
    public static char[] toCharArray(final Collection<Character> c, final char defaultForNull) {
        return toCharArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified character collection to a char array.
     *
     * @param c the collection of Character objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default char value to use if a Character object in the collection is null
     * @return a char array containing the primitive char values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static char[] toCharArray(final Collection<Character> c, final int fromIndex, final int toIndex, final char defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final char[] result = new char[len];

        if (c instanceof final List<Character> list && c instanceof RandomAccess) {
            Character val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val;
                }
            }
        } else {
            final Iterator<Character> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Character val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val;
                }
            }
        }

        return result;
    }

    /**
     * Converts a collection of Number objects to a byte array.
     * Each Number is converted to its byte value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Byte> list = N.asList((byte) 1, (byte) 2, (byte) 3);
     * byte[] array = N.toByteArray(list);
     * // array is [1, 2, 3]
     *
     * // Works with other Number types (truncates to byte range)
     * List<Integer> ints = N.asList(100, 200, 50);
     * byte[] fromInts = N.toByteArray(ints);
     * // fromInts is [100, -56, 50] (200 overflows to -56)
     *
     * // Null elements become 0
     * List<Byte> withNull = N.asList((byte) 1, null, (byte) 3);
     * byte[] arrayWithNull = N.toByteArray(withNull);
     * // arrayWithNull is [1, 0, 3]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a byte array containing the primitive byte values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static byte[] toByteArray(final Collection<? extends Number> c) {
        return toByteArray(c, (byte) 0);
    }

    /**
     * Converts the specified range of the specified Number collection to a byte array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a byte array containing the primitive byte values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static byte[] toByteArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toByteArray(c, fromIndex, toIndex, (byte) 0);
    }

    /**
     * Converts a collection of Number objects to a byte array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default byte value to use if a Number object in the collection is null
     * @return a byte array containing the primitive byte values from the collection
     */
    public static byte[] toByteArray(final Collection<? extends Number> c, final byte defaultForNull) {
        return toByteArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to a byte array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default byte value to use if a Number object in the collection is null
     * @return a byte array containing the primitive byte values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static byte[] toByteArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final byte defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final byte[] result = new byte[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.byteValue();
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.byteValue();
                }
            }
        }

        return result;
    }

    /**
     * Converts a boolean array to a byte array.
     * Each boolean value is converted to a byte value: {@code true} to 1 and {@code false} to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] bools = {true, false, true, true};
     * byte[] bytes = N.toByteArray(bools);
     * // bytes is [1, 0, 1, 1]
     *
     * // Null or empty returns empty array
     * byte[] empty = N.toByteArray((boolean[]) null);
     * // empty is an empty byte array
     * }</pre>
     *
     * @param a the boolean array to be converted. Can be {@code null}.
     * @return a byte array with the same length as the input array, or an empty byte array if the input array is {@code null} or empty.
     *         {@code true} becomes 1, {@code false} becomes 0.
     */
    public static byte[] toByteArray(final boolean[] a) {
        if ((a == null) || (a.length == 0)) {
            return EMPTY_BYTE_ARRAY; // return null; // NOSONAR
        } else {
            final int len = a.length;
            final byte[] result = new byte[len];

            for (int i = 0; i < len; i++) {
                result[i] = a[i] ? Numbers.BYTE_ONE : Numbers.BYTE_ZERO;
            }

            return result;
        }
    }

    /**
     * Converts a collection of Number objects to a short array.
     * Each Number is converted to its short value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Short> list = N.asList((short) 100, (short) 200, (short) 300);
     * short[] array = N.toShortArray(list);
     * // array is [100, 200, 300]
     *
     * // Works with other Number types (truncates to short range)
     * List<Integer> ints = N.asList(1000, 50000, 500);
     * short[] fromInts = N.toShortArray(ints);
     * // fromInts is [1000, -15536, 500] (50000 overflows)
     *
     * // Null elements become 0
     * List<Short> withNull = N.asList((short) 10, null, (short) 30);
     * short[] arrayWithNull = N.toShortArray(withNull);
     * // arrayWithNull is [10, 0, 30]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a short array containing the primitive short values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static short[] toShortArray(final Collection<? extends Number> c) {
        return toShortArray(c, (short) 0);
    }

    /**
     * Converts the specified range of the specified Number collection to a short array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a short array containing the primitive short values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static short[] toShortArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toShortArray(c, fromIndex, toIndex, (short) 0);
    }

    /**
     * Converts a collection of Number objects to a short array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default short value to use if a Number object in the collection is null
     * @return a short array containing the primitive short values from the collection
     */
    public static short[] toShortArray(final Collection<? extends Number> c, final short defaultForNull) {
        return toShortArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to a short array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default short value to use if a Number object in the collection is null
     * @return a short array containing the primitive short values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static short[] toShortArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final short defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final short[] result = new short[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.shortValue();
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.shortValue();
                }
            }
        }

        return result;
    }

    /**
     * Converts a collection of Number objects to an int array.
     * Each Number is converted to its int value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> list = N.asList(1, 2, 3, 4);
     * int[] array = N.toIntArray(list);
     * // array is [1, 2, 3, 4]
     *
     * // Works with other Number types (truncates decimals)
     * List<Double> doubles = N.asList(1.5, 2.9, 3.1);
     * int[] fromDoubles = N.toIntArray(doubles);
     * // fromDoubles is [1, 2, 3]
     *
     * // Null elements become 0
     * List<Integer> withNull = N.asList(1, null, 3);
     * int[] arrayWithNull = N.toIntArray(withNull);
     * // arrayWithNull is [1, 0, 3]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return an int array containing the primitive int values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static int[] toIntArray(final Collection<? extends Number> c) {
        return toIntArray(c, 0);
    }

    /**
     * Converts the specified range of the specified Number collection to an int array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return an int array containing the primitive int values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static int[] toIntArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toIntArray(c, fromIndex, toIndex, 0);
    }

    /**
     * Converts a collection of Number objects to an int array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default int value to use if a Number object in the collection is null
     * @return an int array containing the primitive int values from the collection
     */
    public static int[] toIntArray(final Collection<? extends Number> c, final int defaultForNull) {
        return toIntArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to an int array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default int value to use if a Number object in the collection is null
     * @return an int array containing the primitive int values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static int[] toIntArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final int defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final int[] result = new int[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.intValue();
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.intValue();
                }
            }
        }

        return result;
    }

    /**
     * Converts a char array to an int array.
     * Each char value is converted to its corresponding int value.
     *
     * @param a the char array to be converted
     * @return an int array with the same length as the input array, or an empty int array if the input array is {@code null} or empty
     */
    public static int[] toIntArray(final char[] a) {
        if ((a == null) || (a.length == 0)) {
            return EMPTY_INT_ARRAY; // return null; // NOSONAR
        } else {
            final int len = a.length;
            final int[] result = new int[len];

            for (int i = 0; i < len; i++) {
                result[i] = a[i]; //NOSONAR
            }

            return result;
        }
    }

    /**
     * Converts a boolean array to an int array.
     * Each boolean value is converted to an int value: {@code true} to 1 and {@code false} to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] bools = {true, false, true, true};
     * int[] ints = N.toIntArray(bools);
     * // ints is [1, 0, 1, 1]
     *
     * // Useful for boolean arithmetic operations
     * int trueCount = IntStream.of(N.toIntArray(bools)).sum();
     * // trueCount is 3
     *
     * // Null or empty returns empty array
     * int[] empty = N.toIntArray((boolean[]) null);
     * }</pre>
     *
     * @param a the boolean array to be converted. Can be {@code null}.
     * @return an int array with the same length as the input array, or an empty int array if the input array is {@code null} or empty.
     *         {@code true} becomes 1, {@code false} becomes 0.
     */
    public static int[] toIntArray(final boolean[] a) {
        if ((a == null) || (a.length == 0)) {
            return EMPTY_INT_ARRAY; // return null; // NOSONAR
        } else {
            final int len = a.length;
            final int[] result = new int[len];

            for (int i = 0; i < len; i++) {
                result[i] = a[i] ? 1 : 0;
            }

            return result;
        }
    }

    /**
     * Converts a collection of Number objects to a long array.
     * Each Number is converted to its long value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Long> list = N.asList(100L, 200L, 300L);
     * long[] array = N.toLongArray(list);
     * // array is [100, 200, 300]
     *
     * // Works with other Number types
     * List<Integer> ints = N.asList(1, 2, 3);
     * long[] fromInts = N.toLongArray(ints);
     * // fromInts is [1L, 2L, 3L]
     *
     * // Null elements become 0
     * List<Long> withNull = N.asList(10L, null, 30L);
     * long[] arrayWithNull = N.toLongArray(withNull);
     * // arrayWithNull is [10, 0, 30]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a long array containing the primitive long values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static long[] toLongArray(final Collection<? extends Number> c) {
        return toLongArray(c, 0);
    }

    /**
     * Converts the specified range of the specified Number collection to a long array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a long array containing the primitive long values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static long[] toLongArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toLongArray(c, fromIndex, toIndex, 0);
    }

    /**
     * Converts a collection of Number objects to a long array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default long value to use if a Number object in the collection is null
     * @return a long array containing the primitive long values from the collection
     */
    public static long[] toLongArray(final Collection<? extends Number> c, final long defaultForNull) {
        return toLongArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to a long array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default long value to use if a Number object in the collection is null
     * @return a long array containing the primitive long values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static long[] toLongArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final long defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final long[] result = new long[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.longValue();
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = val.longValue();
                }
            }
        }

        return result;
    }

    /**
     * Converts a collection of Number objects to a float array.
     * Each Number is converted to its float value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Float> list = N.asList(1.5f, 2.5f, 3.5f);
     * float[] array = N.toFloatArray(list);
     * // array is [1.5, 2.5, 3.5]
     *
     * // Works with other Number types
     * List<Integer> ints = N.asList(1, 2, 3);
     * float[] fromInts = N.toFloatArray(ints);
     * // fromInts is [1.0f, 2.0f, 3.0f]
     *
     * // Null elements become 0
     * List<Float> withNull = N.asList(1.1f, null, 3.3f);
     * float[] arrayWithNull = N.toFloatArray(withNull);
     * // arrayWithNull is [1.1, 0.0, 3.3]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a float array containing the primitive float values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static float[] toFloatArray(final Collection<? extends Number> c) {
        return toFloatArray(c, 0);
    }

    /**
     * Converts the specified range of the specified Number collection to a float array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a float array containing the primitive float values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static float[] toFloatArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toFloatArray(c, fromIndex, toIndex, 0);
    }

    /**
     * Converts a collection of Number objects to a float array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default float value to use if a Number object in the collection is null
     * @return a float array containing the primitive float values from the collection
     */
    public static float[] toFloatArray(final Collection<? extends Number> c, final float defaultForNull) {
        return toFloatArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to a float array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default float value to use if a Number object in the collection is null
     * @return a float array containing the primitive float values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static float[] toFloatArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final float defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final float[] result = new float[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = Numbers.toFloat(val);
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = Numbers.toFloat(val);
                }
            }
        }

        return result;
    }

    /**
     * Converts a collection of Number objects to a double array.
     * Each Number is converted to its double value. Null elements are converted to 0.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Double> list = N.asList(1.5, 2.5, 3.5);
     * double[] array = N.toDoubleArray(list);
     * // array is [1.5, 2.5, 3.5]
     *
     * // Works with other Number types
     * List<Integer> ints = N.asList(1, 2, 3);
     * double[] fromInts = N.toDoubleArray(ints);
     * // fromInts is [1.0, 2.0, 3.0]
     *
     * // Null elements become 0
     * List<Double> withNull = N.asList(1.1, null, 3.3);
     * double[] arrayWithNull = N.toDoubleArray(withNull);
     * // arrayWithNull is [1.1, 0.0, 3.3]
     * }</pre>
     *
     * @param c the collection of Number objects to be converted. Can be {@code null} or contain {@code null} elements.
     * @return a double array containing the primitive double values from the collection. Null elements are converted to 0.
     *         Returns an empty array if {@code c} is {@code null} or empty.
     */
    public static double[] toDoubleArray(final Collection<? extends Number> c) {
        return toDoubleArray(c, 0);
    }

    /**
     * Converts the specified range of the specified Number collection to a double array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a double array containing the primitive double values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static double[] toDoubleArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex) {
        return toDoubleArray(c, fromIndex, toIndex, 0);
    }

    /**
     * Converts a collection of Number objects to a double array.
     *
     * @param c the collection of Number objects to be converted
     * @param defaultForNull the default double value to use if a Number object in the collection is null
     * @return a double array containing the primitive double values from the collection
     */
    public static double[] toDoubleArray(final Collection<? extends Number> c, final double defaultForNull) {
        return toDoubleArray(c, 0, size(c), defaultForNull);
    }

    /**
     * Converts the specified range of the specified Number collection to a double array.
     *
     * @param c the collection of Number objects to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param defaultForNull the default double value to use if a Number object in the collection is null
     * @return a double array containing the primitive double values from the specified range of the collection
     * @throws IndexOutOfBoundsException if the specified indices are out of the collection's range
     */
    public static double[] toDoubleArray(final Collection<? extends Number> c, final int fromIndex, final int toIndex, final double defaultForNull)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int len = toIndex - fromIndex;
        final double[] result = new double[len];

        if (c instanceof final List<? extends Number> list && c instanceof RandomAccess) {
            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = list.get(i + fromIndex)) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = Numbers.toDouble(val);
                }
            }
        } else {
            final Iterator<? extends Number> iter = c.iterator();

            if (fromIndex > 0) {
                int offset = 0;

                while (offset++ < fromIndex) {
                    iter.next();
                }
            }

            Number val = null;

            for (int i = 0; i < len; i++) {
                if ((val = iter.next()) == null) {
                    result[i] = defaultForNull;
                } else {
                    result[i] = Numbers.toDouble(val);
                }
            }
        }

        return result;
    }

    /**
     * Converts a boolean array to a modifiable List, which is NOT backed with the input array.
     * Changes to the returned list will not affect the original array, and vice versa.
     *
     * <p><b>Performance Note:</b> This operation boxes each primitive boolean value into a Boolean object,
     * which may have performance implications for large arrays.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false, true};
     * List<Boolean> list = N.toList(array);
     * list.add(false);  // list is now [true, false, true, false]
     * // array is still [true, false, true] - not affected
     *
     * // Null or empty input returns empty list
     * List<Boolean> empty = N.toList((boolean[]) null);
     * // empty is an empty ArrayList
     * }</pre>
     *
     * @param a the boolean array to be converted. Can be {@code null}.
     * @return a modifiable List of Boolean objects containing the values from the boolean array.
     *         Returns an empty ArrayList if {@code a} is {@code null} or empty.
     */
    public static List<Boolean> toList(final boolean[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the boolean array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Boolean objects containing the values from the specified range of the boolean array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Boolean> toList(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Boolean> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a char array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the char array to be converted
     * @return a modifiable List of Character objects containing the values from the char array
     */
    public static List<Character> toList(final char[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the char array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Character objects containing the values from the specified range of the char array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Character> toList(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Character> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a byte array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the byte array to be converted
     * @return a modifiable List of Byte objects containing the values from the byte array
     */
    public static List<Byte> toList(final byte[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the byte array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the byte array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Byte objects containing the values from the specified range of the byte array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Byte> toList(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Byte> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a short array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the short array to be converted
     * @return a modifiable List of Short objects containing the values from the short array
     */
    public static List<Short> toList(final short[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the short array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the short array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Short objects containing the values from the specified range of the short array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Short> toList(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Short> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an int array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the int array to be converted
     * @return a modifiable List of Integer objects containing the values from the int array
     */
    public static List<Integer> toList(final int[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the int array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the int array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Integer objects containing the values from the specified range of the int array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Integer> toList(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Integer> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a long array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the long array to be converted
     * @return a modifiable List of Long objects containing the values from the long array
     */
    public static List<Long> toList(final long[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the long array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the long array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Long objects containing the values from the specified range of the long array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Long> toList(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Long> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a float array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the float array to be converted
     * @return a modifiable List of Float objects containing the values from the float array
     */
    public static List<Float> toList(final float[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the float array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the float array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Float objects containing the values from the specified range of the float array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Float> toList(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Float> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a double array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the double array to be converted
     * @return a modifiable List of Double objects containing the values from the double array
     */
    public static List<Double> toList(final double[] a) {
        return toList(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the double array to a modifiable List, which is NOT backed with the input array
     *
     * @param a the double array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of Double objects containing the values from the specified range of the double array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static List<Double> toList(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final List<Double> result = new ArrayList<>(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of objects to a modifiable List, which is NOT backed with the input array.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be converted
     * @return a modifiable List of objects containing the values from the array
     */
    public static <T> List<T> toList(final T[] a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return asList(a);
    }

    /**
     * Converts the specified range of the array to a modifiable List, which is NOT backed with the input array.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable List of objects containing the values from the specified range of the array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static <T> List<T> toList(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return new ArrayList<>();
        } else if (fromIndex == 0 && toIndex == a.length) {
            return asList(a);
        }

        final List<T> result = new ArrayList<>(toIndex - fromIndex);

        //noinspection ManualArrayToCollectionCopy
        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]); //NOSONAR
        }

        return result;
    }

    /**
     * Converts an Iterator of objects to a modifiable List.
     * The iterator will be fully consumed by this operation and cannot be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = N.asList("a", "b", "c").iterator();
     * List<String> list = N.toList(iter);
     * // list is ["a", "b", "c"]
     * // iter is now exhausted and cannot be reused
     *
     * // Null iterator returns empty list
     * List<String> empty = N.toList((Iterator<String>) null);
     * // empty is an empty ArrayList
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to be converted. Can be {@code null}. Will be consumed by this operation.
     * @return a modifiable ArrayList containing all values from the iterator. Returns an empty ArrayList if {@code iter} is {@code null}.
     */
    public static <T> List<T> toList(final Iterator<? extends T> iter) {
        if (iter == null) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>();

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    /**
     * Converts a boolean array to a modifiable Set, which is NOT backed with the input array.
     * Duplicate values in the array will appear only once in the resulting Set.
     * Changes to the returned Set will not affect the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false, true, false};
     * Set<Boolean> set = N.toSet(array);
     * // set contains only [true, false] - duplicates removed
     * set.add(true);  // no effect, already present
     *
     * // Null or empty input returns empty Set
     * Set<Boolean> empty = N.toSet((boolean[]) null);
     * // empty is an empty HashSet
     * }</pre>
     *
     * @param a the boolean array to be converted. Can be {@code null}.
     * @return a modifiable Set of Boolean objects containing the unique values from the boolean array.
     *         Returns an empty HashSet if {@code a} is {@code null} or empty.
     */
    public static Set<Boolean> toSet(final boolean[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the boolean array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the boolean array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Boolean objects containing the values from the specified range of the boolean array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Boolean> toSet(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Boolean> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a char array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the char array to be converted
     * @return a modifiable Set of Character objects containing the values from the char array
     */
    public static Set<Character> toSet(final char[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the char array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the char array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Character objects containing the values from the specified range of the char array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Character> toSet(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Character> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a byte array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the byte array to be converted
     * @return a modifiable Set of Byte objects containing the values from the byte array
     */
    public static Set<Byte> toSet(final byte[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the byte array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the byte array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Byte objects containing the values from the specified range of the byte array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Byte> toSet(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Byte> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a short array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the short array to be converted
     * @return a modifiable Set of Short objects containing the values from the short array
     */
    public static Set<Short> toSet(final short[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the short array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the short array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Short objects containing the values from the specified range of the short array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Short> toSet(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Short> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an int array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the int array to be converted
     * @return a modifiable Set of Integer objects containing the values from the int array
     */
    public static Set<Integer> toSet(final int[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the int array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the int array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Integer objects containing the values from the specified range of the int array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Integer> toSet(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Integer> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a long array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the long array to be converted
     * @return a modifiable Set of Long objects containing the values from the long array
     */
    public static Set<Long> toSet(final long[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the long array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the long array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Long objects containing the values from the specified range of the long array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Long> toSet(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Long> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a float array to a Set of Float objects, which is NOT backed with the input array.
     *
     * @param a the float array to be converted
     * @return a modifiable Set of Float objects containing the values from the float array
     */
    public static Set<Float> toSet(final float[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the float array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the float array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Float objects containing the values from the specified range of the float array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Float> toSet(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Float> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a double array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the double array to be converted
     * @return a modifiable Set of Double objects containing the values from the double array
     */
    public static Set<Double> toSet(final double[] a) {
        return toSet(a, 0, len(a)); // NOSONAR
    }

    /**
     * Converts the specified range of the double array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param a the double array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of Double objects containing the values from the specified range of the double array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static Set<Double> toSet(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<Double> result = newHashSet(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of objects to a modifiable Set, which is NOT backed with the input array.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be converted
     * @return a modifiable Set of objects containing the values from the array
     */
    public static <T> Set<T> toSet(final T[] a) {
        if (isEmpty(a)) {
            return newHashSet();
        }

        return asSet(a);
    }

    /**
     * Converts the specified range of the array to a modifiable Set, which is NOT backed with the input array.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @return a modifiable Set of objects containing the values from the specified range of the array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     */
    public static <T> Set<T> toSet(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return newHashSet();
        }

        final Set<T> result = newHashSet(toIndex - fromIndex);

        //noinspection ManualArrayToCollectionCopy
        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]); //NOSONAR
        }

        return result;
    }

    /**
     * Converts an Iterator of objects to a modifiable Set.
     * Duplicate elements in the iterator will appear only once in the resulting Set.
     * The iterator will be fully consumed by this operation and cannot be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = N.asList("a", "b", "a", "c").iterator();
     * Set<String> set = N.toSet(iter);
     * // set is ["a", "b", "c"] - duplicates removed
     * // iter is now exhausted and cannot be reused
     *
     * // Null iterator returns empty set
     * Set<String> empty = N.toSet((Iterator<String>) null);
     * // empty is an empty HashSet
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to be converted. Can be {@code null}. Will be consumed by this operation.
     * @return a modifiable HashSet containing unique values from the iterator. Returns an empty HashSet if {@code iter} is {@code null}.
     */
    public static <T> Set<T> toSet(final Iterator<? extends T> iter) {
        if (iter == null) {
            return newHashSet();
        }

        final Set<T> result = newHashSet();

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    /**
     * Converts a boolean array to a specified type of Collection.
     * This method provides flexibility to create any type of Collection implementation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false, true};
     *
     * // Convert to ArrayList
     * List<Boolean> list = N.toCollection(array, ArrayList::new);
     * // list is [true, false, true]
     *
     * // Convert to LinkedHashSet (maintains insertion order, removes duplicates)
     * Set<Boolean> set = N.toCollection(array, LinkedHashSet::new);
     * // set is [true, false]
     *
     * // Convert to TreeSet (sorted)
     * Set<Boolean> sorted = N.toCollection(array, TreeSet::new);
     * // sorted is [false, true]
     * }</pre>
     *
     * @param <C> the type of Collection to be returned
     * @param a the boolean array to be converted. Can be {@code null}.
     * @param supplier a function that provides a new instance of the desired Collection type. The function receives the expected capacity as a parameter.
     * @return a Collection of Boolean objects containing the values from the boolean array. Returns an empty Collection if {@code a} is {@code null} or empty.
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Boolean>> C toCollection(final boolean[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the boolean array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the boolean array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Boolean objects containing the values from the specified range of the boolean array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Boolean>> C toCollection(final boolean[] a, final int fromIndex, final int toIndex,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a char array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the char array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Character objects containing the values from the char array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Character>> C toCollection(final char[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the char array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the char array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Character objects containing the values from the specified range of the char array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Character>> C toCollection(final char[] a, final int fromIndex, final int toIndex,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a byte array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the byte array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Byte objects containing the values from the byte array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Byte>> C toCollection(final byte[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the byte array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the byte array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Byte objects containing the values from the specified range of the byte array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Byte>> C toCollection(final byte[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a short array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the short array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Short objects containing the values from the short array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Short>> C toCollection(final short[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the short array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the short array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Short objects containing the values from the specified range of the short array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Short>> C toCollection(final short[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an int array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the int array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Integer objects containing the values from the int array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Integer>> C toCollection(final int[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the int array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the int array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Integer objects containing the values from the specified range of the int array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Integer>> C toCollection(final int[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a long array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the long array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Long objects containing the values from the long array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Long>> C toCollection(final long[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the long array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the long array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Long objects containing the values from the specified range of the long array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Long>> C toCollection(final long[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a float array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the float array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Float objects containing the values from the float array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Float>> C toCollection(final float[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the float array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the float array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Float objects containing the values from the specified range of the float array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Float>> C toCollection(final float[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts a double array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the double array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Double objects containing the values from the double array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Double>> C toCollection(final double[] a, final IntFunction<? extends C> supplier) {
        return toCollection(a, 0, len(a), supplier);
    }

    /**
     * Converts the specified range of the double array to a specified type of Collection.
     *
     * @param <C> the type of Collection to be returned
     * @param a the double array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of Double objects containing the values from the specified range of the double array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <C extends Collection<Double>> C toCollection(final double[] a, final int fromIndex, final int toIndex,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(a[i]);
        }

        return result;
    }

    /**
     * Converts an array of objects to a specified type of Collection.
     *
     * @param <T> the type of elements in the array and the Collection
     * @param <C> the type of Collection to be returned
     * @param a the array to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of objects containing the values from the array
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <T, C extends Collection<T>> C toCollection(final T[] a, final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return toCollection(a, 0, a.length, supplier);
    }

    /**
     * Converts the specified range of the array to a specified type of Collection.
     *
     * @param <T> the type of elements in the array and the Collection
     * @param <C> the type of Collection to be returned
     * @param a the array to be converted
     * @param fromIndex the starting (inclusive) index of the range to be converted
     * @param toIndex the ending (exclusive) index of the range to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of objects containing the values from the specified range of the array
     * @throws IndexOutOfBoundsException if the specified indices are out of the array's range
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <T, C extends Collection<T>> C toCollection(final T[] a, final int fromIndex, final int toIndex, final IntFunction<? extends C> supplier)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return supplier.apply(0);
        } else if (fromIndex == 0 && toIndex == a.length && a.length >= MIN_SIZE_FOR_COPY_ALL) {
            final C result = supplier.apply(a.length);
            result.addAll(Array.asList(a));
            return result;
        } else {
            final C result = supplier.apply(toIndex - fromIndex);

            //noinspection ManualArrayToCollectionCopy
            for (int i = fromIndex; i < toIndex; i++) {
                result.add(a[i]); //NOSONAR
            }

            return result;
        }
    }

    /**
     * Converts an Iterable to a specified type of Collection.
     *
     * @param <T> the type of elements in the Iterable and the Collection
     * @param <C> the type of Collection to be returned
     * @param c the Iterable to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of objects containing the values from the Iterable
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <T, C extends Collection<T>> C toCollection(final Iterable<? extends T> c, final IntFunction<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        if (c instanceof Collection) {
            final Collection<T> tmp = (Collection<T>) c;
            final C ret = supplier.apply(tmp.size());

            ret.addAll(tmp);

            return ret;
        } else {
            final Iterator<? extends T> iter = c.iterator();
            final C ret = supplier.apply(0);

            while (iter.hasNext()) {
                ret.add(iter.next());
            }

            return ret;
        }
    }

    /**
     * Converts an Iterator to a specified type of Collection.
     *
     * <p>This method consumes all elements from the Iterator and adds them to a new Collection
     * provided by the supplier. The Iterator cannot be reused after this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = N.asList("a", "b", "c").iterator();
     *
     * // Convert to ArrayList
     * List<String> list = N.toCollection(iter, ArrayList::new);
     *
     * // Convert to LinkedHashSet (maintains insertion order)
     * Iterator<String> iter2 = N.asList("a", "b", "a").iterator();
     * Set<String> set = N.toCollection(iter2, LinkedHashSet::new);
     * // Result: ["a", "b"]
     * }</pre>
     *
     * @param <T> the type of elements in the Iterator and the Collection
     * @param <C> the type of Collection to be returned
     * @param iter the Iterator to be converted
     * @param supplier a function that provides a new instance of the desired Collection type
     * @return a Collection of objects containing the values from the Iterator
     * @see IntFunctions#ofList()
     * @see IntFunctions#ofSet()
     */
    public static <T, C extends Collection<T>> C toCollection(final Iterator<? extends T> iter, final Supplier<? extends C> supplier) {
        final C c = supplier.get();

        if (iter == null) {
            return c;
        }

        while (iter.hasNext()) {
            c.add(iter.next());
        }

        return c;
    }

    /**
     * Converts an Iterable to a Map using a key extractor function.
     *
     * <p>Each element in the Iterable becomes a value in the resulting Map, with the key
     * extracted by applying the keyExtractor function to the element. If duplicate keys
     * are produced, the later value overwrites the earlier one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = N.asList("Alice", "Bob", "Charlie");
     * Map<Integer, String> lengthToName = N.toMap(names, String::length);
     * // Result: {5=Alice (or Charlie), 3=Bob}
     *
     * List<User> users = N.asList(new User(1, "Alice"), new User(2, "Bob"));
     * Map<Integer, User> idToUser = N.toMap(users, User::getId);
     * // Result: {1=User(1, Alice), 2=User(2, Bob)}
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param <K> the type of keys in the resulting Map
     * @param c the Iterable to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterable
     * @return a Map containing the elements of the Iterable, with keys extracted by the keyExtractor function
     */
    public static <T, K> Map<K, T> toMap(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        if (isEmptyCollection(c)) {
            return new HashMap<>(0);
        }

        final Map<K, T> result = newHashMap(c instanceof Collection ? ((Collection<T>) c).size() : 0);

        for (final T e : c) {
            result.put(keyExtractor.apply(e), e);
        }

        return result;
    }

    /**
     * Converts an Iterable to a Map using key and value extractor functions.
     *
     * <p>Each element in the Iterable is transformed into a key-value pair using the provided
     * extractor functions. If duplicate keys are produced, the later value overwrites the earlier one.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<User> users = N.asList(new User(1, "Alice"), new User(2, "Bob"));
     * Map<Integer, String> idToName = N.toMap(users, User::getId, User::getName);
     * // Result: {1="Alice", 2="Bob"}
     *
     * List<String> words = N.asList("apple", "banana", "cherry");
     * Map<String, Integer> wordToLength = N.toMap(words, s -> s, String::length);
     * // Result: {"apple"=5, "banana"=6, "cherry"=6}
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param c the Iterable to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterable
     * @param valueExtractor a function that extracts values from the elements of the Iterable
     * @return a Map containing the elements of the Iterable, with keys and values extracted by the keyExtractor and valueExtractor functions
     */
    public static <T, K, V> Map<K, V> toMap(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        if (isEmptyCollection(c)) {
            return new HashMap<>(0);
        }

        final Map<K, V> result = newHashMap(c instanceof Collection ? ((Collection<T>) c).size() : 0);

        for (final T e : c) {
            result.put(keyExtractor.apply(e), valueExtractor.apply(e));
        }

        return result;
    }

    /**
     * Converts an Iterable to a Map using key and value extractor functions, with a custom Map supplier.
     *
     * <p>This method allows specifying a custom Map implementation through the mapSupplier parameter,
     * such as LinkedHashMap for maintaining insertion order or TreeMap for sorted keys.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<User> users = N.asList(new User(1, "Alice"), new User(2, "Bob"));
     *
     * // Using LinkedHashMap to maintain insertion order
     * LinkedHashMap<Integer, String> orderedMap = N.toMap(users, User::getId, User::getName,
     *         size -> new LinkedHashMap<>(size));
     *
     * // Using TreeMap for sorted keys
     * TreeMap<Integer, String> sortedMap = N.toMap(users, User::getId, User::getName,
     *         size -> new TreeMap<>());
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param <M> the type of Map to be returned
     * @param c the Iterable to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterable
     * @param valueExtractor a function that extracts values from the elements of the Iterable
     * @param mapSupplier a function that provides a new instance of the desired Map type
     * @return a Map containing the elements of the Iterable, with keys and values extracted by the keyExtractor and valueExtractor functions
     */
    public static <T, K, V, M extends Map<K, V>> M toMap(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final IntFunction<? extends M> mapSupplier) {
        if (isEmptyCollection(c)) {
            return mapSupplier.apply(0);
        }

        final M result = mapSupplier.apply(c instanceof Collection ? ((Collection<T>) c).size() : 0);

        for (final T e : c) {
            result.put(keyExtractor.apply(e), valueExtractor.apply(e));
        }

        return result;
    }

    /**
     * Converts an Iterable to a Map using key and value extractor functions, with a merge function for handling
     * duplicate keys and a custom Map supplier.
     *
     * <p>When duplicate keys are encountered, the mergeFunction is used to combine the old and new values.
     * This is useful for aggregating values or handling conflicts.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Summing values for duplicate keys
     * List<Transaction> transactions = N.asList(
     *     new Transaction("A", 100), new Transaction("B", 200), new Transaction("A", 50));
     * Map<String, Integer> totalByAccount = N.toMap(transactions,
     *     Transaction::getAccount,
     *     Transaction::getAmount,
     *     Integer::sum,
     *     size -> new HashMap<>(size));
     * // Result: {"A"=150, "B"=200}
     *
     * // Concatenating strings for duplicate keys
     * List<Pair<String, String>> pairs = N.asList(Pair.of("k1", "a"), Pair.of("k1", "b"));
     * Map<String, String> merged = N.toMap(pairs, Pair::getLeft, Pair::getRight,
     *     (v1, v2) -> v1 + "," + v2, size -> new LinkedHashMap<>(size));
     * // Result: {"k1"="a,b"}
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param <M> the type of Map to be returned
     * @param c the Iterable to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterable
     * @param valueExtractor a function that extracts values from the elements of the Iterable
     * @param mergeFunction a function to merge values when duplicate keys are encountered
     * @param mapSupplier a function that provides a new instance of the desired Map type
     * @return a Map containing the elements of the Iterable, with keys and values extracted by the keyExtractor and valueExtractor functions
     * @see Fn#throwingMerger()
     * @see Fn#replacingMerger()
     * @see Fn#ignoringMerger()
     */
    public static <T, K, V, M extends Map<K, V>> M toMap(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final BiFunction<? super V, ? super V, ? extends V> mergeFunction,
            final IntFunction<? extends M> mapSupplier) {
        if (isEmptyCollection(c)) {
            return mapSupplier.apply(0);
        }

        final M result = mapSupplier.apply(c instanceof Collection ? ((Collection<T>) c).size() : 0);
        K key = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);

            final V oldValue = result.get(key);

            if (oldValue == null && !result.containsKey(key)) {
                result.put(key, valueExtractor.apply(e));
            } else {
                result.put(key, mergeFunction.apply(oldValue, valueExtractor.apply(e)));
            }
        }

        return result;
    }

    /**
     * Converts an Iterator to a Map using a key extractor function.
     *
     * <p>Each element from the Iterator becomes a value in the resulting Map, with the key
     * extracted by applying the keyExtractor function to the element.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = N.asList("Alice", "Bob", "Charlie").iterator();
     * Map<Integer, String> lengthToName = N.toMap(iter, String::length);
     * // Result: {5="Charlie", 3="Bob"} (later values overwrite earlier for same key)
     * }</pre>
     *
     * @param <T> the type of elements in the Iterator
     * @param <K> the type of keys in the resulting Map
     * @param iter the Iterator to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterator
     * @return a Map containing the elements of the Iterator, with keys extracted by the keyExtractor function
     */
    public static <T, K> Map<K, T> toMap(final Iterator<? extends T> iter, final Function<? super T, K> keyExtractor) {
        if (iter == null) {
            return new HashMap<>();
        }

        final Map<K, T> result = new HashMap<>();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
            result.put(keyExtractor.apply(e), e);
        }

        return result;
    }

    /**
     * Converts an Iterator to a Map using key and value extractor functions.
     * Each element from the Iterator is transformed into a key-value pair using the provided functions.
     * If duplicate keys are encountered, later values overwrite earlier ones.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = N.asList("apple", "banana", "cherry");
     * Iterator<String> iter = words.iterator();
     * Map<Integer, String> lengthToWord = N.toMap(iter, String::length, s -> s.toUpperCase());
     * // Result: {5="APPLE" or "CHERRY", 6="BANANA"} (later values overwrite earlier for same key)
     *
     * // Null iterator returns empty map
     * Map<Integer, String> empty = N.toMap(null, String::length, String::toUpperCase);
     * // empty is an empty HashMap
     * }</pre>
     *
     * @param <T> the type of elements in the Iterator
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param iter the Iterator to be converted. Can be {@code null}. The iterator will be consumed by this operation.
     * @param keyExtractor a function that extracts keys from the elements of the Iterator. Cannot be {@code null}.
     * @param valueExtractor a function that extracts values from the elements of the Iterator. Cannot be {@code null}.
     * @return a HashMap containing the elements of the Iterator, with keys and values extracted by the keyExtractor and valueExtractor functions.
     *         Returns an empty HashMap if {@code iter} is {@code null}.
     */
    public static <T, K, V> Map<K, V> toMap(final Iterator<? extends T> iter, final Function<? super T, K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        if (iter == null) {
            return new HashMap<>();
        }

        final Map<K, V> result = new HashMap<>();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
            result.put(keyExtractor.apply(e), valueExtractor.apply(e));
        }

        return result;
    }

    /**
     * Converts an Iterator to a Map using key and value extractor functions, with a custom Map supplier.
     * This method allows specifying a custom Map implementation through the mapSupplier parameter.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = N.asList("apple", "banana", "cherry");
     * Iterator<String> iter = words.iterator();
     *
     * // Using LinkedHashMap to maintain insertion order
     * LinkedHashMap<Integer, String> orderedMap = N.toMap(iter,
     *     String::length, String::toUpperCase, LinkedHashMap::new);
     * // orderedMap maintains insertion order of keys
     *
     * // Using TreeMap for sorted keys
     * Iterator<String> iter2 = words.iterator();
     * TreeMap<Integer, String> sortedMap = N.toMap(iter2,
     *     String::length, String::toUpperCase, TreeMap::new);
     * // sortedMap has keys in natural order
     * }</pre>
     *
     * @param <T> the type of elements in the Iterator
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param <M> the type of Map to be returned
     * @param iter the Iterator to be converted. Can be {@code null}. The iterator will be consumed by this operation.
     * @param keyExtractor a function that extracts keys from the elements of the Iterator. Cannot be {@code null}.
     * @param valueExtractor a function that extracts values from the elements of the Iterator. Cannot be {@code null}.
     * @param mapSupplier a function that provides a new instance of the desired Map type. Cannot be {@code null}.
     * @return a Map of the specified type containing the elements of the Iterator, with keys and values extracted by the keyExtractor and valueExtractor functions.
     *         Returns an empty Map of the specified type if {@code iter} is {@code null}.
     */
    public static <T, K, V, M extends Map<K, V>> M toMap(final Iterator<? extends T> iter, final Function<? super T, K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final Supplier<? extends M> mapSupplier) {
        if (iter == null) {
            return mapSupplier.get();
        }

        final M result = mapSupplier.get();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
            result.put(keyExtractor.apply(e), valueExtractor.apply(e));
        }

        return result;
    }

    /**
     * Converts an Iterator to a Map using key and value extractor functions, with a custom Map supplier.
     *
     * @param <T> the type of elements in the Iterator
     * @param <K> the type of keys in the resulting Map
     * @param <V> the type of values in the resulting Map
     * @param <M> the type of Map to be returned
     * @param iter the Iterator to be converted
     * @param keyExtractor a function that extracts keys from the elements of the Iterator
     * @param valueExtractor a function that extracts values from the elements of the Iterator
     * @param mergeFunction a function that merges values if the same key is encountered
     * @param mapSupplier a function that provides a new instance of the desired Map type
     * @return a Map containing the elements of the Iterator, with keys and values extracted by the keyExtractor and valueExtractor functions
     * @see Fn#throwingMerger()
     * @see Fn#replacingMerger()
     * @see Fn#ignoringMerger()
     */
    public static <T, K, V, M extends Map<K, V>> M toMap(final Iterator<? extends T> iter, final Function<? super T, K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final BiFunction<? super V, ? super V, ? extends V> mergeFunction,
            final Supplier<? extends M> mapSupplier) {
        if (iter == null) {
            return mapSupplier.get();
        }

        final M result = mapSupplier.get();
        T e = null;
        K key = null;

        while (iter.hasNext()) {
            e = iter.next();
            key = keyExtractor.apply(e);

            final V oldValue = result.get(key);

            if (oldValue == null && !result.containsKey(key)) {
                result.put(key, valueExtractor.apply(e));
            } else {
                result.put(key, mergeFunction.apply(oldValue, valueExtractor.apply(e)));
            }
        }

        return result;
    }

    /**
     * Returns the input array as-is without any modification or copying.
     * This is a type-safe varargs method that allows creating arrays inline.
     * Note: No defensive copy is made, so the returned array is the same instance as the input.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Create an array inline
     * String[] array = N.asArray("a", "b", "c");
     * // array is ["a", "b", "c"]
     *
     * // Pass varargs to methods expecting arrays
     * void processArray(String[] arr) { }
     * processArray(N.asArray("x", "y", "z"));
     *
     * // Returns null for null input
     * String[] nullArray = N.asArray((String[]) null);
     * // nullArray is null
     * }</pre>
     *
     * @param <T> the type of the array elements
     * @param a the input array. Can be {@code null}.
     * @return the input array unchanged (same reference). Returns {@code null} if {@code a} is {@code null}.
     * @see Arrays#asList(Object[])
     * @see N#copyOf(Object[], int)
     * @see N#asList(Object[])
     */
    @SafeVarargs
    public static <T> T[] asArray(final T... a) {
        return a;
    }

    /**
     * Creates a new Map by populating it with the provided key-value pairs or another Map.
     *
     * @param <K> the type of keys in the Map
     * @param <V> the type of values in the Map
     * @param <T> the type of Map to be returned
     * @param m the Map to be populated
     * @param a an array of key-value pairs or a single Map to populate the Map
     * @return the populated Map
     */
    @SuppressWarnings("unchecked")
    static <K, V, T extends Map<K, V>> T newMap(final T m, final Object... a) {
        if (isEmpty(a)) {
            return m;
        }

        if (a.length == 1) {
            if (a[0] instanceof Map) {
                m.putAll((Map<K, V>) a[0]);
            } else if (Beans.isBeanClass(a[0].getClass())) {
                Beans.bean2Map(a[0], (Map<String, Object>) m);
            } else {
                throw new IllegalArgumentException(
                        "The parameters must be the pairs of property name and value, or Map, or a bean class with getter/setter methods.");
            }
        } else {
            if (0 != (a.length % 2)) {
                throw new IllegalArgumentException(
                        "The parameters must be the pairs of property name and value, or Map, or a bean class with getter/setter methods.");
            }

            for (int i = 0; i < a.length; i++) {
                m.put((K) a[i], (V) a[++i]);
            }
        }

        return m;
    }

    /**
     * Returns a modifiable {@code HashMap} with the specified key and value.
     * This is a convenient factory method for creating a single-entry map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = N.asMap("age", 25);
     * map.put("name", "John");  // Can add more entries
     *
     * // Both key and value can be null
     * Map<String, String> mapWithNull = N.asMap("key", null);
     * }</pre>
     *
     * @param <K> the type of keys in the Map
     * @param <V> the type of values in the Map
     * @param k1 the key to be placed in the Map. Can be {@code null}.
     * @param v1 the value to be associated with the key in the Map. Can be {@code null}.
     * @return a modifiable HashMap containing the specified key and value
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1) {
        final Map<K, V> map = newHashMap(1);
        map.put(k1, v1);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with the specified keys and values.
     *
     * @param <K> the type of keys in the Map
     * @param <V> the type of values in the Map
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2) {
        final Map<K, V> map = newHashMap(2);
        map.put(k1, v1);
        map.put(k2, v2);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3) {
        final Map<K, V> map = newHashMap(3);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4) {
        final Map<K, V> map = newHashMap(4);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5,
            final V v5) {
        final Map<K, V> map = newHashMap(5);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @param k6 the sixth key to be placed in the Map
     * @param v6 the value to be associated with the sixth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5, final V v5,
            final K k6, final V v6) {
        final Map<K, V> map = newHashMap(6);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @param k6 the sixth key to be placed in the Map
     * @param v6 the value to be associated with the sixth key in the Map
     * @param k7 the seventh key to be placed in the Map
     * @param v7 the value to be associated with the seventh key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5, final V v5,
            final K k6, final V v6, final K k7, final V v7) {
        final Map<K, V> map = newHashMap(7);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        map.put(k7, v7);
        return map;
    }

    /**
     * Returns a modifiable {@code Map} with specified key/value pairs.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param a an array of key/value pairs
     * @return a Map containing the specified key/value pairs
     * @deprecated
     */
    @Deprecated
    @NullSafe
    public static <K, V> Map<K, V> asMap(final Object... a) {
        if (isEmpty(a)) {
            return new HashMap<>();
        }

        return newMap(newHashMap(a.length / 2), a);
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified key and value.
     * A LinkedHashMap maintains insertion order, making it useful when iteration order matters.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = N.asLinkedHashMap("first", 1);
     * map.put("second", 2);
     * map.put("third", 3);
     * // Iteration order: first, second, third (insertion order preserved)
     *
     * // Both key and value can be null
     * Map<String, String> mapWithNull = N.asLinkedHashMap("key", null);
     * }</pre>
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map. Can be {@code null}.
     * @param v1 the value to be associated with the first key in the Map. Can be {@code null}.
     * @return a modifiable LinkedHashMap containing the specified key and value, preserving insertion order
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1) {
        final Map<K, V> map = newLinkedHashMap(1);
        map.put(k1, v1);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2) {
        final Map<K, V> map = newLinkedHashMap(2);
        map.put(k1, v1);
        map.put(k2, v2);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3) {
        final Map<K, V> map = newLinkedHashMap(3);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4) {
        final Map<K, V> map = newLinkedHashMap(4);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5,
            final V v5) {
        final Map<K, V> map = newLinkedHashMap(5);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @param k6 the sixth key to be placed in the Map
     * @param v6 the value to be associated with the sixth key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5,
            final V v5, final K k6, final V v6) {
        final Map<K, V> map = newLinkedHashMap(6);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified keys/values.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param k1 the first key to be placed in the Map
     * @param v1 the value to be associated with the first key in the Map
     * @param k2 the second key to be placed in the Map
     * @param v2 the value to be associated with the second key in the Map
     * @param k3 the third key to be placed in the Map
     * @param v3 the value to be associated with the third key in the Map
     * @param k4 the fourth key to be placed in the Map
     * @param v4 the value to be associated with the fourth key in the Map
     * @param k5 the fifth key to be placed in the Map
     * @param v5 the value to be associated with the fifth key in the Map
     * @param k6 the sixth key to be placed in the Map
     * @param v6 the value to be associated with the sixth key in the Map
     * @param k7 the seventh key to be placed in the Map
     * @param v7 the value to be associated with the seventh key in the Map
     * @return a Map containing the specified keys and values
     */
    public static <K, V> Map<K, V> asLinkedHashMap(final K k1, final V v1, final K k2, final V v2, final K k3, final V v3, final K k4, final V v4, final K k5,
            final V v5, final K k6, final V v6, final K k7, final V v7) {
        final Map<K, V> map = newLinkedHashMap(7);
        map.put(k1, v1);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        map.put(k7, v7);
        return map;
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with specified key/value pairs.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param a an array of key/value pairs
     * @return a Map containing the specified key/value pairs
     * @deprecated Use {@link #newLinkedHashMap()} or specific overloads with explicit key-value parameters instead.
     *             This method uses varargs which makes the API less type-safe and more error-prone.
     */
    @Deprecated
    @NullSafe
    public static <K, V> Map<K, V> asLinkedHashMap(final Object... a) {
        if (isEmpty(a)) {
            return newLinkedHashMap();
        }

        return newMap(newLinkedHashMap(a.length / 2), a);
    }

    /**
     * Returns a modifiable {@code LinkedHashMap} with a specified property name and value.
     * This is a type-safe convenience method for creating property maps commonly used in configuration.
     * The returned map uses String keys and Object values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Object> props = N.asProps("timeout", 5000);
     * props.put("retryCount", 3);
     * props.put("enabled", true);
     *
     * // Property value can be null
     * Map<String, Object> propsWithNull = N.asProps("optionalValue", null);
     * }</pre>
     *
     * @param propName the name of the property to be placed in the Map. Can be {@code null}.
     * @param propValue the value to be associated with the property name in the Map. Can be {@code null}.
     * @return a modifiable LinkedHashMap containing the specified property name and value, preserving insertion order
     */
    @Beta
    public static Map<String, Object> asProps(final String propName, final Object propValue) {
        final Map<String, Object> props = newLinkedHashMap(1);
        props.put(propName, propValue);

        return props;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param propName1 the first property name to be placed in the Map
     * @param propValue1 the value to be associated with the first property name in the Map
     * @param propName2 the second property name to be placed in the Map
     * @param propValue2 the value to be associated with the second property name in the Map
     * @return a Map containing the specified property names and values
     */
    public static Map<String, Object> asProps(final String propName1, final Object propValue1, final String propName2, final Object propValue2) {
        final Map<String, Object> props = newLinkedHashMap(2);
        props.put(propName1, propValue1);
        props.put(propName2, propValue2);

        return props;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param propName1 the first property name to be placed in the Map
     * @param propValue1 the value to be associated with the first property name in the Map
     * @param propName2 the second property name to be placed in the Map
     * @param propValue2 the value to be associated with the second property name in the Map
     * @param propName3 the third property name to be placed in the Map
     * @param propValue3 the value to be associated with the third property name in the Map
     * @return a Map containing the specified property names and values
     */
    public static Map<String, Object> asProps(final String propName1, final Object propValue1, final String propName2, final Object propValue2,
            final String propName3, final Object propValue3) {
        final Map<String, Object> props = newLinkedHashMap(3);
        props.put(propName1, propValue1);
        props.put(propName2, propValue2);
        props.put(propName3, propValue3);

        return props;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param propName1 the first property name to be placed in the Map
     * @param propValue1 the value to be associated with the first property name in the Map
     * @param propName2 the second property name to be placed in the Map
     * @param propValue2 the value to be associated with the second property name in the Map
     * @param propName3 the third property name to be placed in the Map
     * @param propValue3 the value to be associated with the third property name in the Map
     * @param propName4 the fourth property name to be placed in the Map
     * @param propValue4 the value to be associated with the fourth property name in the Map
     * @return a Map containing the specified property names and values
     */
    public static Map<String, Object> asProps(final String propName1, final Object propValue1, final String propName2, final Object propValue2,
            final String propName3, final Object propValue3, final String propName4, final Object propValue4) {
        final Map<String, Object> props = newLinkedHashMap(4);
        props.put(propName1, propValue1);
        props.put(propName2, propValue2);
        props.put(propName3, propValue3);
        props.put(propName4, propValue4);

        return props;
    }

    /**
     * Returns a modifiable {@code Map} with specified keys/values.
     *
     * @param propName1 the first property name to be placed in the Map
     * @param propValue1 the value to be associated with the first property name in the Map
     * @param propName2 the second property name to be placed in the Map
     * @param propValue2 the value to be associated with the second property name in the Map
     * @param propName3 the third property name to be placed in the Map
     * @param propValue3 the value to be associated with the third property name in the Map
     * @param propName4 the fourth property name to be placed in the Map
     * @param propValue4 the value to be associated with the fourth property name in the Map
     * @param propName5 the fifth property name to be placed in the Map
     * @param propValue5 the value to be associated with the fifth property name in the Map
     * @return a Map containing the specified property names and values
     */
    public static Map<String, Object> asProps(final String propName1, final Object propValue1, final String propName2, final Object propValue2,
            final String propName3, final Object propValue3, final String propName4, final Object propValue4, final String propName5, final Object propValue5) {
        final Map<String, Object> props = newLinkedHashMap(5);
        props.put(propName1, propValue1);
        props.put(propName2, propValue2);
        props.put(propName3, propValue3);
        props.put(propName4, propValue4);
        props.put(propName5, propValue5);

        return props;
    }

    /**
     * Returns a modifiable {@code Map} with specified key/value pairs.
     *
     * @param a an array of key/value pairs
     * @return a Map containing the specified key/value pairs
     * @deprecated Use {@link #newLinkedHashMap()} or specific {@code asProps} overloads with explicit parameter pairs instead.
     *             This method uses varargs which makes the API less type-safe and more error-prone.
     */
    @Deprecated
    public static Map<String, Object> asProps(final Object... a) {
        if (isEmpty(a)) {
            return newLinkedHashMap();
        }

        return newMap(newLinkedHashMap(a.length / 2), a);
    }

    /**
     * Returns a modifiable {@code ArrayList} with the specified element.
     * This is a convenient factory method for creating a single-element list.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = N.asList("hello");
     * list.add("world");  // Can add more elements
     * // list is now ["hello", "world"]
     *
     * // Element can be null
     * List<String> listWithNull = N.asList(null);
     * // listWithNull is [null]
     * }</pre>
     *
     * @param <T> the type of the element
     * @param e the element to be placed in the List. Can be {@code null}.
     * @return a modifiable ArrayList containing the specified element
     */
    public static <T> List<T> asList(final T e) {
        final List<T> list = new ArrayList<>(1);
        list.add(e);
        return list;
    }

    /**
     * Returns a modifiable {@code ArrayList} with specified elements.
     * This is a convenient factory method for creating a two-element list.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = N.asList("hello", "world");
     * list.add("!");  // Can add more elements
     * // list is now ["hello", "world", "!"]
     *
     * // Elements can be null
     * List<String> listWithNull = N.asList("first", null);
     * // listWithNull is ["first", null]
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List. Can be {@code null}.
     * @param e2 the second element to be placed in the List. Can be {@code null}.
     * @return a modifiable ArrayList containing the specified elements in order
     */
    public static <T> List<T> asList(final T e1, final T e2) {
        final List<T> list = new ArrayList<>(2);
        list.add(e1);
        list.add(e2);
        return list;
    }

    /**
     * Returns a modifiable {@code ArrayList} with specified elements.
     * This is a convenient factory method for creating a three-element list.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> list = N.asList(1, 2, 3);
     * list.add(4);  // Can add more elements
     * // list is now [1, 2, 3, 4]
     *
     * // Elements can be null
     * List<String> listWithNull = N.asList("first", null, "third");
     * // listWithNull is ["first", null, "third"]
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List. Can be {@code null}.
     * @param e2 the second element to be placed in the List. Can be {@code null}.
     * @param e3 the third element to be placed in the List. Can be {@code null}.
     * @return a modifiable ArrayList containing the specified elements in order
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3) {
        final List<T> list = new ArrayList<>(3);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4) {
        final List<T> list = new ArrayList<>(4);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4, final T e5) {
        final List<T> list = new ArrayList<>(5);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = N.asList("a", "b", "c", "d", "e", "f");
     * list.add("g");   // modifiable
     * // list is ["a", "b", "c", "d", "e", "f", "g"]
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6) {
        final List<T> list = new ArrayList<>(6);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @param e7 the seventh element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7) {
        final List<T> list = new ArrayList<>(7);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        list.add(e7);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @param e7 the seventh element to be placed in the List
     * @param e8 the eighth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7, final T e8) {
        final List<T> list = new ArrayList<>(8);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        list.add(e7);
        list.add(e8);
        return list;
    }

    /**
     * Returns a modifiable {@code List} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @param e7 the seventh element to be placed in the List
     * @param e8 the eighth element to be placed in the List
     * @param e9 the ninth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> List<T> asList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7, final T e8, final T e9) {
        final List<T> list = new ArrayList<>(9);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        list.add(e7);
        list.add(e8);
        list.add(e9);
        return list;
    }

    /**
     * Returns a modifiable {@code List} containing the elements from the specified array.
     * If the specified array is {@code null} or empty, an empty {@code List} is returned.
     *
     * <p>This method creates a new {@code ArrayList} and populates it with all elements from the
     * provided array. Unlike {@link Arrays#asList(Object...)}, this method returns a fully
     * modifiable list that is not backed by the original array, meaning modifications to the returned
     * list will not affect the original array and vice versa.</p>
     *
     * @param <T> the type of elements in the list
     * @param a the array of elements to be placed in the List
     * @return a List containing the specified elements
     * @see Array#asList(Object...)
     * @see Arrays#asList(Object...)
     * @see List#of(Object...)
     */
    @SafeVarargs
    @NullSafe
    public static <T> List<T> asList(@NullSafe final T... a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return new ArrayList<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code LinkedList} with the specified element.
     *
     * @param <T> the type of the element
     * @param e the element to be placed in the List
     * @return a List containing the specified element
     */
    public static <T> LinkedList<T> asLinkedList(final T e) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2, final T e3) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2, final T e3, final T e4) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2, final T e3, final T e4, final T e5) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements.
     *
     * @param <T> the type of elements in the list
     * @param e1 the first element to be placed in the List
     * @param e2 the second element to be placed in the List
     * @param e3 the third element to be placed in the List
     * @param e4 the fourth element to be placed in the List
     * @param e5 the fifth element to be placed in the List
     * @param e6 the sixth element to be placed in the List
     * @param e7 the seventh element to be placed in the List
     * @return a List containing the specified elements
     */
    public static <T> LinkedList<T> asLinkedList(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7) { //NOSONAR
        final LinkedList<T> list = new LinkedList<>();
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        list.add(e5);
        list.add(e6);
        list.add(e7);
        return list;
    }

    /**
     * Returns a modifiable {@code LinkedList} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code List} is returned
     * 
     * <p>This method creates a new {@code LinkedList} and populates it with all elements from the
     * provided array. Unlike {@link Arrays#asList(Object...)}, this method returns a fully
     * modifiable list that is not backed by the original array, meaning modifications to the returned
     * list will not affect the original array and vice versa.</p>
     *
     * @param <T> the type of elements in the list
     * @param a the array of elements to be placed in the List
     * @return a List containing the specified elements
     * @see Array#asList(Object...)
     * @see Arrays#asList(Object...)
     * @see List#of(Object...)
     */
    @SafeVarargs
    @NullSafe
    public static <T> LinkedList<T> asLinkedList(final T... a) { //NOSONAR
        if (isEmpty(a)) {
            return new LinkedList<>();
        }

        return new LinkedList<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code Set} with the specified element.
     *
     * @param <T> the type of elements in the set
     * @param e the element to be placed in the Set
     * @return a Set containing the specified element
     */
    public static <T> Set<T> asSet(final T e) {
        final Set<T> set = newHashSet(1);
        set.add(e);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2) {
        final Set<T> set = newHashSet(2);
        set.add(e1);
        set.add(e2);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3) {
        final Set<T> set = newHashSet(3);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4) {
        final Set<T> set = newHashSet(4);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4, final T e5) {
        final Set<T> set = newHashSet(5);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6) {
        final Set<T> set = newHashSet(6);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @param e7 the seventh element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7) {
        final Set<T> set = newHashSet(7);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        set.add(e7);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @param e7 the seventh element to be placed in the Set
     * @param e8 the eighth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7, final T e8) {
        final Set<T> set = newHashSet(8);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        set.add(e7);
        set.add(e8);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @param e7 the seventh element to be placed in the Set
     * @param e8 the eighth element to be placed in the Set
     * @param e9 the ninth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7, final T e8, final T e9) {
        final Set<T> set = newHashSet(9);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        set.add(e7);
        set.add(e8);
        set.add(e9);
        return set;
    }

    /**
     * Returns a modifiable {@code Set} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code Set} is returned.
     *
     * @param <T> the type of elements in the set
     * @param a the array of elements to be placed in the set
     * @return a Set containing the specified elements
     */
    @SafeVarargs
    @NullSafe
    public static <T> Set<T> asSet(final T... a) {
        if (isEmpty(a)) {
            return newHashSet();
        }

        return new HashSet<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with specified element.
     *
     * @param <T> the type of elements in the set
     * @param e the element to be placed in the Set
     * @return a Set containing the specified element
     */
    public static <T> Set<T> asLinkedHashSet(final T e) {
        final Set<T> set = newLinkedHashSet(1);
        set.add(e);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2) {
        final Set<T> set = newLinkedHashSet(2);
        set.add(e1);
        set.add(e2);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2, final T e3) {
        final Set<T> set = newLinkedHashSet(3);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2, final T e3, final T e4) {
        final Set<T> set = newLinkedHashSet(4);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2, final T e3, final T e4, final T e5) {
        final Set<T> set = newLinkedHashSet(5);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6) {
        final Set<T> set = newLinkedHashSet(6);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with the specified elements.
     *
     * @param <T> the type of elements in the set
     * @param e1 the first element to be placed in the Set
     * @param e2 the second element to be placed in the Set
     * @param e3 the third element to be placed in the Set
     * @param e4 the fourth element to be placed in the Set
     * @param e5 the fifth element to be placed in the Set
     * @param e6 the sixth element to be placed in the Set
     * @param e7 the seventh element to be placed in the Set
     * @return a Set containing the specified elements
     */
    public static <T> Set<T> asLinkedHashSet(final T e1, final T e2, final T e3, final T e4, final T e5, final T e6, final T e7) {
        final Set<T> set = newLinkedHashSet(7);
        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);
        set.add(e6);
        set.add(e7);
        return set;
    }

    /**
     * Returns a modifiable {@code LinkedHashSet} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code LinkedHashSet} is returned.
     *
     * @param <T> the type of elements in the set
     * @param a the array of elements to be placed in the set
     * @return a Set containing the specified elements
     */
    @SafeVarargs
    @NullSafe
    public static <T> Set<T> asLinkedHashSet(final T... a) {
        if (isEmpty(a)) {
            return newLinkedHashSet();
        }

        return new LinkedHashSet<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code SortedSet} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code SortedSet} is returned.
     *
     * @param <T> the type of elements in the set
     * @param a the array of elements to be placed in the set
     * @return a Set containing the specified elements
     */
    @SafeVarargs
    @NullSafe
    public static <T extends Comparable<T>> SortedSet<T> asSortedSet(final T... a) {
        if (isEmpty(a)) {
            return new TreeSet<>();
        }

        return new TreeSet<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code NavigableSet} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code NavigableSet} is returned.
     *
     * @param <T> the type of elements in the set
     * @param a the array of elements to be placed in the set
     * @return a Set containing the specified elements
     */
    @SafeVarargs
    public static <T extends Comparable<T>> NavigableSet<T> asNavigableSet(final T... a) {
        if (isEmpty(a)) {
            return new TreeSet<>();
        }

        return new TreeSet<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code Queue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code Queue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T> Queue<T> asQueue(final T... a) {
        return asArrayDeque(a);
    }

    /**
     * Returns a modifiable {@code ArrayBlockingQueue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code ArrayBlockingQueue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T> ArrayBlockingQueue<T> asArrayBlockingQueue(final T... a) {
        if (isEmpty(a)) {
            return new ArrayBlockingQueue<>(1);
        }

        final ArrayBlockingQueue<T> queue = new ArrayBlockingQueue<>(a.length);

        queue.addAll(Array.asList(a));

        return queue;
    }

    /**
     * Returns a modifiable {@code LinkedBlockingQueue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code LinkedBlockingQueue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T> LinkedBlockingQueue<T> asLinkedBlockingQueue(final T... a) {
        if (isEmpty(a)) {
            return new LinkedBlockingQueue<>();
        }

        final LinkedBlockingQueue<T> queue = new LinkedBlockingQueue<>(a.length);

        queue.addAll(Array.asList(a));

        return queue;
    }

    /**
     * Returns a modifiable {@code ConcurrentLinkedQueue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code ConcurrentLinkedQueue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T> ConcurrentLinkedQueue<T> asConcurrentLinkedQueue(final T... a) { //NOSONAR
        if (isEmpty(a)) {
            return new ConcurrentLinkedQueue<>();
        }

        return new ConcurrentLinkedQueue<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code DelayQueue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code DelayQueue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T extends Delayed> DelayQueue<T> asDelayQueue(final T... a) {
        if (isEmpty(a)) {
            return new DelayQueue<>();
        }

        return new DelayQueue<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code PriorityQueue} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code PriorityQueue} is returned.
     *
     * @param <T> the type of elements in the queue
     * @param a the array of elements to be placed in the queue
     * @return a queue containing the specified elements
     */
    @SafeVarargs
    public static <T> PriorityQueue<T> asPriorityQueue(final T... a) {
        if (isEmpty(a)) {
            return new PriorityQueue<>();
        }

        final PriorityQueue<T> queue = new PriorityQueue<>(a.length);

        queue.addAll(Array.asList(a));

        return queue;
    }

    /**
     * Returns a modifiable {@code Deque} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code Deque} is returned.
     *
     * @param <T> the type of elements in the deque
     * @param a the array of elements to be placed in the deque
     * @return a deque containing the specified elements
     */
    @SafeVarargs
    public static <T> Deque<T> asDeque(final T... a) {
        return asArrayDeque(a);
    }

    /**
     * Returns a modifiable {@code ArrayDeque} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code ArrayDeque} is returned.
     *
     * @param <T> the type of elements in the deque
     * @param a the array of elements to be placed in the deque
     * @return a deque containing the specified elements
     */
    @SafeVarargs
    public static <T> ArrayDeque<T> asArrayDeque(final T... a) { //NOSONAR
        if (isEmpty(a)) {
            return new ArrayDeque<>();
        }

        final ArrayDeque<T> arrayDeque = new ArrayDeque<>(a.length);

        arrayDeque.addAll(Array.asList(a));

        return arrayDeque;
    }

    /**
     * Returns a modifiable {@code LinkedBlockingDeque} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code LinkedBlockingDeque} is returned.
     *
     * @param <T> the type of elements in the deque
     * @param a the array of elements to be placed in the deque
     * @return a deque containing the specified elements
     */
    @SafeVarargs
    public static <T> LinkedBlockingDeque<T> asLinkedBlockingDeque(final T... a) {
        if (isEmpty(a)) {
            return new LinkedBlockingDeque<>();
        }

        final LinkedBlockingDeque<T> deque = new LinkedBlockingDeque<>(a.length);

        deque.addAll(Array.asList(a));

        return deque;
    }

    /**
     * Returns a modifiable {@code ConcurrentLinkedDeque} with specified elements. And it's not backed by the specified array.
     * If the specified array is {@code null} or empty, an empty {@code ConcurrentLinkedDeque} is returned.
     *
     * @param <T> the type of elements in the deque
     * @param a the array of elements to be placed in the deque
     * @return a deque containing the specified elements
     */
    @SafeVarargs
    public static <T> ConcurrentLinkedDeque<T> asConcurrentLinkedDeque(final T... a) { //NOSONAR
        if (isEmpty(a)) {
            return new ConcurrentLinkedDeque<>();
        }

        return new ConcurrentLinkedDeque<>(Array.asList(a));
    }

    /**
     * Returns a modifiable {@code Multiset} with the specified elements.
     * If the specified array is {@code null} or empty, an empty modifiable {@code Multiset} is returned.
     *
     * @param <T> the type of elements in the multiset
     * @param a the array of elements to be placed in the multiset
     * @return a Multiset containing the specified elements
     */
    @SafeVarargs
    public static <T> Multiset<T> asMultiset(final T... a) {
        return Multiset.of(a);
    }

    /**
     * Returns an immutable list containing only the specified element.
     *
     * @param <T> the type of the element
     * @param e the element to be wrapped in a singleton list
     * @return an immutable list containing the specified element
     * @see java.util.Collections#singletonList(Object)
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> List<T> asSingletonList(final T e) {
        return Collections.singletonList(e);
    }

    /**
     * Returns an immutable set containing only the specified element.
     *
     * @param <T> the type of the element
     * @param e the element to be wrapped in a singleton set
     * @return an immutable set containing the specified element
     * @see java.util.Collections#singleton(Object)
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> Set<T> asSingletonSet(final T e) {
        return Collections.singleton(e);
    }

    /**
     * Returns an immutable map containing only the specified key-value pair.
     *
     * @param <K> the type of keys maintained by the map
     * @param <V> the type of mapped values
     * @param key the key to be placed in the map
     * @param value the value to be associated with the key
     * @return an immutable map containing the specified key-value pair
     * @see java.util.Collections#singletonMap(Object, Object)
     */
    @com.landawn.abacus.annotation.Immutable
    public static <K, V> Map<K, V> asSingletonMap(final K key, final V value) {
        return Collections.singletonMap(key, value);
    }

    /**
     * Returns an immutable empty {@code List}.
     *
     * @param <T> the type of elements in the list
     * @return an immutable empty list
     * @see Collections#emptyList()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> List<T> emptyList() {
        return EMPTY_LIST;
    }

    /**
     * Returns an immutable empty {@code Set}.
     *
     * @param <T> the type of elements in the set
     * @return an immutable empty set
     * @see Collections#emptySet()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> Set<T> emptySet() {
        return EMPTY_SET;
    }

    /**
     * Returns an immutable empty {@code SortedSet}.
     *
     * @param <T> the type of elements in the set
     * @return an immutable empty set
     * @see Collections#emptySortedSet()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> SortedSet<T> emptySortedSet() {
        return EMPTY_SORTED_SET;
    }

    /**
     * Returns an immutable empty {@code NavigableSet}.
     *
     * @param <T> the type of elements in the set
     * @return an immutable empty set
     * @see Collections#emptyNavigableSet()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> NavigableSet<T> emptyNavigableSet() {
        return EMPTY_NAVIGABLE_SET;
    }

    /**
     * Returns an immutable empty {@code Map}.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @return an immutable empty map
     * @see Collections#emptyMap()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <K, V> Map<K, V> emptyMap() {
        return EMPTY_MAP;
    }

    /**
     * Returns an immutable empty {@code SortedMap}.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @return an immutable empty sorted map
     * @see Collections#emptySortedMap()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <K, V> SortedMap<K, V> emptySortedMap() {
        return EMPTY_SORTED_MAP;
    }

    /**
     * Returns an immutable empty {@code NavigableMap}.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @return an immutable empty navigable map
     * @see Collections#emptyNavigableMap()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <K, V> NavigableMap<K, V> emptyNavigableMap() {
        return EMPTY_NAVIGABLE_MAP;
    }

    /**
     * Returns an immutable empty iterator.
     *
     * @param <T> the type of elements returned by this iterator
     * @return an immutable empty iterator
     * @see Collections#emptyIterator()
     */
    public static <T> Iterator<T> emptyIterator() {
        return EMPTY_ITERATOR;
    }

    /**
     * Returns an immutable empty {@code ListIterator}.
     *
     * @param <T> the type of elements returned by this list iterator
     * @return an immutable empty list iterator
     * @see Collections#emptyListIterator()
     */
    @com.landawn.abacus.annotation.Immutable
    public static <T> ListIterator<T> emptyListIterator() {
        return EMPTY_LIST_ITERATOR;
    }

    private static final ByteArrayInputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);

    /**
     * Returns an immutable empty {@code InputStream}.
     *
     * @return an immutable empty input stream
     * @see ByteArrayInputStream
     */
    @com.landawn.abacus.annotation.Immutable
    public static InputStream emptyInputStream() {
        return EMPTY_INPUT_STREAM;
    }

    /**
     * Returns an immutable empty {@code Dataset}.
     *
     * @return an immutable empty Dataset
     * @see Dataset#empty()
     */
    @com.landawn.abacus.annotation.Immutable
    public static Dataset emptyDataset() {
        return Dataset.empty();
    }

    // ================================ compare... ====================================================================

    /**
     * Compares two boolean values.
     *
     * @param a the first boolean value
     * @param b the second boolean value
     * @return 0 if both values are equal, 1 if the first value is {@code true} and the second is {@code false}, -1 if the first value is {@code false} and the second is true
     */
    public static int compare(final boolean a, final boolean b) {
        return (a == b) ? 0 : (a ? 1 : -1);
    }

    /**
     * Compares two char values.
     *
     * @param a the first char value
     * @param b the second char value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final char a, final char b) {
        return Character.compare(a, b);
    }

    /**
     * Compares two byte values.
     *
     * @param a the first byte value
     * @param b the second byte value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final byte a, final byte b) {
        return Byte.compare(a, b);
    }

    /**
     * Compares two unsigned byte values.
     *
     * @param a the first byte value
     * @param b the second byte value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     * @see Byte#compareUnsigned(byte, byte)
     */
    public static int compareUnsigned(final byte a, final byte b) {
        return Byte.compareUnsigned(a, b);
    }

    /**
     * Compares two short values.
     *
     * @param a the first short value
     * @param b the second short value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final short a, final short b) {
        return Short.compare(a, b);
    }

    /**
     * Compares two unsigned short values.
     *
     * @param a the first short value
     * @param b the second short value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     * @see Short#compareUnsigned(short, short)
     */
    public static int compareUnsigned(final short a, final short b) {
        return Short.compareUnsigned(a, b);
    }

    /**
     * Compares two int values.
     *
     * @param a the first int value
     * @param b the second int value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final int a, final int b) {
        return Integer.compare(a, b);
    }

    /**
     * Compares two unsigned int values.
     *
     * @param a the first int value
     * @param b the second int value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     * @see Integer#compareUnsigned(int, int)
     */
    public static int compareUnsigned(final int a, final int b) {
        return Integer.compareUnsigned(a, b);
    }

    /**
     * Compares two long values.
     *
     * @param a the first long value
     * @param b the second long value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final long a, final long b) {
        return Long.compare(a, b);
    }

    /**
     * Compares two unsigned long values.
     *
     * @param a the first long value
     * @param b the second long value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     * @see Long#compareUnsigned(long, long)
     */
    public static int compareUnsigned(final long a, final long b) {
        return Long.compareUnsigned(a, b);
    }

    /**
     * Compares two float values.
     *
     * @param a the first float value
     * @param b the second float value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final float a, final float b) {
        return Float.compare(a, b);
    }

    /**
     * Compares two double values.
     *
     * @param a the first double value
     * @param b the second double value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static int compare(final double a, final double b) {
        return Double.compare(a, b);
    }

    /**
     * Compares two {@code Comparable} object values. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the comparable objects
     * @param a the first object value
     * @param b the second object value
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static <T extends Comparable<? super T>> int compare(final T a, final T b) {
        return a == null ? (b == null ? 0 : -1) : (b == null ? 1 : a.compareTo(b));
    }

    /**
     * Compares two {@code Comparable} object values using the specified {@code Comparator}.
     *
     * @param <T> the type of objects being compared
     * @param a the first object value
     * @param b the second object value
     * @param cmp the comparator to be used
     * @return 0 if both values are equal; a value greater than {@code 0} if the first value is greater than the second; a value less than {@code 0} if the first value is less than the second
     */
    public static <T> int compare(final T a, final T b, final Comparator<? super T> cmp) {
        if (cmp == null) {
            return NATURAL_COMPARATOR.compare(a, b);
        }

        return cmp.compare(a, b);
    }

    /**
     * Compares two pairs of values (a1, b1) and (a2, b2) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs.
     */
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>> int compare(final T1 a1, final T1 b1, final T2 a2, final T2 b2) {
        final int ret = compare(a1, b1);

        return ret == 0 ? compare(a2, b2) : ret;
    }

    /**
     * Compares three pairs of values (a1, b1), (a2, b2), and (a3, b3) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param <T3> the type of the third pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @param a3 the first value of the third pair
     * @param b3 the second value of the third pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs.
     */
    @SuppressWarnings("java:S1871")
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>, T3 extends Comparable<T3>> int compare(final T1 a1, final T1 b1, final T2 a2,
            final T2 b2, final T3 a3, final T3 b3) {
        int ret = 0;

        if (((ret = compare(a1, b1)) != 0) || ((ret = compare(a2, b2)) != 0)) {
            return ret;
        }

        return compare(a3, b3);
    }

    /**
     * Compares four pairs of values (a1, b1), (a2, b2), (a3, b3), and (a4, b4) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param <T3> the type of the third pair of values, which must be comparable
     * @param <T4> the type of the fourth pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @param a3 the first value of the third pair
     * @param b3 the second value of the third pair
     * @param a4 the first value of the fourth pair
     * @param b4 the second value of the fourth pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs.
     * @deprecated replaced by {@link Builder#compare(Comparable, Comparable)}
     * @see Builder#compare(Comparable, Comparable)
     */
    @Deprecated
    @SuppressWarnings("java:S1871")
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>, T3 extends Comparable<T3>, T4 extends Comparable<T4>> int compare(final T1 a1,
            final T1 b1, final T2 a2, final T2 b2, final T3 a3, final T3 b3, final T4 a4, final T4 b4) {
        int ret = 0;

        if (((ret = compare(a1, b1)) != 0) || ((ret = compare(a2, b2)) != 0) || ((ret = compare(a3, b3)) != 0)) {
            return ret;
        }

        return compare(a4, b4);
    }

    /**
     * Compares five pairs of values (a1, b1), (a2, b2), (a3, b3), (a4, b4), and (a5, b5) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param <T3> the type of the third pair of values, which must be comparable
     * @param <T4> the type of the fourth pair of values, which must be comparable
     * @param <T5> the type of the fifth pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @param a3 the first value of the third pair
     * @param b3 the second value of the third pair
     * @param a4 the first value of the fourth pair
     * @param b4 the second value of the fourth pair
     * @param a5 the first value of the fifth pair
     * @param b5 the second value of the fifth pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs.
     * @deprecated replaced by {@link Builder#compare(Comparable, Comparable)}
     * @see Builder#compare(Comparable, Comparable)
     */
    @Deprecated
    @SuppressWarnings("java:S1871")
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>, T3 extends Comparable<T3>, T4 extends Comparable<T4>, T5 extends Comparable<T5>> int compare(
            final T1 a1, final T1 b1, final T2 a2, final T2 b2, final T3 a3, final T3 b3, final T4 a4, final T4 b4, final T5 a5, final T5 b5) {
        int ret = 0;

        if (((ret = compare(a1, b1)) != 0) || ((ret = compare(a2, b2)) != 0) || ((ret = compare(a3, b3)) != 0) || ((ret = compare(a4, b4)) != 0)) {
            return ret;
        }

        return compare(a5, b5);
    }

    /**
     * Compares six pairs of values (a1, b1), (a2, b2), (a3, b3), (a4, b4), (a5, b5), and (a6, b6) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param <T3> the type of the third pair of values, which must be comparable
     * @param <T4> the type of the fourth pair of values, which must be comparable
     * @param <T5> the type of the fifth pair of values, which must be comparable
     * @param <T6> the type of the sixth pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @param a3 the first value of the third pair
     * @param b3 the second value of the third pair
     * @param a4 the first value of the fourth pair
     * @param b4 the second value of the fourth pair
     * @param a5 the first value of the fifth pair
     * @param b5 the second value of the fifth pair
     * @param a6 the first value of the sixth pair
     * @param b6 the second value of the sixth pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs.
     * @deprecated replaced by {@link Builder#compare(Comparable, Comparable)}
     * @see Builder#compare(Comparable, Comparable)
     */
    @Deprecated
    @SuppressWarnings("java:S1871")
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>, T3 extends Comparable<T3>, T4 extends Comparable<T4>, T5 extends Comparable<T5>, T6 extends Comparable<T6>> int compare(
            final T1 a1, final T1 b1, final T2 a2, final T2 b2, final T3 a3, final T3 b3, final T4 a4, final T4 b4, final T5 a5, final T5 b5, final T6 a6,
            final T6 b6) {
        int ret = 0;

        if (((ret = compare(a1, b1)) != 0) || ((ret = compare(a2, b2)) != 0) || ((ret = compare(a3, b3)) != 0) || ((ret = compare(a4, b4)) != 0)
                || (ret = compare(a5, b5)) != 0) {
            return ret;
        }

        return compare(a6, b6);
    }

    /**
     * Compares seven pairs of values (a1, b1), (a2, b2), (a3, b3), (a4, b4), (a5, b5), (a6, b6), and (a7, b7) until they are not equal. ({@code null} is considered as the smallest value in natural order).
     * Returns 0 if all pairs of values are equal.
     *
     * @param <T1> the type of the first pair of values, which must be comparable
     * @param <T2> the type of the second pair of values, which must be comparable
     * @param <T3> the type of the third pair of values, which must be comparable
     * @param <T4> the type of the fourth pair of values, which must be comparable
     * @param <T5> the type of the fifth pair of values, which must be comparable
     * @param <T6> the type of the sixth pair of values, which must be comparable
     * @param <T7> the type of the seventh pair of values, which must be comparable
     * @param a1 the first value of the first pair
     * @param b1 the second value of the first pair
     * @param a2 the first value of the second pair
     * @param b2 the second value of the second pair
     * @param a3 the first value of the third pair
     * @param b3 the second value of the third pair
     * @param a4 the first value of the fourth pair
     * @param b4 the second value of the fourth pair
     * @param a5 the first value of the fifth pair
     * @param b5 the second value of the fifth pair
     * @param a6 the first value of the sixth pair
     * @param b6 the second value of the sixth pair
     * @param a7 the first value of the seventh pair
     * @param b7 the second value of the seventh pair
     * @return a negative integer, zero, or a positive integer as the first value is less than, equal to, or greater than the second values in the specified pairs
     * @deprecated replaced by {@link Builder#compare(Comparable, Comparable)}
     * @see Builder#compare(Comparable, Comparable)
     */
    @Deprecated
    @SuppressWarnings("java:S1871")
    public static <T1 extends Comparable<T1>, T2 extends Comparable<T2>, T3 extends Comparable<T3>, T4 extends Comparable<T4>, T5 extends Comparable<T5>, T6 extends Comparable<T6>, T7 extends Comparable<T7>> int compare(
            final T1 a1, final T1 b1, final T2 a2, final T2 b2, final T3 a3, final T3 b3, final T4 a4, final T4 b4, final T5 a5, final T5 b5, final T6 a6,
            final T6 b6, final T7 a7, final T7 b7) {
        int ret = 0;

        if (((ret = compare(a1, b1)) != 0) || ((ret = compare(a2, b2)) != 0) || ((ret = compare(a3, b3)) != 0) || ((ret = compare(a4, b4)) != 0)
                || ((ret = compare(a5, b5)) != 0) || ((ret = compare(a6, b6)) != 0)) {
            return ret;
        }

        return compare(a7, b7);
    }

    /**
     * Threshold for array comparison operations. Arrays with length greater than this threshold
     * use optimized comparison methods from {@link java.util.Arrays}; smaller arrays use simple loops.
     */
    private static final int MISMATCH_THRESHOLD = 1000;

    /**
     * Compares two arrays lexicographically.
     * <p><b>Lexicographic Comparison:</b> Arrays are compared element by element from index 0.
     * The first differing element determines the result. If all compared elements are equal,
     * the shorter array is considered less than the longer array. Null or empty arrays are
     * considered less than non-empty arrays.
     *
     * @param a the first array to compare, may be {@code null}
     * @param b the second array to compare, may be {@code null}
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {false, true, false};
     * boolean[] b = {false, true, true};
     * compare(a, 0, b, 0, 3);   // returns negative value (false < true at index 2)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final boolean[] a, final int fromIndexA, final boolean[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] > b[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'a', 'b', 'd'};
     * compare(a, 0, b, 0, 3);   // returns negative value ('c' < 'd')
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final char[] a, final int fromIndexA, final char[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] > b[j] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] > b[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {1, 2, 4};
     * compare(a, 0, b, 0, 3);   // returns negative value (3 < 4)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final byte[] a, final int fromIndexA, final byte[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] > b[j] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     * @see Arrays#compareUnsigned(byte[], byte[])
     * @see Byte#compareUnsigned(byte, byte)
     */
    public static int compareUnsigned(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, b);
    }

    /**
     * Compares two subarrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index (inclusive) of the first subarray
     * @param b the second array to compare
     * @param fromIndexB the starting index (inclusive) of the second subarray
     * @param len the length of the subarrays to compare
     * @return a negative integer, zero, or a positive integer as the first subarray is less than, equal to, or greater than the second subarray
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified indices are out of bounds
     * @see Arrays#compareUnsigned(byte[], int, int, byte[], int, int)
     * @see Byte#compareUnsigned(byte, byte)
     */
    public static int compareUnsigned(final byte[] a, final int fromIndexA, final byte[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] > b[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 3};
     * short[] b = {1, 2, 4};
     * compare(a, 0, b, 0, 3);   // returns negative value (3 < 4)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final short[] a, final int fromIndexA, final short[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] > b[j] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     * @see Arrays#compareUnsigned(short[], short[])
     * @see Short#compareUnsigned(short, short)
     */
    public static int compareUnsigned(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, b);
    }

    /**
     * Compares two subarrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index (inclusive) of the first subarray
     * @param b the second array to compare
     * @param fromIndexB the starting index (inclusive) of the second subarray
     * @param len the length of the subarrays to compare
     * @return a negative integer, zero, or a positive integer as the first subarray is less than, equal to, or greater than the second subarray
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified indices are out of bounds
     * @see Arrays#compareUnsigned(short[], int, int, short[], int, int)
     * @see Short#compareUnsigned(short, short)
     */
    public static int compareUnsigned(final short[] a, final int fromIndexA, final short[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] > b[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 3};
     * int[] b = {1, 2, 4};
     * compare(a, 0, b, 0, 3);   // returns negative value (3 < 4)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final int[] a, final int fromIndexA, final int[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] > b[j] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     * @see Arrays#compareUnsigned(int[], int[])
     * @see Integer#compareUnsigned(int, int)
     */
    public static int compareUnsigned(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, b);
    }

    /**
     * Compares two subarrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index (inclusive) of the first subarray
     * @param b the second array to compare
     * @param fromIndexB the starting index (inclusive) of the second subarray
     * @param len the length of the subarrays to compare
     * @return a negative integer, zero, or a positive integer as the first subarray is less than, equal to, or greater than the second subarray
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified indices are out of bounds
     * @see Arrays#compareUnsigned(int[], int, int, int[], int, int)
     * @see Integer#compareUnsigned(int, int)
     */
    public static int compareUnsigned(final int[] a, final int fromIndexA, final int[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return a[i] > b[i] ? 1 : -1;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1L, 2L, 3L};
     * long[] b = {1L, 2L, 4L};
     * compare(a, 0, b, 0, 3);   // returns negative value (3L < 4L)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final long[] a, final int fromIndexA, final long[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return a[i] > b[j] ? 1 : -1;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     * @see Arrays#compareUnsigned(long[], long[])
     * @see Long#compareUnsigned(long, long)
     */
    public static int compareUnsigned(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, b);
    }

    /**
     * Compares two subarrays lexicographically, treating the values as unsigned.
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index (inclusive) of the first subarray
     * @param b the second array to compare
     * @param fromIndexB the starting index (inclusive) of the second subarray
     * @param len the length of the subarrays to compare
     * @return a negative integer, zero, or a positive integer as the first subarray is less than, equal to, or greater than the second subarray
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified indices are out of bounds
     * @see Arrays#compareUnsigned(long[], int, int, long[], int, int)
     * @see Long#compareUnsigned(long, long)
     */
    public static int compareUnsigned(final long[] a, final int fromIndexA, final long[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        return Arrays.compareUnsigned(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        int ret = 0;

        for (int i = 0; i < minLen; i++) {
            if ((ret = Float.compare(a[i], b[i])) != 0) {
                return ret;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {1.0f, 2.0f, 4.0f};
     * compare(a, 0, b, 0, 3);   // returns negative value (3.0f < 4.0f)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final float[] a, final int fromIndexA, final float[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        int ret = 0;

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if ((ret = Float.compare(a[i], b[j])) != 0) {
                return ret;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically.
     *
     * @param a the first array to compare
     * @param b the second array to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second
     */
    public static int compare(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, b);
        }

        int ret = 0;

        for (int i = 0; i < minLen; i++) {
            if ((ret = Double.compare(a[i], b[i])) != 0) {
                return ret;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * double[] b = {1.0, 2.0, 4.0};
     * compare(a, 0, b, 0, 3);   // returns negative value (3.0 < 4.0)
     * compare(a, 0, b, 0, 2);   // returns 0
     * }</pre>
     *
     * @param a the first array to compare
     * @param fromIndexA the starting index in the first array
     * @param b the second array to compare
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static int compare(final double[] a, final int fromIndexA, final double[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.compare(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        int ret = 0;

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if ((ret = Double.compare(a[i], b[j])) != 0) {
                return ret;
            }
        }

        return 0;
    }

    /**
     * Compares two arrays lexicographically. ({@code null} is considered as the smallest value in natural order).
     *
     * <p>If both arrays are {@code null} or empty, returns 0. If only the first array is {@code null} or empty, returns -1.
     * If only the second array is {@code null} or empty, returns 1. Otherwise, compares elements lexicographically using their natural ordering.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"a", "b", "c"};
     * String[] b = {"a", "b", "d"};
     * N.compare(a, b);      // returns negative value (c < d)
     * N.compare(a, a);      // returns 0
     * N.compare(null, b);   // returns -1
     * }</pre>
     *
     * @param <T> the type of the comparable array elements
     * @param a the first array to compare, may be {@code null}
     * @param b the second array to compare, may be {@code null}
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     */
    public static <T extends Comparable<? super T>> int compare(final T[] a, final T[] b) {
        final Comparator<T> cmp = NATURAL_COMPARATOR;

        return compare(a, b, cmp);
    }

    /**
     * Compares two arrays lexicographically over the specified range. ({@code null} is considered as the smallest value in natural order).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"a", "b", "c", "d"};
     * String[] b = {"a", "b", "x", "y"};
     * N.compare(a, 0, b, 0, 2);   // returns 0 (first 2 elements are same)
     * N.compare(a, 2, b, 2, 2);   // returns negative value (c < x)
     * }</pre>
     *
     * @param <T> the type of the comparable array elements
     * @param a the first array to compare, may be {@code null}
     * @param fromIndexA the starting index (inclusive) in the first array
     * @param b the second array to compare, may be {@code null}
     * @param fromIndexB the starting index (inclusive) in the second array
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if {@code len} is negative
     * @throws IndexOutOfBoundsException if the specified indices or length result in out of bounds access
     */
    public static <T extends Comparable<? super T>> int compare(final T[] a, final int fromIndexA, final T[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {

        return compare(a, fromIndexA, b, fromIndexB, len, NATURAL_COMPARATOR);
    }

    /**
     * Compares two arrays using the specified comparator.
     *
     * <p>If both arrays are {@code null} or empty, returns 0. If only the first array is {@code null} or empty, returns -1.
     * If only the second array is {@code null} or empty, returns 1. If the comparator is {@code null}, uses natural ordering.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"apple", "banana"};
     * String[] b = {"APPLE", "BANANA"};
     * N.compare(a, b, String.CASE_INSENSITIVE_ORDER);   // returns 0
     * N.compare(a, b, null);                            // uses natural ordering
     * }</pre>
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array to compare, may be {@code null}
     * @param b the second array to compare, may be {@code null}
     * @param cmp the comparator to compare array elements, may be {@code null}
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     */
    public static <T> int compare(final T[] a, final T[] b, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        cmp = checkComparator(cmp);

        int ret = 0;

        for (int i = 0, minLen = N.min(a.length, b.length); i < minLen; i++) {
            if ((ret = cmp.compare(a[i], b[i])) != 0) {
                return ret;
            }
        }

        return Integer.compare(a.length, b.length);
    }

    /**
     * Compares two arrays lexicographically over the specified range using the specified comparator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"apple", "BANANA", "cherry"};
     * String[] b = {"APPLE", "banana", "CHERRY"};
     * N.compare(a, 0, b, 0, 3, String.CASE_INSENSITIVE_ORDER);   // returns 0
     * N.compare(a, 0, b, 0, 1, null);                            // uses natural ordering for first element
     * }</pre>
     *
     * @param <T> the type of the array elements
     * @param a the first array to compare, may be {@code null}
     * @param fromIndexA the starting index (inclusive) in the first array
     * @param b the second array to compare, may be {@code null}
     * @param fromIndexB the starting index (inclusive) in the second array
     * @param len the number of elements to compare
     * @param cmp the comparator to compare array elements, may be {@code null} (uses natural ordering)
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array
     * @throws IllegalArgumentException if {@code len} is negative
     * @throws IndexOutOfBoundsException if the specified indices or length result in out of bounds access
     */
    public static <T> int compare(final T[] a, final int fromIndexA, final T[] b, final int fromIndexB, final int len, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        cmp = checkComparator(cmp);
        int ret = 0;

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if ((ret = cmp.compare(a[i], b[j])) != 0) {
                return ret;
            }
        }

        return 0;
    }

    /**
     * Compares two collections lexicographically over the specified range. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the collection elements
     * @param a the first collection to compare
     * @param fromIndexA the starting index in the first collection
     * @param b the second collection to compare
     * @param fromIndexB the starting index in the second collection
     * @param len the number of elements to compare
     * @return a negative integer, zero, or a positive integer as the first collection is less than, equal to, or greater than the second collection
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the specified ranges are out of bounds
     */
    public static <T> int compare(final Collection<T> a, final int fromIndexA, final Collection<T> b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {

        return compare(a, fromIndexA, b, fromIndexB, len, NATURAL_COMPARATOR);
    }

    /**
     * Compares two iterables lexicographically. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of elements in the iterables, which must be comparable
     * @param a the first iterable to compare
     * @param b the second iterable to compare
     * @return a negative integer, zero, or a positive integer as the first iterable is less than, equal to, or greater than the second iterable
     */
    public static <T extends Comparable<? super T>> int compare(final Iterable<T> a, final Iterable<T> b) {
        final Comparator<T> cmp = NATURAL_COMPARATOR;

        return compare(a, b, cmp);
    }

    /**
     * Compares two iterators lexicographically. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of elements in the iterators, which must be comparable
     * @param a the first iterator to compare
     * @param b the second iterator to compare
     * @return a negative integer, zero, or a positive integer as the first iterator is less than, equal to, or greater than the second iterator
     */
    public static <T extends Comparable<? super T>> int compare(final Iterator<T> a, final Iterator<T> b) {
        final Comparator<T> cmp = NATURAL_COMPARATOR;

        return compare(a, b, cmp);
    }

    /**
     * Compares two collections lexicographically over the specified range using the specified comparator.
     *
     * @param <T> the type of elements in the collections
     * @param a the first collection to compare
     * @param fromIndexA the starting index in the first collection
     * @param b the second collection to compare
     * @param fromIndexB the starting index in the second collection
     * @param len the number of elements to compare
     * @param cmp the comparator to compare collection elements
     * @return a negative integer, zero, or a positive integer as the first collection is less than, equal to, or greater than the second collection
     * @throws IllegalArgumentException if the specified length is negative
     * @throws IndexOutOfBoundsException if the specified indices are out of range
     */
    public static <T> int compare(final Collection<T> a, int fromIndexA, final Collection<T> b, int fromIndexB, final int len, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, size(a));
        checkFromIndexSize(fromIndexB, len, size(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return 0;
        }

        cmp = checkComparator(cmp);
        final Iterator<T> iterA = a.iterator();
        final Iterator<T> iterB = b.iterator();

        while (fromIndexA-- > 0) {
            iterA.next();
        }

        while (fromIndexB-- > 0) {
            iterB.next();
        }

        int ret = 0;

        for (int i = 0; i < len; i++) {
            if ((ret = cmp.compare(iterA.next(), iterB.next())) != 0) {
                return ret;
            }
        }

        return 0;
    }

    /**
     * Compares two iterables using the specified comparator.
     *
     * @param <T> the type of elements in the iterables
     * @param a the first iterable to compare
     * @param b the second iterable to compare
     * @param cmp the comparator to compare elements from iterables
     * @return a negative integer, zero, or a positive integer as the first iterable is less than, equal to, or greater than the second iterable
     */
    public static <T> int compare(final Iterable<T> a, final Iterable<T> b, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return isEmpty(b) ? 0 : -1;
        } else if (isEmpty(b)) {
            return 1;
        }

        cmp = checkComparator(cmp);

        return compare(a.iterator(), b.iterator(), cmp);
    }

    /**
     * Compares two iterators using the specified comparator.
     *
     * @param <T> the type of elements in the iterators
     * @param a the first iterator to compare
     * @param b the second iterator to compare
     * @param cmp the comparator to compare elements from iterators
     * @return a negative integer, zero, or a positive integer as the first iterator is less than, equal to, or greater than the second iterator
     */
    public static <T> int compare(final Iterator<T> a, final Iterator<T> b, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        final Iterator<T> iterA = a == null ? ObjIterator.empty() : a;
        final Iterator<T> iterB = b == null ? ObjIterator.empty() : b;
        int ret = 0;

        while (iterA.hasNext() && iterB.hasNext()) {
            if ((ret = cmp.compare(iterA.next(), iterB.next())) != 0) {
                return ret;
            }
        }

        return iterA.hasNext() ? 1 : (iterB.hasNext() ? -1 : 0);
    }

    /**
     * Compares two strings lexicographically, ignoring case differences.
     *
     * @param a the first string to compare
     * @param b the second string to compare
     * @return a negative integer, zero, or a positive integer as the first string is less than, equal to, or greater than the second string, ignoring case considerations
     */
    public static int compareIgnoreCase(final String a, final String b) {
        return a == null ? (b == null ? 0 : -1) : (b == null ? 1 : a.compareToIgnoreCase(b));
    }

    /**
     * Compares two arrays of strings lexicographically, ignoring case differences.
     *
     * @param a the first array of strings to compare
     * @param b the second array of strings to compare
     * @return a negative integer, zero, or a positive integer as the first array is less than, equal to, or greater than the second array, ignoring case considerations
     */
    public static int compareIgnoreCase(final String[] a, final String[] b) {
        return compare(a, b, Comparators.comparingIgnoreCase());
    }

    /**
     * Compares two beans based on the specified properties.
     *
     * @param bean1 the first bean to compare, must not be null
     * @param bean2 the second bean to compare, must not be null
     * @param propNamesToCompare the collection of property names to compare, which may be null
     * @return a negative integer, zero, or a positive integer as the first bean is less than, equal to, or greater than the second bean
     * @throws IllegalArgumentException if any of the arguments are null
     * @deprecated Use {@link Beans#compareByProps(Object,Object,Collection<String>)} instead
     * @see Builder#compare(Object, Object, Comparator)
     * @see ComparisonBuilder
     */
    @Deprecated
    public static int compareByProps(@NotNull final Object bean1, @NotNull final Object bean2, final Collection<String> propNamesToCompare) {
        return Beans.compareByProps(bean1, bean2, propNamesToCompare);
    }

    /**
     * Returns default Comparator {@code NATURAL_COMPARATOR} if the specified {@code cmp} is {@code null}. Otherwise returns {@code cmp}.
     *
     * @param <T> the type of objects being compared
     * @param cmp the comparator to check, may be {@code null}
     * @return the provided comparator or the natural comparator if {@code null}
     */
    static <T> Comparator<T> checkComparator(final Comparator<T> cmp) {
        return cmp == null ? NATURAL_COMPARATOR : cmp;
    }

    /**
     * Compares two comparable objects to determine if the first is less than the second. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @return {@code true} if the first object is less than the second, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean lessThan(final T a, final T b) {
        return compare(a, b) < 0;
    }

    /**
     * Compares two objects using the specified comparator to determine if the first is less than the second.
     *
     * @param <T> the type of the objects being compared
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the first object is less than the second, {@code false} otherwise
     */
    public static <T> boolean lessThan(final T a, final T b, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        return cmp.compare(a, b) < 0;
    }

    /**
     * Compares two comparable objects to determine if the first is less than or equal to the second. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @return {@code true} if the first object is less than or equal to the second, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean lessEqual(final T a, final T b) {
        return compare(a, b) <= 0;
    }

    /**
     * Compares two objects using the specified comparator to determine if the first is less than or equal to the second.
     *
     * @param <T> the type of the objects being compared
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the first object is less than or equal to the second, {@code false} otherwise
     */
    public static <T> boolean lessEqual(final T a, final T b, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        return cmp.compare(a, b) <= 0;
    }

    /**
     * Compares two comparable objects to determine if the first is greater than the second. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @return {@code true} if the first object is greater than the second, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean greaterThan(final T a, final T b) {
        return compare(a, b) > 0;
    }

    /**
     * Compares two objects using the specified comparator to determine if the first is greater than the second.
     *
     * @param <T> the type of the objects being compared
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the first object is greater than the second, {@code false} otherwise
     */
    public static <T> boolean greaterThan(final T a, final T b, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        return cmp.compare(a, b) > 0;
    }

    /**
     * Compares two comparable objects to determine if the first is greater than or equal to the second. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @return {@code true} if the first object is greater than or equal to the second, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean greaterEqual(final T a, final T b) {
        return compare(a, b) >= 0;
    }

    /**
     * Compares two objects using the specified comparator to determine if the first is greater than or equal to the second.
     *
     * @param <T> the type of the objects being compared
     * @param a the first object to compare, may be {@code null}
     * @param b the second object to compare, may be {@code null}
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the first object is greater than or equal to the second, {@code false} otherwise
     */
    public static <T> boolean greaterEqual(final T a, final T b, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        return cmp.compare(a, b) >= 0;
    }

    /**
     * Checks if the given value is greater than the minimum value and less than the maximum value. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @return {@code true} if the value is greater than the minimum and less than the maximum, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean gtAndLt(final T value, final T min, final T max) {
        if (compare(value, min) <= 0) {
            return false;
        }

        return compare(value, max) < 0;
    }

    /**
     * Checks if the given value is greater than the minimum value and less than the maximum value using the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the value is greater than the minimum and less than the maximum, {@code false} otherwise
     */
    public static <T> boolean gtAndLt(final T value, final T min, final T max, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        if (cmp.compare(value, min) <= 0) {
            return false;
        }

        return cmp.compare(value, max) < 0;
    }

    /**
     * Checks if the given value is greater than or equal to the minimum value and less than the maximum value. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @return {@code true} if the value is greater than or equal to the minimum and less than the maximum, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean geAndLt(final T value, final T min, final T max) {
        if (compare(value, min) < 0) {
            return false;
        }

        return compare(value, max) < 0;
    }

    /**
     * Checks if the given value is greater than or equal to the minimum value and less than the maximum value using the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the value is greater than or equal to the minimum and less than the maximum, {@code false} otherwise
     */
    public static <T> boolean geAndLt(final T value, final T min, final T max, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        if (cmp.compare(value, min) < 0) {
            return false;
        }

        return cmp.compare(value, max) < 0;
    }

    /**
     * Checks if the given value is greater than or equal to the minimum value and less than or equal to the maximum value. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @return {@code true} if the value is greater than or equal to the minimum and less than or equal to the maximum, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean geAndLe(final T value, final T min, final T max) {
        if (compare(value, min) < 0) {
            return false;
        }

        return compare(value, max) <= 0;
    }

    /**
     * Checks if the given value is greater than or equal to the minimum value and less than or equal to the maximum value using the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the value is greater than or equal to the minimum and less than or equal to the maximum, {@code false} otherwise
     */
    public static <T> boolean geAndLe(final T value, final T min, final T max, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        if (cmp.compare(value, min) < 0) {
            return false;
        }

        return cmp.compare(value, max) <= 0;
    }

    /**
     * Checks if the given value is greater than the minimum value and less than or equal to the maximum value. ({@code null} is considered as the smallest value in natural order).
     *
     * @param <T> the type of the objects being compared, which must be comparable
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @return {@code true} if the value is greater than the minimum and less than or equal to the maximum, {@code false} otherwise
     */
    public static <T extends Comparable<? super T>> boolean gtAndLe(final T value, final T min, final T max) {
        if (compare(value, min) <= 0) {
            return false;
        }

        return compare(value, max) <= 0;
    }

    /**
     * Checks if the given value is greater than the minimum value and less than or equal to the maximum value using the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @param cmp the comparator to use for comparison, if {@code null}, the natural ordering of the objects will be used
     * @return {@code true} if the value is greater than the minimum and less than or equal to the maximum, {@code false} otherwise
     */
    public static <T> boolean gtAndLe(final T value, final T min, final T max, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        if (cmp.compare(value, min) <= 0) {
            return false;
        }

        return cmp.compare(value, max) <= 0;
    }

    /**
     * Checks if the given value is between the specified minimum and maximum values, inclusive.
     * It means {@code min <= value <= max}.
     * {@code null} is considered as the smallest value in natural order.
     * <p><b>Implementation Note:</b> it is equivalent to {@link #geAndLe(Comparable, Comparable, Comparable)}.</p>
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @return {@code true} if the value is between the minimum and maximum values, inclusive; {@code false} otherwise
     * @deprecated Use {@link #geAndLe(Comparable, Comparable, Comparable)} instead.
     */
    @Deprecated
    public static <T extends Comparable<? super T>> boolean isBetween(final T value, final T min, final T max) {
        return geAndLe(value, min, max);
    }

    /**
     * Checks if the given value is between the specified minimum and maximum values, inclusive.
     * It means {@code min <= value <= max}.
     * <p><b>Implementation Note:</b> it is equivalent to {@link #geAndLe(Object, Object, Object, Comparator)}.</p>
     *
     * @param <T> the type of the objects being compared
     * @param value the value to check, must not be null
     * @param min the minimum value, must not be null
     * @param max the maximum value, must not be null
     * @param cmp the comparator to compare the values, must not be null
     * @return {@code true} if the value is between the minimum and maximum values, inclusive; {@code false} otherwise
     * @deprecated Use {@link #geAndLe(Object, Object, Object, Comparator)} instead.
     */
    @Deprecated
    public static <T> boolean isBetween(final T value, final T min, final T max, final Comparator<? super T> cmp) {
        return geAndLe(value, min, max, cmp);
    }

    // ================================ compare... ====================================================================

    // ================================ get/find matched/mismatch element... ===========================================
    /**
     * Retrieves the element at the specified position in the given Iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.getElement(list, 0);   // returns "a"
     * N.getElement(list, 2);   // returns "c"
     * // N.getElement(list, 5);   // throws IndexOutOfBoundsException
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable from which to retrieve the element
     * @param index the position of the element to retrieve
     * @return the element at the specified position in the iterable
     * @throws IllegalArgumentException if the iterable is {@code null} or the index is negative
     * @throws IndexOutOfBoundsException if the index is bigger than the maximum index of the specified Iterable or Iterator
     */
    public static <T> T getElement(@NotNull final Iterable<? extends T> c, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(c, cs.c);
        N.checkArgNotNegative(index, cs.index);

        if (c instanceof Collection) {
            checkElementIndex(index, ((Collection<T>) c).size());
        }

        if (c instanceof List) {
            return ((List<T>) c).get(index);
        }

        return getElement(c.iterator(), index);
    }

    /**
     * Retrieves the element at the specified position in the given Iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("a", "b", "c").iterator();
     * N.getElement(iter, 1);   // returns "b"
     * }</pre>
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to retrieve the element from; must not be {@code null}
     * @param index the index of the element to retrieve. Must be a non-negative integer.
     * @return the element at the specified index in the Iterator
     * @throws IllegalArgumentException if the Iterator is {@code null} or the index is negative
     * @throws IndexOutOfBoundsException if the index is bigger than the maximum index of the specified Iterable or Iterator
     */
    public static <T> T getElement(@NotNull final Iterator<? extends T> iter, final long index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(iter, cs.iter);
        N.checkArgNotNegative(index, cs.index);

        long idx = index;

        while (idx-- > 0 && iter.hasNext()) {
            iter.next();
        }

        if (iter.hasNext()) {
            return iter.next();
        } else {
            throw new IndexOutOfBoundsException("Index: " + index + " is bigger than the maximum index of the specified Iterable or Iterator");
        }
    }

    /**
     * Returns the only element in the given Iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> singleElement = Arrays.asList("only");
     * N.getOnlyElement(singleElement);   // returns Nullable.of("only")
     *
     * List<String> empty = Arrays.asList();
     * N.getOnlyElement(empty);   // returns Nullable.empty()
     *
     * List<String> multiple = Arrays.asList("a", "b");
     * // N.getOnlyElement(multiple);   // throws TooManyElementsException
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param c the Iterable to get the element from
     * @return a {@code Nullable} containing the only element in the Iterable if it exists, otherwise an empty Nullable
     * @throws TooManyElementsException if the Iterable contains more than one element
     */
    public static <T> Nullable<T> getOnlyElement(final Iterable<? extends T> c) throws TooManyElementsException {
        if (isEmptyCollection(c)) {
            return Nullable.empty();
        }

        if (c instanceof Collection && ((Collection<T>) c).size() > 1) {
            final Iterator<? extends T> iter = c.iterator();

            throw new TooManyElementsException("Expected at most one element but was: [" + Strings.concat(iter.next(), ", ", iter.next(), "...]"));
        }

        return getOnlyElement(c.iterator());
    }

    /**
     * Returns the only element in the given Iterator.
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to get the element from
     * @return a {@code Nullable} containing the only element in the Iterator if it exists, otherwise an empty Nullable
     * @throws TooManyElementsException if the Iterator contains more than one element
     */
    public static <T> Nullable<T> getOnlyElement(final Iterator<? extends T> iter) throws TooManyElementsException {
        if (iter == null || !iter.hasNext()) {
            return Nullable.empty();
        }

        final T first = iter.next();

        if (iter.hasNext()) {
            throw new TooManyElementsException("Expected at most one element but was: [" + Strings.concat(first, ", ", iter.next(), "...]"));
        }

        return Nullable.of(first);
    }

    /**
     * Returns the first element in the given Iterable wrapped in a {@code Nullable}.
     * If the Iterable is empty, an empty {@code Nullable} is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.firstElement(list);   // returns Nullable.of("a")
     *
     * List<String> empty = Arrays.asList();
     * N.firstElement(empty);   // returns Nullable.empty()
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param c the Iterable to get the first element from
     * @return a {@code Nullable} containing the first element in the Iterable if it exists, otherwise an empty Nullable
     */
    public static <T> Nullable<T> firstElement(final Iterable<? extends T> c) {
        if (isEmpty(c)) {
            return Nullable.empty();
        }

        if (c instanceof List && c instanceof RandomAccess) {
            return Nullable.of(((List<T>) c).get(0));
        } else {
            return Nullable.of(c.iterator().next());
        }
    }

    /**
     * Returns the first element in the given Iterator wrapped in a {@code Nullable}.
     * If the Iterator is empty, an empty {@code Nullable} is returned.
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to get the first element from
     * @return a {@code Nullable} containing the first element in the Iterator if it exists, otherwise an empty Nullable
     */
    public static <T> Nullable<T> firstElement(final Iterator<? extends T> iter) {
        return iter != null && iter.hasNext() ? Nullable.of(iter.next()) : Nullable.empty();
    }

    /**
     * Returns the last element in the given Iterable wrapped in a {@code Nullable}.
     * If the Iterable is empty, an empty {@code Nullable} is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.lastElement(list);   // returns Nullable.of("c")
     *
     * List<String> empty = Arrays.asList();
     * N.lastElement(empty);   // returns Nullable.empty()
     * }</pre>
     *
     * @param <T> the type of elements in the Iterable
     * @param c the Iterable to get the last element from
     * @return a {@code Nullable} containing the last element in the Iterable if it exists, otherwise an empty Nullable
     */
    public static <T> Nullable<T> lastElement(final Iterable<? extends T> c) {
        if (isEmpty(c)) {
            return Nullable.empty();
        }

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            return Nullable.of(list.get(list.size() - 1));
        }

        final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            return Nullable.of(descendingIterator.next());
        }

        return lastElement(c.iterator());
    }

    /**
     * Returns the last element in the given Iterator wrapped in a {@code Nullable}.
     * If the Iterator is empty, an empty {@code Nullable} is returned.
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to get the last element from
     * @return a {@code Nullable} containing the last element in the Iterator if it exists, otherwise an empty Nullable
     */
    public static <T> Nullable<T> lastElement(final Iterator<? extends T> iter) {
        if (iter == null || !iter.hasNext()) {
            return Nullable.empty();
        }

        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
        }

        return Nullable.of(e);
    }

    /**
     * Returns a list containing the first <i>n</i> elements from the given array.
     * If the array has less than <i>n</i> elements, it returns a list with all the elements in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"a", "b", "c", "d", "e"};
     * N.firstElements(arr, 3);    // returns ["a", "b", "c"]
     * N.firstElements(arr, 10);   // returns ["a", "b", "c", "d", "e"]
     * N.firstElements(arr, 0);    // returns []
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to get the elements from
     * @param n the number of elements to retrieve from the array
     * @return a list containing the first <i>n</i> elements from the array
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    public static <T> List<T> firstElements(final T[] a, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(a) || n == 0) {
            return new ArrayList<>();
        }

        return N.toList(a, 0, Math.min(n, a.length));
    }

    /**
     * Returns a list containing the first <i>n</i> elements from the given Iterable.
     * If the Iterable has less than <i>n</i> elements, it returns a list with all the elements in the Iterable.
     *
     * @param <T> the type of elements in the Iterable
     * @param c the Iterable to get the elements from
     * @param n the number of elements to retrieve from the Iterable
     * @return a list containing the first <i>n</i> elements from the Iterable
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    @Beta
    public static <T> List<T> firstElements(final Iterable<? extends T> c, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(c) || n == 0) {
            return new ArrayList<>();
        }

        if (c instanceof final Collection<? extends T> coll) { // NOSONAR
            if (coll.size() <= n) {
                return new ArrayList<>(coll);
            } else if (coll instanceof final List<? extends T> list) { // NOSONAR
                return new ArrayList<>((list).subList(0, n));
            }
        }

        final List<T> result = new ArrayList<>(Math.min(1024, n));
        int cnt = 0;

        for (final T e : c) {
            result.add(e);

            if (++cnt == n) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the first <i>n</i> elements from the given Iterator.
     * If the Iterator has less than <i>n</i> elements, it returns a list with all the elements in the Iterator.
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to get the elements from
     * @param n the number of elements to retrieve from the Iterator
     * @return a list containing the first <i>n</i> elements from the Iterator
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    @Beta
    public static <T> List<T> firstElements(final Iterator<? extends T> iter, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(iter) || n == 0) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(Math.min(1024, n));
        int cnt = 0;

        while (iter.hasNext()) {
            result.add(iter.next());

            if (++cnt == n) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the last <i>n</i> elements from the given array.
     * If the array has less than <i>n</i> elements, it returns a list with all the elements in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"a", "b", "c", "d", "e"};
     * N.lastElements(arr, 3);    // returns ["c", "d", "e"]
     * N.lastElements(arr, 10);   // returns ["a", "b", "c", "d", "e"]
     * N.lastElements(arr, 0);    // returns []
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to get the elements from
     * @param n the number of elements to retrieve from the end of the array
     * @return a list containing the last <i>n</i> elements from the array
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    public static <T> List<T> lastElements(final T[] a, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(a) || n == 0) {
            return new ArrayList<>();
        }

        return N.toList(a, Math.max(0, a.length - n), a.length);
    }

    /**
     * Returns a list containing the last <i>n</i> elements from the given Iterable.
     * If the Iterable has less than <i>n</i> elements, it returns a list with all the elements in the Iterable.
     *
     * @param <T> the type of elements in the Iterable
     * @param c the Iterable to get the elements from
     * @param n the number of elements to retrieve from the end of the Iterable
     * @return a list containing the last <i>n</i> elements from the Iterable
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    @Beta
    public static <T> List<T> lastElements(final Iterable<? extends T> c, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(c) || n == 0) {
            return new ArrayList<>();
        }

        if (c instanceof final Collection<? extends T> coll) { // NOSONAR
            if (coll.size() <= n) {
                return new ArrayList<>(coll);
            } else if (coll instanceof final List<? extends T> list) { // NOSONAR
                return new ArrayList<>(list.subList(list.size() - n, list.size()));
            }
        }

        final Deque<T> deque = new ArrayDeque<>(Math.min(1024, n));

        for (final T e : c) {
            if (deque.size() >= n) {
                deque.pollFirst();
            }

            deque.offerLast(e);
        }

        return new ArrayList<>(deque);
    }

    /**
     * Returns a list containing the last <i>n</i> elements from the given Iterator.
     * If the Iterator has less than <i>n</i> elements, it returns a list with all the elements in the Iterator.
     *
     * @param <T> the type of elements in the Iterator
     * @param iter the Iterator to get the elements from
     * @param n the number of elements to retrieve from the Iterator
     * @return a list containing the last <i>n</i> elements from the Iterator
     * @throws IllegalArgumentException if <i>n</i> is negative
     */
    @Beta
    public static <T> List<T> lastElements(final Iterator<? extends T> iter, final int n) throws IllegalArgumentException {
        checkArgument(n >= 0, "'n' cannot be negative:" + n);

        if (isEmpty(iter) || n == 0) {
            return new ArrayList<>();
        }

        final Deque<T> deque = new ArrayDeque<>(Math.min(1024, n));

        while (iter.hasNext()) {
            if (deque.size() >= n) {
                deque.pollFirst();
            }

            deque.offerLast(iter.next());
        }

        return new ArrayList<>(deque);
    }

    /**
     * Returns the first {@code non-null} value among the two provided values.
     * If both values are {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.firstNonNull("value", null);   // returns Optional.of("value")
     * N.firstNonNull(null, "value");   // returns Optional.of("value")
     * N.firstNonNull(null, null);      // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to check
     * @param b the second value to check
     * @return an Optional containing the first {@code non-null} value if it exists, otherwise an empty Optional
     * @see Iterables#firstNonNull(Object, Object)
     */
    public static <T> Optional<T> firstNonNull(final T a, final T b) {
        return a != null ? Optional.of(a) : (b != null ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first {@code non-null} value among the three provided values.
     * If all values are {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.firstNonNull("first", null, null);    // returns Optional.of("first")
     * N.firstNonNull(null, "second", null);   // returns Optional.of("second")
     * N.firstNonNull(null, null, "third");    // returns Optional.of("third")
     * N.firstNonNull(null, null, null);       // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to check
     * @param b the second value to check
     * @param c the third value to check
     * @return an Optional containing the first {@code non-null} value if it exists, otherwise an empty Optional
     * @see Iterables#firstNonNull(Object, Object, Object)
     */
    public static <T> Optional<T> firstNonNull(final T a, final T b, final T c) {
        return a != null ? Optional.of(a) : (b != null ? Optional.of(b) : (c != null ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first {@code non-null} value among the provided values.
     * If all values are {@code null} or the array is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.firstNonNull(null, null, "value", "other");     // returns Optional.of("value")
     * N.firstNonNull(new String[]{null, null, null});   // returns Optional.empty()
     * N.firstNonNull();                                 // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the array of values to check, may be {@code null} or empty
     * @return an Optional containing the first {@code non-null} value if it exists, otherwise an empty Optional
     * @see Iterables#firstNonNull(Object[])
     */
    @SafeVarargs
    public static <T> Optional<T> firstNonNull(final T... a) {
        if (isEmpty(a)) {
            return Optional.empty();
        }

        for (final T e : a) {
            if (e != null) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first {@code non-null} value from the provided iterable.
     * If all values are {@code null} or the iterable is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList(null, null, "value", "other");
     * N.firstNonNull(list);                        // returns Optional.of("value")
     * N.firstNonNull(Arrays.asList(null, null));   // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param c the iterable of values to check, may be {@code null} or empty
     * @return an Optional containing the first {@code non-null} value if it exists, otherwise an empty Optional
     * @see Iterables#firstNonNull(Iterable)
     * @see Iterables#firstNonNullOrDefault(Iterable, Object)
     */
    public static <T> Optional<T> firstNonNull(final Iterable<? extends T> c) {
        if (isEmpty(c)) {
            return Optional.empty();
        }

        for (final T e : c) {
            if (e != null) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first {@code non-null} value from the provided iterator.
     * If all values are {@code null} or the iterator is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList(null, null, "value").iterator();
     * N.firstNonNull(iter);                          // returns Optional.of("value")
     * N.firstNonNull(Collections.emptyIterator());   // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param iter the iterator of values to check, may be {@code null}
     * @return an Optional containing the first {@code non-null} value if it exists, otherwise an empty Optional
     * @see Iterables#firstNonNull(Iterator)
     * @see Iterables#firstNonNullOrDefault(Iterator, Object)
     */
    public static <T> Optional<T> firstNonNull(final Iterator<? extends T> iter) {
        if (iter == null) {
            return Optional.empty();
        }

        T e = null;

        while (iter.hasNext()) {
            if ((e = iter.next()) != null) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the last {@code non-null} value from the provided values.
     * If both values are {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.lastNonNull("first", "second");   // returns Optional.of("second")
     * N.lastNonNull("value", null);       // returns Optional.of("value")
     * N.lastNonNull(null, null);          // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to check
     * @param b the second value to check
     * @return an Optional containing the last {@code non-null} value if it exists, otherwise an empty Optional
     */
    public static <T> Optional<T> lastNonNull(final T a, final T b) {
        return b != null ? Optional.of(b) : (a != null ? Optional.of(a) : Optional.empty());
    }

    /**
     * Returns the last {@code non-null} value from the provided values.
     * If all values are {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.lastNonNull("first", "second", "third");   // returns Optional.of("third")
     * N.lastNonNull("first", null, "third");       // returns Optional.of("third")
     * N.lastNonNull(null, null, null);             // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to check
     * @param b the second value to check
     * @param c the third value to check
     * @return an Optional containing the last {@code non-null} value if it exists, otherwise an empty Optional
     */
    public static <T> Optional<T> lastNonNull(final T a, final T b, final T c) {
        return c != null ? Optional.of(c) : (b != null ? Optional.of(b) : (a != null ? Optional.of(a) : Optional.empty()));
    }

    /**
     * Returns the last {@code non-null} value from the provided array of values.
     * If all values are {@code null} or the array is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.lastNonNull("first", null, "last", null);      // returns Optional.of("last")
     * N.lastNonNull(new String[]{null, null, null});   // returns Optional.empty()
     * N.lastNonNull();                                 // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the array of values to check, may be {@code null} or empty
     * @return an Optional containing the last {@code non-null} value if it exists, otherwise an empty Optional
     */
    @SafeVarargs
    public static <T> Optional<T> lastNonNull(final T... a) {
        if (N.isEmpty(a)) {
            return Optional.empty();
        }

        for (int i = a.length - 1; i >= 0; i--) {
            if (a[i] != null) {
                return Optional.of(a[i]);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the last {@code non-null} value from the provided iterable.
     * If all values are {@code null} or the iterable is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("first", null, "last", null);
     * N.lastNonNull(list);                        // returns Optional.of("last")
     * N.lastNonNull(Arrays.asList(null, null));   // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param c the iterable to check, may be {@code null} or empty
     * @return an Optional containing the last {@code non-null} value if it exists, otherwise an empty Optional
     */
    public static <T> Optional<T> lastNonNull(final Iterable<? extends T> c) {
        if (N.isEmpty(c)) {
            return Optional.empty();
        }

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = list.size() - 1; i >= 0; i--) {
                if (list.get(i) != null) {
                    return Optional.of(list.get(i));
                }
            }

            return Optional.empty();
        }

        final Iterator<T> descendingIterator = N.getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            T next = null;

            while (descendingIterator.hasNext()) {
                if ((next = descendingIterator.next()) != null) {
                    return Optional.of(next);
                }
            }

            return Optional.empty();
        }

        return lastNonNull(c.iterator());
    }

    /**
     * Returns the last {@code non-null} value from the provided iterator.
     * If all values are {@code null} or the iterator is empty, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("first", null, "last").iterator();
     * N.lastNonNull(iter);                          // returns Optional.of("last")
     * N.lastNonNull(Collections.emptyIterator());   // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the values
     * @param iter the iterator to check, may be {@code null}
     * @return an Optional containing the last {@code non-null} value if it exists, otherwise an empty Optional
     */
    public static <T> Optional<T> lastNonNull(final Iterator<? extends T> iter) {
        if (iter == null) {
            return Optional.empty();
        }

        T e = null;
        T lastNonNull = null;

        while (iter.hasNext()) {
            if ((e = iter.next()) != null) {
                lastNonNull = e;
            }
        }

        return Optional.ofNullable(lastNonNull);
    }

    /**
     * Returns the first non-empty array from the given arrays.
     * If both arrays are empty or {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr1 = {"a", "b"};
     * String[] arr2 = {"c", "d"};
     * N.firstNonEmpty(arr1, arr2);            // returns Optional.of(arr1)
     * N.firstNonEmpty(new String[0], arr2);   // returns Optional.of(arr2)
     * N.firstNonEmpty(null, null);            // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array to check
     * @param b the second array to check
     * @return an Optional containing the first non-empty array, or an empty Optional if both arrays are empty or null
     */
    public static <T> Optional<T[]> firstNonEmpty(final T[] a, final T[] b) {
        return a != null && a.length > 0 ? Optional.of(a) : (b != null && b.length > 0 ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first non-empty array from the given arrays.
     * If all arrays are empty or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array to check
     * @param b the second array to check
     * @param c the third array to check
     * @return an Optional containing the first non-empty array, or an empty Optional if all arrays are empty or null
     */
    public static <T> Optional<T[]> firstNonEmpty(final T[] a, final T[] b, final T[] c) {
        return a != null && a.length > 0 ? Optional.of(a)
                : (b != null && b.length > 0 ? Optional.of(b) : (c != null && c.length > 0 ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first non-empty collection from the given collections.
     * If both collections are empty or {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list1 = Arrays.asList("a", "b");
     * List<String> list2 = Arrays.asList("c", "d");
     * N.firstNonEmpty(list1, list2);                     // returns Optional.of(list1)
     * N.firstNonEmpty(Collections.emptyList(), list2);   // returns Optional.of(list2)
     * N.firstNonEmpty(null, null);                       // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the collections
     * @param a the first collection to check
     * @param b the second collection to check
     * @return an Optional containing the first non-empty collection, or an empty Optional if both collections are empty or null
     */
    public static <T extends Collection<?>> Optional<T> firstNonEmpty(final T a, final T b) {
        return a != null && a.size() > 0 ? Optional.of(a) : (b != null && b.size() > 0 ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first non-empty collection from the given collections.
     * If all collections are empty or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the collections
     * @param a the first collection to check
     * @param b the second collection to check
     * @param c the third collection to check
     * @return an Optional containing the first non-empty collection, or an empty Optional if all collections are empty or null
     */
    public static <T extends Collection<?>> Optional<T> firstNonEmpty(final T a, final T b, final T c) {
        return a != null && a.size() > 0 ? Optional.of(a)
                : (b != null && b.size() > 0 ? Optional.of(b) : (c != null && c.size() > 0 ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first non-empty map from the given maps.
     * If both maps are empty or {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map1 = N.asMap("a", 1, "b", 2);
     * Map<String, Integer> map2 = N.asMap("c", 3);
     * N.firstNonEmpty(map1, map2);                     // returns Optional.of(map1)
     * N.firstNonEmpty(Collections.emptyMap(), map2);   // returns Optional.of(map2)
     * N.firstNonEmpty(null, null);                     // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the maps
     * @param a the first map to check
     * @param b the second map to check
     * @return an Optional containing the first non-empty map, or an empty Optional if both maps are empty or null
     */
    public static <T extends Map<?, ?>> Optional<T> firstNonEmpty(final T a, final T b) {
        return a != null && !a.isEmpty() ? Optional.of(a) : (b != null && !b.isEmpty() ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first non-empty map from the given maps.
     * If all maps are empty or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the maps
     * @param a the first map to check
     * @param b the second map to check
     * @param c the third map to check
     * @return an Optional containing the first non-empty map, or an empty Optional if all maps are empty or null
     */
    public static <T extends Map<?, ?>> Optional<T> firstNonEmpty(final T a, final T b, final T c) {
        return a != null && !a.isEmpty() ? Optional.of(a)
                : (b != null && !b.isEmpty() ? Optional.of(b) : (c != null && !c.isEmpty() ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first non-empty CharSequence from the given CharSequences.
     * If both CharSequences are empty or {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.firstNonEmpty("", "value");     // returns Optional.of("value")
     * N.firstNonEmpty("first", null);   // returns Optional.of("first")
     * N.firstNonEmpty("", null);        // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the CharSequences
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return an Optional containing the first non-empty CharSequence, or an empty Optional if both CharSequences are empty or null
     * @see Strings#firstNonEmpty(String, String)
     */
    public static <T extends CharSequence> Optional<T> firstNonEmpty(final T a, final T b) {
        return Strings.isNotEmpty(a) ? Optional.of(a) : (Strings.isNotEmpty(b) ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first non-empty CharSequence from the given CharSequences.
     * If all CharSequences are empty or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the CharSequences
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return an Optional containing the first non-empty CharSequence, or an empty Optional if all CharSequences are empty or null
     * @see Strings#firstNonEmpty(String, String, String)
     */
    public static <T extends CharSequence> Optional<T> firstNonEmpty(final T a, final T b, final T c) {
        return Strings.isNotEmpty(a) ? Optional.of(a) : (Strings.isNotEmpty(b) ? Optional.of(b) : (Strings.isNotEmpty(c) ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first non-empty CharSequence from the given CharSequences.
     * If all CharSequences are empty or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the CharSequences
     * @param a the array of CharSequences to check
     * @return an Optional containing the first non-empty CharSequence, or an empty Optional if all CharSequences are empty or null
     * @see Strings#firstNonEmpty(String...)
     */
    @SafeVarargs
    public static <T extends CharSequence> Optional<T> firstNonEmpty(final T... a) {
        if (isEmpty(a)) {
            return Optional.empty();
        }

        for (final T e : a) {
            if (Strings.isNotEmpty(e)) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns an Optional containing the first non-empty CharSequence from the given Iterable of CharSequences.
     * If all CharSequences are empty or the Iterable is empty, returns an empty Optional.
     *
     * @param <T> the type of the CharSequence
     * @param css the Iterable of CharSequences to check, may be {@code null} or empty
     * @return an Optional containing the first non-empty CharSequence, or an empty Optional if all are empty or the Iterable is empty
     * @see Strings#firstNonEmpty(Iterable)
     */
    public static <T extends CharSequence> Optional<T> firstNonEmpty(final Iterable<? extends T> css) {
        if (isEmpty(css)) {
            return Optional.empty();
        }

        for (final T e : css) {
            if (Strings.isNotEmpty(e)) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first non-blank CharSequence from the given CharSequences.
     * If both CharSequences are blank or {@code null}, it returns an empty Optional.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.firstNonBlank("  ", "value");    // returns Optional.of("value")
     * N.firstNonBlank("first", "   ");   // returns Optional.of("first")
     * N.firstNonBlank("  ", null);       // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the CharSequences
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @return an Optional containing the first non-blank CharSequence, or an empty Optional if both CharSequences are blank or null
     * @see Strings#firstNonBlank(String, String)
     */
    public static <T extends CharSequence> Optional<T> firstNonBlank(final T a, final T b) {
        return Strings.isNotBlank(a) ? Optional.of(a) : (Strings.isNotBlank(b) ? Optional.of(b) : Optional.empty());
    }

    /**
     * Returns the first non-blank CharSequence from the given CharSequences.
     * If all CharSequences are blank or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the CharSequences
     * @param a the first CharSequence to check
     * @param b the second CharSequence to check
     * @param c the third CharSequence to check
     * @return an Optional containing the first non-blank CharSequence, or an empty Optional if all CharSequences are blank or null
     * @see Strings#firstNonBlank(String, String, String)
     */
    public static <T extends CharSequence> Optional<T> firstNonBlank(final T a, final T b, final T c) {
        return Strings.isNotBlank(a) ? Optional.of(a) : (Strings.isNotBlank(b) ? Optional.of(b) : (Strings.isNotBlank(c) ? Optional.of(c) : Optional.empty()));
    }

    /**
     * Returns the first non-blank CharSequence from the given CharSequences.
     * If all CharSequences are blank or {@code null}, it returns an empty Optional.
     *
     * @param <T> the type of the CharSequences
     * @param a the array of CharSequences to check
     * @return an Optional containing the first non-blank CharSequence, or an empty Optional if all CharSequences are blank or null
     * @see Strings#firstNonBlank(String...)
     */
    @SafeVarargs
    public static <T extends CharSequence> Optional<T> firstNonBlank(final T... a) {
        if (isEmpty(a)) {
            return Optional.empty();
        }

        for (final T e : a) {
            if (Strings.isNotBlank(e)) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns an Optional containing the first non-blank CharSequence from the given Iterable of CharSequences.
     * If all CharSequences are blank or the Iterable is empty, returns an empty Optional.
     *
     * @param <T> the type of the CharSequence
     * @param css the Iterable of CharSequences to check, may be {@code null} or empty
     * @return an Optional containing the first non-blank CharSequence, or an empty Optional if all are blank or the Iterable is empty
     * @see Strings#firstNonBlank(Iterable)
     */
    public static <T extends CharSequence> Optional<T> firstNonBlank(final Iterable<? extends T> css) {
        if (isEmpty(css)) {
            return Optional.empty();
        }

        for (final T e : css) {
            if (Strings.isNotBlank(e)) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first entry from the given map.
     * If the map is {@code null} or empty, it returns an empty Optional.
     * The definition of "first" depends on the map's iteration order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("a", 1);
     * map.put("b", 2);
     * N.firstEntry(map);                      // returns Optional.of(entry("a", 1))
     * N.firstEntry(Collections.emptyMap());   // returns Optional.empty()
     * }</pre>
     *
     * @param <K> the type of keys maintained by the map
     * @param <V> the type of mapped values
     * @param map the map from which to retrieve the first entry, may be {@code null} or empty
     * @return an Optional containing the first entry of the map, or an empty Optional if the map is {@code null} or empty
     */
    public static <K, V> Optional<Map.Entry<K, V>> firstEntry(final Map<K, V> map) {
        if (map == null || map.isEmpty()) {
            return Optional.empty();
        }

        return Optional.of(map.entrySet().iterator().next());
    }

    /**
     * Returns the last entry from the given map.
     * If the map is {@code null} or empty, it returns an empty Optional.
     * The definition of "last" depends on the map's iteration order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> map = new LinkedHashMap<>();
     * map.put("a", 1);
     * map.put("b", 2);
     * N.lastEntry(map);                      // returns Optional.of(entry("b", 2))
     * N.lastEntry(Collections.emptyMap());   // returns Optional.empty()
     * }</pre>
     *
     * @param <K> the type of keys maintained by the map
     * @param <V> the type of mapped values
     * @param map the map from which to retrieve the last entry, may be {@code null} or empty
     * @return an Optional containing the last entry of the map, or an empty Optional if the map is {@code null} or empty
     */
    public static <K, V> Optional<Map.Entry<K, V>> lastEntry(final Map<K, V> map) {
        if (map == null || map.isEmpty()) {
            return Optional.empty();
        }

        return lastNonNull(map.entrySet().iterator());
    }

    /**
     * Returns the first element of the given array if it is not empty, otherwise returns {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"a", "b", "c"};
     * N.firstOrNullIfEmpty(arr);             // returns "a"
     * N.firstOrNullIfEmpty(new String[0]);   // returns null
     * N.firstOrNullIfEmpty(null);            // returns null
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to check, may be {@code null} or empty
     * @return the first element of the array if it is not empty, otherwise {@code null}
     */
    public static <T> T firstOrNullIfEmpty(final T[] a) {
        return a == null || a.length == 0 ? null : a[0];
    }

    /**
     * Returns the first element of the given iterable if it is not empty, otherwise returns {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.firstOrNullIfEmpty(list);   // returns "a"
     *
     * List<String> empty = Arrays.asList();
     * N.firstOrNullIfEmpty(empty);   // returns null
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to check, may be {@code null} or empty
     * @return the first element of the iterable if it is not empty, otherwise {@code null}
     */
    public static <T> T firstOrNullIfEmpty(final Iterable<? extends T> c) {
        return firstOrDefaultIfEmpty(c, null);
    }

    /**
     * Returns the first element of the given iterator if it is not empty, otherwise returns {@code null}.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to check, may be {@code null} or empty
     * @return the first element of the iterator if it is not empty, otherwise {@code null}
     */
    public static <T> T firstOrNullIfEmpty(final Iterator<? extends T> iter) {
        return firstOrDefaultIfEmpty(iter, null);
    }

    /**
     * Returns the first element of the given array if it is not empty, otherwise returns the specified default value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"a", "b", "c"};
     * N.firstOrDefaultIfEmpty(arr, "default");             // returns "a"
     * N.firstOrDefaultIfEmpty(new String[0], "default");   // returns "default"
     * N.firstOrDefaultIfEmpty(null, "default");            // returns "default"
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to check, may be {@code null} or empty
     * @param defaultValueForEmpty the default value to return if the array is empty or {@code null}
     * @return the first element of the array if it is not empty, otherwise the specified default value
     */
    public static <T> T firstOrDefaultIfEmpty(final T[] a, final T defaultValueForEmpty) {
        return a == null || a.length == 0 ? defaultValueForEmpty : a[0];
    }

    /**
     * Returns the first element of the given iterable if it is not empty, otherwise returns the specified default value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.firstOrDefaultIfEmpty(list, "default");   // returns "a"
     *
     * List<String> empty = Arrays.asList();
     * N.firstOrDefaultIfEmpty(empty, "default");   // returns "default"
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to check
     * @param defaultValueForEmpty the default value to return if the iterable is empty
     * @return the first element of the iterable if it is not empty, otherwise the specified default value
     */
    public static <T> T firstOrDefaultIfEmpty(final Iterable<? extends T> c, final T defaultValueForEmpty) {
        if (isEmpty(c)) {
            return defaultValueForEmpty;
        }

        if (c instanceof List && c instanceof RandomAccess) {
            return ((List<T>) c).get(0);
        } else {
            return c.iterator().next();
        }
    }

    /**
     * Returns the first element of the given iterator if it is not empty, otherwise returns the specified default value.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to check
     * @param defaultValueForEmpty the default value to return if the iterator is empty
     * @return the first element of the iterator if it is not empty, otherwise the specified default value
     */
    public static <T> T firstOrDefaultIfEmpty(final Iterator<? extends T> iter, final T defaultValueForEmpty) {
        if (iter == null || !iter.hasNext()) {
            return defaultValueForEmpty;
        }

        return iter.next();
    }

    /**
     * Returns the last element of the given array if it is not empty, otherwise returns {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"a", "b", "c"};
     * N.lastOrNullIfEmpty(arr);             // returns "c"
     * N.lastOrNullIfEmpty(new String[0]);   // returns null
     * N.lastOrNullIfEmpty(null);            // returns null
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to check, may be {@code null} or empty
     * @return the last element of the array if it is not empty, otherwise {@code null}
     */
    public static <T> T lastOrNullIfEmpty(final T[] a) {
        return a == null || a.length == 0 ? null : a[a.length - 1];
    }

    /**
     * Returns the last element of the given iterable if it is not empty, otherwise returns {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.lastOrNullIfEmpty(list);   // returns "c"
     *
     * List<String> empty = Arrays.asList();
     * N.lastOrNullIfEmpty(empty);   // returns null
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to check
     * @return the last element of the iterable if it is not empty, otherwise null
     */
    public static <T> T lastOrNullIfEmpty(final Iterable<? extends T> c) {
        return lastOrDefaultIfEmpty(c, null);
    }

    /**
     * Returns the last element of the given iterator if it is not empty, otherwise returns {@code null}.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to check, may be {@code null} or empty
     * @return the last element of the iterator if it is not empty, otherwise {@code null}
     */
    public static <T> T lastOrNullIfEmpty(final Iterator<? extends T> iter) {
        return lastOrDefaultIfEmpty(iter, null);
    }

    /**
     * Returns the last element of the given array if it is not empty, otherwise returns the specified default value.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to check
     * @param defaultValueForEmpty the default value to return if the array is empty
     * @return the last element of the array if it is not empty, otherwise the specified default value
     */
    public static <T> T lastOrDefaultIfEmpty(final T[] a, final T defaultValueForEmpty) {
        return a == null || a.length == 0 ? defaultValueForEmpty : a[a.length - 1];
    }

    /**
     * Returns the last element of the given iterable if it is not empty, otherwise returns the specified default value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c");
     * N.lastOrDefaultIfEmpty(list, "default");   // returns "c"
     *
     * List<String> empty = Arrays.asList();
     * N.lastOrDefaultIfEmpty(empty, "default");   // returns "default"
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to check
     * @param defaultValueForEmpty the default value to return if the iterable is empty
     * @return the last element of the iterable if it is not empty, otherwise the specified default value
     */
    public static <T> T lastOrDefaultIfEmpty(final Iterable<? extends T> c, final T defaultValueForEmpty) {
        if (isEmpty(c)) {
            return defaultValueForEmpty;
        }

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            return list.get(list.size() - 1);
        }

        final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            return descendingIterator.next();
        }

        return lastOrDefaultIfEmpty(c.iterator(), defaultValueForEmpty);
    }

    /**
     * Returns the last element of the given iterator if it is not empty, otherwise returns the specified default value.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to check
     * @param defaultValueForEmpty the default value to return if the iterator is empty
     * @return the last element of the iterator if it is not empty, otherwise the specified default value
     */
    public static <T> T lastOrDefaultIfEmpty(final Iterator<? extends T> iter, final T defaultValueForEmpty) {
        if (iter == null || !iter.hasNext()) {
            return defaultValueForEmpty;
        }

        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
        }

        return e;
    }

    /**
     * Returns the first element in the given array that matches the specified predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "cherry"};
     * N.findFirst(arr, s -> s.startsWith("b"));   // returns Nullable.of("banana")
     * N.findFirst(arr, s -> s.startsWith("z"));   // returns Nullable.empty()
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to search
     * @param predicate the predicate to apply to elements of the array
     * @return a {@code Nullable} containing the first element that matches the predicate, or an empty {@code Nullable} if no such element is found
     */
    public static <T> Nullable<T> findFirst(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return Nullable.empty();
        }

        for (final T element : a) {
            if (predicate.test(element)) {
                return Nullable.of(element);
            }
        }

        return Nullable.empty();
    }

    /**
     * Returns the first element in the given iterable that matches the specified predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "cherry");
     * N.findFirst(list, s -> s.startsWith("b"));   // returns Nullable.of("banana")
     * N.findFirst(list, s -> s.startsWith("z"));   // returns Nullable.empty()
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to search
     * @param predicate the predicate to apply to elements of the iterable
     * @return a {@code Nullable} containing the first element that matches the predicate, or an empty {@code Nullable} if no such element is found
     */
    public static <T> Nullable<T> findFirst(final Iterable<? extends T> c, final Predicate<? super T> predicate) {
        if (isEmpty(c)) {
            return Nullable.empty();
        }

        for (final T e : c) {
            if (predicate.test(e)) {
                return Nullable.of(e);
            }
        }

        return Nullable.empty();
    }

    /**
     * Returns the first element in the given iterator that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to search
     * @param predicate the predicate to apply to elements of the iterator
     * @return a {@code Nullable} containing the first element that matches the predicate, or an empty {@code Nullable} if no such element is found
     */
    public static <T> Nullable<T> findFirst(final Iterator<? extends T> iter, final Predicate<? super T> predicate) {
        if (iter == null) {
            return Nullable.empty();
        }

        T next = null;

        while (iter.hasNext()) {
            next = iter.next();

            if (predicate.test(next)) {
                return Nullable.of(next);
            }
        }

        return Nullable.empty();
    }

    /**
     * Returns the last element in the given array that matches the specified predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"apple", "banana", "blueberry"};
     * N.findLast(arr, s -> s.startsWith("b"));   // returns Nullable.of("blueberry")
     * N.findLast(arr, s -> s.startsWith("z"));   // returns Nullable.empty()
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to search
     * @param predicate the predicate to apply to elements of the array
     * @return a {@code Nullable} containing the last element that matches the predicate, or an empty {@code Nullable} if no such element is found
     */
    public static <T> Nullable<T> findLast(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return Nullable.empty();
        }

        for (int len = a.length, i = len - 1; i >= 0; i--) {
            if (predicate.test(a[i])) {
                return Nullable.of(a[i]);
            }
        }

        return Nullable.empty();
    }

    /**
     * Returns the last element in the given iterable that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to search
     * @param predicate the predicate to apply to elements of the iterable
     * @return a {@code Nullable} containing the last element that matches the predicate, or an empty {@code Nullable} if no such element is found
     */
    public static <T> Nullable<T> findLast(final Iterable<? extends T> c, final Predicate<? super T> predicate) {
        return (Nullable<T>) findLast(c, predicate, false);
    }

    /**
     * Internal helper method that returns the last element in the given iterable that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to search
     * @param predicate the predicate to apply to elements of the iterable
     * @param isForNonNull if {@code true}, only non-null elements are considered and an Optional is returned; if {@code false}, a Nullable is returned
     * @return an Optional or Nullable (depending on isForNonNull) containing the last element that matches the predicate, or empty if no such element is found
     */
    private static <T> Object findLast(final Iterable<? extends T> c, final Predicate<? super T> predicate, final boolean isForNonNull) {
        if (isEmptyCollection(c)) {
            return isForNonNull ? Optional.empty() : Nullable.empty();
        }

        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = list.size() - 1; i >= 0; i--) {
                e = list.get(i);

                if ((!isForNonNull || e != null) && predicate.test(e)) {
                    return isForNonNull ? Optional.of(e) : Nullable.of(e);
                }
            }

            return isForNonNull ? Optional.empty() : Nullable.empty();
        }

        final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            while (descendingIterator.hasNext()) {
                e = descendingIterator.next();

                if ((!isForNonNull || e != null) && predicate.test(e)) {
                    return isForNonNull ? Optional.of(e) : Nullable.of(e);
                }
            }

            return isForNonNull ? Optional.empty() : Nullable.empty();
        }

        T[] a = null;

        if (c instanceof Collection) {
            a = (T[]) ((Collection<T>) c).toArray();
        } else {
            final List<T> tmp = new ArrayList<>();

            for (final T t : c) {
                tmp.add(t);
            }

            a = (T[]) tmp.toArray();
        }

        for (int i = a.length - 1; i >= 0; i--) {
            if ((!isForNonNull || a[i] != null) && predicate.test(a[i])) {
                return isForNonNull ? Optional.of(a[i]) : Nullable.of(a[i]);
            }
        }

        return isForNonNull ? Optional.empty() : Nullable.empty();
    }

    /**
     * Returns the first {@code non-null} element in the given array that matches the specified predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {null, "apple", "banana", null, "cherry"};
     * N.findFirstNonNull(arr, s -> s.startsWith("b"));   // returns Optional.of("banana")
     * N.findFirstNonNull(arr, s -> s.startsWith("z"));   // returns Optional.empty()
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to search
     * @param predicate the predicate to apply to elements of the array
     * @return an Optional containing the first {@code non-null} element that matches the predicate, or an empty Optional if no such element is found
     */
    public static <T> Optional<T> findFirstNonNull(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return Optional.empty();
        }

        for (final T element : a) {
            if (element != null && predicate.test(element)) {
                return Optional.of(element);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first {@code non-null} element in the given iterable that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to search
     * @param predicate the predicate to apply to elements of the iterable
     * @return an Optional containing the first {@code non-null} element that matches the predicate, or an empty Optional if no such element is found
     */
    public static <T> Optional<T> findFirstNonNull(final Iterable<? extends T> c, final Predicate<? super T> predicate) {
        if (isEmpty(c)) {
            return Optional.empty();
        }

        for (final T e : c) {
            if (e != null && predicate.test(e)) {
                return Optional.of(e);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the first {@code non-null} element in the given iterator that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator to search
     * @param predicate the predicate to apply to elements of the iterator
     * @return an Optional containing the first {@code non-null} element that matches the predicate, or an empty Optional if no such element is found
     */
    public static <T> Optional<T> findFirstNonNull(final Iterator<? extends T> iter, final Predicate<? super T> predicate) {
        if (iter == null) {
            return Optional.empty();
        }

        T next = null;

        while (iter.hasNext()) {
            next = iter.next();

            if (next != null && predicate.test(next)) {
                return Optional.of(next);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the last {@code non-null} element in the given array that matches the specified predicate.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to search
     * @param predicate the predicate to apply to elements of the array
     * @return an Optional containing the last {@code non-null} element that matches the predicate, or an empty Optional if no such element is found
     */
    public static <T> Optional<T> findLastNonNull(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return Optional.empty();
        }

        for (int len = a.length, i = len - 1; i >= 0; i--) {
            if (a[i] != null && predicate.test(a[i])) {
                return Optional.of(a[i]);
            }
        }

        return Optional.empty();
    }

    /**
     * Returns the last {@code non-null} element in the given iterable that matches the specified predicate.
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable to search
     * @param predicate the predicate to apply to elements of the iterable
     * @return an Optional containing the last {@code non-null} element that matches the predicate, or an empty Optional if no such element is found
     */
    public static <T> Optional<T> findLastNonNull(final Iterable<? extends T> c, final Predicate<? super T> predicate) {
        return (Optional<T>) findLast(c, predicate, true);
    }

    /**
     * Checks whether two boolean arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first boolean array to compare, may be {@code null}
     * @param b the second boolean array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final boolean[] a, final boolean[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Boolean> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two char arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first char array to compare, may be {@code null}
     * @param b the second char array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final char[] a, final char[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Character> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two byte arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first byte array to compare, may be {@code null}
     * @param b the second byte array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final byte[] a, final byte[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Byte> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two short arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first short array to compare, may be {@code null}
     * @param b the second short array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final short[] a, final short[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Short> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two int arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * <p>For example:
     * 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 3, 2};
     * int[] b = {2, 1, 3, 2};
     * int[] c = {1, 2, 3};
     * int[] d = {1, 2, 2, 2};
     * 
     * haveSameElements(a, b);                     // returns {@code true} (same elements, different order)
     * haveSameElements(a, c);                     // returns {@code false} (different lengths)
     * haveSameElements(a, d);                     // returns {@code false} (different frequencies of element 2)
     * haveSameElements(null, null);               // returns true
     * haveSameElements(new int[0], new int[0]);   // returns true
     * }</pre>
     * 
     * 
     * @param a the first int array to compare, may be {@code null}
     * @param b the second int array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     */
    public static boolean haveSameElements(final int[] a, final int[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Integer> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two long arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul> 
     * 
     * @param a the first long array to compare, may be {@code null}
     * @param b the second long array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final long[] a, final long[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Long> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two float arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first float array to compare, may be {@code null}
     * @param b the second float array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final float[] a, final float[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Float> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two double arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first double array to compare, may be {@code null}
     * @param b the second double array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final double[] a, final double[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Double> multiset = newMultiset(len);

        for (int i = 0; i < len; i++) {
            multiset.add(a[i]);
        }

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two object arrays contain the same elements with the same frequencies,
     * regardless of their order. Two arrays are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first object array to compare, may be {@code null}
     * @param b the second object array to compare, may be {@code null}
     * @return {@code true} if both arrays contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(int[], int[])
     */
    public static boolean haveSameElements(final Object[] a, final Object[] b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = len(a);

        if (len(b) != len) {
            return false;
        }

        final Multiset<Object> multiset = newMultiset(len);

        multiset.addAll(Arrays.asList(a).subList(0, len));

        for (int i = 0; i < len; i++) {
            if (!multiset.remove(b[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether two collections contain the same elements with the same frequencies, regardless of their order.
     * <p>
     * This method compares the contents of two collections to determine if they are equal in terms of
     * elements and their frequencies. Two collections are considered equal if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They both contain the same elements with identical frequencies</li>
     *   <li>They are both empty or {@code null}</li>
     * </ul>
     * <p>
     * The method is agnostic to the actual implementation of the collections and focuses only
     * on their content. Order of elements is not considered in the comparison.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("a", "b", "c");
     * List<String> b = Arrays.asList("c", "a", "b");
     * List<String> c = Arrays.asList("a", "b", "b");
     *
     * N.haveSameElements(a, b);         // returns true (same elements, different order)
     * N.haveSameElements(a, c);         // returns false (different frequencies)
     * N.haveSameElements(null, null);   // returns true
     * }</pre>
     *
     * @param a the first collection to compare, may be {@code null}
     * @param b the second collection to compare, may be {@code null}
     * @return {@code true} if both collections contain the same elements with the same frequencies,
     *         {@code false} otherwise
     * @see #haveSameElements(Object[], Object[])
     * @see N#isProperSubCollection(Collection, Collection)
     * @see N#isSubCollection(Collection, Collection)
     */
    public static boolean haveSameElements(final Collection<?> a, final Collection<?> b) {
        if (a == b || (isEmpty(a) && isEmpty(b))) {
            return true;
        }

        final int len = size(a);

        if (size(b) != len) {
            return false;
        }

        final Multiset<Object> multiset = newMultiset(a);

        for (Object e : b) {
            if (!multiset.remove(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Finds and returns the index of the first mismatch between two boolean arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     * If the arrays have different lengths but all common elements match, returns the length of the shorter array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false, true};
     * boolean[] b = {true, false, false};
     * N.mismatch(a, b);         // returns 2
     * N.mismatch(a, a);         // returns -1
     * N.mismatch(null, null);   // returns -1
     * }</pre>
     *
     * @param a the first boolean array, may be {@code null}
     * @param b the second boolean array, may be {@code null}
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty
     * @see Arrays#mismatch(boolean[], boolean[])
     */
    public static int mismatch(final boolean[] a, final boolean[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the relative index of the first mismatch between two boolean arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     * The returned index is relative to {@code fromIndexA}, not an absolute array index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false, true, false};
     * boolean[] b = {true, true, true, true};
     * N.mismatch(a, 0, b, 0, 4);   // returns 1 (relative index)
     * N.mismatch(a, 2, b, 2, 2);   // returns -1 (identical in range)
     * }</pre>
     *
     * @param a the first boolean array
     * @param fromIndexA the starting index (inclusive) in the first array
     * @param b the second boolean array
     * @param fromIndexB the starting index (inclusive) in the second array
     * @param len the number of elements to compare
     * @return the relative index of the first mismatch from {@code fromIndexA}, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if {@code len} is negative
     * @throws IndexOutOfBoundsException if the specified indices or length result in out of bounds access
     * @see Arrays#mismatch(boolean[], int, int, boolean[], int, int)
     */
    public static int mismatch(final boolean[] a, final int fromIndexA, final boolean[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first char array
     * @param b the second char array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(char[], char[])
     */
    public static int mismatch(final char[] a, final char[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two char arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first char array
     * @param fromIndexA the starting index in the first array
     * @param b the second char array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(char[], int, int, char[], int, int)
     */
    public static int mismatch(final char[] a, final int fromIndexA, final char[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first byte array
     * @param b the second byte array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(byte[], byte[])
     */
    public static int mismatch(final byte[] a, final byte[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two byte arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first byte array
     * @param fromIndexA the starting index in the first array
     * @param b the second byte array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(byte[], int, int, byte[], int, int)
     */
    public static int mismatch(final byte[] a, final int fromIndexA, final byte[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first short array
     * @param b the second short array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(short[], short[])
     */
    public static int mismatch(final short[] a, final short[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two short arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first short array
     * @param fromIndexA the starting index in the first array
     * @param b the second short array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(short[], int, int, short[], int, int)
     */
    public static int mismatch(final short[] a, final int fromIndexA, final short[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first int array
     * @param b the second int array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(int[], int[])
     */
    public static int mismatch(final int[] a, final int[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two int arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first int array
     * @param fromIndexA the starting index in the first array
     * @param b the second int array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(int[], int, int, int[], int, int)
     */
    public static int mismatch(final int[] a, final int fromIndexA, final int[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first long array
     * @param b the second long array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(long[], long[])
     */
    public static int mismatch(final long[] a, final long[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (a[i] != b[i]) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two long arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first long array
     * @param fromIndexA the starting index in the first array
     * @param b the second long array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(long[], int, int, long[], int, int)
     */
    public static int mismatch(final long[] a, final int fromIndexA, final long[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (a[i] != b[j]) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first float array
     * @param b the second float array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(float[], float[])
     */
    public static int mismatch(final float[] a, final float[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (Float.compare(a[i], b[i]) != 0) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two float arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first float array
     * @param fromIndexA the starting index in the first array
     * @param b the second float array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(float[], int, int, float[], int, int)
     */
    public static int mismatch(final float[] a, final int fromIndexA, final float[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (Float.compare(a[i], b[j]) != 0) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param a the first double array
     * @param b the second double array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(double[], double[])
     */
    public static int mismatch(final double[] a, final double[] b) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        final int minLen = N.min(a.length, b.length);

        if (minLen > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, b);
        }

        for (int i = 0; i < minLen; i++) {
            if (Double.compare(a[i], b[i]) != 0) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two double arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param a the first double array
     * @param fromIndexA the starting index in the first array
     * @param b the second double array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(double[], int, int, double[], int, int)
     */
    public static int mismatch(final double[] a, final int fromIndexA, final double[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        if (len > MISMATCH_THRESHOLD) {
            return Arrays.mismatch(a, fromIndexA, fromIndexA + len, b, fromIndexB, fromIndexB + len);
        }

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (Double.compare(a[i], b[j]) != 0) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the arrays, which must be Comparable
     * @param a the first array
     * @param b the second array
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(Object[], Object[])
     */
    public static <T extends Comparable<? super T>> int mismatch(final T[] a, final T[] b) {

        return mismatch(a, b, NATURAL_COMPARATOR);
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param <T> the type of the comparable array elements
     * @param a the first array
     * @param fromIndexA the starting index in the first array
     * @param b the second array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(Object[], int, int, Object[], int, int)
     */
    public static <T extends Comparable<? super T>> int mismatch(final T[] a, final int fromIndexA, final T[] b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {

        return mismatch(a, fromIndexA, b, fromIndexB, len, NATURAL_COMPARATOR);
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays.
     * If the arrays are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the arrays, which must be Comparable
     * @param a the first array
     * @param b the second array
     * @param cmp the comparator to compare array elements
     * @return the index of the first mismatch, or -1 if the arrays are identical or both are {@code null} or empty.
     * @see Arrays#mismatch(Object[], Object[], Comparator)
     */
    public static <T> int mismatch(final T[] a, final T[] b, Comparator<? super T> cmp) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        cmp = checkComparator(cmp);
        final int minLen = N.min(a.length, b.length);

        for (int i = 0; i < minLen; i++) {
            if (cmp.compare(a[i], b[i]) != 0) {
                return i;
            }
        }

        return a.length == b.length ? -1 : minLen;
    }

    /**
     * Finds and returns the index of the first mismatch between two arrays starting from specified indices.
     * If the arrays are identical in the specified range, returns -1.
     *
     * @param <T> the type of the array elements
     * @param a the first array
     * @param fromIndexA the starting index in the first array
     * @param b the second array
     * @param fromIndexB the starting index in the second array
     * @param len the number of elements to compare
     * @param cmp the comparator to compare array elements
     * @return the index of the first mismatch, or -1 if the arrays are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(Object[], int, int, Object[], int, int, Comparator)
     */
    public static <T> int mismatch(final T[] a, final int fromIndexA, final T[] b, final int fromIndexB, final int len, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, len(a)); // NOSONAR
        checkFromIndexSize(fromIndexB, len, len(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        cmp = checkComparator(cmp);

        for (int i = fromIndexA, j = fromIndexB, k = 0; k < len; i++, j++, k++) {
            if (cmp.compare(a[i], b[j]) != 0) {
                return i - fromIndexA;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two collections starting from specified indices.
     * If the collections are identical in the specified range, returns -1.
     *
     * @param <T> the type of elements in the collections
     * @param a the first collection
     * @param fromIndexA the starting index in the first collection
     * @param b the second collection
     * @param fromIndexB the starting index in the second collection
     * @param len the number of elements to compare
     * @return the index of the first mismatch, or -1 if the collections are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(Object[], int, int, Object[], int, int)
     */
    public static <T> int mismatch(final Collection<T> a, final int fromIndexA, final Collection<T> b, final int fromIndexB, final int len)
            throws IllegalArgumentException, IndexOutOfBoundsException {

        return mismatch(a, fromIndexA, b, fromIndexB, len, NATURAL_COMPARATOR);
    }

    /**
     * Finds and returns the index of the first mismatch between two iterables.
     * If the iterables are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the iterables
     * @param a the first iterable
     * @param b the second iterable
     * @return the index of the first mismatch, or -1 if the iterables are identical or both are {@code null} or empty
     * @see Arrays#mismatch(Object[], Object[])
     */
    public static <T extends Comparable<? super T>> int mismatch(final Iterable<T> a, final Iterable<T> b) {

        return mismatch(a, b, NATURAL_COMPARATOR);
    }

    /**
     * Finds and returns the index of the first mismatch between two iterators.
     * If the iterators are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the iterators
     * @param a the first iterator
     * @param b the second iterator
     * @return the index of the first mismatch, or -1 if the iterators are identical or both are {@code null} or empty
     * @see Arrays#mismatch(Object[], Object[])
     */
    public static <T extends Comparable<? super T>> int mismatch(final Iterator<T> a, final Iterator<T> b) {

        return mismatch(a, b, NATURAL_COMPARATOR);
    }

    /**
     * Finds and returns the index of the first mismatch between two collections starting from specified indices.
     * If the collections are identical in the specified range, returns -1.
     *
     * @param <T> the type of elements in the collections
     * @param a the first collection
     * @param fromIndexA the starting index in the first collection
     * @param b the second collection
     * @param fromIndexB the starting index in the second collection
     * @param len the number of elements to compare
     * @param cmp the comparator to compare elements
     * @return the index of the first mismatch, or -1 if the collections are identical in the specified range
     * @throws IllegalArgumentException if the length is negative
     * @throws IndexOutOfBoundsException if the starting indices or length are out of bounds
     * @see Arrays#mismatch(Object[], int, int, Object[], int, int, Comparator)
     */
    public static <T> int mismatch(final Collection<T> a, int fromIndexA, final Collection<T> b, int fromIndexB, final int len, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(len, cs.len);
        checkFromIndexSize(fromIndexA, len, size(a));
        checkFromIndexSize(fromIndexB, len, size(b));

        if ((fromIndexA == fromIndexB && a == b) || len == 0) {
            return -1;
        }

        cmp = checkComparator(cmp);
        final Iterator<T> iterA = a.iterator();
        final Iterator<T> iterB = b.iterator();

        while (fromIndexA-- > 0) {
            iterA.next();
        }

        while (fromIndexB-- > 0) {
            iterB.next();
        }

        for (int i = 0; i < len; i++) {
            if (cmp.compare(iterA.next(), iterB.next()) != 0) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Finds and returns the index of the first mismatch between two iterables using the specified comparator.
     * If the iterables are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the iterables
     * @param a the first iterable
     * @param b the second iterable
     * @param cmp the comparator to compare elements
     * @return the index of the first mismatch, or -1 if the iterables are identical or both are {@code null} or empty
     * @see Arrays#mismatch(Object[], Object[], Comparator)
     */
    public static <T> int mismatch(final Iterable<T> a, final Iterable<T> b, final Comparator<? super T> cmp) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        return mismatch(a.iterator(), b.iterator(), cmp);
    }

    /**
     * Finds and returns the index of the first mismatch between two iterators using the specified comparator.
     * If the iterators are identical or both are {@code null} or empty, returns -1.
     *
     * @param <T> the type of elements in the iterators
     * @param a the first iterator
     * @param b the second iterator
     * @param cmp the comparator to compare elements
     * @return the index of the first mismatch, or -1 if the iterators are identical or both are {@code null} or empty
     * @see Arrays#mismatch(Object[], Object[], Comparator)
     */
    public static <T> int mismatch(final Iterator<T> a, final Iterator<T> b, Comparator<? super T> cmp) {
        if (a == b) {
            return -1;
        }

        if (isEmpty(a)) {
            return isEmpty(b) ? -1 : 0;
        } else if (isEmpty(b)) {
            return 0;
        }

        cmp = checkComparator(cmp);

        // a == null ? ObjIterator.empty() : a;
        // b == null ? ObjIterator.empty() : b;
        int idx = 0;

        while (a.hasNext() && b.hasNext()) {
            if (cmp.compare(a.next(), b.next()) != 0) {
                return idx;
            }

            idx++;
        }

        return a.hasNext() || b.hasNext() ? idx : -1;
    }

    // ================================ get/find matched/mismatch element... ===========================================

    // ================================ reverse/rotate/shuffle/swap/fill/pad/repeat... ================================== 

    /**
     * Reverses the order of elements in the specified boolean array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [true, false]} becomes {@code [false, true]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the boolean array to be reversed. May be {@code null}.
     * @see #reverse(boolean[], int, int)
     */
    public static void reverse(final boolean[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a boolean array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [true, false, {@code false}, true, true]}
     * results in {@code [true, true, false, {@code false}, true]}.</p>
     *
     * @param a the boolean array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(boolean[])
     */
    public static void reverse(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        boolean tmp = false;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified char array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code ['a', 'b', 'c']} becomes {@code ['c', 'b', 'a']}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the char array to be reversed. May be {@code null}.
     * @see #reverse(char[], int, int)
     */
    public static void reverse(final char[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a char array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code ['a', 'b', 'c', 'd', 'e']}
     * results in {@code ['a', 'd', 'c', 'b', 'e']}.</p>
     *
     * @param a the char array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(char[])
     */
    public static void reverse(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        char tmp = 0;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified byte array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1, 2, 3]} becomes {@code [3, 2, 1]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the byte array to be reversed. May be {@code null}.
     * @see #reverse(byte[], int, int)
     */
    public static void reverse(final byte[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a byte array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1, 2, 3, 4, 5]}
     * results in {@code [1, 4, 3, 2, 5]}.</p>
     *
     * @param a the byte array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(byte[])
     */
    public static void reverse(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        byte tmp = 0;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified short array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1, 2, 3]} becomes {@code [3, 2, 1]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the short array to be reversed. May be {@code null}.
     * @see #reverse(short[], int, int)
     */
    public static void reverse(final short[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a short array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1, 2, 3, 4, 5]}
     * results in {@code [1, 4, 3, 2, 5]}.</p>
     *
     * @param a the short array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(short[])
     */
    public static void reverse(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        short tmp = 0;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified int array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1, 2, 3]} becomes {@code [3, 2, 1]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the int array to be reversed. May be {@code null}.
     * @see #reverse(int[], int, int)
     */
    public static void reverse(final int[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within an int array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1, 2, 3, 4, 5]}
     * results in {@code [1, 4, 3, 2, 5]}.</p>
     *
     * @param a the int array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(int[])
     */
    public static void reverse(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        int tmp = 0;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified long array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1L, 2L, 3L]} becomes {@code [3L, 2L, 1L]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the long array to be reversed. May be {@code null}.
     * @see #reverse(long[], int, int)
     */
    public static void reverse(final long[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a long array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1L, 2L, 3L, 4L, 5L]}
     * results in {@code [1L, 4L, 3L, 2L, 5L]}.</p>
     *
     * @param a the long array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(long[])
     */
    public static void reverse(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        long tmp = 0L; //NOSONAR

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified float array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1.0f, 2.0f, 3.0f]} becomes {@code [3.0f, 2.0f, 1.0f]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the float array to be reversed. May be {@code null}.
     * @see #reverse(float[], int, int)
     */
    public static void reverse(final float[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a float array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1.0f, 2.0f, 3.0f, 4.0f, 5.0f]}
     * results in {@code [1.0f, 4.0f, 3.0f, 2.0f, 5.0f]}.</p>
     *
     * @param a the float array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(float[])
     */
    public static void reverse(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        float tmp = 0f; //NOSONAR

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified double array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code [1.0, 2.0, 3.0]} becomes {@code [3.0, 2.0, 1.0]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the double array to be reversed. May be {@code null}.
     * @see #reverse(double[], int, int)
     */
    public static void reverse(final double[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within a double array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code [1.0, 2.0, 3.0, 4.0, 5.0]}
     * results in {@code [1.0, 4.0, 3.0, 2.0, 5.0]}.</p>
     *
     * @param a the double array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(double[])
     */
    public static void reverse(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        double tmp = 0d; //NOSONAR

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified object array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of all elements.
     * For example, the array {@code ["a", "b", "c"]} becomes {@code ["c", "b", "a"]}.
     * If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the object array to be reversed. May be {@code null}.
     * @see #reverse(Object[], int, int)
     */
    public static void reverse(final Object[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverse(a, 0, a.length);
    }

    /**
     * Reverses the order of elements in the specified range within an object array in-place.
     * 
     * <p>This method modifies the original array by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the array {@code ["a", "b", "c", "d", "e"]}
     * results in {@code ["a", "d", "c", "b", "e"]}.</p>
     *
     * @param a the object array containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #reverse(Object[])
     */
    public static void reverse(final Object[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (toIndex - fromIndex <= 1) {
            return;
        }

        Object tmp = null;

        for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }

    /**
     * Reverses the order of elements in the specified list in-place.
     * 
     * <p>This method modifies the original list by reversing the order of all elements.
     * For {@link RandomAccess} lists, elements are swapped directly using index access.
     * For non-RandomAccess lists, {@link ListIterator}s are used for efficient reversal.</p>
     * 
     * For example, the list {@code ["a", "b", "c"]} becomes {@code ["c", "b", "a"]}.
     * 
     * <p>If the list is {@code null} or empty, this method does nothing.</p>
     *
     * @param list the list to be reversed. May be {@code null}.
     * @see #reverse(List, int, int)
     * @see #reverse(Collection)
     * @see #reverseToList(Collection)
     * @see Collections#reverse(List)
     */
    public static void reverse(final List<?> list) {
        if (isEmpty(list)) {
            return;
        }

        reverse(list, 0, list.size());
    }

    /**
     * Reverses the order of elements in the specified range within a list in-place.
     * 
     * <p>This method modifies the original list by reversing the order of elements
     * between {@code fromIndex} (inclusive) and {@code toIndex} (exclusive).
     * Elements outside this range remain unchanged.</p>
     * 
     * <p>For {@link RandomAccess} lists or small ranges, elements are swapped directly using index access.
     * For non-RandomAccess lists with larger ranges, {@link ListIterator}s are used for efficient reversal.</p>
     * 
     * <p>For example, reversing the range [1, 4) in the list {@code ["a", "b", "c", "d", "e"]}
     * results in {@code ["a", "d", "c", "b", "e"]}.</p>
     *
     * @param list the list containing the range to be reversed
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > list.size()} or {@code fromIndex > toIndex}
     * @see #reverse(List)
     * @see #reverse(Collection)
     * @see #reverseToList(Collection)
     */
    public static void reverse(final List<?> list, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(list));

        if (toIndex - fromIndex <= 1) {
            return;
        }

        final List<Object> l = (List<Object>) list;

        if (toIndex - fromIndex < REVERSE_THRESHOLD || list instanceof RandomAccess) {
            for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
                l.set(i, l.set(j, l.get(i)));
            }
        } else {
            final ListIterator<Object> fwd = l.listIterator(fromIndex);
            final ListIterator<Object> rev = l.listIterator(toIndex);

            for (int i = 0, mid = (toIndex - fromIndex) / 2; i < mid; i++) {
                final Object tmp = fwd.next();
                fwd.set(rev.previous());
                rev.set(tmp);
            }
        }
    }

    // replaced by SequencedCollection in JDK 21?

    /**
     * Reverses the order of elements in the specified collection in-place.
     * 
     * <p>This method is designed for collections with a well-defined encounter order.
     * For {@link List} implementations, it delegates to {@link #reverse(List)}.
     * For other collections, it converts the collection to an array, reverses the array,
     * and then repopulates the collection with the reversed elements.</p>
     * 
     * <p>If the collection is {@code null}, empty, or contains only one element,
     * this method does nothing.</p>
     * 
     * <p><b>Note:</b> This method is marked as {@link Beta} and may be replaced by
     * {@code SequencedCollection} functionality in JDK 21 or later.</p>
     *
     * @param c the collection to be reversed. Should have a well-defined encounter order.
     * @see #reverse(List)
     * @see #reverseToList(Collection)
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static void reverse(final Collection<?> c) {
        if (isEmpty(c) || c.size() <= 1) {
            return;
        }

        if (c instanceof List) {
            reverse((List) c);
        } else {
            final Object[] tmp = c.toArray();
            reverse(tmp);
            c.clear();
            c.addAll((List) Arrays.asList(tmp));
        }
    }

    // replaced by SequencedCollection in JDK 21?

    /**
     * Creates a new list containing the elements from the specified collection in reversed order.
     * 
     * <p>This method does not modify the original collection. Instead, it creates a new
     * {@link ArrayList} containing all elements from the collection, then reverses the
     * order of elements in the new list.</p>
     * 
     * <p>The input collection does not need to have a well-defined encounter order.
     * If the collection is {@code null} or empty, an empty list is returned.</p>
     * 
     * <p><b>Note:</b> This method is marked as {@link Beta} and may be replaced by
     * {@code SequencedCollection} functionality in JDK 21 or later.</p>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection whose elements will be added to the returned list in reverse order. May be {@code null}.
     * @return a new list containing the elements from the collection in reversed order
     * @see #reverse(List)
     * @see #reverse(Collection)
     */
    @Beta
    public static <T> List<T> reverseToList(final Collection<? extends T> c) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(c);

        reverse(result);

        return result;
    }

    /**
     * Rotates the elements of the specified boolean array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [true, false, true, false]}
     * by distance 1 results in {@code [false, true, false, true]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the boolean array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(boolean[], int, int, int)
     */
    public static void rotate(final boolean[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a boolean array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the boolean array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(boolean[], int)
     */
    public static void rotate(final boolean[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final boolean tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified char array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code ['a', 'b', 'c', 'd']}
     * by distance 1 results in {@code ['d', 'a', 'b', 'c']}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the char array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(char[], int, int, int)
     */
    public static void rotate(final char[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a char array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the char array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(char[], int)
     */
    public static void rotate(final char[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final char tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified byte array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [1, 2, 3, 4]}
     * by distance 1 results in {@code [4, 1, 2, 3]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the byte array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(byte[], int, int, int)
     */
    public static void rotate(final byte[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a byte array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the byte array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(byte[], int)
     */
    public static void rotate(final byte[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final byte tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified short array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [1, 2, 3, 4]}
     * by distance 1 results in {@code [4, 1, 2, 3]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the short array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(short[], int, int, int)
     */
    public static void rotate(final short[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a short array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the short array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(short[], int)
     */
    public static void rotate(final short[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final short tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified int array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example: </p>
     * 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Rotate an int array to the right by 2 positions
     * int[] a = {1, 2, 3, 4, 5};
     * rotate(a, 2);   // a => [4, 5, 1, 2, 3]
     *
     * //  Rotate an int array to the left by 1 position (negative distance)
     * int[] a = {1, 2, 3, 4, 5};
     * rotate(a, -1);   // a => [2, 3, 4, 5, 1]
     *
     * // Rotate by a distance larger than the stream size
     * int[] a = {1, 2, 3, 4, 5};
     * rotate(a, 7);   // a => [4, 5, 1, 2, 3], same as rotated(2) due to modulo operation
     * }</pre>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the int array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(int[], int, int, int)
     */
    public static void rotate(final int[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of an int array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the int array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(int[], int)
     */
    public static void rotate(final int[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final int tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified long array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [1L, 2L, 3L, 4L]}
     * by distance 1 results in {@code [4L, 1L, 2L, 3L]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the long array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(long[], int, int, int)
     */
    public static void rotate(final long[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a long array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the long array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(long[], int)
     */
    public static void rotate(final long[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final long tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified float array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [1.0f, 2.0f, 3.0f, 4.0f]}
     * by distance 1 results in {@code [4.0f, 1.0f, 2.0f, 3.0f]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the float array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(float[], int, int, int)
     */
    public static void rotate(final float[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a float array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the float array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(float[], int)
     */
    public static void rotate(final float[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final float tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified double array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [1.0, 2.0, 3.0, 4.0]}
     * by distance 1 results in {@code [4.0, 1.0, 2.0, 3.0]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the double array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(double[], int, int, int)
     */
    public static void rotate(final double[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of a double array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the double array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(double[], int)
     */
    public static void rotate(final double[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final double tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified object array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code ["a", "b", "c", "d"]}
     * by distance 1 results in {@code ["d", "a", "b", "c"]}.</p>
     * 
     * <p>The rotation is performed in-place, modifying the original array.
     * If the array is {@code null}, empty, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param a the object array to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(Object[], int, int, int)
     */
    public static void rotate(final Object[] a, int distance) {
        rotate(a, 0, len(a), distance);
    }

    /**
     * Rotates the elements in the specified range of an object array by the specified distance.
     * 
     * <p>Rotation shifts elements circularly within the specified range. A positive distance
     * rotates elements to the right, while a negative distance rotates to the left.
     * Elements outside the specified range remain unchanged.</p>
     * 
     * <p>The rotation is performed in-place using a cyclic algorithm that minimizes
     * the number of element moves. The effective distance is calculated as {@code distance % (toIndex - fromIndex)}.</p>
     *
     * @param a the object array containing the range to be rotated
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #rotate(Object[], int)
     */
    public static void rotate(final Object[] a, int fromIndex, int toIndex, int distance) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        final int len = toIndex - fromIndex;

        if (len <= 1 || distance % len == 0) {
            return;
        }

        distance = distance % len;

        if (distance < 0) {
            distance += len;
        }

        for (int i = fromIndex, count = 0; count < len; i++) {
            final Object tmp = a[i];
            int curr = i;
            int next = curr - fromIndex < distance ? curr - distance + len : curr - distance;

            while (next != i) {
                a[curr] = a[next];
                curr = next;
                next = curr - fromIndex < distance ? curr - distance + len : curr - distance;
                count++;
            }

            a[curr] = tmp;
            count++;
        }
    }

    /**
     * Rotates the elements of the specified list by the specified distance.
     * 
     * <p>Rotation shifts elements circularly. A positive distance rotates elements to the right,
     * while a negative distance rotates to the left. For example, rotating {@code [a, b, c, d]}
     * by distance 1 results in {@code [d, a, b, c]}.</p>
     * 
     * <p>This method delegates to {@link Collections#rotate(List, int)} for the actual rotation.
     * If the list is {@code null}, has size 1 or less, or the effective rotation distance is 0,
     * this method does nothing.</p>
     *
     * @param list the list to be rotated. May be {@code null}.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see Collections#rotate(List, int)
     */
    public static void rotate(final List<?> list, final int distance) {
        if (list == null || list.size() <= 1 || distance % list.size() == 0) {
            return;
        }

        Collections.rotate(list, distance);
    }

    /**
     * Rotates the elements of the specified collection by the specified distance.
     * 
     * <p>This method is designed for collections with a well-defined encounter order.
     * For {@link List} implementations, it delegates to {@link #rotate(List, int)}.
     * For other collections, it converts the collection to an array, rotates the array,
     * and then repopulates the collection with the rotated elements.</p>
     * 
     * <p>If the collection is {@code null} or has fewer than 2 elements,
     * this method does nothing.</p>
     * 
     * <p><b>Note:</b> This method is marked as {@link Beta} and its behavior may change
     * in future versions.</p>
     *
     * @param c the collection to be rotated. Should have a well-defined encounter order.
     * @param distance the distance to rotate. Positive values rotate right, negative values rotate left.
     * @see #rotate(List, int)
     * @see Collections#rotate(List, int)
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static void rotate(final Collection<?> c, final int distance) {
        if (isEmpty(c) || c.size() < 2) {
            return;
        }

        if (c instanceof List) {
            rotate((List) c, distance);
        } else {
            final Object[] tmp = c.toArray();
            rotate(tmp, distance);
            c.clear();
            c.addAll((List) Arrays.asList(tmp));
        }
    }

    /**
     * Shuffles the elements of the specified boolean array randomly.
     * 
     * <p>This method uses a default {@link Random} instance to perform the shuffle.
     * The shuffling is performed in-place, meaning the original array is modified.
     * 
     * <p>If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the boolean array to be shuffled. May be {@code null}.
     * @see #shuffle(boolean[], Random)
     * @see #shuffle(boolean[], int, int)
     */
    public static void shuffle(final boolean[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements in the specified range of a boolean array randomly.
     * 
     * <p>This method uses a default {@link Random} instance to perform the shuffle.
     * Only elements within the specified range are shuffled; elements outside
     * this range remain in their original positions.</p>
     * 
     * <p>The shuffle is performed in-place using the Fisher-Yates algorithm.</p>
     *
     * @param a the boolean array containing the range to be shuffled
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #shuffle(boolean[], int, int, Random)
     */
    public static void shuffle(final boolean[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified boolean array using the provided random number generator.
     * 
     * <p>The shuffle is performed in-place using the Fisher-Yates algorithm,
     * which ensures each permutation has equal probability when using a proper
     * random number generator.</p>
     * 
     * <p>If the array is {@code null} or empty, this method does nothing.</p>
     *
     * @param a the boolean array to be shuffled. May be {@code null}.
     * @param rnd the random number generator to use for shuffling
     * @see #shuffle(boolean[])
     * @see #shuffle(boolean[], int, int, Random)
     */
    public static void shuffle(final boolean[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements in the specified range of a boolean array using the provided random number generator.
     * 
     * <p>Only elements within the specified range are shuffled; elements outside
     * this range remain in their original positions. The shuffle is performed
     * in-place using the Fisher-Yates algorithm.</p>
     * 
     * <p>If the array is {@code null}, empty, or the range contains 1 or fewer elements,
     * this method does nothing.</p>
     *
     * @param a the boolean array containing the range to be shuffled
     * @param fromIndex the starting index of the range (inclusive). Must be non-negative.
     * @param toIndex the ending index of the range (exclusive). Must be greater than or equal to {@code fromIndex}.
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #shuffle(boolean[], Random)
     */
    public static void shuffle(final boolean[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified char array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the char array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(char[], Random)
     */
    public static void shuffle(final char[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified char array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the char array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of  range.
     * @see #shuffle(char[], int, int, Random)
     */
    public static void shuffle(final char[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified char array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the char array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final char[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**
     * Shuffles the elements of the specified char array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the char array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final char[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified byte array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the byte array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(byte[], Random)
     */
    public static void shuffle(final byte[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified byte array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the byte array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of  range.
     * @see #shuffle(byte[], int, int, Random)
     */
    public static void shuffle(final byte[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified byte array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the byte array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final byte[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**
     * Shuffles the elements of the specified byte array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the byte array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final byte[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified short array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the short array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(short[], Random)
     */
    public static void shuffle(final short[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified short array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the short array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of  range.
     * @see #shuffle(short[], int, int, Random)
     */
    public static void shuffle(final short[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified short array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the short array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final short[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified short array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the short array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final short[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified int array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the int array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(int[], Random)
     */
    public static void shuffle(final int[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified int array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the int array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     * @see #shuffle(int[], int, int, Random)
     */
    public static void shuffle(final int[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified int array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the int array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final int[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified int array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the int array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final int[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified long array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the long array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(long[], Random)
     */
    public static void shuffle(final long[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified long array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the long array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     * @see #shuffle(long[], int, int, Random)
     */
    public static void shuffle(final long[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified long array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the long array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final long[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified long array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the long array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final long[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified float array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the float array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(float[], Random)
     */
    public static void shuffle(final float[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified float array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the float array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     * @see #shuffle(float[], int, int, Random)
     */
    public static void shuffle(final float[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified float array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the float array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final float[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified float array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the float array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final float[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified double array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the double array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(double[], Random)
     */
    public static void shuffle(final double[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified double array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the double array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     * @see #shuffle(double[], int, int, Random)
     */
    public static void shuffle(final double[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified double array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the double array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final double[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified double array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the double array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final double[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified object array using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * This method uses the default random number generator.
     *
     * @param a the object array to be shuffled. If {@code null} or empty, no operation is performed.
     * @see #shuffle(Object[], Random)
     */
    public static void shuffle(final Object[] a) {
        shuffle(a, RAND);
    }

    /**
     * Shuffles the elements of the specified object array within a specified range using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     * This method uses the default random number generator.
     *
     * @param a the object array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     * @see #shuffle(Object[], int, int, Random)
     */
    public static void shuffle(final Object[] a, final int fromIndex, final int toIndex) {
        shuffle(a, fromIndex, toIndex, RAND);
    }

    /**
     * Shuffles the elements of the specified object array using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     *
     * @param a the object array to be shuffled. If {@code null} or empty, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see Random
     */
    public static void shuffle(final Object[] a, final Random rnd) {
        shuffle(a, 0, len(a), rnd);
    }

    /**     
     * Shuffles the elements of the specified object array within a specified range using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original array is modified.
     * Only elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive) are shuffled.
     *
     * @param a the object array to be shuffled
     * @param fromIndex the starting index (inclusive) of the range to shuffle
     * @param toIndex the ending index (exclusive) of the range to shuffle
     * @param rnd the random number generator to use for shuffling
     * @throws IndexOutOfBoundsException if the specified {@code fromIndex} or {@code toIndex} is out of range.
     */
    public static void shuffle(final Object[] a, final int fromIndex, final int toIndex, final Random rnd) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (isEmpty(a) || toIndex - fromIndex <= 1) {
            return;
        }

        for (int i = toIndex, n = toIndex - fromIndex; i > fromIndex; i--, n--) {
            swap(a, i - 1, rnd.nextInt(n) + fromIndex);
        }
    }

    /**
     * Shuffles the elements of the specified list using the Fisher-Yates algorithm.
     * The shuffling is performed in-place, meaning the original list is modified.
     * This method uses the default random number generator.
     * 
     * <p>This method runs in linear time for lists that implement {@link RandomAccess},
     * and may have degraded performance for lists that do not support constant-time
     * positional access.</p>
     *
     * @param list the list to be shuffled. If {@code null}, empty, or contains only one element, no operation is performed.
     * @see java.util.Collections#shuffle(List)
     * @see #shuffle(List, Random)
     */
    public static void shuffle(final List<?> list) {
        shuffle(list, RAND);
    }

    /**
     * Shuffles the elements of the specified list using the Fisher-Yates algorithm
     * with the specified random number generator.
     * The shuffling is performed in-place, meaning the original list is modified.
     * 
     * <p>This method runs in linear time for lists that implement {@link RandomAccess},
     * and may have degraded performance for lists that do not support constant-time
     * positional access.</p>
     *
     * @param list the list to be shuffled. If {@code null}, empty, or contains only one element, no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see java.util.Collections#shuffle(List, Random)
     * @see Random
     */
    public static void shuffle(final List<?> list, final Random rnd) {
        if (isEmpty(list) || list.size() == 1) {
            return;
        }

        Collections.shuffle(list, rnd);
    }

    /**
     * Shuffles the elements of the specified collection that has a well-defined encounter order.
     * The shuffling is performed in-place, meaning the original collection is modified.
     * This method uses the default random number generator.
     * 
     * <p>For {@link List} implementations, this method delegates to {@link #shuffle(List)}.
     * For other collection types, the collection is converted to an array, shuffled, and then
     * the collection is cleared and repopulated with the shuffled elements.</p>
     * 
     * <p><b>Note:</b> This method is marked as {@code @Beta} and may be subject to change in future versions.</p>
     *
     * @param c the collection to be shuffled. It should be a collection that has a well-defined encounter order
     *          (e.g., {@link List}, {@link java.util.LinkedHashSet}). If {@code null} or contains fewer than 2 elements,
     *          no operation is performed.
     * @see #shuffle(List)
     * @see #shuffle(Collection, Random)
     * @see java.util.Collections#shuffle(List)
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static void shuffle(final Collection<?> c) {
        if (isEmpty(c) || c.size() < 2) {
            return;
        }

        if (c instanceof List) {
            shuffle((List) c);
        } else {
            final Object[] tmp = c.toArray();
            shuffle(tmp);
            c.clear();
            c.addAll((List) Arrays.asList(tmp));
        }
    }

    /**
     * Shuffles the elements of the specified collection that has a well-defined encounter order
     * using the specified random number generator.
     * The shuffling is performed in-place, meaning the original collection is modified.
     * 
     * <p>For {@link List} implementations, this method delegates to {@link #shuffle(List, Random)}.
     * For other collection types, the collection is converted to an array, shuffled, and then
     * the collection is cleared and repopulated with the shuffled elements.</p>
     * 
     * <p><b>Note:</b> This method is marked as {@code @Beta} and may be subject to change in future versions.</p>
     *
     * @param c the collection to be shuffled. It should be a collection that has a well-defined encounter order
     *          (e.g., {@link List}, {@link java.util.LinkedHashSet}). If {@code null} or contains fewer than 2 elements,
     *          no operation is performed.
     * @param rnd the random number generator to use for shuffling
     * @see #shuffle(List, Random)
     * @see #shuffle(Collection)
     * @see java.util.Collections#shuffle(List, Random)
     * @see Random
     */
    @Beta
    @SuppressWarnings("rawtypes")
    public static void shuffle(final Collection<?> c, final Random rnd) {
        if (isEmpty(c) || c.size() < 2) {
            return;
        }

        if (c instanceof List) {
            shuffle((List) c, rnd);
        } else {
            final Object[] tmp = c.toArray();
            shuffle(tmp, rnd);
            c.clear();
            c.addAll((List) Arrays.asList(tmp));
        }
    }

    /**
     * Swaps the elements at the specified positions in the specified boolean array.
     *
     * @param a the boolean array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final boolean[] a, final int i, final int j) {
        final boolean tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified char array.
     *
     * @param a the char array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final char[] a, final int i, final int j) {
        final char tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified byte array.
     *
     * @param a the byte array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final byte[] a, final int i, final int j) {
        final byte tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified short array.
     *
     * @param a the short array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final short[] a, final int i, final int j) {
        final short tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified int array.
     *
     * @param a the int array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final int[] a, final int i, final int j) {
        final int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified long array.
     *
     * @param a the long array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final long[] a, final int i, final int j) {
        final long tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified float array.
     *
     * @param a the float array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final float[] a, final int i, final int j) {
        final float tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified double array.
     *
     * @param a the double array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final double[] a, final int i, final int j) {
        final double tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified Object array.
     *
     * @param a the Object array in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     */
    public static void swap(final Object[] a, final int i, final int j) {
        final Object tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    /**
     * Swaps the elements at the specified positions in the specified list.
     *
     * @param list the list in which to swap elements
     * @param i the index of one element to be swapped
     * @param j the index of the other element to be swapped
     * @see java.util.Collections#swap(List, int, int)
     */
    public static void swap(final List<?> list, final int i, final int j) {
        Collections.swap(list, i, j);
    }

    /**
     * Swaps the left and right elements in the specified pair.
     *
     * @param <T> the type of the elements in the pair
     * @param pair the pair whose elements are to be swapped
     */
    public static <T> void swap(final Pair<T, T> pair) {
        pair.set(pair.right(), pair.left());
    }

    /**
     * Swaps the left and right elements in the specified pair if the specified predicate is {@code true}.
     *
     * @param <T> the type of the elements in the pair
     * @param pair the pair whose elements are to be swapped
     * @param predicate the predicate to determine if the elements should be swapped
     * @return {@code true} if the left and right elements are swapped, otherwise {@code false}
     */
    public static <T> boolean swapIf(final Pair<T, T> pair, final Predicate<? super Pair<T, T>> predicate) {
        if (predicate.test(pair)) {
            pair.set(pair.right(), pair.left());
            return true;
        }

        return false;
    }

    /**
     * Swaps the left and right elements in the specified triple.
     *
     * @param <T> the type of the elements in the triple
     * @param <M> the type of the middle element in the triple
     * @param triple the triple whose elements are to be swapped
     */
    public static <T, M> void swap(final Triple<T, M, T> triple) {
        final T left = triple.left();
        triple.setLeft(triple.right());
        triple.setRight(left);
    }

    /**
     * Swaps the left and right elements in the specified triple if the specified predicate is {@code true}.
     *
     * @param <T> the type of the elements in the triple
     * @param <M> the type of the middle element in the triple
     * @param triple the triple whose elements are to be swapped
     * @param predicate the predicate to determine if the elements should be swapped
     * @return {@code true} if the left and right elements are swapped, otherwise {@code false}
     */
    public static <T, M> boolean swapIf(final Triple<T, M, T> triple, final Predicate<? super Triple<T, M, T>> predicate) {
        if (predicate.test(triple)) {
            final T left = triple.left();
            triple.setLeft(triple.right());
            triple.setRight(left);
            return true;
        }

        return false;
    }

    /**
     * Fills the specified boolean array with the specified value.
     *
     * @param a the boolean array to be filled
     * @param val the boolean value to fill the array with
     * @see Arrays#fill(boolean[], boolean)
     */
    public static void fill(final boolean[] a, final boolean val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified boolean array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the boolean array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the boolean value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(boolean[], int, int, boolean)
     */
    public static void fill(final boolean[] a, final int fromIndex, final int toIndex, final boolean val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified char array with the specified value.
     *
     * @param a the char array to be filled
     * @param val the char value to fill the array with
     * @see Arrays#fill(char[], char)
     */
    public static void fill(final char[] a, final char val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified char array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the char array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the char value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(char[], int, int, char)
     */
    public static void fill(final char[] a, final int fromIndex, final int toIndex, final char val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified byte array with the specified value.
     *
     * @param a the byte array to be filled
     * @param val the byte value to fill the array with
     * @see Arrays#fill(byte[], byte)
     */
    public static void fill(final byte[] a, final byte val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified byte array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the byte array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the byte value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(byte[], int, int, byte)
     */
    public static void fill(final byte[] a, final int fromIndex, final int toIndex, final byte val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified short array with the specified value.
     *
     * @param a the short array to be filled
     * @param val the short value to fill the array with
     * @see Arrays#fill(short[], short)
     */
    public static void fill(final short[] a, final short val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified short array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the short array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the short value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(short[], int, int, short)
     */
    public static void fill(final short[] a, final int fromIndex, final int toIndex, final short val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified int array with the specified value.
     *
     * @param a the int array to be filled
     * @param val the int value to fill the array with
     * @see Arrays#fill(int[], int)
     */
    public static void fill(final int[] a, final int val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified int array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the int array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the int value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(int[], int, int, int)
     */
    public static void fill(final int[] a, final int fromIndex, final int toIndex, final int val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified long array with the specified value.
     *
     * @param a the long array to be filled
     * @param val the long value to fill the array with
     * @see Arrays#fill(long[], long)
     */
    public static void fill(final long[] a, final long val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified long array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the long array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the long value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(long[], int, int, long)
     */
    public static void fill(final long[] a, final int fromIndex, final int toIndex, final long val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified float array with the specified value.
     *
     * @param a the float array to be filled
     * @param val the float value to fill the array with
     * @see Arrays#fill(float[], float)
     */
    public static void fill(final float[] a, final float val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified float array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the float array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the float value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(float[], int, int, float)
     */
    public static void fill(final float[] a, final int fromIndex, final int toIndex, final float val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified double array with the specified value.
     *
     * @param a the double array to be filled
     * @param val the double value to fill the array with
     * @see Arrays#fill(double[], double)
     */
    public static void fill(final double[] a, final double val) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.fill(a, val);
    }

    /**
     * Fills the specified double array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param a the double array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the double value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(double[], int, int, double)
     */
    public static void fill(final double[] a, final int fromIndex, final int toIndex, final double val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        Arrays.fill(a, fromIndex, toIndex, val);
    }

    /**
     * Fills the specified Object array with the specified value.
     *
     * @param <T> the type of the array elements
     * @param a the Object array to be filled
     * @param val the Object value to fill the array with
     * @see Arrays#fill(Object[], Object)
     * @see N#setAll(Object[], IntFunction)
     * @see N#replaceAll(Object[], UnaryOperator)
     * @see Iterables#fill(Object[], Supplier)
     * @see Iterables#fill(Object[], int, int, Supplier)
     */
    public static <T> void fill(final T[] a, final T val) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, len = a.length; i < len; i++) {
            a[i] = val;
        }
    }

    /**
     * Fills the specified Object array with the specified value from the specified fromIndex (inclusive) to the specified toIndex (exclusive).
     *
     * @param <T> the type of the array elements
     * @param a the Object array to be filled
     * @param fromIndex the index to start filling (inclusive)
     * @param toIndex the index to stop filling (exclusive)
     * @param val the Object value to fill the array with
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of bounds
     * @see Arrays#fill(Object[], int, int, Object)
     * @see Iterables#fill(Object[], Supplier)
     * @see Iterables#fill(Object[], int, int, Supplier)
     */
    public static <T> void fill(final T[] a, final int fromIndex, final int toIndex, final T val) {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (fromIndex == toIndex) {
            return;
        }

        for (int i = fromIndex; i < toIndex; i++) {
            a[i] = val;
        }
    }

    /**
     * Fills the specified list with the specified value.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be filled
     * @param val the value to fill the list with
     * @throws IllegalArgumentException if the specified list is null
     * @see Iterables#fill(List, Supplier)
     * @see Iterables#fill(List, int, int, Supplier)
     * @see N#setAll(List, IntFunction)
     * @see N#replaceAll(List, UnaryOperator)
     * @see #fill(List, int, int, Object)
     * @see #padLeft(List, int, Object)
     * @see #padRight(Collection, int, Object)
     */
    public static <T> void fill(final List<? super T> list, final T val) throws IllegalArgumentException {
        checkArgNotNull(list, cs.list);

        fill(list, 0, list.size(), val);
    }

    /**
     * Fills the specified list with the specified value from the specified start index to the specified end index.
     * The list will be extended automatically if the size of the list is less than the specified toIndex.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be filled
     * @param fromIndex the starting index (inclusive) to begin filling
     * @param toIndex the ending index (exclusive) to stop filling
     * @param val the value to fill the list with
     * @throws IllegalArgumentException if the specified list is null
     * @throws IndexOutOfBoundsException if the specified indices are out of range
     * @see Iterables#fill(List, Supplier)
     * @see Iterables#fill(List, int, int, Supplier)
     * @see #fill(List, Object)
     * @see #padLeft(List, int, Object)
     * @see #padRight(Collection, int, Object)
     */
    public static <T> void fill(final List<? super T> list, final int fromIndex, final int toIndex, final T val)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(list, cs.list);
        checkFromToIndex(fromIndex, toIndex, Integer.MAX_VALUE);

        final int size = list.size();

        if (size < toIndex) {
            if (fromIndex < size) {
                for (int i = fromIndex; i < size; i++) {
                    list.set(i, val);
                }
            } else {
                for (int i = size; i < fromIndex; i++) {
                    list.add(null);
                }
            }

            for (int i = 0, len = toIndex - list.size(); i < len; i++) {
                list.add(val);
            }
        } else {
            if (toIndex - fromIndex < FILL_THRESHOLD || list instanceof RandomAccess) {
                for (int i = fromIndex; i < toIndex; i++) {
                    list.set(i, val);
                }
            } else {
                final ListIterator<? super T> itr = list.listIterator(fromIndex);

                for (int i = fromIndex; i < toIndex; i++) {
                    itr.next();

                    itr.set(val);
                }
            }
        }
    }

    /**
     * Fills the properties of the specified bean with random values.
     *
     * @param bean the bean object with getter/setter methods to be filled with random values
     * @throws IllegalArgumentException if the specified bean is {@code null} or the bean class is not a valid JavaBean
     * @deprecated Use {@link Beans#fill(Object)} instead
     */
    @Deprecated
    public static void fill(final Object bean) throws IllegalArgumentException {
        Beans.fill(bean);
    }

    /**
     * Fills the properties of a new instance of the specified bean class with random values.
     *
     * @param <T> the type of the bean
     * @param beanClass the class of the bean to be filled
     * @return a new instance of the specified bean class with properties filled with random values
     * @throws IllegalArgumentException if the specified beanClass is {@code null} or the bean class is not a valid JavaBean
     * @deprecated Use {@link Beans#fill(Class<? extends T>)} instead
     */
    @Deprecated
    public static <T> T fill(final Class<? extends T> beanClass) throws IllegalArgumentException {
        return Beans.fill(beanClass);
    }

    /**
     * Returns a list of new instances of the specified bean class with properties filled with random values.
     *
     * @param <T> the type of the bean
     * @param beanClass the class of the bean to be filled
     * @param count the number of instances to create and fill
     * @return a list of new instances of the specified bean class with properties filled with random values
     * @throws IllegalArgumentException if the specified beanClass is {@code null} or the bean class is not a valid JavaBean
     * @deprecated Use {@link Beans#fill(Class, int)} instead
     */
    @Deprecated
    public static <T> List<T> fill(final Class<? extends T> beanClass, final int count) throws IllegalArgumentException {
        return Beans.fill(beanClass, count);
    }

    /**
     * Appends the provided object to the beginning of the list till the list has at least the specified minimum size.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be padded
     * @param minSize the minimum size the list should have after this operation
     * @param objToAdd the object to add to the list if it is smaller than the specified minimum size
     * @return {@code true} if the list was modified as a result of this operation, {@code false} otherwise
     * @throws IllegalArgumentException if the list is {@code null} or the minimum size is negative
     * @see #padRight(Collection, int, Object)
     * @see Strings#padStart(String, int)
     * @see Strings#padStart(String, int, char)
     */
    @SuppressWarnings("rawtypes")
    public static <T> boolean padLeft(final List<T> list, final int minSize, final T objToAdd) throws IllegalArgumentException {
        checkArgNotNull(list, cs.list);
        checkArgNotNegative(minSize, cs.minSize);

        final int size = size(list);

        if (size < minSize) {
            final int elementCountToAdd = minSize - size;
            final Object[] a = new Object[elementCountToAdd];

            if (objToAdd != null) {
                fill(a, objToAdd);
            }

            list.addAll(0, (List) Arrays.asList(a));

            return true;
        }

        return false;
    }

    /**
     * Appends the provided object to the end of the collection until the collection has at least the specified minimum size.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to be padded
     * @param minSize the minimum size the collection should have after padding
     * @param objToAdd the object to be added to the collection
     * @return {@code true} if the collection was modified, {@code false} otherwise
     * @throws IllegalArgumentException if the collection is {@code null} or the minimum size is negative
     * @see #padLeft(List, int, Object)
     * @see #fill(List, Object)
     * @see #fill(List, int, int, Object)
     */
    @SuppressWarnings("rawtypes")
    public static <T> boolean padRight(final Collection<T> c, final int minSize, final T objToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.collection);
        checkArgNotNegative(minSize, cs.minSize);

        final int size = size(c);

        if (size < minSize) {
            final int elementCountToAdd = minSize - size;
            final Object[] a = new Object[elementCountToAdd];

            if (objToAdd != null) {
                fill(a, objToAdd);
            }

            c.addAll((Collection) Arrays.asList(a));

            return true;
        }

        return false;
    }

    /**
     * Repeats the provided value a specified number of times.
     *
     * @param <T> the type of the value to be repeated
     * @param value the value to be repeated
     * @param n the number of times to repeat the value
     * @return a list containing the repeated values
     * @throws IllegalArgumentException if the specified number of repetitions is negative
     * @see Array#repeat(Object, int, Class)
     * @see Iterators#repeat(Object, int)
     * @see Collections#nCopies(int, Object)
     */
    public static <T> List<T> repeat(final T value, final int n) throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        final List<T> res = new ArrayList<>(n);
        fill(res, 0, n, value);
        return res;
    }

    /**
     * Repeats each element in the specified collection {@code n} times in iteration order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * repeatElements(asList(1, 2, 3), 2) => [1, 1, 2, 2, 3, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection whose elements are to be repeated; may be {@code null} or empty
     * @param n the number of times to repeat the elements; must not be negative
     * @return a list containing the repeated elements; an empty list if {@code n == 0} or the collection is {@code null} or empty
     * @throws IllegalArgumentException if the specified number of repetitions is negative
     * @see Iterators#repeatElements(Collection, long)
     */
    public static <T> List<T> repeatElements(final Collection<? extends T> c, final int n) throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0 || isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(c.size() * n);

        for (final T e : c) {
            for (int i = 0; i < n; i++) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Repeats the entire specified collection {@code n} times.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * repeatCollection(asList(1, 2, 3), 2) => [1, 2, 3, 1, 2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection whose elements are to be repeated; may be {@code null} or empty
     * @param n the number of times to repeat the elements; must not be negative
     * @return a list containing the repeated elements; an empty list if {@code n == 0} or the collection is {@code null} or empty
     * @throws IllegalArgumentException if the specified number of repetitions is negative
     * @see Iterators#repeatCollection(Collection, long)
     */
    public static <T> List<T> repeatCollection(final Collection<T> c, final int n) throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0 || isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(c.size() * n);

        for (int i = 0; i < n; i++) {
            result.addAll(c);
        }

        return result;
    }

    /**
     * Repeats each element in the specified Collection <i>n</i> times one by one till reach the specified size.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * repeatElementsToSize(asList(1, 2, 3), 5) => [1, 1, 2, 2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection whose elements are to be repeated
     * @param size the target size of the resulting list
     * @return a list containing the repeated elements; an empty list if {@code size} is {@code 0}
     * @throws IllegalArgumentException if the specified size is negative, or if {@code size > 0} and the collection is {@code null} or empty
     * @see Iterators#repeatElementsToSize(Collection, long)
     */
    public static <T> List<T> repeatElementsToSize(final Collection<T> c, final int size) throws IllegalArgumentException {
        checkArgument(size == 0 || notEmpty(c), "Collection cannot be empty or null when size > 0");
        checkArgNotNegative(size, cs.size);

        if (size == 0 || isEmpty(c)) {
            return new ArrayList<>();
        }

        final int n = size / c.size();
        int mod = size % c.size();

        final List<T> result = new ArrayList<>(size);

        for (final T e : c) {
            for (int i = 0, cnt = mod-- > 0 ? n + 1 : n; i < cnt; i++) {
                result.add(e);
            }

            if (result.size() == size) {
                break;
            }
        }

        return result;
    }

    /**
     * Repeats the entire specified Collection {@code n} times till reach the specified size.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * repeatCollectionToSize(asList(1, 2, 3), 5) => [1, 2, 3, 1, 2]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection whose elements are to be repeated
     * @param size the target size of the resulting list
     * @return a list containing the repeated elements
     * @throws IllegalArgumentException if the specified collection is {@code null} or empty, or the specified size is negative
     * @see Iterators#repeatCollectionToSize(Collection, long)
     */
    public static <T> List<T> repeatCollectionToSize(final Collection<? extends T> c, final int size) throws IllegalArgumentException {
        checkArgument(size == 0 || notEmpty(c), "Collection cannot be empty or null when size > 0");
        checkArgNotNegative(size, cs.size);

        if (size == 0 || isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(size);

        while (result.size() < size) {
            if (c.size() <= size - result.size()) {
                result.addAll(c);
            } else {
                final Iterator<? extends T> iter = c.iterator();

                for (int i = 0, cnt = size - result.size(); i < cnt; i++) {
                    result.add(iter.next());
                }
            }
        }

        return result;
    }

    // ================================ reverse/rotate/shuffle/swap/fill/pad/repeat... ==================================

    // ================================ copy/copyOf/copyOfRange/clone... ================================================

    /**
     * Copies elements from the source boolean array to the destination boolean array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final boolean[] src, final int srcPos, final boolean[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source char array to the destination char array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final char[] src, final int srcPos, final char[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source byte array to the destination byte array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final byte[] src, final int srcPos, final byte[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source short array to the destination short array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final short[] src, final int srcPos, final short[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source int array to the destination int array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final int[] src, final int srcPos, final int[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source long array to the destination long array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final long[] src, final int srcPos, final long[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source float array to the destination float array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final float[] src, final int srcPos, final float[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source double array to the destination double array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final double[] src, final int srcPos, final double[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source array to the destination array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final Object[] src, final int srcPos, final Object[] dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, len(src));
        checkFromIndexSize(destPos, length, len(dest));

        if (isEmpty(src) && srcPos == 0 && length == 0) {
            return;
        }

        if (length < MIN_SIZE_FOR_COPY_ALL) {
            // for same array copy.
            if (destPos > srcPos) {
                //noinspection ManualArrayCopy
                for (int i = length - 1; i >= 0; i--) {
                    dest[destPos + i] = src[srcPos + i];
                }
            } else {
                //noinspection ManualArrayCopy
                for (int i = 0; i < length; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        } else {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }
    }

    /**
     * Copies elements from the source array to the destination array.
     *
     * @param src the source array from which elements are to be copied
     * @param srcPos starting position in the source array
     * @param dest the destination array to which elements are to be copied
     * @param destPos starting position in the destination array
     * @param length the number of array elements to be copied
     * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    public static void copy(final Object src, final int srcPos, final Object dest, final int destPos, final int length) throws IndexOutOfBoundsException {
        checkFromIndexSize(srcPos, length, Array.getLength(src));
        checkFromIndexSize(destPos, length, Array.getLength(dest));

        //noinspection SuspiciousSystemArraycopy
        System.arraycopy(src, srcPos, dest, destPos, length);
    }

    /**
     * Returns a new boolean array containing a copy of the original array,
     * truncated or padded with {@code false} (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new boolean array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(boolean[], int)
     */
    public static boolean[] copyOf(final boolean[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final boolean[] copy = new boolean[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new char array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new char array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(char[], int)
     */
    public static char[] copyOf(final char[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final char[] copy = new char[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new byte array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new byte array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(byte[], int)
     */
    public static byte[] copyOf(final byte[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final byte[] copy = new byte[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new short array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new short array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(short[], int)
     */
    public static short[] copyOf(final short[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final short[] copy = new short[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new int array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new int array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(int[], int)
     */
    public static int[] copyOf(final int[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final int[] copy = new int[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new long array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new long array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(long[], int)
     */
    public static long[] copyOf(final long[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final long[] copy = new long[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new float array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new float array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(float[], int)
     */
    public static float[] copyOf(final float[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final float[] copy = new float[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new double array containing a copy of the original array,
     * truncated or padded with default value (if necessary) so the copy has the specified length.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new double array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(double[], int)
     */
    public static double[] copyOf(final double[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (original != null && newLength == original.length) {
            return original.clone();
        }

        final double[] copy = new double[newLength];

        if (notEmpty(original)) {
            copy(original, 0, copy, 0, Math.min(original.length, newLength));
        }

        return copy;
    }

    /**
     * Returns a new Object array containing a copy of the original array,
     * truncated or padded with {@code null} (if necessary) so the copy has the specified length.
     *
     * @param <T> the type of the elements in the array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a new Object array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(Object[], int)
     */
    public static <T> T[] copyOf(final T[] original, final int newLength) {
        checkArgNotNegative(newLength, cs.newLength);

        if (newLength == original.length) {
            return original.clone();
        }

        return (T[]) copyOf(original, newLength, original.getClass());
    }

    /**
     * Returns a new array containing a copy of the original array, truncated or padded with {@code null} (if necessary) so the copy has the specified length.
     *
     * @param <T> the type of the elements in the array 
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @param newType the class of the copy to be returned
     * @return a new array containing a copy of the original array
     * @throws IllegalArgumentException if the specified new length is negative
     * @see Arrays#copyOf(Object[], int)
     */
    public static <T> T[] copyOf(final Object[] original, final int newLength, final Class<? extends T[]> newType) {
        checkArgNotNegative(newLength, cs.newLength);

        final T[] copy = Object[].class.equals(newType) ? (T[]) new Object[newLength] : (T[]) newArray(newType.getComponentType(), newLength);
        final int originalLength = original == null ? 0 : Array.getLength(original);

        if (originalLength > 0) {
            copy(original, 0, copy, 0, Math.min(originalLength, newLength));
        }

        return copy;
    }

    /**
     * Returns a new boolean array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new boolean array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(boolean[], int, int)
     */
    public static boolean[] copyOfRange(final boolean[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final boolean[] copy = new boolean[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new boolean array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new boolean array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static boolean[] copyOfRange(final boolean[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final boolean[] copy = new boolean[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new char array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new char array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(char[], int, int)
     */
    public static char[] copyOfRange(final char[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final char[] copy = new char[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new char array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new char array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static char[] copyOfRange(final char[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_CHAR_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final char[] copy = new char[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new byte array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new byte array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(byte[], int, int)
     */
    public static byte[] copyOfRange(final byte[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final byte[] copy = new byte[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new byte array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new byte array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static byte[] copyOfRange(final byte[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_BYTE_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final byte[] copy = new byte[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new short array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new short array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(short[], int, int)
     */
    public static short[] copyOfRange(final short[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final short[] copy = new short[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new short array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new short array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static short[] copyOfRange(final short[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_SHORT_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final short[] copy = new short[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new int array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new int array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(int[], int, int)
     */
    public static int[] copyOfRange(final int[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final int[] copy = new int[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new int array containing a copy of the specified range of the original array, with elements selected at intervals defined by the {@code step} parameter.
     * A positive {@code step} copies elements forward from {@code fromIndex} (inclusive) up to {@code toIndex} (exclusive). A negative {@code step} copies
     * elements in reverse from {@code fromIndex} (inclusive) down to but not including {@code toIndex}; when {@code toIndex} is {@code -1} it is treated as
     * {@code 0} for bounds validation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = { 0, 1, 2, 3, 4, 5 };
     * copyOfRange(a, 1, 5, 1);     // [1, 2, 3, 4]
     * copyOfRange(a, 1, 5, 2);     // [1, 3]
     *
     * copyOfRange(a, 5, 1, -1);    // [5, 4, 3, 2]
     * copyOfRange(a, 5, 1, -2);    // [5, 3]
     * copyOfRange(a, 5, -1, -1);   // [5, 4, 3, 2, 1, 0]
     * copyOfRange(a, 6, -1, -1);   // [5, 4, 3, 2, 1, 0]
     * }</pre>
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new int array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if the resolved range end points fall outside {@code [0, original.length]}
     * @throws IllegalArgumentException  if step is zero
     */
    public static int[] copyOfRange(final int[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_INT_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final int[] copy = new int[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new long array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new long array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(long[], int, int)
     */
    public static long[] copyOfRange(final long[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final long[] copy = new long[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new long array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new long array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static long[] copyOfRange(final long[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_LONG_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final long[] copy = new long[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new float array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new float array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(float[], int, int)
     */
    public static float[] copyOfRange(final float[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final float[] copy = new float[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new float array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new float array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static float[] copyOfRange(final float[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final float[] copy = new float[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new double array containing a copy of the specified range of the original array.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new double array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(double[], int, int)
     */
    public static double[] copyOfRange(final double[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        final int newLength = toIndex - fromIndex;
        final double[] copy = new double[newLength];
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new double array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new double array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static double[] copyOfRange(final double[] original, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final double[] copy = new double[len];

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = original[j];
        }

        return copy;
    }

    /**
     * Returns a new Object array containing a copy of the specified range of the original array.
     *
     * @param <T> the type of the elements in the array
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new Object array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(Object[], int, int)
     */
    public static <T> T[] copyOfRange(final T[] original, final int fromIndex, final int toIndex) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        if (fromIndex == 0 && toIndex == original.length) {
            return original.clone();
        }

        return copyOfRange(original, fromIndex, toIndex, (Class<T[]>) original.getClass());
    }

    /**
     * Returns a new Object array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param <T> the type of the elements in the array
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new Object array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static <T> T[] copyOfRange(final T[] original, final int fromIndex, final int toIndex, final int step) {
        return copyOfRange(original, fromIndex, toIndex, step, (Class<T[]>) original.getClass());
    }

    /**
     * Returns a new array containing a copy of the specified range of the original array.
     *
     * @param <T> the type of the elements in the new array
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param newType the class of the new array
     * @return a new array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @see Arrays#copyOfRange(Object[], int, int, Class)
     */
    public static <T> T[] copyOfRange(final Object[] original, final int fromIndex, final int toIndex, final Class<? extends T[]> newType) {
        checkFromToIndex(fromIndex, toIndex, original.length);

        final int newLength = toIndex - fromIndex;
        final T[] copy = Object[].class.equals(newType) ? (T[]) new Object[newLength] : (T[]) newArray(newType.getComponentType(), newLength);
        copy(original, fromIndex, copy, 0, Math.min(original.length - fromIndex, newLength));
        return copy;
    }

    /**
     * Returns a new array containing a copy of the specified range of the original array, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param <T> the type of the elements in the new array
     * @param original the array from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @param newType the class of the new array
     * @return a new array containing the specified range from the original array
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, or toIndex is larger than the length of array
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    public static <T> T[] copyOfRange(final Object[] original, int fromIndex, final int toIndex, final int step, final Class<? extends T[]> newType)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), original.length);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return Object[].class.equals(newType) ? (T[]) new Object[0] : (T[]) newArray(newType.getComponentType(), 0);
        }

        if (step == 1) {
            return copyOfRange(original, fromIndex, toIndex, newType);
        }

        fromIndex = fromIndex > toIndex ? N.min(original.length - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        final T[] copy = Object[].class.equals(newType) ? (T[]) new Object[len] : (T[]) newArray(newType.getComponentType(), len);

        for (int i = 0, j = fromIndex; i < len; i++, j += step) {
            copy[i] = (T) original[j];
        }

        return copy;
    }

    /**
     * Returns a new list containing a copy of the specified range of the original list.
     *
     * @param <T> the type of elements in the list
     * @param c the list from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @return a new list containing the specified range from the original list
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, toIndex is greater than the size of list
     */
    public static <T> List<T> copyOfRange(final List<T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, c.size());

        final List<T> result = new ArrayList<>(toIndex - fromIndex);
        result.addAll(c.subList(fromIndex, toIndex));
        return result;
    }

    /**
     * Returns a new list containing a copy of the specified range of the original list, with elements selected at intervals defined by the step parameter.
     * If step negative, the elements will be copied in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param c the list from which a range is to be copied
     * @param fromIndex the initial index of the range to be copied, inclusive
     * @param toIndex the final index of the range to be copied, exclusive
     * @param step the interval between elements to be copied
     * @return a new list containing the specified range from the original list
     * @throws IndexOutOfBoundsException if fromIndex is negative or larger than toIndex, toIndex is greater than the size of list
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    @SuppressWarnings("deprecation")
    public static <T> List<T> copyOfRange(final List<T> c, int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), c.size());

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return new ArrayList<>();
        }

        if (step == 1) {
            return copyOfRange(c, fromIndex, toIndex);
        }

        fromIndex = fromIndex > toIndex ? N.min(c.size() - 1, fromIndex) : fromIndex;
        final int len = (toIndex - fromIndex) / step + ((toIndex - fromIndex) % step == 0 ? 0 : 1);
        List<T> result = null;

        if (c instanceof RandomAccess) {
            result = new ArrayList<>(len);

            for (int i = 0, j = fromIndex; i < len; i++, j += step) {
                result.add(c.get(j));
            }
        } else {
            final T[] a = (T[]) c.subList(fromIndex, toIndex).toArray();
            result = InternalUtil.createList(copyOfRange(a, 0, a.length, step));
        }

        return result;
    }

    /**
     * Returns a new string that is a substring of the specified string.
     * The substring begins at the specified <i>fromIndex</i> and extends to the character at index <i>toIndex - 1</i>.
     * Thus, the length of the substring is <i>toIndex - fromIndex</i>.
     *
     * @param str the original string from which a range is to be copied
     * @param fromIndex the beginning index, inclusive
     * @param toIndex the ending index, exclusive
     * @return the specified substring
     * @throws IndexOutOfBoundsException if the <i>fromIndex</i> is negative, <i>toIndex</i> is greater than the length of the string, or <i>fromIndex</i> is greater than <i>toIndex</i>
     */
    public static String copyOfRange(final String str, final int fromIndex, final int toIndex) {
        final int len = len(str);

        checkFromToIndex(fromIndex, toIndex, len);

        if (str == null) {
            return Strings.EMPTY;
        }

        if (fromIndex == 0 && toIndex == len) {
            return str;
        }

        return str.substring(fromIndex, toIndex);
    }

    /**
     * Returns a new string that is a substring of the specified string, with characters selected at intervals defined by the step parameter.
     * If step negative, the characters will be copied in reverse order.
     *
     * @param str the original string from which a range is to be copied
     * @param fromIndex the beginning index, inclusive
     * @param toIndex the ending index, exclusive
     * @param step the interval between characters to be copied
     * @return the specified substring
     * @throws IndexOutOfBoundsException if the <i>fromIndex</i> is negative, <i>toIndex</i> is greater than the length of the string, or <i>fromIndex</i> is greater than <i>toIndex</i>
     * @throws IllegalArgumentException  if step is zero
     * @see #copyOfRange(int[], int, int, int)
     */
    @SuppressWarnings("deprecation")
    public static String copyOfRange(final String str, final int fromIndex, final int toIndex, final int step) throws IndexOutOfBoundsException {
        final int len = len(str);

        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), len);

        if (step == 0) {
            throw new IllegalArgumentException("The input parameter 'step' cannot be zero");
        }

        if (str == null) {
            return Strings.EMPTY;
        }

        if (fromIndex == toIndex || fromIndex < toIndex != step > 0) {
            return Strings.EMPTY;
        }

        if (step == 1) {
            return copyOfRange(str, fromIndex, toIndex);
        }

        return String.valueOf(copyOfRange(InternalUtil.getCharsForReadOnly(str), fromIndex, toIndex, step));
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static boolean[] clone(final boolean[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static char[] clone(final char[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static byte[] clone(final byte[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static short[] clone(final short[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static int[] clone(final int[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static long[] clone(final long[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static float[] clone(final float[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static double[] clone(final double[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Returns a new array that is a clone of the specified array, or {@code null} if the original array is {@code null}.
     *
     * @param <T> the type of the array elements
     * @param original the array to be cloned
     * @return a clone of the original array, or {@code null} if the original array is null
     */
    @MayReturnNull
    public static <T> T[] clone(final T[] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        return original.clone();
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(boolean[])
     */
    @MayReturnNull
    public static boolean[][] clone(final boolean[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final boolean[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(char[])
     */
    @MayReturnNull
    public static char[][] clone(final char[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final char[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(byte[])
     */
    @MayReturnNull
    public static byte[][] clone(final byte[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final byte[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(short[])
     */
    @MayReturnNull
    public static short[][] clone(final short[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final short[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(int[])
     */
    @MayReturnNull
    public static int[][] clone(final int[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final int[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(long[])
     */
    @MayReturnNull
    public static long[][] clone(final long[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final long[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(float[])
     */
    @MayReturnNull
    public static float[][] clone(final float[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final float[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(double[])
     */
    @MayReturnNull
    public static double[][] clone(final double[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final double[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param <T> the type of the array elements
     * @param original the two-dimensional array to be cloned
     * @return a clone of the original two-dimensional array, or {@code null} if the original array is null
     * @see #clone(Object[])
     */
    @MayReturnNull
    public static <T> T[][] clone(final T[][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final T[][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(boolean[])
     * @see #clone(boolean[][])
     */
    @MayReturnNull
    public static boolean[][][] clone(final boolean[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final boolean[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(char[])
     * @see #clone(char[][])
     */
    @MayReturnNull
    public static char[][][] clone(final char[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final char[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(byte[])
     * @see #clone(byte[][])
     */
    @MayReturnNull
    public static byte[][][] clone(final byte[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final byte[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(short[])
     * @see #clone(short[][])
     */
    @MayReturnNull
    public static short[][][] clone(final short[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final short[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(int[])
     * @see #clone(int[][])
     */
    @MayReturnNull
    public static int[][][] clone(final int[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final int[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(long[])
     * @see #clone(long[][])
     */
    @MayReturnNull
    public static long[][][] clone(final long[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final long[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(float[])
     * @see #clone(float[][])
     */
    @MayReturnNull
    public static float[][][] clone(final float[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final float[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(double[])
     * @see #clone(double[][])
     */
    @MayReturnNull
    public static double[][][] clone(final double[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final double[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    /**
     * Clone the original array and its sub arrays. {@code null} is returned if the input array is {@code null}.
     *
     * @param <T> the type of the array elements
     * @param original the three-dimensional array to be cloned
     * @return a clone of the original three-dimensional array, or {@code null} if the original array is null
     * @see #clone(Object[])
     * @see #clone(Object[][])
     */
    @MayReturnNull
    public static <T> T[][][] clone(final T[][][] original) {
        if (original == null) {
            return null; // NOSONAR
        }

        final T[][][] cp = original.clone();

        for (int i = 0, len = cp.length; i < len; i++) {
            cp[i] = clone(original[i]);
        }

        return cp;
    }

    // ================================ copy/copyOf/copyOfRange/clone... ================================================

    // ================================ isSorted/sort/sortBy/parallelSort/reverseSort/binarySearch/Index... =============

    /**
     * Checks if the specified boolean array is sorted in ascending order.
     *
     * @param a the boolean array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final boolean[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (Boolean.compare(a[len - 1], a[0]) < 0) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (Boolean.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the boolean array is sorted in ascending order.
     *
     * @param a the boolean array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (Boolean.compare(a[toIndex - 1], a[fromIndex]) < 0) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Boolean.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified char array is sorted in ascending order.
     *
     * @param a the char array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final char[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (a[len - 1] < a[0]) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the char array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (a[toIndex - 1] < a[fromIndex]) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified byte array is sorted in ascending order.
     *
     * @param a the byte array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final byte[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (a[len - 1] < a[0]) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the byte array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (a[toIndex - 1] < a[fromIndex]) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified short array is sorted in ascending order.
     *
     * @param a the short array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final short[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (a[len - 1] < a[0]) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the short array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (a[toIndex - 1] < a[fromIndex]) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified integer array is sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] sorted = {1, 2, 3, 4, 5};
     * boolean result1 = isSorted(sorted);   // Returns true
     *
     * int[] unsorted = {1, 3, 2, 4, 5};
     * boolean result2 = isSorted(unsorted);   // Returns false
     *
     * int[] empty = {};
     * boolean result3 = isSorted(empty);   // Returns true
     * }</pre>
     *
     * @param a the integer array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final int[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (a[len - 1] < a[0]) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the integer array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (a[toIndex - 1] < a[fromIndex]) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified long array is sorted in ascending order.
     *
     * @param a the long array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final long[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (a[len - 1] < a[0]) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the long array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (a[toIndex - 1] < a[fromIndex]) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < a[i - 1]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified float array is sorted in ascending order.
     *
     * @param a the float array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final float[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (Float.compare(a[len - 1], a[0]) < 0) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (Float.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the float array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (Float.compare(a[toIndex - 1], a[fromIndex]) < 0) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Float.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified double array is sorted in ascending order.
     *
     * @param a the double array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     */
    public static boolean isSorted(final double[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (Double.compare(a[len - 1], a[0]) < 0) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (Double.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the double array is sorted in ascending order.
     *
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static boolean isSorted(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (Double.compare(a[toIndex - 1], a[fromIndex]) < 0) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Double.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified array is sorted in ascending order (where {@code null} is smallest).
     *
     * @param <T> the type of elements in the array, which must be Comparable
     * @param a the array to be checked
     * @return {@code true} if the array is sorted in ascending order, {@code false} otherwise
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> boolean isSorted(final T[] a) {
        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (compare(a[len - 1], a[0]) < 0) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the array is sorted in ascending order (where {@code null} is smallest).
     *
     * @param <T> the type of elements in the array, which must be Comparable
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the array is sorted in ascending order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> boolean isSorted(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (compare(a[toIndex - 1], a[fromIndex]) < 0) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the array is sorted according to the order induced by the specified comparator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"apple", "banana", "cherry", "date"};
     * boolean result1 = isSorted(array, Comparator.naturalOrder());   // Returns true
     *
     * String[] array2 = {"apple", "cherry", "banana"};
     * boolean result2 = isSorted(array2, Comparator.naturalOrder());   // Returns false
     *
     * String[] byLength = {"a", "bb", "ccc", "dddd"};
     * boolean result3 = isSorted(byLength, Comparator.comparing(String::length));   // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to be checked
     * @param cmp the comparator to determine the order of the array
     * @return {@code true} if the array is sorted according to the specified comparator, {@code false} otherwise
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> boolean isSorted(final T[] a, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        final int len = len(a);

        if (len < 2) {
            return true;
        } else if (cmp.compare(a[len - 1], a[0]) < 0) {
            return false;
        }

        for (int i = 1; i < len; i++) {
            if (cmp.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the specified range of the array is sorted according to the order induced by the specified comparator.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @param cmp the comparator to determine the order of the array
     * @return {@code true} if the specified range of the array is sorted according to the specified comparator, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> boolean isSorted(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a));

        cmp = checkComparator(cmp);

        if (toIndex - fromIndex < 2) {
            return true;
        } else if (cmp.compare(a[toIndex - 1], a[fromIndex]) < 0) {
            return false;
        }

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (cmp.compare(a[i], a[i - 1]) < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the collection is sorted in ascending order (where {@code null} is smallest).
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to be checked
     * @return {@code true} if the collection is sorted in natural order, {@code false} otherwise
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> boolean isSorted(final Collection<? extends T> c) {
        if (size(c) < 2) {
            return true;
        }

        final Iterator<? extends T> iter = c.iterator();
        T prev = iter.next();
        T cur = null;

        while (iter.hasNext()) {
            cur = iter.next();

            if (compare(cur, prev) < 0) {
                return false;
            }

            prev = cur;
        }

        return true;
    }

    /**
     * Checks if the specified range of the collection is sorted in ascending order (where {@code null} is smallest).
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @return {@code true} if the specified range of the collection is sorted in natural order, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> boolean isSorted(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (toIndex - fromIndex < 2) {
            return true;
        }

        final Iterator<? extends T> iter = c.iterator();
        int cursor = 0;

        while (cursor < fromIndex) {
            iter.next();
            cursor++;
        }

        cursor++;
        T prev = iter.next();
        T cur = null;

        while (cursor < toIndex) {
            cur = iter.next();

            if (compare(cur, prev) < 0) {
                return false;
            }

            prev = cur;
            cursor++;
        }

        return true;
    }

    /**
     * Checks if the collection is sorted according to the order induced by the specified comparator.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to be checked
     * @param cmp the comparator to determine the order of the collection
     * @return {@code true} if the collection is sorted according to the specified comparator, {@code false} otherwise
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> boolean isSorted(final Collection<? extends T> c, Comparator<? super T> cmp) {
        if (size(c) < 2) {
            return true;
        }

        cmp = checkComparator(cmp);

        final Iterator<? extends T> iter = c.iterator();
        T prev = iter.next();
        T cur = null;

        while (iter.hasNext()) {
            cur = iter.next();

            if (cmp.compare(cur, prev) < 0) {
                return false;
            }

            prev = cur;
        }

        return true;
    }

    /**
     * Checks if the specified range of the collection is sorted according to the order induced by the specified comparator.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to be checked
     * @param fromIndex the starting index (inclusive) of the range to be checked
     * @param toIndex the ending index (exclusive) of the range to be checked
     * @param cmp the comparator to determine the order of the collection
     * @return {@code true} if the specified range of the collection is sorted according to the specified comparator, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> boolean isSorted(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (toIndex - fromIndex < 2) {
            return true;
        }

        cmp = checkComparator(cmp);

        final Iterator<? extends T> iter = c.iterator();
        int cursor = 0;

        while (cursor < fromIndex) {
            iter.next();
            cursor++;
        }

        cursor++;
        T prev = iter.next();
        T cur = null;

        while (cursor < toIndex) {
            cur = iter.next();

            if (cmp.compare(cur, prev) < 0) {
                return false;
            }

            prev = cur;
            cursor++;
        }

        return true;
    }

    /**
     * Sorts the specified array of booleans into ascending order. {@code false} is considered less than {@code true}.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This operation runs in O(n) time where n is the array length.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {true, false, true, false, false};
     * sort(array);
     * // Result: array = {false, false, false, true, true}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void sort(final boolean[] a) {
        if (isEmpty(a)) {
            return;
        }

        sort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending order. {@code false} is considered less than {@code true}.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        int numOfFalse = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (!a[i]) {
                numOfFalse++;
            }
        }

        fill(a, fromIndex, fromIndex + numOfFalse, false);
        fill(a, fromIndex + numOfFalse, toIndex, true);
    }

    /**
     * Sorts the specified array of characters into ascending order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(char[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] array = {'d', 'a', 'c', 'b'};
     * sort(array);
     * // Result: array = {'a', 'b', 'c', 'd'}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void sort(final char[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(byte[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * @param a the array to be sorted
     */
    public static void sort(final byte[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of shorts into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(short[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] array = {30, 10, 50, 20, 40};
     * sort(array);
     * // Result: array = {10, 20, 30, 40, 50}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void sort(final short[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(int[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * @param a the array to be sorted
     */
    public static void sort(final int[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of longs into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(long[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] array = {300L, 100L, 500L, 200L, 400L};
     * sort(array);
     * // Result: array = {100L, 200L, 300L, 400L, 500L}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void sort(final long[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of floats into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(float[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] array = {3.5f, 1.2f, 5.8f, 2.1f, 4.3f};
     * sort(array);
     * // Result: array = {1.2f, 2.1f, 3.5f, 4.3f, 5.8f}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void sort(final float[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array into ascending numerical order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method uses a dual-pivot Quicksort via {@link Arrays#sort(double[])},
     * which offers O(n log n) performance on most data sets.</p>
     *
     * @param a the array to be sorted
     */
    public static void sort(final double[] a) {
        if (isEmpty(a)) {
            return;
        }

        Arrays.sort(a);
    }

    /**
     * Sorts the specified range of the array into ascending order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void sort(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array according to the natural ordering (where {@code null} is smallest).
     *
     * @param a the array to be sorted
     * @throws ClassCastException if the array contains elements that are not mutually comparable
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static void sort(final Object[] a) {
        if (isEmpty(a)) {
            return;
        }

        sort(a, NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified range of the specified array according to the natural ordering (where {@code null} is smallest).
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static void sort(final Object[] a, final int fromIndex, final int toIndex) {
        sort(a, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified array according to the order induced by the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param a the array to be sorted
     * @param cmp the comparator to determine the order of the array. A {@code null} value indicates that the elements' natural ordering should be used.
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void sort(final T[] a, final Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return;
        }

        sort(a, 0, a.length, cmp);
    }

    /**
     * Sorts the specified range of the specified array according to the order induced by the specified comparator.
     *
     * @param <T> the type of the objects being compared
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the array. A {@code null} value indicates that the elements' natural ordering should be used.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void sort(final T[] a, final int fromIndex, final int toIndex, final Comparator<? super T> cmp) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        Arrays.sort(a, fromIndex, toIndex, cmp);
    }

    /**
     * Sorts the specified list according to the natural ordering (where {@code null} is smallest).
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void sort(final List<? extends T> list) {
        if (isEmpty(list)) {
            return;
        }

        sort(list, 0, list.size(), NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified range of the specified list according to the natural ordering (where {@code null} is smallest).
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void sort(final List<? extends T> list, final int fromIndex, final int toIndex) {
        if (isEmpty(list)) {
            return;
        }

        sort(list, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified list according to the order induced by the specified comparator.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param cmp the comparator to determine the order of the list. A {@code null} value indicates that the elements' natural ordering should be used
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void sort(final List<? extends T> list, final Comparator<? super T> cmp) {
        if (isEmpty(list)) {
            return;
        }

        sort(list, 0, list.size(), cmp);
    }

    /**
     * Sorts the specified range of the list according to the order induced by the specified comparator.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the list. A {@code null} value indicates that the elements' natural ordering should be used.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#sort(Object[])
     * @see Arrays#sort(Object[], Comparator)
     * @see Arrays#sort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void sort(final List<? extends T> list, final int fromIndex, final int toIndex, final Comparator<? super T> cmp) {
        checkFromToIndex(fromIndex, toIndex, size(list));

        if ((isEmpty(list) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        if (fromIndex == 0 && toIndex == list.size()) {
            list.sort(cmp);
            return;
        }

        @SuppressWarnings("deprecation")
        final T[] a = (T[]) InternalUtil.getInternalArray(list);

        if (a != null) {
            sort(a, fromIndex, toIndex, cmp);

            return;
        }

        final T[] array = (T[]) list.toArray();
        Arrays.sort(array, fromIndex, toIndex, cmp);
        final ListIterator<T> i = (ListIterator<T>) list.listIterator();

        for (final T element : array) {
            i.next();
            i.set(element);
        }
    }

    /**
     * Sorts the specified array based on the keys extracted by the provided {@code Function}.
     * <p>This method modifies the original array in-place using the natural ordering of the extracted keys.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person[] people = {new Person("Bob", 30), new Person("Alice", 25), new Person("Charlie", 35)};
     * sortBy(people, Person::getName);
     * // Result: sorted by name - Alice, Bob, Charlie
     *
     * sortBy(people, Person::getAge);
     * // Result: sorted by age - 25, 30, 35
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of the key values, which must be comparable
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the key values from the array elements
     * @see Comparators#comparingBy(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsFirst(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsLast(Function)
     */
    public static <T, U extends Comparable<? super U>> void sortBy(final T[] a, final Function<? super T, ? extends U> keyExtractor) {
        sort(a, Comparators.comparingBy(keyExtractor));
    }

    /**
     * Sorts the specified list based on the keys extracted by the provided {@code Function}.
     *
     * @param <T> the type of elements in the list
     * @param <U> the type of the key values, which must be comparable
     * @param list the List to be sorted
     * @param keyExtractor the function to extract the key values from the list elements
     * @see Comparators#comparingBy(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsFirst(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsLast(Function)
     */
    public static <T, U extends Comparable<? super U>> void sortBy(final List<? extends T> list, final Function<? super T, ? extends U> keyExtractor) {
        sort(list, Comparators.comparingBy(keyExtractor));
    }

    /**
     * Sorts the specified array into ascending numerical order based on the keys extracted by the provided {@code ToIntFunction}.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the key values from the array elements
     */
    public static <T> void sortByInt(final T[] a, final ToIntFunction<? super T> keyExtractor) {
        sort(a, Comparators.comparingInt(keyExtractor));
    }

    /**
     * Sorts the specified list into ascending numerical order based on the keys extracted by the provided {@code ToIntFunction}.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the key values from the list elements
     */
    public static <T> void sortByInt(final List<? extends T> list, final ToIntFunction<? super T> keyExtractor) {
        sort(list, Comparators.comparingInt(keyExtractor));
    }

    /**
     * Sorts the specified array into ascending numerical order based on the keys extracted by the provided {@code ToLongFunction}.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the key values from the array elements
     */
    public static <T> void sortByLong(final T[] a, final ToLongFunction<? super T> keyExtractor) {
        sort(a, Comparators.comparingLong(keyExtractor));
    }

    /**
     * Sorts the specified list into ascending numerical order based on the keys extracted by the provided {@code ToLongFunction}.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the key values from the list elements
     */
    public static <T> void sortByLong(final List<? extends T> list, final ToLongFunction<? super T> keyExtractor) {
        sort(list, Comparators.comparingLong(keyExtractor));
    }

    /**
     * Sorts the specified array into ascending numerical order based on the keys extracted by the provided {@code ToFloatFunction}.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the key values from the array elements
     */
    public static <T> void sortByFloat(final T[] a, final ToFloatFunction<? super T> keyExtractor) {
        sort(a, Comparators.comparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified list into ascending numerical order based on the keys extracted by the provided {@code ToFloatFunction}.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the key values from the list elements
     */
    public static <T> void sortByFloat(final List<? extends T> list, final ToFloatFunction<? super T> keyExtractor) {
        sort(list, Comparators.comparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified array into ascending numerical order based on the keys extracted by the provided {@code ToDoubleFunction}.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the key values from the array elements
     */
    public static <T> void sortByDouble(final T[] a, final ToDoubleFunction<? super T> keyExtractor) {
        sort(a, Comparators.comparingDouble(keyExtractor));
    }

    /**
     * Sorts the specified list into ascending numerical order based on the keys extracted by the provided {@code ToDoubleFunction}.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the key values from the list elements
     */
    public static <T> void sortByDouble(final List<? extends T> list, final ToDoubleFunction<? super T> keyExtractor) {
        sort(list, Comparators.comparingDouble(keyExtractor));
    }

    /*
     * Tested by ArrayUtilTest.test_parallel_sort_perf
    @Test
    public void test_parallel_sort_perf() {
        final int arrayLength = 3000;
        final int loopNum = 100000;
        {
            final int[] a = Array.random(arrayLength);
            Profiler.run(1, loopNum, 3, "Arrays.sort(int[])", () -> Arrays.sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "sort(int[])", () -> sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "Arrays.parallelSort(int[])", () -> Arrays.parallelSort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "parallelSort(int[])", () -> parallelSort(a.clone())).printResult();
        }
    
        {
            final long[] a = LongList.random(arrayLength).toArray();
            Profiler.run(1, loopNum, 3, "Arrays.sort(long[])", () -> Arrays.sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "sort(long[])", () -> sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "Arrays.parallelSort(long[])", () -> Arrays.parallelSort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "parallelSort(long[])", () -> parallelSort(a.clone())).printResult();
        }
    
        {
            final double[] a = DoubleList.random(arrayLength).toArray();
            Profiler.run(1, loopNum, 3, "Arrays.sort(double[])", () -> Arrays.sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "sort(double[])", () -> sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "Arrays.parallelSort(double[])", () -> Arrays.parallelSort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "parallelSort(double[])", () -> parallelSort(a.clone())).printResult();
        }
    
        {
            final String[] a = new String[2000];
            for (int i = 0; i < a.length; i++) {
                a[i] = Strings.uuid();
            }
    
            Profiler.run(1, loopNum, 3, "Arrays.sort(Object[])", () -> Arrays.sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "sort(Object[])", () -> sort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "Arrays.parallelSort(Object[])", () -> Arrays.parallelSort(a.clone())).printResult();
            Profiler.run(1, loopNum, 3, "parallelSort(Object[])", () -> parallelSort(a.clone())).printResult();
        }
    }
     */
    private static final int PARALLEL_SORT_PRIMITIVE_THRESHOLD = 3000;
    private static final int PARALLEL_SORT_OBJECT_THRESHOLD = 2000;

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting using {@link Arrays#sort(char[])}.
     * Otherwise, it uses {@link Arrays#parallelSort(char[])} for parallel execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] largeArray = new char[10000];
     * // ... populate array ...
     * parallelSort(largeArray);   // Uses multiple threads for better performance
     * // Result: array sorted in ascending order using parallel processing
     *
     * char[] smallArray = {'z', 'a', 'm', 'b'};
     * parallelSort(smallArray);   // Uses single-threaded sort (array too small)
     * // Result: smallArray = {'a', 'b', 'm', 'z'}
     * }</pre>
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(char[])
     * @see Arrays#parallelSort(char[], int, int)
     * @see #parallelSort(char[], int, int)
     */
    public static void parallelSort(final char[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(char[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(char[], int, int)} for parallel execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] array = {'z', 'y', 'x', 'w', 'v', 'u', 't', 's'};
     *
     * // Sort a range from index 2 to 6 (exclusive)
     * parallelSort(array, 2, 6);
     * // Result: array = {'z', 'y', 'v', 'w', 'x', 'u', 't', 's'}
     * //                              ^^^^^^^^^ sorted range
     *
     * // Sort the entire array except first and last element
     * parallelSort(array, 1, array.length - 1);
     * }</pre>
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(char[])
     * @see Arrays#parallelSort(char[], int, int)
     * @see #parallelSort(char[])
     */
    public static void parallelSort(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(byte[])} for parallel execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] largeArray = new byte[10000];
     * // ... populate array ...
     * parallelSort(largeArray);   // Uses multiple threads for better performance
     * }</pre>
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(byte[])
     * @see Arrays#parallelSort(byte[], int, int)
     * @see #parallelSort(byte[], int, int)
     */
    public static void parallelSort(final byte[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(byte[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(byte[], int, int)} for parallel execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] array = {30, 10, 50, 20, 40, 15, 25, 35};
     *
     * // Sort a range from index 2 to 6 (exclusive)
     * parallelSort(array, 2, 6);
     * // Result: array = {30, 10, 20, 40, 50, 15, 25, 35}
     * }</pre>
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(byte[])
     * @see Arrays#parallelSort(byte[], int, int)
     * @see #parallelSort(byte[])
     */
    public static void parallelSort(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(short[])} for parallel execution.
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(short[])
     * @see Arrays#parallelSort(short[], int, int)
     * @see #parallelSort(short[], int, int)
     */
    public static void parallelSort(final short[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(short[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(short[], int, int)} for parallel execution.
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(short[])
     * @see Arrays#parallelSort(short[], int, int)
     * @see #parallelSort(short[])
     */
    public static void parallelSort(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(int[])} for parallel execution.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] largeArray = new int[10000];
     * // ... populate array ...
     * parallelSort(largeArray);   // Uses multiple threads for better performance
     * // Result: array sorted in ascending order using parallel processing
     * }</pre>
     *
     * @param a the array to be sorted
     * @see Arrays#parallelSort(int[])
     * @see Arrays#parallelSort(int[], int, int)
     */
    public static void parallelSort(final int[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IndexOutOfBoundsException if the fromIndex or toIndex is out of range
     * @see Arrays#parallelSort(int[])
     * @see Arrays#parallelSort(int[], int, int)
     */
    public static void parallelSort(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(long[])} for parallel execution.
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(long[])
     * @see Arrays#parallelSort(long[], int, int)
     * @see #parallelSort(long[], int, int)
     */
    public static void parallelSort(final long[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(long[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(long[], int, int)} for parallel execution.
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(long[])
     * @see Arrays#parallelSort(long[], int, int)
     * @see #parallelSort(long[])
     */
    public static void parallelSort(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(float[])} for parallel execution.
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(float[])
     * @see Arrays#parallelSort(float[], int, int)
     * @see #parallelSort(float[], int, int)
     */
    public static void parallelSort(final float[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(float[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(float[], int, int)} for parallel execution.
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(float[])
     * @see Arrays#parallelSort(float[], int, int)
     * @see #parallelSort(float[])
     */
    public static void parallelSort(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts the entire array by dividing the work across available
     * CPU cores when the array size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller arrays or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Implementation Note:</b> For arrays smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method falls back to single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(double[])} for parallel execution.
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @see Arrays#parallelSort(double[])
     * @see Arrays#parallelSort(double[], int, int)
     * @see #parallelSort(double[], int, int)
     */
    public static void parallelSort(final double[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array into ascending numerical order using multiple threads.
     * <p>This method efficiently sorts a portion of the array by dividing the work across available
     * CPU cores when the range size exceeds the parallel sort threshold (3000 elements) and multiple
     * cores are available. For smaller ranges or single-core systems, it falls back to standard
     * single-threaded sorting for optimal performance.
     *
     * <p>The array is sorted in place, modifying the original array. The range to be sorted is
     * half-open: {@code [fromIndex, toIndex)}, meaning it includes the element at {@code fromIndex}
     * but excludes the element at {@code toIndex}.
     *
     * <p><b>Implementation Note:</b> For ranges smaller than {@code PARALLEL_SORT_PRIMITIVE_THRESHOLD} (3000 elements),
     * or when only one CPU core is available, this method uses {@link Arrays#sort(double[], int, int)} for single-threaded sorting.
     * Otherwise, it uses {@link Arrays#parallelSort(double[], int, int)} for parallel execution.
     *
     * @param a the array to be sorted - may be {@code null} (in which case the method returns immediately)
     * @param fromIndex the index of the first element (inclusive) to be sorted - must be non-negative and not greater than {@code toIndex}
     * @param toIndex the index of the last element (exclusive) to be sorted - must be non-negative and not greater than {@code a.length}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > a.length}, or {@code fromIndex > toIndex}
     * @see Arrays#parallelSort(double[])
     * @see Arrays#parallelSort(double[], int, int)
     * @see #parallelSort(double[])
     */
    public static void parallelSort(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_PRIMITIVE_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex);
        }
    }

    /**
     * Sorts the specified array according to the natural ordering (where {@code null} is minimum) using multiple threads.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be sorted
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void parallelSort(final T[] a) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the specified array according to the natural ordering (where {@code null} is minimum) using multiple threads.
     *
     * @param <T> the type of the comparable array elements
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void parallelSort(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        parallelSort(a, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified array according to the order induced by the specified comparator using multiple threads.
     *
     * @param <T> the type of the objects being compared
     * @param a the array to be sorted
     * @param cmp the comparator to determine the order of the array. A {@code null} value indicates that the elements' natural ordering should be used.
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void parallelSort(final T[] a, final Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return;
        }

        parallelSort(a, 0, a.length, cmp);
    }

    /**
     * Sorts the specified range of the specified array according to the order induced by the specified comparator using multiple threads.
     *
     * @param <T> the type of the objects being compared
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the array. A {@code null} value indicates that the elements' natural ordering should be used.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void parallelSort(final T[] a, final int fromIndex, final int toIndex, final Comparator<? super T> cmp) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (toIndex - fromIndex <= PARALLEL_SORT_OBJECT_THRESHOLD || IOUtil.CPU_CORES == 1) {
            Arrays.sort(a, fromIndex, toIndex, cmp);
        } else {
            Arrays.parallelSort(a, fromIndex, toIndex, cmp);
        }
    }

    /**
     * Sorts the specified list according to the natural ordering (where {@code null} is minimum) using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void parallelSort(final List<? extends T> list) {
        if (isEmpty(list)) {
            return;
        }

        parallelSort(list, 0, list.size());
    }

    /**
     * Sorts the specified range of the specified list according to the natural ordering (where {@code null} is minimum) using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T extends Comparable<? super T>> void parallelSort(final List<? extends T> list, final int fromIndex, final int toIndex) {
        parallelSort(list, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Sorts the specified list according to the order induced by the specified comparator using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param cmp the comparator to determine the order of the list. A {@code null} value indicates that the elements' natural ordering should be used
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void parallelSort(final List<? extends T> list, final Comparator<? super T> cmp) {
        if (isEmpty(list)) {
            return;
        }

        parallelSort(list, 0, list.size(), cmp);
    }

    /**
     * Sorts the specified range of the list according to the order induced by the specified comparator using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the list. A {@code null} value indicates that the elements' natural ordering should be used.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @see Arrays#parallelSort(Comparable[])
     * @see Arrays#parallelSort(Object[], Comparator)
     * @see Arrays#parallelSort(Object[], int, int, Comparator)
     * @see Comparators#naturalOrder()
     * @see Comparators#nullsFirst()
     * @see Comparators#nullsLast()
     * @see Comparators#comparingBy(Function)
     */
    public static <T> void parallelSort(final List<? extends T> list, final int fromIndex, final int toIndex, final Comparator<? super T> cmp) {
        checkFromToIndex(fromIndex, toIndex, size(list));

        if ((isEmpty(list) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        if ((fromIndex == 0 && toIndex == list.size()) && (toIndex - fromIndex <= PARALLEL_SORT_OBJECT_THRESHOLD || IOUtil.CPU_CORES == 1)) {
            list.sort(cmp);
        } else {
            @SuppressWarnings("deprecation")
            final T[] a = (T[]) InternalUtil.getInternalArray(list);

            if (a != null) {
                parallelSort(a, fromIndex, toIndex, cmp);

                return;
            }

            final T[] array = (T[]) list.toArray();

            parallelSort(array, fromIndex, toIndex, cmp);

            final ListIterator<T> it = (ListIterator<T>) list.listIterator();

            for (final T element : array) {
                it.next();

                it.set(element);
            }
        }
    }

    /**
     * Sorts the specified array based on the comparable keys extracted by the provided {@code Function} using multiple threads.
     * <p>This method provides a convenient way to sort an array of objects based on a property or derived value,
     * without having to manually create a comparator. The {@code keyExtractor} function is applied to each element
     * to obtain a comparable key, and elements are sorted in ascending order of these keys.
     *
     * <p>The array is sorted in place, modifying the original array. This method uses parallel sorting when
     * beneficial (large arrays on multi-core systems).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Person {
     *     String name;
     *     int age;
     *     Person(String name, int age) { this.name = name; this.age = age; }
     *     String getName() { return name; }
     *     int getAge() { return age; }
     * }
     *
     * Person[] people = {
     *     new Person("Alice", 30),
     *     new Person("Bob", 25),
     *     new Person("Charlie", 35)
     * };
     *
     * // Sort by name (alphabetically)
     * parallelSortBy(people, Person::getName);
     * // Result: [Alice, Bob, Charlie]
     *
     * // Sort by age (numerically)
     * parallelSortBy(people, p -> p.getAge());
     * // Result: [Bob(25), Alice(30), Charlie(35)]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param <U> the type of the comparable keys extracted by the key extractor function
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @param keyExtractor the function used to extract comparable keys from elements for comparison - must not be {@code null}
     * @see Comparators#comparingBy(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsFirst(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsLast(Function)
     * @see #parallelSort(Object[], Comparator)
     */
    public static <T, U extends Comparable<? super U>> void parallelSortBy(final T[] a, final Function<? super T, ? extends U> keyExtractor) {
        parallelSort(a, Comparators.comparingBy(keyExtractor));
    }

    /**
     * Sorts the specified list based on the comparable keys extracted by the provided {@code Function} using multiple threads.
     * <p>This method provides a convenient way to sort a list of objects based on a property or derived value,
     * without having to manually create a comparator. The {@code keyExtractor} function is applied to each element
     * to obtain a comparable key, and elements are sorted in ascending order of these keys.
     *
     * <p>The list is sorted in place, modifying the original list. This method uses parallel sorting when
     * beneficial (large lists on multi-core systems).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Employee {
     *     String name;
     *     double salary;
     *     Employee(String name, double salary) { this.name = name; this.salary = salary; }
     *     String getName() { return name; }
     *     double getSalary() { return salary; }
     * }
     *
     * List<Employee> employees = Arrays.asList(
     *     new Employee("Alice", 75000),
     *     new Employee("Bob", 60000),
     *     new Employee("Charlie", 85000)
     * );
     *
     * // Sort by name (alphabetically)
     * parallelSortBy(employees, Employee::getName);
     * // Result: [Alice, Bob, Charlie]
     *
     * // Sort by salary (numerically)
     * parallelSortBy(employees, e -> e.getSalary());
     * // Result: [Bob(60000), Alice(75000), Charlie(85000)]
     * }</pre>
     *
     * @param <T> the type of the elements in the list
     * @param <U> the type of the comparable keys extracted by the key extractor function
     * @param list the list to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @param keyExtractor the function used to extract comparable keys from elements for comparison - must not be {@code null}
     * @see Comparators#comparingBy(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsFirst(Function)
     * @see Comparators#comparingByIfNotNullOrElseNullsLast(Function)
     * @see #parallelSort(List, Comparator)
     */
    public static <T, U extends Comparable<? super U>> void parallelSortBy(final List<? extends T> list, final Function<? super T, ? extends U> keyExtractor) {
        parallelSort(list, Comparators.comparingBy(keyExtractor));
    }

    /**
     * Sorts the specified array based on the int values extracted by the provided {@code ToIntFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function used to extract the int key for comparison
     */
    public static <T> void parallelSortByInt(final T[] a, final ToIntFunction<? super T> keyExtractor) {
        parallelSort(a, Comparators.comparingInt(keyExtractor));
    }

    /**
     * Sorts the specified list based on the int values extracted by the provided {@code ToIntFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function used to extract the int key for comparison
     */
    public static <T> void parallelSortByInt(final List<? extends T> list, final ToIntFunction<? super T> keyExtractor) {
        parallelSort(list, Comparators.comparingInt(keyExtractor));
    }

    /**
     * Sorts the specified array based on the long values extracted by the provided {@code ToLongFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function used to extract the long key for comparison
     */
    public static <T> void parallelSortByLong(final T[] a, final ToLongFunction<? super T> keyExtractor) {
        parallelSort(a, Comparators.comparingLong(keyExtractor));
    }

    /**
     * Sorts the specified list based on the long values extracted by the provided {@code ToLongFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function used to extract the long key for comparison
     */
    public static <T> void parallelSortByLong(final List<? extends T> list, final ToLongFunction<? super T> keyExtractor) {
        parallelSort(list, Comparators.comparingLong(keyExtractor));
    }

    /**
     * Sorts the specified array based on the float values extracted by the provided {@code ToFloatFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function used to extract the float key for comparison
     */
    public static <T> void parallelSortByFloat(final T[] a, final ToFloatFunction<? super T> keyExtractor) {
        parallelSort(a, Comparators.comparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified list based on the float values extracted by the provided {@code ToFloatFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function used to extract the float key for comparison
     */
    public static <T> void parallelSortByFloat(final List<? extends T> list, final ToFloatFunction<? super T> keyExtractor) {
        parallelSort(list, Comparators.comparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified array based on the double values extracted by the provided {@code ToDoubleFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function used to extract the double key for comparison
     */
    public static <T> void parallelSortByDouble(final T[] a, final ToDoubleFunction<? super T> keyExtractor) {
        parallelSort(a, Comparators.comparingDouble(keyExtractor));
    }

    /**
     * Sorts the specified list based on the double values extracted by the provided {@code ToDoubleFunction} using multiple threads.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function used to extract the double key for comparison
     */
    public static <T> void parallelSortByDouble(final List<? extends T> list, final ToDoubleFunction<? super T> keyExtractor) {
        parallelSort(list, Comparators.comparingDouble(keyExtractor));
    }

    /**
     * Sorts the specified array of booleans in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final boolean[] a) {
        if (isEmpty(a)) {
            return;
        }

        reverseSort(a, 0, a.length);
    }

    /**
     * Sorts the specified range of the array of booleans in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     */
    public static void reverseSort(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (a == null || toIndex - fromIndex <= 1) {
            return;
        }

        int numOfTrue = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (a[i]) {
                numOfTrue++;
            }
        }

        fill(a, fromIndex, fromIndex + numOfTrue, true);
        fill(a, fromIndex + numOfTrue, toIndex, false);
    }

    /**
     * Sorts the specified array of characters in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final char[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of characters in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final char[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of bytes in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final byte[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of bytes in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final byte[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of shorts in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final short[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of shorts in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final short[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of ints in reverse (descending) order.
     * <p>This method modifies the original array in-place.
     * <p><b>Implementation Note:</b> This method first sorts the array in ascending order and then reverses it.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] array = {30, 10, 50, 20, 40};
     * reverseSort(array);
     * // Result: array = {50, 40, 30, 20, 10}
     * }</pre>
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final int[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of ints in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final int[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of longs in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final long[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of longs in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final long[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of floats in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final float[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of floats in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final float[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of doubles in reverse order.
     *
     * @param a the array to be sorted
     */
    public static void reverseSort(final double[] a) {
        sort(a);
        reverse(a);
    }

    /**
     * Sorts the specified range of the array of doubles in reverse order.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final double[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex);
        reverse(a, fromIndex, toIndex);
    }

    /**
     * Sorts the specified array of objects in reverse (descending) order.
     * <p>This method sorts the array in place in descending order, where the largest elements come first.
     * {@code null} values are treated as maximum and will appear at the end of the sorted array.
     *
     * <p>The elements must implement {@link Comparable}, or a {@link ClassCastException} will be thrown.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {30, 10, 50, 20, 40};
     * reverseSort(numbers);
     * // Result: numbers = {50, 40, 30, 20, 10}
     *
     * String[] words = {"apple", "cherry", "banana", null};
     * reverseSort(words);
     * // Result: words = {"cherry", "banana", "apple", null}  // null is maximum
     * }</pre>
     *
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @throws ClassCastException if the array contains elements that are not mutually comparable
     * @see #reverseSort(Object[], int, int)
     * @see #sort(Object[])
     */
    public static void reverseSort(final Object[] a) {
        sort(a, REVERSED_COMPARATOR);
    }

    /**
     * Sorts the specified range of the array of objects in reverse order. (where {@code null} is maximum)
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static void reverseSort(final Object[] a, final int fromIndex, final int toIndex) throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(a, fromIndex, toIndex, REVERSED_COMPARATOR);
    }

    /**
     * Sorts the specified list in reverse order. (where {@code null} is maximum)
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     */
    public static <T extends Comparable<? super T>> void reverseSort(final List<? extends T> list) {
        sort(list, REVERSED_COMPARATOR);
    }

    /**
     * Sorts the specified range of the list in reverse order. (where {@code null} is maximum)
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param fromIndex the index of the first element (inclusive) to be sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws ArrayIndexOutOfBoundsException if fromIndex or toIndex is out of range
     */
    public static <T extends Comparable<? super T>> void reverseSort(final List<? extends T> list, final int fromIndex, final int toIndex)
            throws ArrayIndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, list == null ? 0 : list.size());

        if (toIndex - fromIndex <= 1) {
            return;
        }

        sort(list, fromIndex, toIndex, REVERSED_COMPARATOR);
    }

    /**
     * Sorts the specified array in reverse (descending) order based on the comparable keys extracted by the provided {@code Function}.
     * <p>This method provides a convenient way to sort an array of objects in descending order based on a property or derived value.
     * The {@code keyExtractor} function is applied to each element to obtain a comparable key, and elements are sorted
     * in descending order of these keys (largest to smallest).
     *
     * <p>The array is sorted in place, modifying the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Student {
     *     String name;
     *     double gpa;
     *     Student(String name, double gpa) { this.name = name; this.gpa = gpa; }
     *     String getName() { return name; }
     *     double getGpa() { return gpa; }
     * }
     *
     * Student[] students = {
     *     new Student("Alice", 3.5),
     *     new Student("Bob", 3.9),
     *     new Student("Charlie", 3.7)
     * };
     *
     * // Sort by GPA in descending order (highest first)
     * reverseSortBy(students, Student::getGpa);
     * // Result: [Bob(3.9), Charlie(3.7), Alice(3.5)]
     *
     * // Sort by name in reverse alphabetical order
     * reverseSortBy(students, Student::getName);
     * // Result: [Charlie, Bob, Alice]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of comparable keys extracted from the elements
     * @param a the array to be sorted - if {@code null} or empty, the method returns immediately without effect
     * @param keyExtractor the function to extract comparable keys from the elements - must not be {@code null}
     * @see #reverseSortBy(List, Function)
     * @see #sortBy(Object[], Function)
     * @see Comparators#reversedComparingBy(Function)
     */
    public static <T, U extends Comparable<? super U>> void reverseSortBy(final T[] a, final Function<? super T, ? extends U> keyExtractor) {
        sort(a, Comparators.reversedComparingBy(keyExtractor));
    }

    /**
     * Sorts the specified list based on the keys extracted by the provided {@code Function} in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param <U> the type of keys extracted from the elements, which must be comparable
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the keys from the elements
     */
    public static <T, U extends Comparable<? super U>> void reverseSortBy(final List<? extends T> list, final Function<? super T, ? extends U> keyExtractor) {
        sort(list, Comparators.reversedComparingBy(keyExtractor));
    }

    /**
     * Sorts the specified array based on the int values extracted by the provided {@code ToIntFunction} in reverse order.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the int key from the elements
     */
    public static <T> void reverseSortByInt(final T[] a, final ToIntFunction<? super T> keyExtractor) {
        sort(a, Comparators.reversedComparingInt(keyExtractor));
    }

    /**
     * Sorts the specified list based on the int values extracted by the provided {@code ToIntFunction} in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the int key from the elements
     */
    public static <T> void reverseSortByInt(final List<? extends T> list, final ToIntFunction<? super T> keyExtractor) {
        sort(list, Comparators.reversedComparingInt(keyExtractor));
    }

    /**
     * Sorts the specified array based on the long values extracted by the provided {@code ToLongFunction} in reverse order.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the long key from the elements
     */
    public static <T> void reverseSortByLong(final T[] a, final ToLongFunction<? super T> keyExtractor) {
        sort(a, Comparators.reversedComparingLong(keyExtractor));
    }

    /**
     * Sorts the specified list based on the long values extracted by the provided {@code ToLongFunction} in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the long key from the elements
     */
    public static <T> void reverseSortByLong(final List<? extends T> list, final ToLongFunction<? super T> keyExtractor) {
        sort(list, Comparators.reversedComparingLong(keyExtractor));
    }

    /**
     * Sorts the specified array based on the float values extracted by the provided {@code ToFloatFunction} in reverse order.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the float key from the elements
     */
    public static <T> void reverseSortByFloat(final T[] a, final ToFloatFunction<? super T> keyExtractor) {
        sort(a, Comparators.reversedComparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified list based on the float values extracted by the provided {@code ToFloatFunction} in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the float key from the elements
     */
    public static <T> void reverseSortByFloat(final List<? extends T> list, final ToFloatFunction<? super T> keyExtractor) {
        sort(list, Comparators.reversedComparingFloat(keyExtractor));
    }

    /**
     * Sorts the specified array based on the double values extracted by the provided {@code ToDoubleFunction} in reverse order.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be sorted
     * @param keyExtractor the function to extract the double key from the elements
     */
    public static <T> void reverseSortByDouble(final T[] a, final ToDoubleFunction<? super T> keyExtractor) {
        sort(a, Comparators.reversedComparingDouble(keyExtractor));
    }

    /**
     * Sorts the specified list based on the double values extracted by the provided {@code ToDoubleFunction} in reverse order.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be sorted
     * @param keyExtractor the function to extract the double key from the elements
     */
    public static <T> void reverseSortByDouble(final List<? extends T> list, final ToDoubleFunction<? super T> keyExtractor) {
        sort(list, Comparators.reversedComparingDouble(keyExtractor));
    }

    /**
     * Performs a binary search on the specified array of booleans to find the specified value.
     * The array must be sorted (as by the {@link #sort(boolean[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     */
    static int binarySearch(final boolean[] a, final boolean valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        if (a[0] == valueToFind) {
            return 0;
        } else if (a[a.length - 1] != valueToFind) {
            return !valueToFind ? -1 : -(a.length + 1);
        }

        int left = 0, right = a.length - 1;
        while (left < right) {
            final int mid = left + (right - left) / 2;

            if (a[mid] == valueToFind) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }

    /**
     * Performs a binary search on the specified array of characters to find the specified value.
     * The array must be sorted (as by the {@link #sort(char[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] sortedArray = {'a', 'b', 'c', 'd', 'e'};
     * int index1 = binarySearch(sortedArray, 'c');   // Returns 2
     * int index2 = binarySearch(sortedArray, 'f');   // Returns negative insertion point
     * }</pre>
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(char[], char)
     */
    public static int binarySearch(final char[] a, final char valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of characters to find the specified value.
     * The range must be sorted (as by the {@link #sort(char[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(char[], int, int, char)
     */
    public static int binarySearch(final char[] a, final int fromIndex, final int toIndex, final char valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of bytes to find the specified value.
     * The array must be sorted (as by the {@link #sort(byte[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(byte[], byte)
     */
    public static int binarySearch(final byte[] a, final byte valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of bytes to find the specified value.
     * The range must be sorted (as by the {@link #sort(byte[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(byte[], int, int, byte)
     */
    public static int binarySearch(final byte[] a, final int fromIndex, final int toIndex, final byte valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of shorts to find the specified value.
     * The array must be sorted (as by the {@link #sort(short[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(short[], short)
     */
    public static int binarySearch(final short[] a, final short valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of shorts to find the specified value.
     * The range must be sorted (as by the {@link #sort(short[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(short[], int, int, short)
     */
    public static int binarySearch(final short[] a, final int fromIndex, final int toIndex, final short valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of ints to find the specified value.
     * The array must be sorted (as by the {@link #sort(int[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(int[], int)
     */
    public static int binarySearch(final int[] a, final int valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of ints to find the specified value.
     * The range must be sorted (as by the {@link #sort(int[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(int[], int, int, int)
     */
    public static int binarySearch(final int[] a, final int fromIndex, final int toIndex, final int valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of longs to find the specified value.
     * The array must be sorted (as by the {@link #sort(long[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(long[], long)
     */
    public static int binarySearch(final long[] a, final long valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of longs to find the specified value.
     * The range must be sorted (as by the {@link #sort(long[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(long[], int, int, long)
     */
    public static int binarySearch(final long[] a, final int fromIndex, final int toIndex, final long valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of floats to find the specified value.
     * The array must be sorted (as by the {@link #sort(float[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(float[], float)
     */
    public static int binarySearch(final float[] a, final float valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of floats to find the specified value.
     * The range must be sorted (as by the {@link #sort(float[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(float[], int, int, float)
     */
    public static int binarySearch(final float[] a, final int fromIndex, final int toIndex, final float valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of doubles to find the specified value.
     * The array must be sorted (as by the {@link #sort(double[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(double[], double)
     */
    public static int binarySearch(final double[] a, final double valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of doubles to find the specified value.
     * The range must be sorted (as by the {@link #sort(double[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(double[], int, int, double)
     */
    public static int binarySearch(final double[] a, final int fromIndex, final int toIndex, final double valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of objects to find the specified value.
     * The array must be sorted (as by the {@link #sort(Object[])} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(Object[], Object)
     */
    public static int binarySearch(final Object[] a, final Object valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the array of objects to find the specified value.
     * The range must be sorted (as by the {@link #sort(Object[], int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(Object[], int, int, Object)
     */
    public static int binarySearch(final Object[] a, final int fromIndex, final int toIndex, final Object valueToFind) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind);
    }

    /**
     * Performs a binary search on the specified array of objects to find the specified value.
     * The array must be sorted (as by the {@link #sort(Object[], Comparator)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @param cmp the comparator by which the array is ordered
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @see Arrays#binarySearch(Object[], Object, Comparator)
     */
    public static <T> int binarySearch(final T[] a, final T valueToFind, final Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, valueToFind, checkComparator(cmp));
    }

    /**
     * Performs a binary search on the specified range of the array of objects to find the specified value.
     * The range must be sorted (as by the {@link #sort(Object[], int, int, Comparator)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @param cmp the comparator by which the array is ordered
     * @return the index of the value to be searched, if it is contained in the array within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Arrays#binarySearch(Object[], int, int, Object, Comparator)
     */
    public static <T> int binarySearch(final T[] a, final int fromIndex, final int toIndex, final T valueToFind, final Comparator<? super T> cmp) {
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return Arrays.binarySearch(a, fromIndex, toIndex, valueToFind, checkComparator(cmp));
    }

    /**
     * Performs a binary search on the specified list of objects to find the specified value.
     * The list must be sorted (as by the {@link #sort(List)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the list contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @return the index of the value to be searched, if it is contained in the list within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the list is {@code null} or empty.
     * @see Collections#binarySearch(List, Object)
     */
    public static <T extends Comparable<? super T>> int binarySearch(final List<? extends T> list, final T valueToFind) {
        if (isEmpty(list)) {
            return INDEX_NOT_FOUND;
        }

        return Collections.binarySearch(list, valueToFind);
    }

    /**
     * Performs a binary search on the specified range of the list of objects to find the specified value.
     * The range must be sorted (as by the {@link #sort(List, int, int)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @return the index of the value to be searched, if it is contained in the list within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the list is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Collections#binarySearch(List, Object)
     */
    public static <T extends Comparable<? super T>> int binarySearch(final List<? extends T> list, final int fromIndex, final int toIndex,
            final T valueToFind) {
        checkFromToIndex(fromIndex, toIndex, size(list));

        if (isEmpty(list)) {
            return INDEX_NOT_FOUND;
        }

        return binarySearch(list, fromIndex, toIndex, valueToFind, NATURAL_COMPARATOR);
    }

    /**
     * Performs a binary search on the specified list of objects to find the specified value.
     * The list must be sorted (as by the {@link #sort(List, Comparator)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the list contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be searched. It must be sorted in ascending order
     * @param valueToFind the value to be searched for
     * @param cmp the comparator by which the list is ordered
     * @return the index of the value to be searched, if it is contained in the list within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the list is {@code null} or empty.
     * @see Collections#binarySearch(List, Object, Comparator)
     */
    public static <T> int binarySearch(final List<? extends T> list, final T valueToFind, final Comparator<? super T> cmp) {
        if (isEmpty(list)) {
            return INDEX_NOT_FOUND;
        }

        return Collections.binarySearch(list, valueToFind, checkComparator(cmp));
    }

    /**
     * Performs a binary search on the specified range of the list of objects to find the specified value.
     * The range must be sorted (as by the {@link #sort(List, int, int, Comparator)} method) before making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
     *
     * @param <T> the type of the elements in the list
     * @param list the list to be searched. It must be sorted in ascending order.
     * @param fromIndex the index of the first element (inclusive) to be searched.
     * @param toIndex the index of the last element (exclusive) to be searched.
     * @param valueToFind the value to be searched for.
     * @param cmp the comparator by which the list is ordered
     * @return the index of the value to be searched, if it is contained in the list within the specified range;
     *         otherwise, <code>(-(insertion point) - 1)</code>, or <code>-1</code> if the list is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of bounds.
     * @see Collections#binarySearch(List, Object, Comparator)
     */
    public static <T> int binarySearch(final List<? extends T> list, final int fromIndex, final int toIndex, final T valueToFind, Comparator<? super T> cmp) {
        checkFromToIndex(fromIndex, toIndex, size(list));

        if (isEmpty(list)) {
            return INDEX_NOT_FOUND;
        }

        cmp = checkComparator(cmp);

        if (fromIndex == 0 && toIndex == list.size()) {
            return Collections.binarySearch(list, valueToFind, cmp);
        }

        @SuppressWarnings("deprecation")
        final T[] a = (T[]) InternalUtil.getInternalArray(list);

        if (a != null) {
            return binarySearch(a, fromIndex, toIndex, valueToFind, cmp);
        }

        final int ret = Collections.binarySearch(list.subList(fromIndex, toIndex), valueToFind, cmp);

        return ret >= 0 ? ret + fromIndex : ret - fromIndex;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] array = {false, true, false, true, false};
     * int index1 = indexOf(array, true);    // Returns 1
     * int index2 = indexOf(array, false);   // Returns 0
     * }</pre>
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final boolean[] a, final boolean valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     * <p>A negative {@code fromIndex} is treated as zero. A {@code fromIndex} larger than the array
     * length will return {@code -1}.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final boolean[] a, final boolean valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final char[] a, final char valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final char[] a, final char valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final byte[] a, final byte valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final byte[] a, final byte valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final short[] a, final short valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final short[] a, final short valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final int[] a, final int valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final int[] a, final int valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final long[] a, final long valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final long[] a, final long valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final float[] a, final float valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final float[] a, final float valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (Float.compare(a[i], valueToFind) == 0) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final double[] a, final double valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final double[] a, final double valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (Double.compare(a[i], valueToFind) == 0) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * <p>Finds the index of the given value within a given tolerance in the array.
     * This method will return the index of the first value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.
     *
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.
     *
     * @param a the array to search through for the object, may be {@code null}
     * @param valueToFind the value to search for
     * @param tolerance tolerance of the search
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */
    public static int indexOf(final double[] a, final double valueToFind, final double tolerance) {
        return indexOf(a, valueToFind, tolerance, 0);
    }

    /**
     * <p>Finds the index of the given value in the array starting at the given index.
     * This method will return the index of the first value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.
     *
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.
     *
     * <p>A negative startIndex is treated as zero. A startIndex larger than the array
     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).
     *
     * @param a the array to search through for the object, may be {@code null}
     * @param valueToFind the value to search for
     * @param tolerance tolerance of the search
     * @param fromIndex the index to start searching at
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */
    public static int indexOf(final double[] a, final double valueToFind, final double tolerance, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (Numbers.fuzzyEquals(a[i], valueToFind, tolerance)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"apple", "banana", "cherry", "banana"};
     * int index1 = indexOf(array, "banana");   // Returns 1
     * int index2 = indexOf(array, "grape");    // Returns -1 (not found)
     * int index3 = indexOf(array, null);       // Returns -1 (or index if array contains null)
     * }</pre>
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final Object[] a, final Object valueToFind) {
        return indexOf(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the array, starting the search at the specified index.
     *
     * @param a the array to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the array,
     *         or -1 if the array is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final Object[] a, final Object valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (equals(a[i], valueToFind)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the specified collection.
     *
     * @param c the collection to be searched
     * @param valueToFind the value to be searched for
     * @return the index of the first occurrence of the specified value in the collection,
     *         or -1 if the collection is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final Collection<?> c, final Object valueToFind) {
        return indexOf(c, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the specified collection, starting the search at the specified index.
     *
     * @param c the collection to be searched
     * @param valueToFind the value to be searched for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified value in the collection,
     *         or -1 if the collection is {@code null} or empty or does not contain the value
     */
    public static int indexOf(final Collection<?> c, final Object valueToFind, final int fromIndex) {
        final int len = size(c);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        if (c instanceof final List<?> list && c instanceof RandomAccess) {
            for (int i = N.max(fromIndex, 0); i < len; i++) {
                if (equals(list.get(i), valueToFind)) {
                    return i;
                }
            }
        } else {
            final Iterator<?> iter = c.iterator();

            int index = 0;

            if (fromIndex > 0) {
                while (index < fromIndex && iter.hasNext()) {
                    iter.next();
                    index++;
                }
            }

            while (iter.hasNext()) {
                if (equals(iter.next(), valueToFind)) {
                    return index;
                }

                index++;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the first occurrence of the specified value in the given iterator.
     *
     * @param iter the iterator to be searched.
     * @param valueToFind the value to find in the iterator.
     * @return the index of the first occurrence of the specified value in the iterator, or -1 if the value is not found.
     * @throws ArithmeticException if the found {@code index} overflows an int.
     * @see Iterators#indexOf(Iterator, Object)
     */
    public static int indexOf(final Iterator<?> iter, final Object valueToFind) throws ArithmeticException {
        return indexOf(iter, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified value in the given iterator, starting the search from the specified index.
     *
     * @param iter the iterator to be searched.
     * @param valueToFind the value to find in the iterator.
     * @param fromIndex the index to start the search from.
     * @return the index of the first occurrence of the specified value in the iterator, or -1 if the value is not found.
     * @throws ArithmeticException if the found {@code index} overflows an int.
     * @see Iterators#indexOf(Iterator, Object, long)
     */
    public static int indexOf(final Iterator<?> iter, final Object valueToFind, final int fromIndex) throws ArithmeticException {
        if (iter == null) {
            return INDEX_NOT_FOUND;
        }

        return Numbers.toIntExact(Iterators.indexOf(iter, valueToFind, fromIndex));
    }

    /**
     * Returns the starting position of the first occurrence of the specified sublist within the source list.
     *
     * @param sourceList the list to search within
     * @param subListToFind the sublist to search for
     * @return the starting position of the first occurrence of the specified sublist, or -1 if there is no such occurrence
     * @see java.util.Collections#indexOfSubList(List, List)
     */
    public static int indexOfSubList(final List<?> sourceList, final List<?> subListToFind) {
        if (sourceList == null || subListToFind == null) {
            return INDEX_NOT_FOUND;
        }

        if (subListToFind.isEmpty()) {
            return 0;
        }

        if (sourceList.isEmpty()) {
            return INDEX_NOT_FOUND;
        }

        return Collections.indexOfSubList(sourceList, subListToFind);
    }

    /**
     * Returns the starting position of the first occurrence of the specified sublist within the source list, starting the search at the specified index.
     *
     * @param sourceList the list to search within
     * @param subListToFind the sublist to search for
     * @param fromIndex the index to start the search from
     * @return the starting position of the first occurrence of the specified sublist, or -1 if there is no such occurrence
     * @throws IndexOutOfBoundsException if the starting index is out of range
     * @see Index#ofSubList(List, int, List)
     */
    public static int indexOfSubList(final List<?> sourceList, final List<?> subListToFind, final int fromIndex) {
        return Index.ofSubList(sourceList, fromIndex, subListToFind).orElse(INDEX_NOT_FOUND);
    }

    /**
     * Returns the index of the first occurrence of the specified string in the array, ignoring case considerations.
     *
     * @param a the array to search within
     * @param valueToFind the string to search for
     * @return the index of the first occurrence of the specified string, or -1 if there is no such occurrence
     */
    public static int indexOfIgnoreCase(final String[] a, final String valueToFind) {
        return indexOfIgnoreCase(a, valueToFind, 0);
    }

    /**
     * Returns the index of the first occurrence of the specified string in the array, ignoring case considerations, starting the search at the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the string to search for
     * @param fromIndex the index to start the search from
     * @return the index of the first occurrence of the specified string, or -1 if there is no such occurrence
     */
    public static int indexOfIgnoreCase(final String[] a, final String valueToFind, final int fromIndex) {
        final int len = len(a);

        if (len == 0 || fromIndex >= len) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.max(fromIndex, 0); i < len; i++) {
            if (equalsIgnoreCase(a[i], valueToFind)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final boolean[] a, final boolean valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     * <p>A negative {@code startIndexFromBack} will return {@code -1}.
     * A {@code startIndexFromBack} larger than the array length will search from the end of the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final boolean[] a, final boolean valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final char[] a, final char valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final char[] a, final char valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final byte[] a, final byte valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);

    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final byte[] a, final byte valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final short[] a, final short valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final short[] a, final short valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final int[] a, final int valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final int[] a, final int valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final long[] a, final long valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final long[] a, final long valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (a[i] == valueToFind) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final float[] a, final float valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final float[] a, final float valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (Float.compare(a[i], valueToFind) == 0) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final double[] a, final double valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final double[] a, final double valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (Double.compare(a[i], valueToFind) == 0) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * <p>Finds the last index of the given value within a given tolerance in the array.
     * This method will return the index of the last value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.
     *
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.
     *
     * @param a the array to search through for the object, may be {@code null}
     * @param valueToFind the value to search for
     * @param tolerance tolerance of the search
     * @return the index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */
    public static int lastIndexOf(final double[] a, final double valueToFind, final double tolerance) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, tolerance, a.length - 1);
    }

    /**
     * <p>Finds the last index of the given value in the array starting at the given index.
     * This method will return the index of the last value which falls between the region
     * defined by valueToFind - tolerance and valueToFind + tolerance.
     *
     * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.
     *
     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} ({@code -1}). A startIndex larger than the
     * array length will search from the end of the array.
     *
     * @param a the array to traverse for looking for the object, may be {@code null}
     * @param valueToFind the value to search for
     * @param tolerance search for value within plus/minus this amount
     * @param startIndexFromBack the start index to traverse backwards from
     * @return the last index of the value within the array,
     *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input
     */
    public static int lastIndexOf(final double[] a, final double valueToFind, final double tolerance, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (Numbers.fuzzyEquals(a[i], valueToFind, tolerance)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"apple", "banana", "cherry", "banana", "date"};
     * int index1 = lastIndexOf(array, "banana");   // Returns 3
     * int index2 = lastIndexOf(array, "apple");    // Returns 0
     * int index3 = lastIndexOf(array, "grape");    // Returns -1 (not found)
     * }</pre>
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final Object[] a, final Object valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the array, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final Object[] a, final Object valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (equals(a[i], valueToFind)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Returns the index of the last occurrence of the specified value in the specified collection.
     *
     * @param c the collection to search within
     * @param valueToFind the value to search for
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final Collection<?> c, final Object valueToFind) {
        if (isEmpty(c)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOf(c, valueToFind, c.size() - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified value in the specified collection, starting the search backwards from the specified index.
     *
     * @param c the collection to search within
     * @param valueToFind the value to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified value, or -1 if there is no such occurrence
     */
    public static int lastIndexOf(final Collection<?> c, final Object valueToFind, final int startIndexFromBack) {
        final int size = size(c);

        if (size == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        if (c instanceof List && c instanceof RandomAccess) {
            final List<Object> list = (List<Object>) c;

            for (int i = N.min(startIndexFromBack, size - 1); i >= 0; i--) {
                if (equals(list.get(i), valueToFind)) {
                    return i;
                }
            }

            return INDEX_NOT_FOUND;
        }

        final Iterator<Object> descendingIterator = getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            for (int i = size - 1; descendingIterator.hasNext(); i--) {
                if (i > startIndexFromBack) {
                    descendingIterator.next();
                } else if (equals(descendingIterator.next(), valueToFind)) {
                    return i;
                }
            }

            return INDEX_NOT_FOUND;
        }

        final Object[] a = c.toArray();

        return lastIndexOf(a, valueToFind, startIndexFromBack);
    }

    /**
     * Returns the index of the last occurrence of the specified sublist in the source list.
     *
     * @param sourceList the list to search within
     * @param subListToFind the sublist to search for
     * @return the index of the last occurrence of the specified sublist, or -1 if there is no such occurrence
     */
    public static int lastIndexOfSubList(final List<?> sourceList, final List<?> subListToFind) {
        if (sourceList == null || subListToFind == null) {
            return INDEX_NOT_FOUND;
        }

        if (subListToFind.isEmpty()) {
            return sourceList.size();
        }

        if (sourceList.isEmpty()) {
            return INDEX_NOT_FOUND;
        }

        return Collections.lastIndexOfSubList(sourceList, subListToFind);
    }

    /**
     * Returns the index of the last occurrence of the specified sublist in the source list, starting the search backwards from the specified index.
     *
     * @param sourceList the list to search within
     * @param subListToFind the sublist to search for
     * @param startIndexFromBack the index to start the search from.
     * @return the index of the last occurrence of the specified sublist, or -1 if there is no such occurrence
     * @see Index#lastOfSubList(List, int, List)
     */
    public static int lastIndexOfSubList(final List<?> sourceList, final List<?> subListToFind, final int startIndexFromBack) {
        return Index.lastOfSubList(sourceList, startIndexFromBack, subListToFind).orElse(INDEX_NOT_FOUND);
    }

    /**
     * Returns the index of the last occurrence of the specified string in the array, ignoring case considerations.
     *
     * @param a the array to search within
     * @param valueToFind the string to search for
     * @return the index of the last occurrence of the specified string, or -1 if there is no such occurrence
     */
    public static int lastIndexOfIgnoreCase(final String[] a, final String valueToFind) {
        if (isEmpty(a)) {
            return INDEX_NOT_FOUND;
        }

        return lastIndexOfIgnoreCase(a, valueToFind, a.length - 1);
    }

    /**
     * Returns the index of the last occurrence of the specified string in the array, ignoring case considerations, starting the search backwards from the specified index.
     *
     * @param a the array to search within
     * @param valueToFind the string to search for
     * @param startIndexFromBack the index to start the search from
     * @return the index of the last occurrence of the specified string, or -1 if there is no such occurrence
     */
    public static int lastIndexOfIgnoreCase(final String[] a, final String valueToFind, final int startIndexFromBack) {
        final int len = len(a);

        if (len == 0 || startIndexFromBack < 0) {
            return INDEX_NOT_FOUND;
        }

        for (int i = N.min(startIndexFromBack, len - 1); i >= 0; i--) {
            if (equalsIgnoreCase(a[i], valueToFind)) {
                return i;
            }
        }

        return INDEX_NOT_FOUND;
    }

    /**
     * Finds the index of the first element in the array that matches the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"apple", "banana", "cherry", "date"};
     * OptionalInt index1 = findFirstIndex(array, s -> s.startsWith("b"));   // Returns OptionalInt[1]
     * OptionalInt index2 = findFirstIndex(array, s -> s.length() > 5);      // Returns OptionalInt[1] ("banana")
     * OptionalInt index3 = findFirstIndex(array, s -> s.startsWith("z"));   // Returns OptionalInt.empty()
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @param predicate the predicate to apply to elements of the array
     * @return an OptionalInt containing the index of the first matching element, or an empty OptionalInt if no match is found
     */
    public static <T> OptionalInt findFirstIndex(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return OptionalInt.empty();
        }

        for (int len = a.length, i = 0; i < len; i++) {
            if (predicate.test(a[i])) {
                return OptionalInt.of(i);
            }
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the first element in the array that matches the given predicate.
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of the second argument to the predicate
     * @param a the array to search within
     * @param u the second argument to the predicate
     * @param predicate the predicate to apply to elements of the array
     * @return an OptionalInt containing the index of the first matching element, or an empty OptionalInt if no match is found
     */
    public static <T, U> OptionalInt findFirstIndex(final T[] a, final U u, final BiPredicate<? super T, ? super U> predicate) {
        if (isEmpty(a)) {
            return OptionalInt.empty();
        }

        for (int len = a.length, i = 0; i < len; i++) {
            if (predicate.test(a[i], u)) {
                return OptionalInt.of(i);
            }
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the first element in the collection that matches the given predicate.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within
     * @param predicate the predicate to apply to elements of the collection
     * @return an OptionalInt containing the index of the first matching element, or an empty OptionalInt if no match is found
     */
    public static <T> OptionalInt findFirstIndex(final Collection<? extends T> c, final Predicate<? super T> predicate) {
        if (isEmpty(c)) {
            return OptionalInt.empty();
        }

        int idx = 0;

        for (final T e : c) {
            if (predicate.test(e)) {
                return OptionalInt.of(idx);
            }

            idx++;
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the first element in the collection that matches the given predicate.
     *
     * @param <T> the type of elements in the collection
     * @param <U> the type of the second argument to the predicate
     * @param c the collection to search within
     * @param u the second argument to the predicate
     * @param predicate the predicate to apply to elements of the collection
     * @return an OptionalInt containing the index of the first matching element, or an empty OptionalInt if no match is found
     */
    public static <T, U> OptionalInt findFirstIndex(final Collection<? extends T> c, final U u, final BiPredicate<? super T, ? super U> predicate) {
        if (isEmpty(c)) {
            return OptionalInt.empty();
        }

        int idx = 0;

        for (final T e : c) {
            if (predicate.test(e, u)) {
                return OptionalInt.of(idx);
            }

            idx++;
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the last element in the array that matches the given predicate.
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @param predicate the predicate to apply to elements of the array
     * @return an OptionalInt containing the index of the last matching element, or an empty OptionalInt if no match is found
     */
    public static <T> OptionalInt findLastIndex(final T[] a, final Predicate<? super T> predicate) {
        if (isEmpty(a)) {
            return OptionalInt.empty();
        }

        for (int i = a.length - 1; i >= 0; i--) {
            if (predicate.test(a[i])) {
                return OptionalInt.of(i);
            }
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the last element in the array that matches the given predicate.
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of the second argument to the predicate
     * @param a the array to search within
     * @param u the second argument to the predicate
     * @param predicate the predicate to apply to elements of the array
     * @return an OptionalInt containing the index of the last matching element, or an empty OptionalInt if no match is found
     */
    public static <T, U> OptionalInt findLastIndex(final T[] a, final U u, final BiPredicate<? super T, ? super U> predicate) {
        if (isEmpty(a)) {
            return OptionalInt.empty();
        }

        for (int i = a.length - 1; i >= 0; i--) {
            if (predicate.test(a[i], u)) {
                return OptionalInt.of(i);
            }
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the last element in the collection that matches the given predicate.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within
     * @param predicate the predicate to apply to elements of the collection
     * @return an OptionalInt containing the index of the last matching element, or an empty OptionalInt if no match is found
     */
    public static <T> OptionalInt findLastIndex(final Collection<? extends T> c, final Predicate<? super T> predicate) {
        if (isEmpty(c)) {
            return OptionalInt.empty();
        }

        final int size = c.size();

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = size - 1; i >= 0; i--) {
                if (predicate.test(list.get(i))) {
                    return OptionalInt.of(i);
                }
            }

            return OptionalInt.empty();
        }

        final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

        if (descendingIterator != null) {
            for (int i = size - 1; descendingIterator.hasNext(); i--) {
                if (predicate.test(descendingIterator.next())) {
                    return OptionalInt.of(i);
                }
            }

            return OptionalInt.empty();
        }

        final T[] a = (T[]) c.toArray();

        for (int i = a.length - 1; i >= 0; i--) {
            if (predicate.test(a[i])) {
                return OptionalInt.of(i);
            }
        }

        return OptionalInt.empty();
    }

    /**
     * Finds the index of the last element in the collection that matches the given predicate.
     *
     * @param <T> the type of elements in the collection
     * @param <U> the type of the second argument to the predicate
     * @param c the collection to search within
     * @param u the second argument to the predicate
     * @param predicate the predicate to apply to elements of the collection
     * @return an OptionalInt containing the index of the last matching element, or an empty OptionalInt if no match is found
     */
    public static <T, U> OptionalInt findLastIndex(final Collection<? extends T> c, final U u, final BiPredicate<? super T, ? super U> predicate) {
        if (isEmpty(c)) {
            return OptionalInt.empty();
        }

        final Predicate<? super T> predicate2 = t -> predicate.test(t, u);

        return findLastIndex(c, predicate2);
    }

    /**
     * Returns the indices of all minimum elements in the specified array.
     * 
     * <p>This method finds all elements in the array that are equal to the minimum value
     * and returns their indices. The comparison is performed using the natural ordering
     * of the elements (their {@code compareTo} method).
     *
     * <p>If the array contains multiple elements with the same minimum value, all their
     * indices will be included in the returned array. The indices are returned in 
     * ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] array1 = {3, 1, 4, 1, 5};
     * int[] minIndices1 = indicesOfAllMin(array1);   // Returns [1, 3] (both 1's)
     *
     * String[] array2 = {"cat", "dog", "ant", "ant"};
     * int[] minIndices2 = indicesOfAllMin(array2);   // Returns [2, 3] (both "ant"s)
     *
     * Integer[] array3 = {5, 5, 5};
     * int[] minIndices3 = indicesOfAllMin(array3);   // Returns [0, 1, 2] (all equal)
     *
     * Integer[] emptyArray = {};
     * int[] minIndices4 = indicesOfAllMin(emptyArray);   // Returns empty array []
     * }</pre>
     *
     * @param <T> the type of elements in the array - must implement {@link Comparable}
     * @param a the array to search for minimum elements - may be {@code null} or empty
     * @return an array of indices where minimum elements are located. Returns an empty
     *         array if the input array is {@code null} or empty. The indices are in
     *         ascending order.
     * @throws ClassCastException if elements in the array are not mutually comparable
     *         using their natural ordering
     * @see #indicesOfAllMin(Object[], Comparator)
     * @see #indicesOfAllMax(Comparable[])
     * @see Arrays#sort(Object[])
     * @see Comparable#compareTo(Object)
     */
    public static <T extends Comparable<? super T>> int[] indicesOfAllMin(final T[] a) {
        return indicesOfAllMin(a, NATURAL_COMPARATOR);
    }

    /**
     * Returns the indices of all minimum elements in the specified array using the provided comparator.
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @param cmp the comparator to compare elements of the array
     * @return an array of indices of all minimum elements. An empty array if the input array is empty.
     */
    public static <T> int[] indicesOfAllMin(final T[] a, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;
        final IntList result = new IntList();
        final int len = len(a);
        T candidate = a[0];
        int cp = 0;

        result.add(0);

        for (int idx = 1; idx < len; idx++) {
            cp = cmp.compare(a[idx], candidate);

            if (cp == 0) {
                result.add(idx);
            } else if (cp < 0) {
                result.clear();
                result.add(idx);
                candidate = a[idx];
            }
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all minimum elements in the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within
     * @return an array of indices of all minimum elements. An empty array if the input collection is empty.
     */
    public static <T extends Comparable<? super T>> int[] indicesOfAllMin(final Collection<? extends T> c) throws IllegalArgumentException {
        return indicesOfAllMin(c, NATURAL_COMPARATOR);
    }

    /**
     * Returns the indices of all minimum elements in the specified collection using the provided comparator.
     * <p>This method finds all elements in the collection that are equal to the minimum value according
     * to the provided comparator and returns their indices. If multiple elements have the same minimum value,
     * all their indices will be included in the returned array.
     *
     * <p>The indices are returned in ascending order (the order they appear in the collection's iteration).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Person {
     *     String name;
     *     int age;
     *     Person(String name, int age) { this.name = name; this.age = age; }
     * }
     *
     * List<Person> people = Arrays.asList(
     *     new Person("Alice", 30),
     *     new Person("Bob", 25),
     *     new Person("Charlie", 25),
     *     new Person("David", 35)
     * );
     *
     * // Find all youngest people (minimum age)
     * Comparator<Person> byAge = Comparator.comparingInt(p -> p.age);
     * int[] minIndices = indicesOfAllMin(people, byAge);
     * // Returns [1, 2] (Bob and Charlie, both age 25)
     *
     * // Find alphabetically first names
     * Comparator<Person> byName = Comparator.comparing(p -> p.name);
     * int[] firstNames = indicesOfAllMin(people, byName);
     * // Returns [0] (Alice is alphabetically first)
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within - may be {@code null} or empty
     * @param cmp the comparator to compare elements - if {@code null}, uses natural ordering with null values treated as maximum
     * @return an array of indices where minimum elements are located according to the comparator.
     *         Returns an empty array if the input collection is {@code null} or empty.
     *         The indices are in ascending order.
     * @throws IllegalArgumentException if comparison operations fail (e.g., incomparable elements when using natural ordering)
     * @see #indicesOfAllMin(Collection)
     * @see #indicesOfAllMax(Collection, Comparator)
     * @see #indicesOfAllMin(Object[], Comparator)
     */
    public static <T> int[] indicesOfAllMin(final Collection<? extends T> c, Comparator<? super T> cmp) throws IllegalArgumentException {
        if (isEmpty(c)) {
            return EMPTY_INT_ARRAY;
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;
        final IntList result = new IntList();
        final Iterator<? extends T> iter = c.iterator();

        T candidate = iter.next();
        T next = null;
        int cp = 0;
        int idx = 0;

        result.add(idx++);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candidate);

            if (cp == 0) {
                result.add(idx);
            } else if (cp < 0) {
                result.clear();
                result.add(idx);
                candidate = next;
            }

            idx++;
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all maximum elements in the specified array.
     * <p>This method finds all elements in the array that are equal to the maximum value
     * and returns their indices. The comparison is performed using the natural ordering
     * of the elements (their {@code compareTo} method).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] array1 = {3, 5, 4, 5, 2};
     * int[] maxIndices1 = indicesOfAllMax(array1);   // Returns [1, 3] (both 5's)
     *
     * String[] array2 = {"cat", "dog", "dog", "ant"};
     * int[] maxIndices2 = indicesOfAllMax(array2);   // Returns [1, 2] (both "dog"s)
     *
     * Integer[] array3 = {5, 5, 5};
     * int[] maxIndices3 = indicesOfAllMax(array3);   // Returns [0, 1, 2] (all equal)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @return an array of indices of all maximum elements. An empty array if the input array is empty.
     */
    public static <T extends Comparable<? super T>> int[] indicesOfAllMax(final T[] a) throws IllegalArgumentException {
        return indicesOfAllMax(a, NATURAL_COMPARATOR);
    }

    /**
     * Returns the indices of all maximum elements in the specified array using the provided comparator.
     * <p>This method finds all elements in the array that are equal to the maximum value according
     * to the provided comparator and returns their indices. If multiple elements have the same maximum value,
     * all their indices will be included in the returned array.
     *
     * <p>The indices are returned in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Product {
     *     String name;
     *     double price;
     *     Product(String name, double price) { this.name = name; this.price = price; }
     * }
     *
     * Product[] products = {
     *     new Product("Apple", 1.50),
     *     new Product("Banana", 0.75),
     *     new Product("Cherry", 2.00),
     *     new Product("Date", 2.00)
     * };
     *
     * // Find all most expensive products (maximum price)
     * Comparator<Product> byPrice = Comparator.comparingDouble(p -> p.price);
     * int[] maxIndices = indicesOfAllMax(products, byPrice);
     * // Returns [2, 3] (Cherry and Date, both $2.00)
     *
     * // Find products with longest names (maximum length)
     * Comparator<Product> byNameLength = Comparator.comparingInt(p -> p.name.length());
     * int[] longestNames = indicesOfAllMax(products, byNameLength);
     * // Returns [1, 2] (Banana and Cherry, both 6 characters)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within - may be {@code null} or empty
     * @param cmp the comparator to compare elements - if {@code null}, uses natural ordering with null values treated as minimum
     * @return an array of indices where maximum elements are located according to the comparator.
     *         Returns an empty array if the input array is {@code null} or empty.
     *         The indices are in ascending order.
     * @throws IllegalArgumentException if comparison operations fail (e.g., incomparable elements when using natural ordering)
     * @see #indicesOfAllMax(Comparable[])
     * @see #indicesOfAllMin(Object[], Comparator)
     * @see #indicesOfAllMax(Collection, Comparator)
     */
    public static <T> int[] indicesOfAllMax(final T[] a, Comparator<? super T> cmp) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;
        final IntList result = new IntList();
        final int len = len(a);
        T candidate = a[0];
        int cp = 0;

        result.add(0);

        for (int idx = 1; idx < len; idx++) {
            cp = cmp.compare(a[idx], candidate);

            if (cp == 0) {
                result.add(idx);
            } else if (cp > 0) {
                result.clear();
                result.add(idx);
                candidate = a[idx];
            }
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all maximum elements in the specified collection.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within
     * @return an array of indices of all maximum elements. An empty array if the input collection is empty.
     */
    public static <T extends Comparable<? super T>> int[] indicesOfAllMax(final Collection<? extends T> c) throws IllegalArgumentException {
        return indicesOfAllMax(c, NATURAL_COMPARATOR);
    }

    /**
     * Returns the indices of all maximum elements in the specified collection using the provided comparator.
     * <p>This method finds all elements in the collection that are equal to the maximum value according
     * to the provided comparator and returns their indices (positions in iteration order). If multiple elements
     * have the same maximum value, all their indices will be included in the returned array.
     *
     * <p>The indices are returned in ascending order (the order they appear in the collection's iteration).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * class Score {
     *     String player;
     *     int points;
     *     Score(String player, int points) { this.player = player; this.points = points; }
     * }
     *
     * List<Score> scores = Arrays.asList(
     *     new Score("Alice", 100),
     *     new Score("Bob", 150),
     *     new Score("Charlie", 150),
     *     new Score("David", 120)
     * );
     *
     * // Find all players with highest score (maximum points)
     * Comparator<Score> byPoints = Comparator.comparingInt(s -> s.points);
     * int[] topScorers = indicesOfAllMax(scores, byPoints);
     * // Returns [1, 2] (Bob and Charlie, both 150 points)
     *
     * // Find alphabetically last player names
     * Comparator<Score> byName = Comparator.comparing(s -> s.player);
     * int[] lastNames = indicesOfAllMax(scores, byName);
     * // Returns [3] (David is alphabetically last)
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within - may be {@code null} or empty
     * @param cmp the comparator to compare elements - if {@code null}, uses natural ordering with null values treated as minimum
     * @return an array of indices where maximum elements are located according to the comparator.
     *         Returns an empty array if the input collection is {@code null} or empty.
     *         The indices are in ascending order.
     * @throws IllegalArgumentException if comparison operations fail (e.g., incomparable elements when using natural ordering)
     * @see #indicesOfAllMax(Collection)
     * @see #indicesOfAllMin(Collection, Comparator)
     * @see #indicesOfAllMax(Object[], Comparator)
     */
    public static <T> int[] indicesOfAllMax(final Collection<? extends T> c, Comparator<? super T> cmp) throws IllegalArgumentException {
        if (isEmpty(c)) {
            return EMPTY_INT_ARRAY;
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;
        final IntList result = new IntList();
        final Iterator<? extends T> iter = c.iterator();

        T candidate = iter.next();
        T next = null;
        int cp = 0;
        int idx = 0;

        result.add(idx++);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candidate);

            if (cp == 0) {
                result.add(idx);
            } else if (cp > 0) {
                result.clear();
                result.add(idx);
                candidate = next;
            }

            idx++;
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all occurrences of the specified value in the given array.
     * <p>This method searches the entire array and returns the positions (indices) of all elements
     * that are equal to the specified value. Equality is determined using {@link Objects#equals(Object, Object)},
     * which handles {@code null} values correctly.
     *
     * <p>The indices are returned in ascending order (the order they appear in the array).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry", "apple", "date"};
     * int[] indices1 = indicesOfAll(words, "apple");
     * // Returns [0, 2, 4] (all positions where "apple" appears)
     *
     * int[] indices2 = indicesOfAll(words, "grape");
     * // Returns [] (empty array - value not found)
     *
     * String[] withNull = {"a", null, "b", null, "c"};
     * int[] indices3 = indicesOfAll(withNull, null);
     * // Returns [1, 3] (all positions where null appears)
     * }</pre>
     *
     * @param a the array to search within - may be {@code null} or empty
     * @param valueToFind the value to find in the array - may be {@code null}
     * @return an array of indices of all occurrences of the specified value.
     *         Returns an empty array if no occurrences are found or if the input array is {@code null} or empty.
     *         The indices are in ascending order.
     * @see #indicesOfAll(Object[], Object, int)
     * @see #indicesOfAll(Collection, Object)
     * @see #indexOf(Object[], Object)
     */
    public static int[] indicesOfAll(final Object[] a, final Object valueToFind) {
        return indicesOfAll(a, valueToFind, 0);
    }

    /**
     * Returns the indices of all occurrences of the specified value in the given array, starting the search from the specified index.
     * <p>This method searches the array from {@code startIndex} (inclusive) onwards and returns the positions (indices)
     * of all elements that are equal to the specified value. Equality is determined using {@link Objects#equals(Object, Object)},
     * which handles {@code null} values correctly.
     *
     * <p>If {@code startIndex} is negative, the search starts from index 0. If {@code startIndex} is greater than or equal
     * to the array length, an empty array is returned.
     *
     * <p>The indices are returned in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry", "apple", "date", "apple"};
     *
     * // Find all "apple" occurrences from the beginning
     * int[] indices1 = indicesOfAll(words, "apple", 0);
     * // Returns [0, 2, 4, 6] (all positions where "apple" appears)
     *
     * // Find "apple" occurrences starting from index 3
     * int[] indices2 = indicesOfAll(words, "apple", 3);
     * // Returns [4, 6] (only "apple"s at or after index 3)
     *
     * // Search with negative startIndex (treated as 0)
     * int[] indices3 = indicesOfAll(words, "banana", -1);
     * // Returns [1]
     *
     * // Search from index beyond array length
     * int[] indices4 = indicesOfAll(words, "apple", 100);
     * // Returns [] (empty array)
     * }</pre>
     *
     * @param a the array to search within - may be {@code null} or empty
     * @param valueToFind the value to find in the array - may be {@code null}
     * @param startIndex the index to start the search from (inclusive); negative values are treated as {@code 0}
     * @return an array of indices of all occurrences of the specified value starting from {@code startIndex}.
     *         Returns an empty array if no occurrences are found, the array is {@code null}/empty, or {@code startIndex} is beyond the array length.
     *         The indices are in ascending order.
     * @see #indicesOfAll(Object[], Object)
     * @see #indicesOfAll(Collection, Object, int)
     * @see #indexOf(Object[], Object, int)
     */
    public static int[] indicesOfAll(final Object[] a, final Object valueToFind, final int startIndex) {
        final int len = len(a);

        if (len == 0 || startIndex >= len) {
            return EMPTY_INT_ARRAY;
        }

        final IntList result = new IntList();

        for (int idx = N.max(startIndex, 0); idx < len; idx++) {
            if (equals(a[idx], valueToFind)) {
                result.add(idx);
            }
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all occurrences of the specified value in the specified collection.
     *
     * @param c the collection to search within
     * @param valueToFind the value to find in the collection
     * @return an array of indices of all occurrences of the specified value
     */
    public static int[] indicesOfAll(final Collection<?> c, final Object valueToFind) {
        return indicesOfAll(c, valueToFind, 0);
    }

    /**
     * Returns the indices of all occurrences of the specified value in the specified collection, starting the search from the specified index.
     *
     * @param c the collection to search within
     * @param valueToFind the value to find in the collection
     * @param startIndex the index to start the search from
     * @return an array of indices of all occurrences of the specified value
     */
    public static int[] indicesOfAll(final Collection<?> c, final Object valueToFind, final int startIndex) {
        final int size = size(c);

        if (size == 0 || startIndex >= size) {
            return EMPTY_INT_ARRAY;
        }

        final IntList result = new IntList();

        if (c instanceof final List<?> list && c instanceof RandomAccess) {

            for (int idx = N.max(startIndex, 0); idx < size; idx++) {
                if (equals(list.get(idx), valueToFind)) {
                    result.add(idx);
                }
            }
        } else {
            final Iterator<?> iter = c.iterator();

            int idx = 0;

            while (idx < startIndex) {
                iter.next();
                idx++;
            }

            while (iter.hasNext()) {
                if (equals(iter.next(), valueToFind)) {
                    result.add(idx);
                }

                idx++;
            }
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all elements in the specified array that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] array = {"apple", "banana", "cherry", "date", "apricot"};
     * int[] indices1 = indicesOfAll(array, s -> s.startsWith("a"));   // Returns [0, 4] ("apple", "apricot")
     * int[] indices2 = indicesOfAll(array, s -> s.length() > 5);      // Returns [1, 2] ("banana", "cherry")
     * int[] indices3 = indicesOfAll(array, s -> s.contains("z"));     // Returns [] (empty)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @param predicate the predicate to apply to elements of the array
     * @return an array of indices of all elements that match the predicate. An empty array if the input array is empty.
     */
    public static <T> int[] indicesOfAll(final T[] a, final Predicate<? super T> predicate) {
        return indicesOfAll(a, predicate, 0);
    }

    /**
     * Returns the indices of all elements in the specified array that match the given predicate, starting the search from the specified index.
     *
     * @param <T> the type of elements in the array
     * @param a the array to search within
     * @param predicate the predicate to apply to elements of the array
     * @param startIndex the index to start the search from
     * @return an array of indices of all elements that match the predicate. An empty array if the input array is empty.
     */
    public static <T> int[] indicesOfAll(final T[] a, final Predicate<? super T> predicate, final int startIndex) {
        final int len = len(a);

        if (len == 0 || startIndex >= len) {
            return EMPTY_INT_ARRAY;
        }

        final IntList result = new IntList();

        for (int idx = N.max(startIndex, 0); idx < len; idx++) {
            if (predicate.test(a[idx])) {
                result.add(idx);
            }
        }

        return result.toArray();
    }

    /**
     * Returns the indices of all elements in the specified collection that match the given predicate.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search within
     * @param predicate the predicate to apply to elements of the collection
     * @return an array of indices of all elements that match the predicate. An empty array if the input collection is empty.
     */
    public static <T> int[] indicesOfAll(final Collection<? extends T> c, final Predicate<? super T> predicate) {
        return indicesOfAll(c, predicate, 0);
    }

    /**
     * Returns the indices of all elements in the specified collection that satisfy the given predicate,
     * starting the search from the specified index.
     *
     * <p>This method searches through the collection starting from {@code fromIndex} (inclusive)
     * and returns an array containing the indices of all elements that match the predicate.
     * The search is performed efficiently using random access for {@link RandomAccess} lists,
     * or iterator-based traversal for other collection types.
     *
     * <p>If {@code fromIndex} is negative, the search starts from index 0. If {@code fromIndex}
     * is greater than or equal to the collection size, an empty array is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("apple", "banana", "apple", "cherry", "apple");
     *
     * // Find all "apple" occurrences from index 1
     * int[] indices1 = indicesOfAll(list, s -> "apple".equals(s), 1);   // Returns [2, 4]
     *
     * // Find all strings longer than 5 characters from start
     * int[] indices2 = indicesOfAll(list, s -> s.length() > 5, 0);   // Returns [1, 3]
     *
     * // Search from index beyond collection size
     * int[] indices3 = indicesOfAll(list, s -> true, 10);   // Returns []
     *
     * // Search with negative fromIndex (treated as 0)
     * int[] indices4 = indicesOfAll(list, s -> "apple".equals(s), -1);   // Returns [0, 2, 4]
     *
     * Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
     * int[] indices5 = indicesOfAll(set, n -> n % 2 == 0, 0);   // Returns even number indices
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to search - may be {@code null} or empty
     * @param predicate the predicate to test each element - must not be {@code null}
     * @param fromIndex the index to start the search from (inclusive); negative values are treated as {@code 0}
     * @return an array of indices where elements satisfy the predicate. Returns an empty array if no matches are found,
     *         the collection is {@code null}/empty, or {@code fromIndex} is beyond the collection size. The indices are in ascending order.
     * @see #indicesOfAll(Collection, Predicate)
     * @see #indicesOfAll(Object[], Predicate, int)
     * @see #findFirstIndex(Collection, Predicate)
     * @see #indexOf(Collection, Object, int)
     */
    public static <T> int[] indicesOfAll(final Collection<? extends T> c, final Predicate<? super T> predicate, final int fromIndex) {
        final int size = size(c);

        if (size == 0 || fromIndex >= size) {
            return EMPTY_INT_ARRAY;
        }

        final IntList result = new IntList();

        if (c instanceof final List<? extends T> list && c instanceof RandomAccess) {

            for (int i = N.max(fromIndex, 0); i < size; i++) {
                if (predicate.test(list.get(i))) {
                    result.add(i);
                }
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();

            int idx = 0;

            while (idx < fromIndex) {
                iter.next();
                idx++;
            }

            while (iter.hasNext()) {
                if (predicate.test(iter.next())) {
                    result.add(idx);
                }

                idx++;
            }
        }

        return result.toArray();
    }

    static <T> Iterator<T> getDescendingIteratorIfPossible(final Iterable<? extends T> c) {
        if (c instanceof Deque) {
            return ((Deque<T>) c).descendingIterator();
        } else {
            try {
                Method m = null;

                if ((m = ClassUtil.getDeclaredMethod(c.getClass(), "descendingIterator")) != null && Modifier.isPublic(m.getModifiers())
                        && Iterator.class.isAssignableFrom(m.getReturnType())) {

                    return ClassUtil.invokeMethod(c, m);
                }
            } catch (final Exception e) {
                // continue
            }
        }

        return null; // NOSONAR
    }

    // ================================ isSorted/sort/sortBy/parallelSort/reverseSort/binarySearch/Index... =============

    static <T> T createMask(final Class<T> interfaceClass) {
        final InvocationHandler h = (proxy, method, args) -> {
            throw new UnsupportedOperationException("It's a mask");
        };

        return newProxyInstance(interfaceClass, h);
    }
}
