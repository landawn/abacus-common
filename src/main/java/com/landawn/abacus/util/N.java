/*
 * Copyright (c) 2015, Haiyang Li.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.landawn.abacus.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.RandomAccess;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.DoublePredicate;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntPredicate;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongPredicate;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.function.LongUnaryOperator;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Collector;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.MayReturnNull;
import com.landawn.abacus.annotation.NotNull;
import com.landawn.abacus.parser.DeserializationConfig;
import com.landawn.abacus.parser.JSONDeserializationConfig;
import com.landawn.abacus.parser.JSONDeserializationConfig.JDC;
import com.landawn.abacus.parser.JSONSerializationConfig;
import com.landawn.abacus.parser.XMLDeserializationConfig;
import com.landawn.abacus.parser.XMLDeserializationConfig.XDC;
import com.landawn.abacus.parser.XMLSerializationConfig;
import com.landawn.abacus.type.Type;
import com.landawn.abacus.util.Fn.Factory;
import com.landawn.abacus.util.Fn.Fnn;
import com.landawn.abacus.util.Fn.IntFunctions;
import com.landawn.abacus.util.Fn.Suppliers;
import com.landawn.abacus.util.Iterables.Slice;
import com.landawn.abacus.util.Tuple.Tuple2;
import com.landawn.abacus.util.Tuple.Tuple3;
import com.landawn.abacus.util.Tuple.Tuple4;
import com.landawn.abacus.util.Tuple.Tuple5;
import com.landawn.abacus.util.u.Nullable;
import com.landawn.abacus.util.function.BooleanPredicate;
import com.landawn.abacus.util.function.BooleanUnaryOperator;
import com.landawn.abacus.util.function.BytePredicate;
import com.landawn.abacus.util.function.ByteUnaryOperator;
import com.landawn.abacus.util.function.CharPredicate;
import com.landawn.abacus.util.function.CharUnaryOperator;
import com.landawn.abacus.util.function.FloatPredicate;
import com.landawn.abacus.util.function.FloatUnaryOperator;
import com.landawn.abacus.util.function.IntBiFunction;
import com.landawn.abacus.util.function.ShortPredicate;
import com.landawn.abacus.util.function.ShortUnaryOperator;
import com.landawn.abacus.util.function.ToBooleanFunction;
import com.landawn.abacus.util.function.ToByteFunction;
import com.landawn.abacus.util.function.ToCharFunction;
import com.landawn.abacus.util.function.ToFloatFunction;
import com.landawn.abacus.util.function.ToShortFunction;
import com.landawn.abacus.util.function.TriFunction;
import com.landawn.abacus.util.stream.IntStream;
import com.landawn.abacus.util.stream.Stream;

/**
 * <p>
 * Note: This class includes codes copied from Apache Commons Lang, Google Guava and other open source projects under the Apache License 2.0.
 * The methods copied from other libraries/frameworks/projects may be modified in this class.
 * </p>
 * Class {@code N} is a general java utility class. It provides the most daily used operations for Object/primitive types/String/Array/Collection/Map/Bean...:
 *
 * <br />
 * <br />
 * When to throw exception? It's designed to avoid throwing any unnecessary
 * exception if the contract defined by method is not broken. for example, if
 * user tries to reverse a {@code null} or empty String. the input String will be
 * returned. But exception will be thrown if try to add element to a {@code null} Object array or collection.
 * <br />
 * <br />
 * An empty String/Array/Collection/Map/Iterator/Iterable/InputStream/Reader will always be a preferred choice than a {@code null} for the return value of a method.
 * <br />
 * There are only {@code fromIndex/startIndex} and {toIndex/endIndex} parameters in the methods defined in class {@code CommonUtil/N}, no {@code offset/count} parameters.
 * <br />
 *
 *
 * @see com.landawn.abacus.util.CommonUtil
 * @see com.landawn.abacus.util.Array
 * @see com.landawn.abacus.util.Iterables
 * @see com.landawn.abacus.util.Iterators
 * @see com.landawn.abacus.util.Index
 * @see com.landawn.abacus.util.Median
 * @see com.landawn.abacus.util.Maps
 * @see com.landawn.abacus.util.Strings
 * @see com.landawn.abacus.util.Numbers
 * @see com.landawn.abacus.util.IOUtil
 *
 * @version $Revision: 0.8 $ 07/03/10
 *
 */
@SuppressWarnings({ "java:S1192", "java:S6539" })
public final class N extends CommonUtil { // public final class N extends π implements ℕ, ℂ, ℚ, ℝ, ℤ { //  Error while storing the mojo status in Maven

    static final int CPU_CORES = Runtime.getRuntime().availableProcessors();

    static final AsyncExecutor ASYNC_EXECUTOR = new AsyncExecutor(//
            max(64, IOUtil.CPU_CORES * 8), // coreThreadPoolSize
            max(128, IOUtil.CPU_CORES * 16), // maxThreadPoolSize
            180L, TimeUnit.SECONDS);

    static final ScheduledExecutorService SCHEDULED_EXECUTOR;

    static {
        final ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(Math.max(64, CPU_CORES));
        //    executor.setKeepAliveTime(180, TimeUnit.SECONDS);
        //    executor.allowCoreThreadTimeOut(true);
        //    executor.setRemoveOnCancelPolicy(true);
        SCHEDULED_EXECUTOR = MoreExecutors.getExitingScheduledExecutorService(executor);
    }

    private static final float LOAD_FACTOR_FOR_FLAT_MAP = 1.75f;

    private static final int LOAD_FACTOR_FOR_TWO_FLAT_MAP = 2;

    private N() {
        // Utility class.
    }

    /**
     * Counts the occurrences of a specific boolean value in a boolean array.
     *
     * @param a The boolean array to be checked for the presence of the valueToFind.
     * @param valueToFind The boolean value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final boolean[] a, final boolean valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final boolean element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific char value in a char array.
     *
     * @param a The char array to be checked for the presence of the valueToFind.
     * @param valueToFind The char value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final char[] a, final char valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final char element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific byte value in a byte array.
     *
     * @param a The byte array to be checked for the presence of the valueToFind.
     * @param valueToFind The byte value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final byte[] a, final byte valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final byte element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific short value in a short array.
     *
     * @param a The short array to be checked for the presence of the valueToFind.
     * @param valueToFind The short value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final short[] a, final short valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final short element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific int value in a int array.
     *
     * @param a The int array to be checked for the presence of the valueToFind.
     * @param valueToFind The int value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final int[] a, final int valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final int element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific long value in a long array.
     *
     * @param a The long array to be checked for the presence of the valueToFind.
     * @param valueToFind The long value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final long[] a, final long valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final long element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific float value in a float array.
     *
     * @param a The float array to be checked for the presence of the valueToFind.
     * @param valueToFind The float value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final float[] a, final float valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final float element : a) {
            if (Float.compare(element, valueToFind) == 0) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific double value in a double array.
     *
     * @param a The double array to be checked for the presence of the valueToFind.
     * @param valueToFind The double value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final double[] a, final double valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final double element : a) {
            if (Double.compare(element, valueToFind) == 0) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific Object value in an Object array.
     *
     * @param a The Object array to be checked for the presence of the valueToFind.
     * @param valueToFind The Object value to be checked for its occurrences in the array a.
     * @return The number of occurrences of valueToFind in array a. Returns 0 if the array is {@code null} or empty.
     */
    public static int occurrencesOf(final Object[] a, final Object valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        if (valueToFind == null) {
            for (final Object element : a) {
                if (element == null) {
                    occurrences++;
                }
            }
        } else {
            for (final Object element : a) {
                if (valueToFind.equals(element)) {
                    occurrences++;
                }
            }
        }

        return occurrences;
    }

    /**
     * Counts the occurrences of a specific Object value in an {@code Iterable}.
     *
     * @param c The {@code Iterable} to be checked for the presence of the valueToFind.
     * @param valueToFind The Object value to be checked for its occurrences in the {@code Iterable} <i>c</i>.
     * @return The number of occurrences of valueToFind in {@code Iterable} <i>c</i>. Returns 0 if the {@code Iterable} is {@code null}.
     */
    public static int occurrencesOf(final Iterable<?> c, final Object valueToFind) {
        if (c == null) {
            return 0;
        }

        long occurrences = 0;

        if (valueToFind == null) {
            for (final Object e : c) {
                if (e == null) {
                    occurrences++;
                }
            }
        } else {
            for (final Object e : c) {
                if (equals(e, valueToFind)) {
                    occurrences++;
                }
            }
        }

        return Numbers.toIntExact(occurrences);
    }

    /**
     * Counts the occurrences of a specific Object value in an {@code Iterator}.
     *
     * @param iter The {@code Iterator} to be checked for the presence of the valueToFind.
     * @param valueToFind The Object value to be checked for its occurrences in the Iterator <i>iter</i>.
     * @return The number of occurrences of valueToFind in Iterator <i>iter</i>. Returns 0 if the Iterator is {@code null}.
     * @throws ArithmeticException if the number of occurrences exceeds Integer.MAX_VALUE.
     * @see Iterators#occurrencesOf(Iterator, Object)
     */
    public static int occurrencesOf(final Iterator<?> iter, final Object valueToFind) throws ArithmeticException {
        return Numbers.toIntExact(Iterators.occurrencesOf(iter, valueToFind));
    }

    /**
     * Counts the occurrences of a specific character in a String.
     *
     * @param str The String to be checked for the presence of the valueToFind.
     * @param valueToFind The character to be checked for its occurrences in the String <i>str</i>.
     * @return The number of occurrences of valueToFind in String <i>str</i>. Returns 0 if the String is {@code null} or empty.
     * @see Strings#countMatches(String, char)
     */
    public static int occurrencesOf(final String str, final char valueToFind) {
        return Strings.countMatches(str, valueToFind);
    }

    /**
     * Counts the occurrences of a specific String value in another String.
     *
     * @param str The String to be checked for the presence of the valueToFind.
     * @param valueToFind The String value to be checked for its occurrences in the String <i>str</i>.
     * @return The number of occurrences of valueToFind in String <i>str</i>. Returns 0 if the String is {@code null} or empty.
     * @see Strings#countMatches(String, String)
     */
    public static int occurrencesOf(final String str, final String valueToFind) {
        return Strings.countMatches(str, valueToFind);
    }

    /**
     * Returns a map with the occurrences of each element in the given array.
     * The map's keys are the distinct elements in the array, and their corresponding values are the number of occurrences of each element.
     * If the input array is {@code null} or empty, an empty map is returned.
     *
     * @param <T> the type of elements in the array
     * @param a the array to count occurrences from
     * @return a Map containing the elements of the array as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final T[] a) {
        return occurrencesMap(a, Suppliers.<T, Integer> ofMap());
    }

    /**
     * Returns a map with the occurrences of each element in the given array.
     * The map's keys are the distinct elements in the array, and their corresponding values are the number of occurrences of each element.
     * If the input array is {@code null} or empty, a map provided by the supplied map supplier is returned.
     *
     * @param <T> the type of elements in the array
     * @param a the array to count occurrences from
     * @param mapSupplier the supplier of the map to be used for collecting occurrences
     * @return a Map containing the elements of the array as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final T[] a, final Supplier<Map<T, Integer>> mapSupplier) {
        if (isEmpty(a)) {
            return mapSupplier.get();
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : a) {
            map.merge(e, 1, (o, n) -> o + n);
        }

        return map;
    }

    /**
     * Returns a map with the occurrences of each element in the given iterable collection.
     * The map's keys are the distinct elements in the collection, and their corresponding values are the number of occurrences of each element.
     * If the input collection is {@code null}, an empty map is returned.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to count occurrences from
     * @return a Map containing the elements of the collection as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterable<? extends T> c) {
        return occurrencesMap(c, Suppliers.<T, Integer> ofMap());
    }

    /**
     * Returns a map with the occurrences of each element in the given iterable collection.
     * The map's keys are the distinct elements in the collection, and their corresponding values are the number of occurrences of each element.
     * If the input collection is {@code null}, a map provided by the supplied map supplier is returned.
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to count occurrences from
     * @param mapSupplier the supplier of the map to be used for collecting occurrences
     * @return a Map containing the elements of the collection as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterable<? extends T> c, final Supplier<Map<T, Integer>> mapSupplier) {
        if (c == null) {
            return mapSupplier.get();
        }

        final Multiset<T> multiset = new Multiset<>();

        for (final T e : c) {
            multiset.add(e, 1);
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : multiset) {
            map.put(e, multiset.getCount(e));
        }

        return map;
    }

    /**
     * Returns a map with the occurrences of each element in the given iterator.
     * The map's keys are the distinct elements in the iterator, and their corresponding values are the number of occurrences of each element.
     * If the input iterator is {@code null} or empty, an empty map is returned.
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to count occurrences from
     * @return a Map containing the elements of the iterator as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterator<? extends T> iter) {
        return occurrencesMap(iter, Suppliers.<T, Integer> ofMap());
    }

    /**
     * Returns a map with the occurrences of each element in the given iterator.
     * The map's keys are the distinct elements in the iterator, and their corresponding values are the number of occurrences of each element.
     * If the input iterator is {@code null} or empty, a map provided by the supplied map supplier is returned.
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to count occurrences from
     * @param mapSupplier the supplier of the map to be used for collecting occurrences
     * @return a Map containing the elements of the iterator as keys and their occurrences as values
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterator<? extends T> iter, final Supplier<Map<T, Integer>> mapSupplier) {
        if (iter == null) {
            return mapSupplier.get();
        }

        final Multiset<T> multiset = new Multiset<>();

        while (iter.hasNext()) {
            multiset.add(iter.next(), 1);
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : multiset) {
            map.put(e, Numbers.toIntExact(multiset.getCount(e)));
        }

        return map;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param a
    //     * @return
    //     * @see Multiset#of(Object[])
    //     */
    //    @Beta
    //    public static <T> Multiset<T> occurrences(final T[] a) {
    //        return Multiset.of(a);
    //    }
    //
    //    /**
    //     *
    //     * @param <T>
    //     * @param c
    //     * @return
    //     * @see Multiset#of(Iterable)
    //     */
    //    @Beta
    //    public static <T> Multiset<T> occurrences(final Iterable<? extends T> c) {
    //        if (c == null) {
    //            return newMultiset();
    //        }
    //
    //        if (c instanceof Collection) {
    //            return Multiset.create((Collection<T>) c);
    //        }
    //
    //        return occurrences(c.iterator());
    //    }
    //
    //    /**
    //     *
    //     * @param <T>
    //     * @param iter
    //     * @return
    //     * @see Multiset#of(Iterator)
    //     */
    //    @Beta
    //    public static <T> Multiset<T> occurrences(final Iterator<? extends T> iter) {
    //        return Multiset.create(iter);
    //    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final boolean[] a, final boolean valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final char[] a, final char valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final byte[] a, final byte valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final short[] a, final short valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final int[] a, final int valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final long[] a, final long valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final float[] a, final float valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final double[] a, final double valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified array contains the specified value.
     *
     * @param a The array to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if <i>a</i> is {@code null} or empty or {@code valueToFind} is not found.
     */
    public static boolean contains(final Object[] a, final Object valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Checks if the specified Collection contains the specified value.
     *
     * @param c The Collection to be checked for the presence of the Collection.
     * @param valueToFind The value to be checked for its presence in the array.
     * @return {@code true} if the array contains the specified value, {@code false} if {@code valueToFind} is not found or <i>c</i> is {@code null} or empty.
     */
    public static boolean contains(final Collection<?> c, final Object valueToFind) {
        if (isEmpty(c)) {
            return false;
        }

        return c.contains(valueToFind);
    }

    /**
     * Checks if the specified {@code Iterable} contains the specified value.
     *
     * @param c The {@code Iterable} to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the {@code Iterable}.
     * @return {@code true} if the array contains the specified value, {@code false} if {@code valueToFind} is not found or <i>c</i> is {@code null} or empty.
     */
    public static boolean contains(final Iterable<?> c, final Object valueToFind) {
        if (c == null) {
            return false;
        }

        for (final Object e : c) {
            if (equals(e, valueToFind)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified Iterator contains the specified value.
     *
     * @param c The {@code Iterator} to be checked for the presence of the value.
     * @param valueToFind The value to be checked for its presence in the Iterator.
     * @return {@code true} if the array contains the specified value, {@code false} if {@code valueToFind} is not found or <i>c</i> is {@code null} or empty.
     */
    public static boolean contains(final Iterator<?> iter, final Object valueToFind) {
        if (iter == null) {
            return false;
        }

        while (iter.hasNext()) {
            if (equals(iter.next(), valueToFind)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified Collection contains all the elements in the specified {@code valuesToFind} Collection.
     *
     * @param c The Collection to be checked for the presence of the elements in valuesToFind.
     * @param valuesToFind The Collection of values to be checked for their presence in the Collection <i>c</i>.
     * @return {@code true} if the Collection <i>c</i> contains all the elements in {@code valuesToFind} or {@code valuesToFind} is {@code null} or empty, {@code false} if any element in {@code valuesToFind} is not found in c or if <i>c</i> is {@code null} or empty.
     */
    public static boolean containsAll(final Collection<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (isEmpty(c)) {
            return false;
        }

        return c.containsAll(valuesToFind);
    }

    /**
     * Checks if the specified Collection contains all the elements in the specified {@code valuesToFind} array.
     *
     * @param c The Collection to be checked for the presence of the elements in valuesToFind.
     * @param valuesToFind The array of values to be checked for their presence in the Collection <i>c</i>.
     * @return {@code true} if the Collection <i>c</i> contains all the elements in {@code valuesToFind} or {@code valuesToFind} is {@code null} or empty, {@code false} if any element in {@code valuesToFind} is not found in c or if <i>c</i> is {@code null} or empty.
     */
    @SafeVarargs
    public static boolean containsAll(final Collection<?> c, final Object... valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (isEmpty(c)) {
            return false;
        }

        return c.containsAll(Array.asList(valuesToFind));
    }

    /**
     * Checks if the specified {@code Iterable} contains all the elements in the specified {@code valuesToFind} Collection.
     *
     * @param c The {@code Iterable} to be checked for the presence of the elements in valuesToFind.
     * @param valuesToFind The Collection of values to be checked for their presence in the {@code Iterable} <i>c</i>.
     * @return {@code true} if the {@code Iterable} c contains all the elements in {@code valuesToFind} or {@code valuesToFind} is {@code null} or empty, {@code false} if any element in {@code valuesToFind} is not found in c or if <i>c</i> is {@code null} or empty.
     */
    public static boolean containsAll(final Iterable<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (c == null) {
            return false;
        }

        final Set<?> set = new HashSet<>(valuesToFind);

        for (final Object e : c) {
            if (set.remove(e) && (set.size() == 0)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified Iterator contains all the elements in the specified {@code valuesToFind} Collection.
     *
     * @param c The {@code Iterator} to be checked for the presence of the elements in valuesToFind.
     * @param valuesToFind The Collection of values to be checked for their presence in the Iterator c.
     * @return {@code true} if the Iterator <i>iter</i> contains all the elements in {@code valuesToFind} or {@code valuesToFind} is {@code null} or empty, {@code false} if any element in {@code valuesToFind} is not found in <i>iter</i> or if <i>iter</i> is {@code null} or empty.
     */
    public static boolean containsAll(final Iterator<?> iter, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (iter == null) {
            return false;
        }

        final Set<?> set = new HashSet<>(valuesToFind);

        while (iter.hasNext()) {
            if (set.remove(iter.next()) && (set.size() == 0)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified Collection contains any elements from the specified {@code valuesToFind} Collection.
     *
     * @param c The Collection to be checked for the presence of any elements in valuesToFind.
     * @param valuesToFind The Collection of values to be checked for their presence in the Collection <i>c</i>.
     * @return {@code true} if the Collection <i>c</i> contains any elements in {@code valuesToFind} or {@code false} if <i>c</i> is {@code null} or empty, or if {@code valuesToFind} is {@code null} or empty .
     */
    public static boolean containsAny(final Collection<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return false;
        }

        return !disjoint(c, valuesToFind);
    }

    /**
     * Checks if the specified Collection contains any elements from the specified {@code valuesToFind} array.
     *
     * @param c The Collection to be checked for the presence of any elements in valuesToFind.
     * @param valuesToFind The array of values to be checked for their presence in the Collection <i>c</i>.
     * @return {@code true} if the Collection <i>c</i> contains any elements in {@code valuesToFind} or {@code false} if <i>c</i> is {@code null} or empty, or if {@code valuesToFind} is {@code null} or empty .
     */
    @SafeVarargs
    public static boolean containsAny(final Collection<?> c, final Object... valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return false;
        }

        return !disjoint(c, Array.asList(valuesToFind));
    }

    /**
     * Checks if the specified {@code Iterable} contains any elements from the specified {@code valuesToFind} Set.
     *
     * @param c The {@code Iterable} to be checked for the presence of any elements in valuesToFind.
     * @param valuesToFind The Set of values to be checked for their presence in the {@code Iterable} <i>c</i>.
     * @return {@code true} if the {@code Iterable} c contains any elements in {@code valuesToFind} or {@code false} if <i>c</i> is {@code null} or empty, or if {@code valuesToFind} is {@code null} or empty .
     */
    public static boolean containsAny(final Iterable<?> c, final Set<?> valuesToFind) {
        if (c == null || isEmpty(valuesToFind)) {
            return false;
        }

        for (final Object e : c) {
            if (valuesToFind.contains(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Checks if the specified Iterator contains any elements from the specified {@code valuesToFind} Set.
     *
     * @param iter The {@code Iterator} to be checked for the presence of any elements in valuesToFind.
     * @param valuesToFind The Set of values to be checked for their presence in the Iterator <i>iter</i>.
     * @return {@code true} if the Iterator <i>iter</i> contains any elements in {@code valuesToFind} or {@code false} if <i>iter</i> is {@code null} or empty, or if {@code valuesToFind} is {@code null} or empty .
     */
    public static boolean containsAny(final Iterator<?> iter, final Set<?> valuesToFind) {
        if (iter == null || isEmpty(valuesToFind)) {
            return false;
        }

        while (iter.hasNext()) {
            if (valuesToFind.contains(iter.next())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns a read-only slice of the input array from the specified start index to the end index.
     *
     * @param <T> The type of the elements in the array.
     * @param a The input array to be sliced.
     * @param fromIndex The start index for the slice, inclusive.
     * @param toIndex The end index for the slice, exclusive.
     * @return An ImmutableList containing the slice of the input array.
     * @throws IndexOutOfBoundsException if the fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static <T> ImmutableList<T> slice(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a)) {
            return ImmutableList.empty();
        }

        return slice(Array.asList(a), fromIndex, toIndex);
    }

    /**
     * Returns a read-only slice of the input list from the specified start index to the end index.
     *
     * @param <T> The type of the elements in the list.
     * @param c The input list to be sliced.
     * @param fromIndex The start index for the slice, inclusive.
     * @param toIndex The end index for the slice, exclusive.
     * @return An ImmutableList containing the slice of the input list.
     * @throws IndexOutOfBoundsException if the fromIndex is negative, toIndex is larger than the length of the list, or fromIndex is larger than toIndex.
     */
    public static <T> ImmutableList<T> slice(final List<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return ImmutableList.empty();
        }

        return ImmutableList.wrap(((List<T>) c).subList(fromIndex, toIndex));
    }

    /**
     * Returns a read-only slice of the input collection from the specified start index to the end index.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The input collection to be sliced.
     * @param fromIndex The start index for the slice, inclusive.
     * @param toIndex The end index for the slice, exclusive.
     * @return An ImmutableCollection containing the slice of the input collection.
     * @throws IndexOutOfBoundsException if the fromIndex is negative, toIndex is larger than the size of the collection, or fromIndex is larger than toIndex.
     */
    public static <T> ImmutableCollection<T> slice(final Collection<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return ImmutableList.empty();
        }

        if (c instanceof List) {
            return slice((List<T>) c, fromIndex, toIndex);
        }

        return new Slice<>(c, fromIndex, toIndex);
    }

    /**
     * Returns a read-only slice of the input iterator from the specified start index to the end index.
     *
     * @param <T> The type of the elements in the iterator.
     * @param iter The input iterator to be sliced.
     * @param fromIndex The start index for the slice, inclusive.
     * @param toIndex The end index for the slice, exclusive.
     * @return An ObjIterator containing the slice of the input iterator.
     * @throws IndexOutOfBoundsException if the fromIndex is negative, or fromIndex is larger than toIndex.
     */
    public static <T> ObjIterator<T> slice(final Iterator<? extends T> iter, final long fromIndex, final long toIndex) {
        if (fromIndex < 0 || fromIndex > toIndex) {
            throw new IndexOutOfBoundsException("Index range [" + fromIndex + ", " + toIndex + "] is out-of-bounds");
        }

        if (iter == null || fromIndex == toIndex) {
            return ObjIterator.empty();
        }

        return Iterators.skipAndLimit(iter, fromIndex, toIndex - fromIndex);
    }

    /**
     * Splits the input boolean array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input boolean array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of boolean sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<boolean[]> split(final boolean[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, "chunkSize"); //NOSONAR

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<boolean[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input boolean array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input boolean array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of boolean sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<boolean[]> split(final boolean[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<boolean[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input char array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input char array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of char sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<char[]> split(final char[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<char[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input char array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input char array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of char sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<char[]> split(final char[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<char[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input byte array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input byte array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of byte sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<byte[]> split(final byte[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<byte[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input byte array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input byte array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of byte sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<byte[]> split(final byte[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<byte[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input short array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input short array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of short sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<short[]> split(final short[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<short[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input short array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input short array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of short sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<short[]> split(final short[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<short[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input int array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input int array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of int sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<int[]> split(final int[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<int[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input int array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input int array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of int sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<int[]> split(final int[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<int[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input long array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input long array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of long sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<long[]> split(final long[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<long[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input long array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input long array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of long sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<long[]> split(final long[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<long[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input float array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input float array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of float sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<float[]> split(final float[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<float[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input float array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input float array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of float sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<float[]> split(final float[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<float[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input double array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param a The input double array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of double sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static List<double[]> split(final double[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<double[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input double array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input double array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of double sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static List<double[]> split(final double[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<double[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input array into sub-arrays of the specified size. The last sub-array may be smaller if the total array length is not a multiple of chunkSize.
     *
     * @param <T> The type of the elements in the array.
     * @param a The input array to be split.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static <T> List<T[]> split(final T[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<T[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input array into sub-arrays of the specified size. The last sub-array may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-arrays are created from the specified range in the input array.
     *
     * @param a The input array to be split.
     * @param fromIndex The start index for the slice of the array to be split, inclusive.
     * @param toIndex The end index for the slice of the array to be split, exclusive.
     * @param chunkSize The desired size of each sub-array.
     * @return A list of sub-arrays, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the length of the array, or fromIndex is larger than toIndex.
     */
    public static <T> List<T[]> split(final T[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<T[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Splits the input collection into sub-collections of the specified size. The last sub-collection may be smaller if the total collection size is not a multiple of chunkSize.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The input collection to be split.
     * @param chunkSize The desired size of each sub-collection.
     * @return A list of sub-collections, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static <T> List<List<T>> split(final Collection<? extends T> c, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        return split(c, 0, c.size(), chunkSize);
    }

    /**
     * Splits the input collection into sub-collections of the specified size. The last sub-collection may be smaller if the length of specified range is not a multiple of chunkSize.
     * The sub-collections are created from the specified range in the input collection.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The input collection to be split.
     * @param fromIndex The start index for the slice of the collection to be split, inclusive.
     * @param toIndex The end index for the slice of the collection to be split, exclusive.
     * @param chunkSize The desired size of each sub-collection.
     * @return A list of sub-collections, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     * @throws IndexOutOfBoundsException if fromIndex is negative, toIndex is larger than the size of the collection, or fromIndex is larger than toIndex.
     */
    public static <T> List<List<T>> split(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(c) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<List<T>> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        if (c instanceof List) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
                res.add(list.subList(i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();

            for (int i = 0; i < toIndex;) {
                if (i < fromIndex) {
                    iter.next();
                    i++;
                    continue;
                }

                final List<T> subList = new ArrayList<>(min(chunkSize, toIndex - i));

                for (final int j = i <= toIndex - chunkSize ? i + chunkSize : toIndex; i < j; i++) {
                    subList.add(iter.next());
                }

                res.add(subList);
            }
        }

        return res;
    }

    /**
     * Splits the input {@code iterable} into sub-collections of the specified size. The last sub-collection may be smaller if the total iterable size is not a multiple of chunkSize.
     *
     * @param <T> The type of the elements in the {@code iterable}.
     * @param c The input {@code iterable} to be split.
     * @param chunkSize The desired size of each sub-collection.
     * @return A list of sub-collections, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static <T> List<List<T>> split(final Iterable<? extends T> c, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (c == null) {
            return new ArrayList<>();
        } else if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;

            return split(coll, 0, coll.size(), chunkSize);
        } else {
            return toList(split(c.iterator(), chunkSize));
        }
    }

    /**
     * Splits the input iterator into sub-collections of the specified size. The last sub-collection may be smaller if the total iterator size is not a multiple of chunkSize.
     *
     * @param <T> The type of the elements in the iterator.
     * @param iter The input iterator to be split.
     * @param chunkSize The desired size of each sub-collection.
     * @return An iterator of sub-collections, each of size chunkSize (except possibly for the last one).
     * @throws IllegalArgumentException if chunkSize is not a positive integer.
     */
    public static <T> ObjIterator<List<T>> split(final Iterator<? extends T> iter, final int chunkSize) throws IllegalArgumentException {
        checkArgument(chunkSize > 0, "'chunkSize' must be greater than 0, can't be: %s", chunkSize);

        if (iter == null) {
            return ObjIterator.empty();
        }

        return new ObjIterator<>() {
            private final Iterator<? extends T> iterator = iter;

            @Override
            public boolean hasNext() {
                return iterator.hasNext();
            }

            @Override
            public List<T> next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                final List<T> next = new ArrayList<>(chunkSize);

                for (int i = 0; i < chunkSize && iterator.hasNext(); i++) {
                    next.add(iterator.next());
                }

                return next;
            }
        };
    }

    /**
     * Returns consecutive substring of the specified string, each of the same length (the final list may be smaller),
     * or an empty array if the specified string is {@code null} or empty.
     *
     * @param str
     * @param chunkSize the desired size of each sub String (the last may be smaller).
     * @return
     * @throws IllegalArgumentException
     */
    public static List<String> split(final CharSequence str, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (Strings.isEmpty(str)) {
            return new ArrayList<>();
        }

        return split(str, 0, str.length(), chunkSize);
    }

    /**
     * Returns consecutive substring of the specified string, each of the same length (the final list may be smaller),
     * or an empty array if the specified string is {@code null} or empty.
     *
     * @param str
     * @param fromIndex
     * @param toIndex
     * @param chunkSize the desired size of each sub String (the last may be smaller).
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static List<String> split(final CharSequence str, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(str));
        checkArgPositive(chunkSize, cs.chunkSize);

        if (Strings.isEmpty(str)) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<String> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(str.subSequence(i, i <= toIndex - chunkSize ? i + chunkSize : toIndex).toString());
        }

        return res;
    }

    /**
     * Splits the total size into chunks based on the specified maximum chunk count.
     * <br />
     * The size of the chunks can be either smaller or larger first based on the flag.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input {@code totalSize} is less than {@code maxChunkCount}.
     *
     * <pre>
     * <code>
     * final int[] a = Array.rangeClosed(1, 7);
     * splitByChunkCount(7, 5, true, (fromIndex, toIndex) ->  copyOfRange(a, fromIndex, toIndex)); // [[1], [2], [3], [4, 5], [6, 7]]
     * splitByChunkCount(7, 5, false, (fromIndex, toIndex) ->  copyOfRange(a, fromIndex, toIndex)); // [[1, 2], [3, 4], [5], [6], [7]]
     * </code>
     * </pre>
     *
     * @param <T> the type of the elements in the resulting stream
     * @param totalSize the total size to be split. It could be the size of an array, list, etc.
     * @param maxChunkCount the maximum number of chunks to split into
     * @param sizeSmallerFirst if {@code true}, smaller chunks will be created first; otherwise, larger chunks will be created first
     * @param mapper a function to map the chunk from and to index to an element in the resulting stream
     * @return a Stream of the mapped chunk values
     * @throws IllegalArgumentException if {@code totalSize} is negative or {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(Collection, int, boolean)
     * @see Stream#splitByChunkCount(int, int, boolean, IntBiFunction)
     * @see IntStream#splitByChunkCount(int, int, boolean, IntBinaryOperator)
     */
    public static <T> List<T> splitByChunkCount(final int totalSize, final int maxChunkCount, final boolean sizeSmallerFirst,
            final IntBiFunction<? extends T> func) {
        N.checkArgNotNegative(totalSize, cs.totalSize);
        N.checkArgPositive(maxChunkCount, cs.maxChunkCount);

        return Stream.<T> splitByChunkCount(totalSize, maxChunkCount, sizeSmallerFirst, func).toList();
    }

    /**
     * Splits the input collection into sub-lists based on the specified maximum chunk count.
     * <br />
     * The size of the chunks can be either smaller or larger first based on the flag.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input Collection size is less than {@code maxChunkCount}.
     *
     * <pre>
     * <code>
     * final List<Integer> c = N.asList(1, 2, 3, 4, 5, 6, 7);
     * splitByChunkCount(c, 5, true); // [[1], [2], [3], [4, 5], [6, 7]]
     * splitByChunkCount(c, 5, false); // [[1, 2], [3, 4], [5], [6], [7]]
     * </code>
     * </pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the input collection to be split
     * @param maxChunkCount the maximum number of chunks to split into
     * @param sizeSmallerFirst if {@code true}, smaller chunks will be created first; otherwise, larger chunks will be created first
     * @return a list of sub-lists.
     * @throws IllegalArgumentException if {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(int, int, boolean, IntBiFunction)
     */
    public static <T> List<List<T>> splitByChunkCount(final Collection<? extends T> c, final int maxChunkCount, final boolean sizeSmallerFirst) {
        N.checkArgPositive(maxChunkCount, cs.maxChunkCount);

        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        IntBiFunction<List<T>> func = null;

        if (c instanceof final List list) {
            func = (fromIndex, toIndex) -> list.subList(fromIndex, toIndex);
        } else {
            final Iterator<? extends T> iter = c.iterator();

            // Only used in below line to call splitByChunkCount.
            func = (fromIndex, toIndex) -> {
                final List<T> subList = new ArrayList<>(toIndex - fromIndex);

                for (int i = fromIndex; i < toIndex; i++) {
                    subList.add(iter.next());
                }

                return subList;
            };
        }

        return splitByChunkCount(c.size(), maxChunkCount, sizeSmallerFirst, func);
    }

    /**
     * Concatenates two boolean arrays into a new array.
     *
     * @param a The first boolean array.
     * @param b The second boolean array.
     * @return A new boolean array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static boolean[] concat(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BOOLEAN_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_BOOLEAN_ARRAY : a.clone();
        }

        final boolean[] c = new boolean[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple boolean arrays into a new array.
     *
     * @param aa The boolean arrays to be concatenated.
     * @return A new boolean array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static boolean[] concat(final boolean[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_BOOLEAN_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final boolean[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final boolean[] c = new boolean[len];
        int fromIndex = 0;

        for (final boolean[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two char arrays into a new array.
     *
     * @param a The first char array.
     * @param b The second char array.
     * @return A new char array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static char[] concat(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_CHAR_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_CHAR_ARRAY : a.clone();
        }

        final char[] c = new char[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple char arrays into a new array.
     *
     * @param aa The char arrays to be concatenated.
     * @return A new char array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static char[] concat(final char[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_CHAR_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_CHAR_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final char[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final char[] c = new char[len];
        int fromIndex = 0;

        for (final char[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two byte arrays into a new array.
     *
     * @param a The first byte array.
     * @param b The second byte array.
     * @return A new byte array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static byte[] concat(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BYTE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_BYTE_ARRAY : a.clone();
        }

        final byte[] c = new byte[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple byte arrays into a new array.
     *
     * @param aa The byte arrays to be concatenated.
     * @return A new byte array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static byte[] concat(final byte[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_BYTE_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_BYTE_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final byte[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final byte[] c = new byte[len];
        int fromIndex = 0;

        for (final byte[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two short arrays into a new array.
     *
     * @param a The first short array.
     * @param b The second short array.
     * @return A new short array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static short[] concat(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_SHORT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_SHORT_ARRAY : a.clone();
        }

        final short[] c = new short[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple short arrays into a new array.
     *
     * @param aa The short arrays to be concatenated.
     * @return A new short array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static short[] concat(final short[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_SHORT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_SHORT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final short[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final short[] c = new short[len];
        int fromIndex = 0;

        for (final short[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two int arrays into a new array.
     *
     * @param a The first int array.
     * @param b The second int array.
     * @return A new int array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static int[] concat(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_INT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_INT_ARRAY : a.clone();
        }

        final int[] c = new int[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple int arrays into a new array.
     *
     * @param aa The int arrays to be concatenated.
     * @return A new int array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static int[] concat(final int[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_INT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_INT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final int[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final int[] c = new int[len];
        int fromIndex = 0;

        for (final int[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two long arrays into a new array.
     *
     * @param a The first long array.
     * @param b The second long array.
     * @return A new long array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static long[] concat(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_LONG_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_LONG_ARRAY : a.clone();
        }

        final long[] c = new long[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple long arrays into a new array.
     *
     * @param aa The long arrays to be concatenated.
     * @return A new long array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static long[] concat(final long[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_LONG_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_LONG_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final long[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final long[] c = new long[len];
        int fromIndex = 0;

        for (final long[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two float arrays into a new array.
     *
     * @param a The first float array.
     * @param b The second float array.
     * @return A new float array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static float[] concat(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_FLOAT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_FLOAT_ARRAY : a.clone();
        }

        final float[] c = new float[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple float arrays into a new array.
     *
     * @param aa The float arrays to be concatenated.
     * @return A new float array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static float[] concat(final float[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_FLOAT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final float[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final float[] c = new float[len];
        int fromIndex = 0;

        for (final float[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two double arrays into a new array.
     *
     * @param a The first double array.
     * @param b The second double array.
     * @return A new double array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty array is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    public static double[] concat(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_DOUBLE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_DOUBLE_ARRAY : a.clone();
        }

        final double[] c = new double[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple double arrays into a new array.
     *
     * @param aa The double arrays to be concatenated.
     * @return A new double array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, an empty array is returned.
     *         If {@code 'aa'} contains only one array, a clone of this array is returned.
     */
    @SafeVarargs
    public static double[] concat(final double[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_DOUBLE_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final double[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final double[] c = new double[len];
        int fromIndex = 0;

        for (final double[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two arrays into a new array.
     *
     * @param <T> The type of the elements in the arrays.
     * @param a The first array.
     * @param b The second array.
     * @return A new array that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, <i>a</i> is returned.
     *         If <i>a</i> is empty or {@code null}, a clone of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a clone of <i>a</i> is returned.
     */
    @SuppressWarnings("unchecked")
    public static <T> T[] concat(final T[] a, final T[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? a : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        final T[] c = (T[]) newArray(a.getClass().getComponentType(), a.length + b.length);

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple arrays into a new array.
     *
     * @param <T> The type of the elements in the arrays.
     * @param aa The arrays to be concatenated.
     * @return A new array that contains the elements of each array in {@code 'aa'} in the same order.
     *         If {@code 'aa'} is empty or {@code null}, {@code null} is returned.
     * @throws IllegalArgumentException if the arrays in {@code 'aa'} are not of the same type.
     */
    @MayReturnNull
    @SafeVarargs
    public static <T> T[] concat(final T[]... aa) throws IllegalArgumentException {
        // checkArgNotNull(aa, "aa");

        if (aa == null) {
            return null; // NOSONAR
        } else if (aa.length == 0) {
            return newArray(aa.getClass().getComponentType().getComponentType(), 0);
        } else if (aa.length == 1) {
            return aa[0] == null ? newArray(aa.getClass().getComponentType().getComponentType(), 0) : aa[0].clone();
        }

        int len = 0;

        for (final T[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final T[] c = newArray(aa.getClass().getComponentType().getComponentType(), len);
        int fromIndex = 0;

        for (final T[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Concatenates two iterables into a new list.
     *
     * @param <T> The type of the elements in the {@code iterables}.
     * @param a The first iterable.
     * @param b The second iterable.
     * @return A new list that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     *         If both <i>a</i> and <i>b</i> are empty or {@code null}, an empty list is returned.
     *         If <i>a</i> is empty or {@code null}, a list containing the elements of <i>b</i> is returned.
     *         If <i>b</i> is empty or {@code null}, a list containing the elements of <i>a</i> is returned.
     */
    public static <T> List<T> concat(final Iterable<? extends T> a, final Iterable<? extends T> b) {
        return concat(Arrays.asList(a, b));
    }

    /**
     * Concatenates multiple iterables into a new list.
     *
     * @param <T> The type of the elements in the {@code iterables}.
     * @param a The iterables to be concatenated.
     * @return A new list that contains the elements of each iterable in <i>a</i> in the same order.
     *         If <i>a</i> is empty or {@code null}, an empty list is returned.
     *         If <i>a</i> contains only one iterable, a list containing the elements of this iterable is returned.
     */
    @SafeVarargs
    public static <T> List<T> concat(final Iterable<? extends T>... a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return concat(Arrays.asList(a));
    }

    /**
     * Concatenates multiple iterables into a new list.
     *
     * @param <T> The type of the elements in the {@code iterables}.
     * @param c The collection of iterables to be concatenated.
     * @return A new list that contains the elements of each iterable in <i>c</i> in the same order.
     *         If <i>c</i> is empty or {@code null}, an empty list is returned.
     *         If <i>c</i> contains only one iterable, a list containing the elements of this iterable is returned.
     */
    public static <T> List<T> concat(final Collection<? extends Iterable<? extends T>> c) {
        return concat(c, Factory.<T> ofList());
    }

    /**
     * Concatenates multiple iterables into a new collection.
     *
     * @param <T> The type of the elements in the {@code iterables}.
     * @param <C> The type of the collection to be returned.
     * @param c The collection of iterables to be concatenated.
     * @param supplier The function that generates a new instance of the return collection.
     * @return A new collection that contains the elements of each iterable in <i>c</i> in the same order.
     *         The type of the returned collection is determined by the supplier function.
     *         If <i>c</i> is empty or {@code null}, an empty collection is returned.
     *         If <i>c</i> contains only one iterable, a collection containing the elements of this iterable is returned.
     */
    public static <T, C extends Collection<T>> C concat(final Collection<? extends Iterable<? extends T>> c, final IntFunction<? extends C> supplier) {
        if (isEmpty(c)) {
            return supplier.apply(0);
        }

        long count = 0;

        for (final Iterable<? extends T> e : c) {
            count += getSizeOrDefault(e, 0);
        }

        final C result = supplier.apply(Numbers.toIntExact(count));

        for (final Iterable<? extends T> e : c) {
            if (e != null) {
                if (e instanceof Collection) {
                    result.addAll((Collection<T>) e);
                } else {
                    for (final T t : e) {
                        result.add(t);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Concatenates two iterators into a new ObjIterator.
     *
     * @param <T> The type of the elements in the iterators.
     * @param a The first iterator.
     * @param b The second iterator.
     * @return A new ObjIterator that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     * @see Iterators#concat(Iterator...)
     */
    public static <T> ObjIterator<T> concat(final Iterator<? extends T> a, final Iterator<? extends T> b) {
        return Iterators.concat(a, b);
    }

    /**
     * Concatenates multiple iterators into a new ObjIterator.
     *
     * @param <T> The type of the elements in the iterators.
     * @param a The array of iterators to be concatenated.
     * @return A new ObjIterator that contains the elements of each iterator in <i>a</i> in the same order.
     * @see Iterators#concat(Iterator...)
     */
    @SafeVarargs
    public static <T> ObjIterator<T> concat(final Iterator<? extends T>... a) {
        return Iterators.concat(a);
    }

    /**
     * Flattens a two-dimensional boolean array into a one-dimensional boolean array.
     *
     * @param a The two-dimensional boolean array to be flattened.
     * @return A one-dimensional boolean array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static boolean[] flatten(final boolean[][] a) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        int count = 0;

        for (final boolean[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final boolean[] ret = new boolean[count];
        int from = 0;

        for (final boolean[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional char array into a one-dimensional char array.
     *
     * @param a The two-dimensional char array to be flattened.
     * @return A one-dimensional char array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static char[] flatten(final char[][] a) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        int count = 0;

        for (final char[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final char[] ret = new char[count];
        int from = 0;

        for (final char[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional byte array into a one-dimensional byte array.
     *
     * @param a The two-dimensional byte array to be flattened.
     * @return A one-dimensional byte array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static byte[] flatten(final byte[][] a) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        int count = 0;

        for (final byte[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final byte[] ret = new byte[count];
        int from = 0;

        for (final byte[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional short array into a one-dimensional short array.
     *
     * @param a The two-dimensional short array to be flattened.
     * @return A one-dimensional short array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static short[] flatten(final short[][] a) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        int count = 0;

        for (final short[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final short[] ret = new short[count];
        int from = 0;

        for (final short[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional int array into a one-dimensional int array.
     *
     * @param a The two-dimensional int array to be flattened.
     * @return A one-dimensional int array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static int[] flatten(final int[][] a) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        int count = 0;

        for (final int[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final int[] ret = new int[count];
        int from = 0;

        for (final int[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional long array into a one-dimensional long array.
     *
     * @param a The two-dimensional long array to be flattened.
     * @return A one-dimensional long array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static long[] flatten(final long[][] a) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        int count = 0;

        for (final long[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final long[] ret = new long[count];
        int from = 0;

        for (final long[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional float array into a one-dimensional float array.
     *
     * @param a The two-dimensional float array to be flattened.
     * @return A one-dimensional float array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static float[] flatten(final float[][] a) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        int count = 0;

        for (final float[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final float[] ret = new float[count];
        int from = 0;

        for (final float[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional double array into a one-dimensional double array.
     *
     * @param a The two-dimensional double array to be flattened.
     * @return A one-dimensional double array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null} or empty.
     */
    public static double[] flatten(final double[][] a) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        int count = 0;

        for (final double[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final double[] ret = new double[count];
        int from = 0;

        for (final double[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional array into a one-dimensional array.
     *
     * @param <T> The type of the elements in the array.
     * @param a The two-dimensional array to be flattened.
     * @return A one-dimensional array containing all elements in the input array.
     *         Returns {@code null} if the input array is {@code null}.
     */
    @MayReturnNull
    public static <T> T[] flatten(final T[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        return flatten(a, (Class<T>) a.getClass().getComponentType().getComponentType());
    }

    /**
     * Flattens a two-dimensional array into a one-dimensional array.
     *
     * @param <T> The type of the elements in the array.
     * @param a The two-dimensional array to be flattened.
     * @param componentType The class object representing the component type of the new array.
     * @return A one-dimensional array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null}.
     */
    public static <T> T[] flatten(final T[][] a, final Class<T> componentType) {
        if (isEmpty(a)) {
            return newArray(componentType, 0);
        }

        int count = 0;

        for (final T[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final T[] ret = newArray(componentType, count);
        int from = 0;

        for (final T[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param c
    //     * @return
    //     */
    //    public static <T> List<T> flatten(final Collection<? extends Iterable<? extends T>> c) {
    //        return flatten(c, IntFunctions.ofList());
    //    }
    //
    //    /**
    //     *
    //     *
    //     * @param <T>
    //     * @param <C>
    //     * @param c
    //     * @param supplier
    //     * @return
    //     */
    //    @SuppressWarnings("rawtypes")
    //    public static <T, C extends Collection<T>> C flatten(final Collection<? extends Iterable<? extends T>> c, IntFunction<? extends C> supplier) {
    //        if (isEmpty(c)) {
    //            return supplier.apply(0);
    //        }
    //
    //        int count = 0;
    //
    //        for (Iterable<? extends T> e : c) {
    //            count += e instanceof Collection ? ((Collection) e).size() : 3; //NOSONAR
    //        }
    //
    //        final C ret = supplier.apply(count);
    //
    //        for (Iterable<? extends T> e : c) {
    //            if (e == null) {
    //                continue; //NOSONAR
    //            } else if (e instanceof Collection) {
    //                ret.addAll((Collection) e);
    //            } else {
    //                for (T ee : e) {
    //                    ret.add(ee);
    //                }
    //            }
    //        }
    //
    //        return ret;
    //    }

    /**
     * Flattens an {@code Iterable} of {@code Iterable<T>} into a one-dimensional List.
     *
     * @param <T> The type of the elements in the {@code Iterable}.
     * @param c The two-dimensional {@code Iterable} to be flattened.
     * @return A one-dimensional List containing all elements in the input {@code Iterable}.
     *         Returns an empty List if the input {@code Iterable} is {@code null} or empty.
     */
    public static <T> List<T> flatten(final Iterable<? extends Iterable<? extends T>> c) {
        return flatten(c, Factory.ofList());
    }

    /**
     * Flattens an {@code Iterable} of {@code Iterable<T>} into a one-dimensional Collection.
     *
     * @param <T> The type of the elements in the {@code Iterable}.
     * @param <C> The type of the Collection to be returned.
     * @param c The two-dimensional {@code Iterable} to be flattened.
     * @param supplier The function that generates the Collection instance.
     * @return A one-dimensional Collection containing all elements in the input {@code Iterable}.
     *         Returns an empty Collection if the input {@code Iterable} is {@code null} or empty.
     */
    @SuppressWarnings("rawtypes")
    public static <T, C extends Collection<T>> C flatten(final Iterable<? extends Iterable<? extends T>> c, final IntFunction<? extends C> supplier) {
        if (isEmpty(c)) {
            return supplier.apply(0);
        }

        int count = 0;

        for (final Iterable<? extends T> e : c) {
            count += e instanceof Collection ? ((Collection) e).size() : DEFAULT_SIZE_FOR_NEW_COLLECTION; //NOSONAR
        }

        final C ret = supplier.apply(count);

        for (final Iterable<? extends T> e : c) {
            if (e == null) {
                continue; //NOSONAR
            } else if (e instanceof Collection) {
                ret.addAll((Collection) e);
            } else {
                for (final T ee : e) {
                    ret.add(ee);
                }
            }
        }

        return ret;
    }

    /**
     * Flattens an {@code Iterator} of {@code Iterator<T>} into a one-dimensional Iterator.
     *
     * @param <T> The type of the elements in the Iterator.
     * @param iters The two-dimensional Iterator to be flattened.
     * @return A one-dimensional Iterator containing all elements in the input {@code Iterator}.
     *         Returns an empty Iterator if the input {@code Iterator} is {@code null}.
     */
    public static <T> ObjIterator<T> flatten(final Iterator<? extends Iterator<? extends T>> iters) {
        if (iters == null) {
            return ObjIterator.empty();
        }

        return new ObjIterator<>() {
            private Iterator<? extends T> cur = null;

            @Override
            public boolean hasNext() {
                if (cur == null || !cur.hasNext()) {
                    while (iters.hasNext()) {
                        cur = iters.next();

                        if (cur != null && cur.hasNext()) {
                            break;
                        }
                    }
                }

                return cur != null && cur.hasNext();
            }

            @Override
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                return cur.next();
            }
        };
    }

    /**
     * Flattens each element of the provided {@code Iterable} if it's an {@code Iterable} itself, otherwise just adds it to the result List.
     * This method is marked as Beta and may be subject to changes or removal in future versions.
     *
     * @param c The {@code Iterable} to be processed. Each element is checked if it's an {@code Iterable} and flattened if so.
     * @return A List containing the flattened elements of the input {@code Iterable}. If the input {@code Iterable} is {@code null}, an empty List is returned.
     */
    @Beta
    public static List<?> flattenEachElement(final Iterable<?> c) { //NOSONAR
        return flattenEachElement(c, Suppliers.ofList());
    }

    /**
     * Flattens each element of the provided {@code Iterable} if it's an {@code Iterable} itself, otherwise just adds it to the result Collection.
     * This method is marked as Beta and may be subject to changes or removal in future versions.
     *
     * @param <T> The type of the elements in the {@code Iterable}.
     * @param <C> The type of the Collection to be returned.
     * @param c The {@code Iterable} to be processed. Each element is checked if it's an {@code Iterable} and flattened if so.
     * @param supplier The function that generates the Collection instance.
     * @return A Collection containing the flattened elements of the input {@code Iterable}. If the input {@code Iterable} is {@code null}, an empty Collection is returned.
     */
    @Beta
    public static <T, C extends Collection<T>> C flattenEachElement(final Iterable<?> c, final Supplier<? extends C> supplier) {
        if (c == null) {
            return supplier.get();
        }

        final C result = supplier.get();

        flattenEachElement((Iterable<Object>) c, (Collection<Object>) result);

        return result;
    }

    private static void flattenEachElement(final Iterable<Object> c, final Collection<Object> output) {
        for (final Object next : c) {
            if (next instanceof Iterable) {
                flattenEachElement((Iterable<Object>) next, output);
            } else {
                output.add(next);
            }
        }
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static boolean[] intersection(final boolean[] a, final boolean[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return isEmpty(a) ? a : EMPTY_BOOLEAN_ARRAY;
        }

        return BooleanList.of(a).intersection(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static char[] intersection(final char[] a, final char[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_CHAR_ARRAY;
        }

        return CharList.of(a).intersection(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static byte[] intersection(final byte[] a, final byte[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_BYTE_ARRAY;
        }

        return ByteList.of(a).intersection(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static short[] intersection(final short[] a, final short[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_SHORT_ARRAY;
        }

        return ShortList.of(a).intersection(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * <pre>
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] c = retainAll(a, b); // The elements c in a will b: [1, 2, 2].
     *
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] c = intersection(a, b); // The elements c in a will b: [1, 2].
     * </pre>
     *
     * @param a
     * @param b
     * @return
     * @see IntList#intersection(IntList)
     */
    public static int[] intersection(final int[] a, final int[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_INT_ARRAY;
        }

        return IntList.of(a).intersection(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static long[] intersection(final long[] a, final long[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_LONG_ARRAY;
        }

        return LongList.of(a).intersection(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static float[] intersection(final float[] a, final float[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return FloatList.of(a).intersection(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     */
    public static double[] intersection(final double[] a, final double[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return DoubleList.of(a).intersection(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     * @see #intersection(Collection, Collection, boolean)
     * @see #commonSet(Collection, Collection)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> List<T> intersection(final T[] a, final Object[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final Multiset<?> bOccurrences = Multiset.of(b);
        final List<T> result = new ArrayList<>(min(9, a.length, b.length));

        for (final T e : a) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements in the specified Array/Collection <i>a</i> and <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #intersection(int[], int[])
     * @see #intersection(Collection, Collection, boolean)
     * @see #commonSet(Collection, Collection)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> List<T> intersection(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final Multiset<Object> bOccurrences = Multiset.create(b);

        final List<T> result = new ArrayList<>(min(9, a.size(), b.size()));

        for (final T e : a) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements in all the specified collections. Occurrences are considered.
     *
     * @param <T> the type of elements in the collections
     * @param c the collections to intersect
     * @return a list containing the intersection of the collections
     * @see #intersection(int[], int[])
     * @see #intersection(Collection, Collection, boolean)
     * @see #commonSet(Collection, Collection)
     * @see Collection#retainAll(Collection)
     */
    public static <T> List<T> intersection(final Collection<? extends Collection<? extends T>> c) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        } else if (c.size() == 1) {
            return newArrayList(c.iterator().next());
        }

        for (final Collection<? extends T> e : c) {
            if (isEmpty(e)) {
                return new ArrayList<>();
            }
        }

        final Iterator<? extends Collection<? extends T>> iter = c.iterator();
        List<T> result = intersection(iter.next(), iter.next());

        while (iter.hasNext()) {
            result = intersection(result, iter.next());

            if (result.size() == 0) {
                break;
            }
        }

        return result;
    }

    /**
     * Return only the elements in the first collection that are contained in the specified second collection.
     * <br />
     * If {@code ignoreOcurrences} is {@code true}, Occurrences are not considered.
     * <br />
     * Duplicated elements in the returned List will not be eliminated.
     * <pre>
     * List<Integer> a = N.asList(0, 1, 2, 2, 3);
     * List<Integer> b = N.asList(2, 5, 1);
     * List<Integer> c = N.intersection(a, b, false); // The elements c in a will b: [1, 2]. same as N.intersection(a, b).
     * List<Integer> d = N.intersection(a, b, true); // The elements c in a will b: [1, 2, 2].
     * </pre>
     *
     * @param <T> the type of elements in the collections
     * @param a the first collection, elements from this collection will be retained
     * @param b the second collection, elements in this collection are to be retained in the first collection
     * @param ignoreOcurrences if {@code true}, the method does not consider the number of occurrences of an element.
     * @return a List the elements in the first collection that are contained in the specified second collection.
     * @see #intersection(Collection, Collection)
     * @see #commonSet(Collection, Collection)
     * @see Iterables#intersection(Set, Set)
     * @see Collection#retainAll(Collection)
     */
    @Beta
    public static <T> List<T> intersection(final Collection<? extends T> a, final Collection<?> b, final boolean ignoreOcurrences) {
        if (isEmpty(a) || isEmpty(b)) {
            return newArrayList();
        }

        if (ignoreOcurrences == false) {
            return intersection(a, b);
        }

        final Set<Object> set = b instanceof Set ? (Set<Object>) b : (Set<Object>) newHashSet(b);
        final List<T> result = new ArrayList<>(max(0, a.size() - b.size()));

        for (final T e : a) {
            if (set.contains(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static boolean[] difference(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return BooleanList.of(a).difference(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static char[] difference(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return CharList.of(a).difference(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static byte[] difference(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ByteList.of(a).difference(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static short[] difference(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ShortList.of(a).difference(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * <pre>
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] c = removeAll(a, b); // The elements c in a will b: [0, 3].
     *
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] c = difference(a, b); // The elements c in a will b: [0, 2, 3].
     * </pre>
     *
     * @param a
     * @param b
     * @return
     * @see IntList#difference(IntList)
     */
    public static int[] difference(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return IntList.of(a).difference(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static long[] difference(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return LongList.of(a).difference(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static float[] difference(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return FloatList.of(a).difference(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     */
    public static double[] difference(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return DoubleList.of(a).difference(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Iterables#difference(Set, Set)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> difference(final T[] a, final Object[] b) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final Multiset<?> bOccurrences = Multiset.of(b);
        final List<T> result = new ArrayList<>(min(a.length, max(9, a.length - b.length)));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns all the elements in the specified Array/Collection <i>a</i> but not in <i>b</i>. Occurrences are considered.
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     * @see #difference(int[], int[])
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Iterables#difference(Set, Set)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> difference(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        } else if (isEmpty(b)) {
            return new ArrayList<>(a);
        }

        final Multiset<Object> bOccurrences = Multiset.create(b);

        final List<T> result = new ArrayList<>(min(a.size(), max(9, a.size() - b.size())));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static boolean[] symmetricDifference(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BOOLEAN_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return BooleanList.of(a).symmetricDifference(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static char[] symmetricDifference(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_CHAR_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return CharList.of(a).symmetricDifference(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static byte[] symmetricDifference(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BYTE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ByteList.of(a).symmetricDifference(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static short[] symmetricDifference(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_SHORT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ShortList.of(a).symmetricDifference(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * <pre>
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] c = symmetricDifference(a, b); // The elements c in a will b: [0, 2, 3, 5].
     * </pre>
     *
     * @param a
     * @param b
     * @return
     * @see IntList#symmetricDifference(IntList)
     * @see #difference(int[], int[])
     */
    public static int[] symmetricDifference(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_INT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return IntList.of(a).symmetricDifference(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static long[] symmetricDifference(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_LONG_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return LongList.of(a).symmetricDifference(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static float[] symmetricDifference(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_FLOAT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return FloatList.of(a).symmetricDifference(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     */
    public static double[] symmetricDifference(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_DOUBLE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return DoubleList.of(a).symmetricDifference(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #difference(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     * @see Iterables#symmetricDifference(Set, Set)
     */
    public static <T> List<T> symmetricDifference(final T[] a, final T[] b) {
        if (isEmpty(a)) {
            return asList(b);
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final Multiset<T> bOccurrences = Multiset.of(b);

        final List<T> result = new ArrayList<>(max(9, Math.abs(a.length - b.length)));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        for (final T e : b) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }

            if (bOccurrences.isEmpty()) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns the elements that are in the specified Array/Collection <i>a</i> but not in <i>b</i> and vice versa. Occurrences are considered
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     * @see #symmetricDifference(int[], int[])
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #difference(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     * @see Iterables#symmetricDifference(Set, Set)
     */
    public static <T> List<T> symmetricDifference(final Collection<? extends T> a, final Collection<? extends T> b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? new ArrayList<>() : new ArrayList<>(b);
        } else if (isEmpty(b)) {
            return isEmpty(a) ? new ArrayList<>() : new ArrayList<>(a);
        }

        final Multiset<T> bOccurrences = Multiset.create(b);
        final List<T> result = new ArrayList<>(max(9, Math.abs(a.size() - b.size())));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        for (final T e : b) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }

            if (bOccurrences.isEmpty()) {
                break;
            }
        }

        return result;
    }

    //    /**
    //     * Returns a set containing elements that are in the first collection <i>a</i> but not in the second collection <i>b</i>.
    //     * The returned set does not contain duplicate elements.
    //     *
    //     * @param <T> the type of elements in the collections
    //     * @param a the first collection to be compared
    //     * @param b the second collection to be compared
    //     * @return a Set containing the difference of the two collections
    //     * @see #difference(Collection, Collection)
    //     * @see #excludeAll(Collection, Collection)
    //     * @see #excludeAllToSet(Collection, Collection)
    //     * @see #removeAll(Collection, Collection)
    //     * @see Iterables#difference(Set, Set)
    //     * @see Difference#of(Collection, Collection)
    //     */
    //    @SuppressWarnings("rawtypes")
    //    public static <T> Set<T> differentSet(final Collection<? extends T> a, final Collection<?> b) {
    //        if (isEmpty(a)) {
    //            return newHashSet();
    //        } else if (isEmpty(b)) {
    //            return newHashSet(a);
    //        }
    //
    //        final Set<T> result = a instanceof List || a instanceof LinkedHashSet ? newLinkedHashSet(a) : newHashSet(a);
    //
    //        removeAll(result, (Collection) b);
    //
    //        return result;
    //    }

    //    /**
    //     * Returns a Set containing elements that are in either of the input collections but not in both.
    //     * In other words, it returns a Set containing the symmetric difference of the two input collections.
    //     * The returned Set does not contain duplicate elements.
    //     *
    //     * @param <T> The type of elements in the collections.
    //     * @param a The first collection to be compared.
    //     * @param b The second collection to be compared.
    //     * @return A Set containing the symmetric difference of the two collections.
    //     * @see #symmetricDifference(Collection, Collection)
    //     * @see #excludeAll(Collection, Collection)
    //     * @see #excludeAllToSet(Collection, Collection)
    //     * @see Iterables#symmetricDifference(Set, Set)
    //     * @see Difference#of(Collection, Collection)
    //     */
    //    public static <T> Set<T> symmetricDifferentSet(final Collection<? extends T> a, final Collection<? extends T> b) {
    //        if (isEmpty(a)) {
    //            return isEmpty(b) ? newHashSet() : newHashSet(b);
    //        } else if (isEmpty(b)) {
    //            return isEmpty(a) ? newHashSet() : newHashSet(a);
    //        }
    //
    //        final Set<T> commonSet = commonSet(a, b);
    //        final Set<T> result = a instanceof List || a instanceof LinkedHashSet ? newLinkedHashSet() : newHashSet();
    //
    //        for (final T e : a) {
    //            if (!commonSet.contains(e)) {
    //                result.add(e);
    //            }
    //        }
    //
    //        for (final T e : b) {
    //            if (!commonSet.contains(e)) {
    //                result.add(e);
    //            }
    //        }
    //
    //        return result;
    //    }

    /**
     * Returns a Set containing the common elements of two given collections.
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     * @see #intersection(Collection, Collection)
     * @see #intersection(Collection, Collection, boolean)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> Set<T> commonSet(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a) || isEmpty(b)) {
            return newHashSet();
        }

        return commonSet(Array.asList(a, (Collection<? extends T>) b));
    }

    /**
     * Returns a Set containing the common elements of the given collections.
     *
     * @param <T>
     * @param c
     * @return
     * @see #intersection(Collection)
     * @see #intersection(Collection, Collection, boolean)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> Set<T> commonSet(final Collection<? extends Collection<? extends T>> c) {
        if (isEmpty(c)) {
            return newHashSet();
        } else if (c.size() == 1) {
            return newHashSet(c.iterator().next());
        }

        Collection<? extends T> smallest = null;

        for (final Collection<? extends T> e : c) {
            if (isEmpty(e)) {
                return newHashSet();
            }

            if (smallest == null || e.size() < smallest.size()) {
                smallest = e;
            }
        }

        final Map<T, MutableInt> map = new HashMap<>();

        for (final T e : smallest) {
            map.put(e, new MutableInt(1));
        }

        int cnt = 1;
        MutableInt val = null;

        for (final Collection<? extends T> ec : c) {
            if (ec == smallest) { // NOSONAR
                continue;
            }

            for (final T e : ec) {
                val = map.get(e);

                if ((val == null) || (val.value() < cnt)) {
                    // do nothing.
                } else if (val.value() == cnt) {
                    val.increment();
                }
            }

            cnt++;
        }

        final Collection<? extends T> firstSet = N.firstOrNullIfEmpty(c);
        final Set<T> result = firstSet instanceof List || firstSet instanceof LinkedHashSet ? newLinkedHashSet(map.size()) : newHashSet(map.size());

        for (final Map.Entry<T, MutableInt> entry : map.entrySet()) {
            if (entry.getValue().value() == cnt) {
                result.add(entry.getKey());
            }
        }

        return result;
    }

    /**
     * Returns a new {@code List} with specified <i>objToExclude</i> excluded.
     * That's to say no more <i>objToExclude</i> will present in the returned {@code List}.
     *
     * @param <T>
     * @param c
     * @param objToExclude
     * @return a new {@code List}
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> exclude(final Collection<? extends T> c, final Object objToExclude) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(c.size() - 1);

        for (final T e : c) {
            if (!equals(e, objToExclude)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new {@code Set} with specified <i>objToExclude</i> excluded.
     * That's to say no more <i>objToExclude</i> will present in the returned {@code Set}.
     *
     * @param <T>
     * @param c
     * @param objToExclude
     * @return a new {@code Set}
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> Set<T> excludeToSet(final Collection<? extends T> c, final Object objToExclude) {
        if (isEmpty(c)) {
            return new HashSet<>();
        }

        final Set<T> result = c instanceof List || c instanceof LinkedHashSet ? newLinkedHashSet(c) : newHashSet(c);

        result.remove(objToExclude);

        return result;
    }

    /**
     * Returns a new {@code List} with specified <i>objsToExclude</i> excluded.
     * That's to say no more value from <i>objsToExclude</i> will present in the returned {@code List}.
     *
     * @param <T>
     * @param c
     * @param objsToExclude
     * @return a new {@code List}
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> excludeAll(final Collection<? extends T> c, final Collection<?> objsToExclude) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        } else if (isEmpty(objsToExclude)) {
            return new ArrayList<>(c);
        } else if (objsToExclude.size() == 1) {
            return exclude(c, firstOrNullIfEmpty(objsToExclude));
        }

        final Set<Object> set = objsToExclude instanceof Set ? ((Set<Object>) objsToExclude) : new HashSet<>(objsToExclude);
        final List<T> result = new ArrayList<>(max(0, c.size() - set.size()));

        for (final T e : c) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new {@code Set} with specified <i>objsToExclude</i> excluded.
     * That's to say no more value from <i>objsToExclude</i> will present in the returned {@code Set}.
     *
     * @param <T>
     * @param c
     * @param objsToExclude
     * @return a new {@code Set}
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Collection)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> Set<T> excludeAllToSet(final Collection<? extends T> c, final Collection<?> objsToExclude) {
        if (isEmpty(c)) {
            return new HashSet<>();
        } else if (isEmpty(objsToExclude)) {
            return new HashSet<>(c);
        } else if (objsToExclude.size() == 1) {
            return excludeToSet(c, firstOrNullIfEmpty(objsToExclude));
        }

        final Set<Object> set = objsToExclude instanceof Set ? ((Set<Object>) objsToExclude) : new HashSet<>(objsToExclude);
        final Set<T> result = c instanceof List || c instanceof LinkedHashSet ? newLinkedHashSet(max(0, c.size() - set.size()))
                : newHashSet(max(0, c.size() - set.size()));

        for (final T e : c) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns {@code true} if <i>subColl</i> is a sub-collection of <i>coll</i>,
     * that is, if the cardinality of <i>e</i> in <i>subColl</i> is less than or
     * equal to the cardinality of <i>e</i> in <i>coll</i>, for each element <i>e</i>
     * in <i>subColl</i>.
     *
     * @param subColl the first (sub?) collection, must not be null
     * @param coll the second (super?) collection, must not be null
     * @return {@code true} if <i>subColl</i> is a sub-collection of <i>coll</i>
     * @throws IllegalArgumentException if {@code subColl} or {@code coll} is {@code null}
     * @see #isProperSubCollection
     * @see Collection#containsAll
     */
    public static boolean isSubCollection(@NotNull final Collection<?> subColl, @NotNull final Collection<?> coll) throws IllegalArgumentException {
        checkArgNotNull(subColl, cs.subColl);
        checkArgNotNull(coll, cs.coll);

        if (isEmpty(subColl)) {
            return true;
        } else if (isEmpty(coll)) {
            return false;
        }

        if (subColl.size() > coll.size()) {
            return false;
        }

        final Multiset<?> multisetA = Multiset.create(subColl);
        final Multiset<?> multisetB = Multiset.create(coll);

        for (final Object e : multisetA.elementSet()) {
            if (multisetA.occurrencesOf(e) > multisetB.occurrencesOf(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if <i>subColl</i> is a <i>proper</i> sub-collection of <i>coll</i>,
     * that is, if the cardinality of <i>e</i> in <i>subColl</i> is less
     * than or equal to the cardinality of <i>e</i> in <i>coll</i>,
     * for each element <i>e</i> in <i>subColl</i>, and there is at least one
     * element <i>f</i> such that the cardinality of <i>f</i> in <i>coll</i>
     * is strictly greater than the cardinality of <i>f</i> in <i>subColl</i>.
     * <p>
     * The implementation assumes
     * </p>
     * <ul>
     *    <li>{@code subColl.size()} and {@code coll.size()} represent the
     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>
     *    <li><code>subColl.size() &lt; Integer.MAXVALUE</code></li>
     * </ul>
     *
     * @param subColl the first (sub?) collection, must not be null
     * @param coll the second (super?) collection, must not be null
     * @return {@code true} if <i>subColl</i> is a <i>proper</i> sub-collection of <i>coll</i>
     * @throws IllegalArgumentException if {@code subColl} or {@code coll} is {@code null}
     * @see #isSubCollection
     * @see Collection#containsAll
     */
    public static boolean isProperSubCollection(@NotNull final Collection<?> subColl, final @NotNull Collection<?> coll) throws IllegalArgumentException {
        checkArgNotNull(subColl, cs.subColl);
        checkArgNotNull(coll, cs.coll);

        return subColl.size() < coll.size() && isSubCollection(subColl, coll);
    }

    /**
     * Returns {@code true} if the given {@link Collection}s contain
     * exactly the same elements with exactly the same cardinalities.
     * <p>
     * That is, if the cardinality of <i>e</i> in <i>a</i> is
     * equal to the cardinality of <i>e</i> in <i>b</i>,
     * for each element <i>e</i> in <i>a</i> or <i>b</i>.
     * </p>
     *
     * @param a the first collection
     * @param b the second collection
     * @return {@code true} if the collections contain the same elements with the same cardinalities.
     */
    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {
        if (a == null && b == null) {
            return true;
        } else if ((a == null) == (b != null)) { //NOSONAR
            return false;
        }

        final int sizeA = size(a);
        final int sizeB = size(b);

        if (sizeA != sizeB) {
            return false;
        }

        final Multiset<?> multisetA = Multiset.create(a);
        final Multiset<?> multisetB = Multiset.create(b);

        if (multisetA.size() != multisetB.size()) {
            return false;
        }

        for (final Object e : multisetA.elementSet()) {
            if (multisetA.occurrencesOf(e) != multisetB.occurrencesOf(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Replaces all occurrences of a specified boolean value in the given boolean array with another specified boolean value.
     *
     * @param a The boolean array in which replacements are to be made.
     * @param oldVal The boolean value to be replaced.
     * @param newVal The boolean value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final boolean[] a, final boolean oldVal, final boolean newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified char value in the given char array with another specified char value.
     *
     * @param a The char array in which replacements are to be made.
     * @param oldVal The char value to be replaced.
     * @param newVal The char value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final char[] a, final char oldVal, final char newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified byte value in the given byte array with another specified byte value.
     *
     * @param a The byte array in which replacements are to be made.
     * @param oldVal The byte value to be replaced.
     * @param newVal The byte value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final byte[] a, final byte oldVal, final byte newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified short value in the given short array with another specified short value.
     *
     * @param a The short array in which replacements are to be made.
     * @param oldVal The short value to be replaced.
     * @param newVal The short value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final short[] a, final short oldVal, final short newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified int value in the given int array with another specified int value.
     *
     * @param a The int array in which replacements are to be made.
     * @param oldVal The int value to be replaced.
     * @param newVal The int value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final int[] a, final int oldVal, final int newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified long value in the given long array with another specified long value.
     *
     * @param a The long array in which replacements are to be made.
     * @param oldVal The long value to be replaced.
     * @param newVal The long value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final long[] a, final long oldVal, final long newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified float value in the given float array with another specified float value.
     *
     * @param a The float array in which replacements are to be made.
     * @param oldVal The float value to be replaced.
     * @param newVal The float value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final float[] a, final float oldVal, final float newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (Float.compare(a[i], oldVal) == 0) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified double value in the given double array with another specified double value.
     *
     * @param a The double array in which replacements are to be made.
     * @param oldVal The double value to be replaced.
     * @param newVal The double value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static int replaceAll(final double[] a, final double oldVal, final double newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (Double.compare(a[i], oldVal) == 0) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified value in the given array with another specified value.
     *
     * @param <T> The type of elements in the array.
     * @param a The array in which replacements are to be made.
     * @param oldVal The value to be replaced.
     * @param newVal The value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static <T> int replaceAll(final T[] a, final Object oldVal, final T newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        if (oldVal == null) {
            for (int i = 0, len = a.length; i < len; i++) {
                if (a[i] == null) {
                    a[i] = newVal;

                    result++;
                }
            }
        } else {
            for (int i = 0, len = a.length; i < len; i++) {
                if (equals(a[i], oldVal)) {
                    a[i] = newVal;

                    result++;
                }
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of a specified value in the given list with another specified value.
     *
     * @param <T> The type of elements in the list.
     * @param list The list in which replacements are to be made.
     * @param oldVal The value to be replaced.
     * @param newVal The value to replace all occurrences of the oldVal.
     * @return The number of replacements made.
     */
    public static <T> int replaceAll(final List<T> list, final Object oldVal, final T newVal) {
        if (isEmpty(list)) {
            return 0;
        }

        int result = 0;

        final int size = list.size();

        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
            if (oldVal == null) {
                for (int i = 0; i < size; i++) {
                    if (list.get(i) == null) {
                        list.set(i, newVal);

                        result++;
                    }
                }
            } else {
                for (int i = 0; i < size; i++) {
                    if (oldVal.equals(list.get(i))) {
                        list.set(i, newVal);

                        result++;
                    }
                }
            }
        } else {
            final ListIterator<T> itr = list.listIterator();

            if (oldVal == null) {
                for (int i = 0; i < size; i++) {
                    if (itr.next() == null) {
                        itr.set(newVal);

                        result++;
                    }
                }
            } else {
                for (int i = 0; i < size; i++) {
                    if (oldVal.equals(itr.next())) {
                        itr.set(newVal);

                        result++;
                    }
                }
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given boolean array according to the provided unary operator.
     *
     * @param a The boolean array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final boolean[] a, final BooleanUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsBoolean(a[i]);
        }
    }

    /**
     * Replaces all elements in the given char array according to the provided unary operator.
     *
     * @param a The char array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final char[] a, final CharUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsChar(a[i]);
        }
    }

    /**
     * Replaces all elements in the given byte array according to the provided unary operator.
     *
     * @param a The byte array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final byte[] a, final ByteUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsByte(a[i]);
        }
    }

    /**
     * Replaces all elements in the given short array according to the provided unary operator.
     *
     * @param a The short array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final short[] a, final ShortUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsShort(a[i]);
        }
    }

    /**
     * Replaces all elements in the given int array according to the provided unary operator.
     *
     * @param a The int array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final int[] a, final IntUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsInt(a[i]);
        }
    }

    /**
     * Replaces all elements in the given long array according to the provided unary operator.
     *
     * @param a The long array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final long[] a, final LongUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsLong(a[i]);
        }
    }

    /**
     * Replaces all elements in the given float array according to the provided unary operator.
     *
     * @param a The float array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final float[] a, final FloatUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsFloat(a[i]);
        }
    }

    /**
     * Replaces all elements in the given double array according to the provided unary operator.
     *
     * @param a The double array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static void replaceAll(final double[] a, final DoubleUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsDouble(a[i]);
        }
    }

    /**
     * Replaces all elements in the given array according to the provided unary operator.
     *
     * @param <T> The type of elements in the array.
     * @param a The array to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static <T> void replaceAll(final T[] a, final UnaryOperator<T> operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.apply(a[i]);
        }
    }

    /**
     * Replaces all elements in the given list according to the provided unary operator.
     *
     * @param <T> The type of elements in the list.
     * @param list The list to be modified.
     * @param operator The operator used to determine the new values.
     */
    public static <T> void replaceAll(final List<T> list, final UnaryOperator<T> operator) {
        if (isEmpty(list)) {
            return;
        }

        final int size = list.size();

        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
            for (int i = 0; i < size; i++) {
                list.set(i, operator.apply(list.get(i)));
            }
        } else {
            final ListIterator<T> itr = list.listIterator();

            for (int i = 0; i < size; i++) {
                itr.set(operator.apply(itr.next()));
            }
        }
    }

    /**
     * Replaces all elements in the given boolean array that satisfy the provided predicate with a specified boolean value.
     *
     * @param a The boolean array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The boolean value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final boolean[] a, final BooleanPredicate predicate, final boolean newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given char array that satisfy the provided predicate with a specified char value.
     *
     * @param a The char array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The char value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final char[] a, final CharPredicate predicate, final char newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given byte array that satisfy the provided predicate with a specified byte value.
     *
     * @param a The byte array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The byte value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final byte[] a, final BytePredicate predicate, final byte newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given short array that satisfy the provided predicate with a specified short value.
     *
     * @param a The short array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The short value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final short[] a, final ShortPredicate predicate, final short newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given int array that satisfy the provided predicate with a specified int value.
     *
     * @param a The int array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The int value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final int[] a, final IntPredicate predicate, final int newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given long array that satisfy the provided predicate with a specified long value.
     *
     * @param a The long array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The long value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final long[] a, final LongPredicate predicate, final long newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given float array that satisfy the provided predicate with a specified float value.
     *
     * @param a The float array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The float value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final float[] a, final FloatPredicate predicate, final float newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given double array that satisfy the provided predicate with a specified double value.
     *
     * @param a The double array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The double value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static int replaceIf(final double[] a, final DoublePredicate predicate, final double newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given array that satisfy the provided predicate with a specified value.
     *
     * @param <T> The type of elements in the array.
     * @param a The array to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static <T> int replaceIf(final T[] a, final Predicate<? super T> predicate, final T newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the given list that satisfy the provided predicate with a specified value.
     *
     * @param <T> The type of elements in the list.
     * @param c The list to be modified.
     * @param predicate The predicate used to determine which elements should be replaced.
     * @param newValue The value to replace all elements that satisfy the predicate.
     * @return The number of replacements made.
     */
    public static <T> int replaceIf(final List<T> c, final Predicate<? super T> predicate, final T newValue) {
        if (isEmpty(c)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = c.size(); i < n; i++) {
            if (predicate.test(c.get(i))) {
                c.set(i, newValue);
                result++;
            }
        }

        return result;
    }

    /**
     * A fake/unsupported method defined to remind user to use {@code replaceAll} when {@code update/updateAll/updateIf} is searched.
     *
     * @throws UnsupportedOperationException
     * @see #replaceAll(Object[], com.landawn.abacus.util.UnaryOperator)
     * @see #replaceAll(Object[], Object, Object)
     * @deprecated use {@code replaceAll}
     */
    @Deprecated
    public static void updateAllUsingReplaceAllInstead() throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Fake method. Please use 'replaceAll'");
    }

    /**
     * A fake/unsupported method defined to remind user to use {@code replaceIf} when {@code update/updateAll/updateIf} is searched.
     *
     * @throws UnsupportedOperationException
     * @see #replaceIf(Object[], com.landawn.abacus.util.Predicate, Object)
     * @deprecated use {@code replaceIf}
     */
    @Deprecated
    public static void updateIfUsingReplaceIfInstead() throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Fake method. Please use 'replaceIf'");
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original boolean array.
     * @param elementToAdd The boolean element to be added to the array.
     * @return A new boolean array containing the original elements and the added element.
     */
    public static boolean[] add(final boolean[] a, final boolean elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final boolean[] newArray = new boolean[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original char array.
     * @param elementToAdd The char element to be added to the array.
     * @return A new char array containing the original elements and the added element.
     */
    public static char[] add(final char[] a, final char elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final char[] newArray = new char[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original byte array.
     * @param elementToAdd The byte element to be added to the array.
     * @return A new byte array containing the original elements and the added element.
     */
    public static byte[] add(final byte[] a, final byte elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final byte[] newArray = new byte[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original short array.
     * @param elementToAdd The short element to be added to the array.
     * @return A new short array containing the original elements and the added element.
     */
    public static short[] add(final short[] a, final short elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final short[] newArray = new short[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original int array.
     * @param elementToAdd The int element to be added to the array.
     * @return A new int array containing the original elements and the added element.
     */
    public static int[] add(final int[] a, final int elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final int[] newArray = new int[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original long array.
     * @param elementToAdd The long element to be added to the array.
     * @return A new long array containing the original elements and the added element.
     */
    public static long[] add(final long[] a, final long elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final long[] newArray = new long[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original float array.
     * @param elementToAdd The float element to be added to the array.
     * @return A new float array containing the original elements and the added element.
     */
    public static float[] add(final float[] a, final float elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final float[] newArray = new float[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original double array.
     * @param elementToAdd The double element to be added to the array.
     * @return A new double array containing the original elements and the added element.
     */
    public static double[] add(final double[] a, final double elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final double[] newArray = new double[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The original String array.
     * @param elementToAdd The String element to be added to the array.
     * @return A new String array containing the original elements and the added element.
     */
    public static String[] add(final String[] a, final String elementToAdd) {
        if (isEmpty(a)) {
            return asArray(elementToAdd);
        }

        final String[] newArray = new String[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> The type of elements in the array.
     * @param a The original array.
     * @param elementToAdd The element to be added to the array.
     * @return A new array containing the original elements and the added element.
     * @throws IllegalArgumentException if the original array is {@code null}.
     */
    public static <T> T[] add(@NotNull final T[] a, final T elementToAdd) throws IllegalArgumentException {
        checkArgNotNull(a, cs.a);

        final int len = a.length;
        final T[] newArray = (T[]) Array.newInstance(a.getClass().getComponentType(), len + 1);

        if (len > 0) {
            copy(a, 0, newArray, 0, len);
        }

        newArray[len] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new boolean array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static boolean[] addAll(final boolean[] a, final boolean... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_BOOLEAN_ARRAY : elementsToAdd.clone();
        }

        final boolean[] newArray = new boolean[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new char array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static char[] addAll(final char[] a, final char... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_CHAR_ARRAY : elementsToAdd.clone();
        }

        final char[] newArray = new char[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new byte array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static byte[] addAll(final byte[] a, final byte... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_BYTE_ARRAY : elementsToAdd.clone();
        }

        final byte[] newArray = new byte[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new short array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static short[] addAll(final short[] a, final short... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_SHORT_ARRAY : elementsToAdd.clone();
        }

        final short[] newArray = new short[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new int array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static int[] addAll(final int[] a, final int... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_INT_ARRAY : elementsToAdd.clone();
        }

        final int[] newArray = new int[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new long array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static long[] addAll(final long[] a, final long... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_LONG_ARRAY : elementsToAdd.clone();
        }

        final long[] newArray = new long[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new float array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static float[] addAll(final float[] a, final float... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_FLOAT_ARRAY : elementsToAdd.clone();
        }

        final float[] newArray = new float[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new double array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static double[] addAll(final double[] a, final double... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_DOUBLE_ARRAY : elementsToAdd.clone();
        }

        final double[] newArray = new double[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The first array whose elements are added to the new array.
     * @param elementsToAdd The additional elements to be added to the new array.
     * @return A new String array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    @SafeVarargs
    public static String[] addAll(final String[] a, final String... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_STRING_ARRAY : elementsToAdd.clone();
        }

        final String[] newArray = new String[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> The type of elements in the array.
     * @param a The original array.
     * @param elementsToAdd The elements to be added to the array.
     * @return A new array containing the original elements and the added elements.
     * @throws IllegalArgumentException if the input array <i>a</i> and <i>elementsToAdd</i> both are {@code null}.
     */
    @SafeVarargs
    public static <T> T[] addAll(@NotNull final T[] a, final T... elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(a, cs.a);

        if (isEmpty(a)) {
            return elementsToAdd == null ? a.clone() : elementsToAdd.clone();
        }

        final T[] newArray = (T[]) Array.newInstance(a.getClass().getComponentType(), a.length + elementsToAdd.length);

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to a given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The original collection.
     * @param elementsToAdd The elements to be added to the collection.
     * @return A boolean indicating if the collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    public static <T> boolean addAll(@NotNull final Collection<T> c, final T... elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (isEmpty(elementsToAdd)) {
            return false;
        }

        return c.addAll(Array.asList(elementsToAdd));
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to a given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The original collection where elements are to be added.
     * @param elementsToAdd The collection of elements to be added to the original collection.
     * @return A boolean indicating if the original collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    public static <T> boolean addAll(@NotNull final Collection<T> c, final Iterable<? extends T> elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (elementsToAdd == null) {
            return false;
        }

        if (elementsToAdd instanceof final Collection coll) { // NOSONAR
            return c.addAll(coll);
        } else {
            return addAll(c, elementsToAdd.iterator());
        }
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to a given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The original collection where elements are to be added.
     * @param elementsToAdd The iterator of elements to be added to the original collection.
     * @return A boolean indicating if the original collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    public static <T> boolean addAll(@NotNull final Collection<T> c, final Iterator<? extends T> elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (elementsToAdd == null) {
            return false;
        }

        boolean wasModified = false;

        while (elementsToAdd.hasNext()) {
            wasModified |= c.add(elementsToAdd.next());
        }

        return wasModified;
    }

    /**
     * Inserts a boolean value into a given boolean array at a specified index.
     * The method creates a new array, copies the original array into it, then adds the new element at the specified index.
     * The original array remains unchanged.
     *
     * @param a the original boolean array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the char value to be inserted into the array
     * @return a new char array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static boolean[] insert(final boolean[] a, final int index, final boolean elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final boolean[] newArray = new boolean[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original char array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the boolean value to be inserted into the array
     * @return a new boolean array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static char[] insert(final char[] a, final int index, final char elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final char[] newArray = new char[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original byte array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the byte value to be inserted into the array
     * @return a new byte array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static byte[] insert(final byte[] a, final int index, final byte elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final byte[] newArray = new byte[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original short array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the short value to be inserted into the array
     * @return a new short array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static short[] insert(final short[] a, final int index, final short elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final short[] newArray = new short[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original int array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the int value to be inserted into the array
     * @return a new int array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static int[] insert(final int[] a, final int index, final int elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final int[] newArray = new int[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original long array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the long value to be inserted into the array
     * @return a new long array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static long[] insert(final long[] a, final int index, final long elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final long[] newArray = new long[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original float array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the float value to be inserted into the array
     * @return a new float array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static float[] insert(final float[] a, final int index, final float elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final float[] newArray = new float[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original double array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the double value to be inserted into the array
     * @return a new double array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static double[] insert(final double[] a, final int index, final double elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final double[] newArray = new double[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original String array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the String value to be inserted into the array
     * @return a new String array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static String[] insert(final String[] a, final int index, final String elementToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return asArray(elementToInsert);
        }

        final String[] newArray = new String[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of the elements in the array
     * @param a the original array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the element to be inserted into the array
     * @return a new array with the original elements and the inserted element
     * @throws IllegalArgumentException if the original array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    public static <T> T[] insert(@NotNull final T[] a, final int index, final T elementToInsert) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a) + 1);

        final T[] newArray = newArray(a.getClass().getComponentType(), a.length + 1);

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param list
    //     * @param index
    //     * @param elementToInsert
    //     * @throws IllegalArgumentException
    //     */
    //    public static <T> void insert(@NotNull final List<T> list, final int index, final T elementToInsert) throws IllegalArgumentException {
    //        checkArgNotNull(list, "list");
    //
    //        list.add(index, elementToInsert);
    //    }

    /**
     * Returns a new String with chars copied from the specified String and the specified String inserted at the specified index.
     * <br />
     * The original String remains unchanged.
     *
     * @param str the original string
     * @param index the position in the string where the new string should be inserted
     * @param strToInsert the string to be inserted into the original string
     * @return a new string with the original characters and the inserted string
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > str.length())
     */
    public static String insert(final String str, final int index, final String strToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(str) + 1);

        if (Strings.isEmpty(strToInsert)) {
            return Strings.nullToEmpty(str);
        } else if (Strings.isEmpty(str)) {
            return Strings.nullToEmpty(strToInsert);
        } else if (index == str.length()) {
            return Strings.concat(str + strToInsert);
        }

        return str;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static boolean[] insertAll(final boolean[] a, final int index, final boolean... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final boolean[] newArray = new boolean[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static char[] insertAll(final char[] a, final int index, final char... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final char[] newArray = new char[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static byte[] insertAll(final byte[] a, final int index, final byte... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final byte[] newArray = new byte[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static short[] insertAll(final short[] a, final int index, final short... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final short[] newArray = new short[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static int[] insertAll(final int[] a, final int index, final int... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final int[] newArray = new int[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static long[] insertAll(final long[] a, final int index, final long... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final long[] newArray = new long[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static float[] insertAll(final float[] a, final int index, final float... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final float[] newArray = new float[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static double[] insertAll(final double[] a, final int index, final double... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final double[] newArray = new double[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static String[] insertAll(final String[] a, final int index, final String... elementsToInsert) throws IndexOutOfBoundsException {
        checkIndex(index, len(a) + 1);

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        }

        final String[] newArray = new String[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IllegalArgumentException if the specified {@code Array} is {@code null}.
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > a.length)
     */
    @SafeVarargs
    public static <T> T[] insertAll(@NotNull final T[] a, final int index, final T... elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a) + 1);

        final T[] newArray = (T[]) Array.newInstance(a.getClass().getComponentType(), a.length + elementsToInsert.length);

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Inserts the specified elements at the specified position in the list.
     * Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
     *
     * @param <T> the type of elements in the list
     * @param list the list to insert into
     * @param index the position in the list where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the list
     * @return {@code true} if the list changed as a result of the call
     * @throws IllegalArgumentException if the list is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > list.size())
     */
    @SafeVarargs
    public static <T> boolean insertAll(@NotNull final List<T> list, final int index, final T... elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(list, cs.list);
        checkIndex(index, size(list) + 1);

        if (isEmpty(elementsToInsert)) {
            return false;
        }

        return list.addAll(index, asList(elementsToInsert));
    }

    /**
     * Inserts the specified elements at the specified position in the list.
     * Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
     *
     * @param <T> the type of elements in the list
     * @param list the list to insert into
     * @param index the position in the list where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the list
     * @return {@code true} if the list changed as a result of the call
     * @throws IllegalArgumentException if the list is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > list.size())
     */
    public static <T> boolean insertAll(@NotNull final List<T> list, final int index, final Collection<? extends T> elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(list, cs.list);
        checkIndex(index, size(list) + 1);

        if (isEmpty(elementsToInsert)) {
            return false;
        }

        return list.addAll(index, elementsToInsert);
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original boolean array
     * @param index the position of the element to be removed
     * @return a new boolean array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static boolean[] deleteByIndex(@NotNull final boolean[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final boolean[] result = new boolean[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original char array
     * @param index the position of the element to be removed
     * @return a new char array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static char[] deleteByIndex(@NotNull final char[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final char[] result = new char[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original byte array
     * @param index the position of the element to be removed
     * @return a new byte array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static byte[] deleteByIndex(@NotNull final byte[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final byte[] result = new byte[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original short array
     * @param index the position of the element to be removed
     * @return a new short array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static short[] deleteByIndex(@NotNull final short[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final short[] result = new short[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original int array
     * @param index the position of the element to be removed
     * @return a new int array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static int[] deleteByIndex(@NotNull final int[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final int[] result = new int[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original long array
     * @param index the position of the element to be removed
     * @return a new long array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static long[] deleteByIndex(@NotNull final long[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final long[] result = new long[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original float array
     * @param index the position of the element to be removed
     * @return a new float array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static float[] deleteByIndex(@NotNull final float[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final float[] result = new float[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original double array
     * @param index the position of the element to be removed
     * @return a new double array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static double[] deleteByIndex(@NotNull final double[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final double[] result = new double[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position of the element to be removed
     * @return a new array containing the existing elements except the element at the specified index
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 || index >= a.length)
     */
    public static <T> T[] deleteByIndex(@NotNull final T[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkIndex(index, len(a));

        final T[] result = newArray(a.getClass().getComponentType(), a.length - 1);

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param list
    //     * @param index
    //     * @return
    //     * @throws IllegalArgumentException
    //     */
    //    public static <T> T delete(@NotNull final List<T> list, final int index) throws IllegalArgumentException {
    //        checkArgNotNull(list, "list");
    //
    //        return list.remove(index);
    //    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input boolean array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new boolean array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static boolean[] deleteAllByIndices(final boolean[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_BOOLEAN_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final boolean[] result = new boolean[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input char array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new char array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static char[] deleteAllByIndices(final char[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_CHAR_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final char[] result = new char[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input byte array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new byte array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static byte[] deleteAllByIndices(final byte[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_BYTE_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final byte[] result = new byte[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input short array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new short array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static short[] deleteAllByIndices(final short[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_SHORT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final short[] result = new short[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input int array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new int array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static int[] deleteAllByIndices(final int[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_INT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final int[] result = new int[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input long array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new long array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static long[] deleteAllByIndices(final long[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_LONG_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final long[] result = new long[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input float array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new float array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static float[] deleteAllByIndices(final float[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_FLOAT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final float[] result = new float[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input double array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new double array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static double[] deleteAllByIndices(final double[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_DOUBLE_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        final int lastIndex = indices[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex); //NOSONAR
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final double[] result = new double[arrayLen - diff];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input String array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new String array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static String[] deleteAllByIndices(final String[] a, int... indices) throws IndexOutOfBoundsException {
        if (isEmpty(indices)) {
            return a == null ? EMPTY_STRING_ARRAY : a.clone();
        } else if (indices.length == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        return deleteAllBySortedIndices(a, indices);
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the input array from which elements are to be removed
     * @param indices the indices of the elements to be removed
     * @return a new array containing the remaining elements after removal
     * @throws IllegalArgumentException if the input array is {@code null}
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    @SafeVarargs
    public static <T> T[] deleteAllByIndices(@NotNull final T[] a, int... indices) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);

        if (isEmpty(indices)) {
            return a.clone();
        } else if (indices.length == 1) {
            return deleteByIndex(a, indices[0]);
        }

        indices = indices.clone();
        sort(indices);

        return deleteAllBySortedIndices(a, indices);
    }

    private static <T> T[] deleteAllBySortedIndices(final T[] a, final int[] indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;
        final int lastIndex = indices[countOfIndex - 1];

        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex);
        }

        int diff = 1;
        for (int i = 1, len = countOfIndex; i < len; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            diff++;
        }

        final T[] result = newArray(a.getClass().getComponentType(), arrayLen - diff);
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Removes the elements at the specified positions from the specified List.
     *
     * @param list
     * @param indices
     * @return
     * @throws IllegalArgumentException
     */
    @SuppressWarnings("rawtypes")
    @SafeVarargs
    public static boolean deleteAllByIndices(@NotNull final List<?> list, int... indices) throws IllegalArgumentException {
        checkArgNotNull(list);

        if (isEmpty(indices)) {
            return false;
        } else if (indices.length == 1) {
            list.remove(indices[0]);
            return true;
        }

        indices = indices.clone();
        sort(indices);

        if (indices[0] < 0 || indices[indices.length - 1] >= list.size()) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + indices[indices.length - 1]);
        }

        if (list instanceof LinkedList) {
            final Iterator<?> iterator = list.iterator();

            int idx = -1;
            for (int i = 0, len = indices.length; i < len; i++) {
                if (i > 0 && indices[i] == indices[i - 1]) {
                    continue;
                }

                while (idx < indices[i]) {
                    idx++;
                    iterator.next();
                }

                iterator.remove();
            }
        } else {
            final Object[] a = list.toArray();
            final Object[] res = deleteAllBySortedIndices(a, indices);
            list.clear();
            list.addAll((List) Arrays.asList(res));
        }

        return true;
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static boolean[] remove(final boolean[] a, final boolean valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] remove(final char[] a, final char valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] remove(final byte[] a, final byte valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] remove(final short[] a, final short valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] remove(final int[] a, final int valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] remove(final long[] a, final long valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] remove(final float[] a, final float valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] remove(final double[] a, final double valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] remove(final String[] a, final String valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with elements copied from the specified array except the first occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] remove(final T[] a, final T valueToRemove) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return a;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Removes the first occurrence of the specified value from the given collection.
     *
     * @param c The collection from which the value should be removed.
     * @param valueToRemove The value to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean remove(final Collection<T> c, final T valueToRemove) {
        if (isEmpty(c)) {
            return false;
        }

        return c.remove(valueToRemove);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static boolean[] removeAll(final boolean[] a, final boolean... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final BooleanList list = BooleanList.of(a.clone());
        list.removeAll(BooleanList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static char[] removeAll(final char[] a, final char... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final CharList list = CharList.of(a.clone());
        list.removeAll(CharList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static byte[] removeAll(final byte[] a, final byte... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final ByteList list = ByteList.of(a.clone());
        list.removeAll(ByteList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static short[] removeAll(final short[] a, final short... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final ShortList list = ShortList.of(a.clone());
        list.removeAll(ShortList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static int[] removeAll(final int[] a, final int... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final IntList list = IntList.of(a.clone());
        list.removeAll(IntList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static long[] removeAll(final long[] a, final long... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final LongList list = LongList.of(a.clone());
        list.removeAll(LongList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static float[] removeAll(final float[] a, final float... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final FloatList list = FloatList.of(a.clone());
        list.removeAll(FloatList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static double[] removeAll(final double[] a, final double... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final DoubleList list = DoubleList.of(a.clone());
        list.removeAll(DoubleList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static String[] removeAll(final String[] a, final String... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final Set<String> set = asSet(valuesToRemove);
        final List<String> result = new ArrayList<>();

        for (final String e : a) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result.toArray(new String[result.size()]);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the values should be removed.
     * @param valuesToRemove The values to be removed from the array.
     * @return A new array with the first occurrence of the specified value removed. The input array itself is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SafeVarargs
    public static <T> T[] removeAll(final T[] a, final T... valuesToRemove) {
        if (isEmpty(a)) {
            return a;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final Set<Object> set = asSet(valuesToRemove);
        final List<T> result = new ArrayList<>();

        for (final T e : a) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result.toArray((T[]) newArray(a.getClass().getComponentType(), result.size()));
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The collection from which the values should be removed.
     * @param valuesToRemove The values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    @SafeVarargs
    public static <T> boolean removeAll(final Collection<T> c, final T... valuesToRemove) {
        if (isEmpty(c) || isEmpty(valuesToRemove)) {
            return false;
        } else {
            return removeAll(c, asSet(valuesToRemove));
        }
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The collection from which the values should be removed.
     * @param valuesToRemove The collection of values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAll(final Collection<T> c, final Iterable<?> valuesToRemove) {
        if (isEmpty(c) || valuesToRemove == null) {
            return false;
        }

        if (c instanceof HashSet && !(valuesToRemove instanceof Set)) {
            boolean wasModified = false;

            for (final Object e : valuesToRemove) {
                wasModified |= c.remove(e);

                if (c.size() == 0) {
                    break;
                }
            }

            return wasModified;
        } else {
            if (valuesToRemove instanceof final Collection coll) { // NOSONAR
                return c.removeAll(coll);
            } else {
                return removeAll(c, valuesToRemove.iterator());
            }
        }
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The collection from which the elements should be removed.
     * @param valuesToRemove The iterator of values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAll(final Collection<T> c, final Iterator<?> valuesToRemove) {
        if (isEmpty(c) || valuesToRemove == null) {
            return false;
        }

        if (c instanceof Set) {
            final Set<T> set = (Set<T>) c;
            final int originalSize = set.size();

            while (valuesToRemove.hasNext()) {
                set.remove(valuesToRemove.next());
            }

            return set.size() != originalSize;
        } else {
            return removeAll(c, toSet(valuesToRemove));
        }
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static boolean[] removeAllOccurrences(final boolean[] a, final boolean valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] copy = a.clone();
        int idx = 0;

        for (final boolean element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] removeAllOccurrences(final char[] a, final char valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] copy = a.clone();
        int idx = 0;

        for (final char element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] removeAllOccurrences(final byte[] a, final byte valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] copy = a.clone();
        int idx = 0;

        for (final byte element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] removeAllOccurrences(final short[] a, final short valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] copy = a.clone();
        int idx = 0;

        for (final short element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] removeAllOccurrences(final int[] a, final int valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        final int[] copy = a.clone();
        int idx = 0;

        for (final int element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] removeAllOccurrences(final long[] a, final long valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] copy = a.clone();
        int idx = 0;

        for (final long element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] removeAllOccurrences(final float[] a, final float valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] copy = a.clone();
        int idx = 0;

        for (final float element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] removeAllOccurrences(final double[] a, final double valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] copy = a.clone();
        int idx = 0;

        for (final double element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] removeAllOccurrences(final String[] a, final String valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        final String[] copy = a.clone();
        int idx = 0;

        for (final String element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which the value should be removed.
     * @param valueToRemove The value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] removeAllOccurrences(final T[] a, final T valueToRemove) {
        if (isEmpty(a)) {
            return a;
        }

        final T[] copy = a.clone();
        int idx = 0;

        for (final T element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Removes all occurrences of the specified value from the given collection.
     *
     * @param <T> The type of elements in the collection.
     * @param c The collection from which the value should be removed.
     * @param valueToRemove The value to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAllOccurrences(final Collection<T> c, final T valueToRemove) {
        if (isEmpty(c)) {
            return false;
        }

        return removeAll(c, asSet(valueToRemove));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static boolean[] removeDuplicates(final boolean[] a) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return removeDuplicates(a, 0, a.length);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The boolean array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @return a new array with duplicate elements from the given array within the specified range
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static boolean[] removeDuplicates(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Boolean[] b = new Boolean[2];

        for (int i = fromIndex; i < toIndex; i++) {
            if (b[0] == null) {
                b[0] = a[i];
            } else if (b[0].booleanValue() != a[i]) {
                b[1] = a[i];
                break;
            }
        }

        return b[1] == null ? new boolean[] { b[0] } : new boolean[] { b[0], b[1] };
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] removeDuplicates(final char[] a) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] removeDuplicates(final char[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static char[] removeDuplicates(final char[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final char[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Character> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final char[] result = new char[set.size()];
                int i = 0;

                for (final char e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] removeDuplicates(final byte[] a) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] removeDuplicates(final byte[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static byte[] removeDuplicates(final byte[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final byte[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Byte> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final byte[] result = new byte[set.size()];
                int i = 0;

                for (final byte e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] removeDuplicates(final short[] a) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] removeDuplicates(final short[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static short[] removeDuplicates(final short[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final short[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Short> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final short[] result = new short[set.size()];
                int i = 0;

                for (final short e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] removeDuplicates(final int[] a) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] removeDuplicates(final int[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static int[] removeDuplicates(final int[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final int[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Integer> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final int[] result = new int[set.size()];
                int i = 0;

                for (final int e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] removeDuplicates(final long[] a) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] removeDuplicates(final long[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static long[] removeDuplicates(final long[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final long[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Long> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final long[] result = new long[set.size()];
                int i = 0;

                for (final long e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] removeDuplicates(final float[] a) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] removeDuplicates(final float[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static float[] removeDuplicates(final float[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final float[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {

            final Set<Float> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final float[] result = new float[set.size()];
                int i = 0;

                for (final float e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] removeDuplicates(final double[] a) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] removeDuplicates(final double[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static double[] removeDuplicates(final double[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final double[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Double> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final double[] result = new double[set.size()];
                int i = 0;

                for (final double e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] removeDuplicates(final String[] a) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] removeDuplicates(final String[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static String[] removeDuplicates(final String[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_STRING_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final String[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<String> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]); //NOSONAR
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final String[] result = new String[set.size()];
                int i = 0;

                for (final String e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @return a new array with all duplicates removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] removeDuplicates(final T[] a) {
        if (isEmpty(a)) {
            return a;
        }

        return removeDuplicates(a, false);
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] removeDuplicates(final T[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return a;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with duplicate elements removed within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a The array from which duplicates should be removed.
     * @param fromIndex The initial index of the range to be considered for duplicate removal.
     * @param toIndex The final index of the range to be considered for duplicate removal.
     * @param isSorted A boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return A new array with duplicates removed within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static <T> T[] removeDuplicates(final T[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return a;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final T[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final List<T> list = distinct(a, fromIndex, toIndex);
            return list.toArray((T[]) newArray(a.getClass().getComponentType(), list.size()));
        }
    }

    /**
     * Removes duplicate elements from the given collection.
     *
     * @param c The collection from which duplicates should be removed.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static boolean removeDuplicates(final Collection<?> c) {
        return removeDuplicates(c, false);
    }

    /**
     * Removes duplicate elements from the given collection.
     *
     * @param c The collection from which duplicates should be removed.
     * @param isSorted A boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    @SuppressWarnings("rawtypes")
    public static boolean removeDuplicates(final Collection<?> c, final boolean isSorted) {
        if (isEmpty(c) || c.size() == 1 || c instanceof Set) {
            return false;
        } else if (c.size() == 2) {
            final Iterator<?> iter = c.iterator();
            final Object first = iter.next();

            if (equals(first, iter.next())) {
                iter.remove();
                return true;
            } else {
                return false;
            }
        }

        if (isSorted) {
            boolean hasDuplicates = false;
            final Iterator<?> it = c.iterator();
            Object pre = it.next();
            Object next = null;
            while (it.hasNext()) {
                next = it.next();
                if (equals(next, pre)) {
                    it.remove();
                    hasDuplicates = true;
                } else {
                    pre = next;
                }
            }

            return hasDuplicates;
        } else {
            final List<?> list = distinct(c);

            final boolean hasDuplicates = list.size() != c.size();

            if (hasDuplicates) {
                c.clear();
                c.addAll((List) list);
            }

            return hasDuplicates;
        }
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static boolean[] deleteRange(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_BOOLEAN_ARRAY : a.clone();
        }

        final int len = len(a);
        final boolean[] b = new boolean[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static char[] deleteRange(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_CHAR_ARRAY : a.clone();
        }

        final int len = len(a);
        final char[] b = new char[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static byte[] deleteRange(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_BYTE_ARRAY : a.clone();
        }

        final int len = len(a);
        final byte[] b = new byte[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static short[] deleteRange(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_SHORT_ARRAY : a.clone();
        }

        final int len = len(a);
        final short[] b = new short[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static int[] deleteRange(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_INT_ARRAY : a.clone();
        }

        final int len = len(a);
        final int[] b = new int[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static long[] deleteRange(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_LONG_ARRAY : a.clone();
        }

        final int len = len(a);
        final long[] b = new long[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static float[] deleteRange(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_FLOAT_ARRAY : a.clone();
        }

        final int len = len(a);
        final float[] b = new float[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static double[] deleteRange(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_DOUBLE_ARRAY : a.clone();
        }

        final int len = len(a);
        final double[] b = new double[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static String[] deleteRange(final String[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_STRING_ARRAY : a.clone();
        }

        final int len = len(a);
        final String[] b = new String[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed
     * @throws IllegalArgumentException if the specified original {@code Array} is {@code null}.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static <T> T[] deleteRange(@NotNull final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a.clone();
        }

        final int len = len(a);
        final T[] b = Array.newInstance(a.getClass().getComponentType(), len - (toIndex - fromIndex));

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Deletes a range of elements from the given list.
     *
     * @param <T> the type of elements in the list
     * @param c the input list from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return {@code true} if the list is updated; {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of the list bounds
     */
    @SuppressWarnings({ "unchecked" })
    public static <T> boolean deleteRange(final List<T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return false;
        }

        final int size = size(c);

        if (c instanceof LinkedList || toIndex - fromIndex <= 3) {
            c.subList(fromIndex, toIndex).clear();
        } else {
            final List<T> tmp = new ArrayList<>(size - (toIndex - fromIndex));

            if (fromIndex > 0) {
                tmp.addAll(c.subList(0, fromIndex));
            }

            if (toIndex < size) {
                tmp.addAll(c.subList(toIndex, size));
            }

            c.clear();
            c.addAll(tmp);
        }

        return true;
    }

    /**
     * Returns a new String with the specified range of chars removed
     * <br />
     * The original String remains unchanged.
     *
     * @param str the input string from which a range of characters are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new string with the specified range of characters deleted. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds
     * @see Strings#deleteRange(String, int, int)
     */
    public static String deleteRange(final String str, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return Strings.deleteRange(str, fromIndex, toIndex);
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static boolean[] replaceRange(final boolean[] a, final int fromIndex, final int toIndex, final boolean[] replacement)
            throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_BOOLEAN_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final boolean[] result = new boolean[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static char[] replaceRange(final char[] a, final int fromIndex, final int toIndex, final char[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_CHAR_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final char[] result = new char[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static byte[] replaceRange(final byte[] a, final int fromIndex, final int toIndex, final byte[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_BYTE_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final byte[] result = new byte[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static short[] replaceRange(final short[] a, final int fromIndex, final int toIndex, final short[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_SHORT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final short[] result = new short[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static int[] replaceRange(final int[] a, final int fromIndex, final int toIndex, final int[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_INT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final int[] result = new int[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static long[] replaceRange(final long[] a, final int fromIndex, final int toIndex, final long[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_LONG_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final long[] result = new long[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static float[] replaceRange(final float[] a, final int fromIndex, final int toIndex, final float[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_FLOAT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final float[] result = new float[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static double[] replaceRange(final double[] a, final int fromIndex, final int toIndex, final double[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_DOUBLE_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final double[] result = new double[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static String[] replaceRange(final String[] a, final int fromIndex, final int toIndex, final String[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_STRING_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final String[] result = new String[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IllegalArgumentException if the specified original {@code Array} is {@code null}.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static <T> T[] replaceRange(@NotNull final T[] a, final int fromIndex, final int toIndex, final T[] replacement)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);

        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? a : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final T[] result = (T[]) newArray(a.getClass().getComponentType(), len - (toIndex - fromIndex) + replacement.length);

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Replaces a range of elements in the given list with the elements from the replacement collection.
     *
     * @param <T> the type of elements in the list and replacement collection
     * @param c the original list to be modified
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the collection to replace the specified range in the original list
     * @return a boolean indicating whether the list was modified
     * @throws IllegalArgumentException if the specified list is {@code null}
     * @throws IndexOutOfBoundsException if the range is out of the list bounds
     */
    public static <T> boolean replaceRange(@NotNull final List<T> c, final int fromIndex, final int toIndex, final Collection<? extends T> replacement)
            throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        final int size = size(c);

        checkFromToIndex(fromIndex, toIndex, size);

        if (isEmpty(replacement)) {
            if (fromIndex == toIndex) {
                return false;
            }

            return deleteRange(c, fromIndex, toIndex);
        }

        final List<T> endList = toIndex < size ? new ArrayList<>(c.subList(toIndex, size)) : null;

        if (fromIndex < size) {
            deleteRange(c, fromIndex, size);
        }

        c.addAll(replacement);

        if (notEmpty(endList)) {
            c.addAll(endList);
        }

        return true;
    }

    /**
     * Returns a new String with the specified range replaced with the replacement String.
     * <br />
     * The original String remains unchanged.
     *
     * @param str the original string
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the string to replace the specified range in the original string
     * @return a new string with the specified range replaced by the replacement string
     * @throws IndexOutOfBoundsException if the range is out of the string bounds
     * @see Strings#replaceRange(String, int, int, String)
     */
    public static String replaceRange(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        return Strings.replaceRange(str, fromIndex, toIndex, replacement);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final boolean[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final boolean[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final char[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final char[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final byte[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final byte[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final short[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final short[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final int[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final int[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final long[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final long[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final float[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final float[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static void moveRange(final double[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final double[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
     * @throws IndexOutOfBoundsException if the range is out of the array bounds or newPositionStartIndex is invalid
     */
    public static <T> void moveRange(final T[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return;
        }

        final T[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionStartIndex < fromIndex) {
            copy(a, newPositionStartIndex, a, toIndex - (fromIndex - newPositionStartIndex), fromIndex - newPositionStartIndex);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionStartIndex - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionStartIndex, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given list to a new position within the list.
     * <br />
     * No elements are deleted in the process, the original list maintains its size.
     *
     * @param <T> the type of elements in the list
     * @param c the original list to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, list.size() - (toIndex - fromIndex)]
     * @return {@code true} if the list was modified as a result of this operation
     * @throws IndexOutOfBoundsException if the range is out of the list bounds or newPositionStartIndex is invalid
     */
    public static <T> boolean moveRange(final List<T> c, final int fromIndex, final int toIndex, final int newPositionStartIndex)
            throws IndexOutOfBoundsException {
        final int size = size(c);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, size);

        if (fromIndex == toIndex || fromIndex == newPositionStartIndex) {
            return false;
        }

        final T[] tmp = (T[]) c.toArray();

        moveRange(tmp, fromIndex, toIndex, newPositionStartIndex);
        c.clear();
        c.addAll(Arrays.asList(tmp));

        return true;
    }

    /**
     * Returns a new string with the specified range moved to the new position.
     * <br />
     * The original String remains unchanged.
     *
     * @param str the original string to be modified
     * @param fromIndex the initial index of the range to be moved, inclusive
     * @param toIndex the final index of the range to be moved, exclusive
     * @param newPositionStartIndex must in the range: [0, String.length - (toIndex - fromIndex)]
     * @return a new string with the specified range moved to the new position
     * @throws IndexOutOfBoundsException if the range is out of the string bounds or newPositionStartIndex is invalid
     * @see Strings#moveRange(String, int, int, int)
     */
    public static String moveRange(final String str, final int fromIndex, final int toIndex, final int newPositionStartIndex) throws IndexOutOfBoundsException {
        return Strings.moveRange(str, fromIndex, toIndex, newPositionStartIndex);
    }

    static void checkIndexAndStartPositionForMoveRange(final int fromIndex, final int toIndex, final int newPositionStartIndex, final int len) {
        checkFromToIndex(fromIndex, toIndex, len);

        if (newPositionStartIndex < 0 || newPositionStartIndex > (len - (toIndex - fromIndex))) {
            throw new IndexOutOfBoundsException("newPositionStartIndex " + newPositionStartIndex + " is out-of-bounds: [0, " + (len - (toIndex - fromIndex))
                    + "=(array.length - (toIndex - fromIndex))]");
        }
    }

    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static boolean[] copyThenMoveRange(final boolean[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final boolean[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static char[] copyThenMoveRange(final char[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final char[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static byte[] copyThenMoveRange(final byte[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final byte[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static short[] copyThenMoveRange(final short[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final short[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static int[] copyThenMoveRange(final int[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final int[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static long[] copyThenMoveRange(final long[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final long[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static double[] copyThenMoveRange(final double[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final double[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static <T> T[] copyThenMoveRange(final T[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final T[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }

    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static boolean[] copyThenMoveRange(final boolean[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final boolean[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static char[] copyThenMoveRange(final char[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final char[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static byte[] copyThenMoveRange(final byte[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final byte[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static short[] copyThenMoveRange(final short[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final short[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static int[] copyThenMoveRange(final int[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final int[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static long[] copyThenMoveRange(final long[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final long[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static double[] copyThenMoveRange(final double[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final double[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static <T> T[] copyThenMoveRange(final T[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final T[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }

    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static boolean[] copyThenMoveRange(final boolean[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final boolean[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static char[] copyThenMoveRange(final char[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final char[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static byte[] copyThenMoveRange(final byte[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final byte[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static short[] copyThenMoveRange(final short[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final short[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static int[] copyThenMoveRange(final int[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final int[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static long[] copyThenMoveRange(final long[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final long[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static double[] copyThenMoveRange(final double[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final double[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }
    //
    //    /**
    //     * Returns a new array copy.
    //     *
    //     * @param a
    //     * @param fromIndex
    //     * @param toIndex
    //     * @param newPositionStartIndex must in the range: [0, array.length - (toIndex - fromIndex)]
    //     * @return a new array.
    //     */
    //    public static <T> T[] copyThenMoveRange(final T[] a, final int fromIndex, final int toIndex, final int newPositionStartIndex) {
    //        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionStartIndex, len(a)); // NOSONAR
    //
    //        final T[] copy = isEmpty(a) ? a : a.clone();
    //
    //        moveRange(copy, fromIndex, toIndex, newPositionStartIndex);
    //
    //        return copy;
    //    }

    /**
     * Returns a new array with the specified range skipped.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the original array to be modified
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @return a new array with the specified range skipped
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static <T> T[] skipRange(final T[] a, final int startInclusive, final int endExclusive) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(startInclusive, endExclusive, len);

        if (a == null) {
            return a;
        } else if (startInclusive == endExclusive) {
            return a.clone();
        }

        final T[] ret = N.newArray(a.getClass().getComponentType(), len - (endExclusive - startInclusive));

        if (startInclusive > 0) {
            N.copy(a, 0, ret, 0, startInclusive);
        }

        if (endExclusive < len) {
            N.copy(a, endExclusive, ret, startInclusive, len - endExclusive);
        }

        return ret;
    }

    /**
     * Returns a new list with the specified range skipped.
     * <br />
     * The original collection remains unchanged.
     *
     * @param <T> the type of elements in the collection
     * @param c the original collection to be modified
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @return a new list with the specified range skipped
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     */
    public static <T> List<T> skipRange(final Collection<? extends T> c, final int startInclusive, final int endExclusive) throws IndexOutOfBoundsException {
        return skipRange(c, startInclusive, endExclusive, IntFunctions.ofList());
    }

    /**
     * Returns a new collection with the specified range skipped.
     * <br />
     * The original collection remains unchanged.
     *
     * @param <T> the type of elements in the collection
     * @param <C> the type of the collection to be returned
     * @param c the original collection to be modified
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @param supplier a function that creates a new instance of the desired collection type
     * @return a new collection with the specified range skipped
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     */
    public static <T, C extends Collection<T>> C skipRange(final Collection<? extends T> c, final int startInclusive, final int endExclusive,
            final IntFunction<C> supplier) throws IndexOutOfBoundsException {
        final int size = size(c);

        checkFromToIndex(startInclusive, endExclusive, size);

        final C result = supplier.apply(size - (endExclusive - startInclusive));

        if (c instanceof List) {
            final List<T> list = (List<T>) c;

            if (startInclusive > 0) {
                result.addAll(list.subList(0, startInclusive));
            }

            if (endExclusive < size) {
                result.addAll(list.subList(endExclusive, size));
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();

            for (int i = 0; i < startInclusive; i++) {
                result.add(iter.next());
            }

            if (endExclusive < size) {
                int idx = startInclusive;

                while (idx++ < endExclusive) {
                    iter.next();
                }

                while (iter.hasNext()) {
                    result.add(iter.next());
                }
            }
        }

        return result;
    }

    // Primitive/Object array converters
    // ----------------------------------------------------------------------

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else {
            return true;
        }
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final char[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final char[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final char[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Character> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final byte[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final byte[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final byte[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Byte> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final short[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final short[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final short[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Short> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final int[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final int[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final int[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Integer> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final long[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final long[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final long[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Long> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final float[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final float[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final float[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Float> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final double[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final double[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final double[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Double> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param <T>
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static <T> boolean hasDuplicates(final T[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param <T>
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static <T> boolean hasDuplicates(final T[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static <T> boolean hasDuplicates(final T[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Object> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(hashKey(a[i]))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given collection has duplicate elements.
     *
     * @param c the collection to be checked for duplicates
     * @return {@code true} if the collection has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final Collection<?> c) {
        return hasDuplicates(c, false);
    }

    /**
     * Checks if the given collection has duplicate elements.
     *
     * @param c the collection to be checked for duplicates
     * @param isSorted a boolean that indicates if the collection is sorted. If {@code true}, the algorithm will be faster
     * @return {@code true} if the collection has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final Collection<?> c, final boolean isSorted) {
        if (isEmpty(c) || c.size() == 1) {
            return false;
        }

        if (isSorted) {
            final Iterator<?> it = c.iterator();
            Object pre = it.next();
            Object next = null;
            while (it.hasNext()) {
                next = it.next();

                if (equals(next, pre)) {
                    return true;
                }

                pre = next;
            }
        } else {
            final Set<Object> set = newHashSet(c.size());

            for (final Object e : c) {
                if (!set.add(hashKey(e))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Retains only the elements in the specified collection that are present in the specified collection of elements to keep.
     * In other words, removes from the first collection all of its elements that are not contained in the second collection.
     *
     * @param <T> the type of elements in the collections
     * @param c the collection to be modified.
     * @param objsToKeep the collection containing elements to be retained in the first collection.
     * @return {@code true} if the first collection changed as a result of the call
     */
    public static <T> boolean retainAll(final Collection<T> c, final Collection<? extends T> objsToKeep) {
        if (isEmpty(c)) {
            return false;
        } else if (isEmpty(objsToKeep)) {
            c.clear();
            return true;
        }

        if (c instanceof HashSet && !(objsToKeep instanceof Set) && (c.size() > 9 || objsToKeep.size() > 9)) {
            return c.retainAll(newHashSet(objsToKeep));
        } else {
            return c.retainAll(objsToKeep);
        }
    }

    /**
     *
     * @param obj
     * @return
     */
    static Object hashKey(final Object obj) {
        return obj == null ? NULL_MASK : (obj.getClass().isArray() ? Wrapper.of(obj) : obj);
    }

    /**
     * Calculates the sum of the given array of characters.
     * The sum is calculated by adding up the ASCII values of the characters.
     *
     * @param a the array of characters to sum. If the array is {@code null} or empty, the method returns 0.
     * @return the sum of the ASCII values of the characters in the array.
     */
    @SafeVarargs
    public static int sum(final char... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Calculates the sum of the ASCII values of the characters in the given array within the specified range.
     *
     * @param a the array of characters to sum. If the array is {@code null} or empty, the method returns 0.
     * @param fromIndex the start index, inclusive.
     * @param toIndex the end index, exclusive.
     * @return the sum of the ASCII values of the characters in the specified range of the array.
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array.
     */
    public static int sum(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Calculates the sum of the bytes in the given array.
     *
     * @param a the array of bytes to sum. If the array is {@code null} or empty, the method returns 0.
     * @return the sum of the bytes in the array.
     */
    @SafeVarargs
    public static int sum(final byte... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Calculates the sum of the bytes in the given array within the specified range.
     *
     * @param a the array of bytes to sum. If the array is {@code null} or empty, the method returns 0.
     * @param fromIndex the start index, inclusive.
     * @param toIndex the end index, exclusive.
     * @return the sum of the bytes in the specified range of the array.
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array.
     */
    public static int sum(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     *
     * @param a
     * @return a long number
     */
    @SafeVarargs
    public static int sum(final short... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int sum(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     *
     * @param a
     * @return a long number
     */
    @SafeVarargs
    public static int sum(final int... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static int sum(final int[] a, final int fromIndex, final int toIndex) {
        return Numbers.toIntExact(sumToLong(a, fromIndex, toIndex));
    }

    /**
     *
     * @param a
     * @return a long number
     */
    @SafeVarargs
    public static long sumToLong(final int... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sumToLong(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static long sumToLong(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return Numbers.toIntExact(sum);
    }

    /**
     *
     * @param a
     * @return a long number
     */
    @SafeVarargs
    public static long sum(final long... a) {
        if (isEmpty(a)) {
            return 0L;
        }

        return sum(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static long sum(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     *
     * @param a
     * @return
     */
    @SafeVarargs
    public static float sum(final float... a) {
        if (isEmpty(a)) {
            return 0f;
        }

        return sum(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static float sum(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0f;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return (float) summation.sum();
    }

    /**
     *
     * @param a
     * @return
     */
    @SafeVarargs
    public static double sumToDouble(final float... a) {
        if (isEmpty(a)) {
            return 0f;
        }

        return sumToDouble(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double sumToDouble(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0f;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.sum();
    }

    /**
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double sum(final double... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return sum(a, 0, a.length);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double sum(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.sum();
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final char... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final byte... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final short... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final int... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final long... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final float... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.average().orElseZero();
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @return a double number
     */
    @SafeVarargs
    public static double average(final double... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static double average(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.average().orElseZero();
    }

    /**
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final T[] a) {
        return sumInt(a, Fn.numToInt());
    }

    /**
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final T[] a, final int fromIndex, final int toIndex) {
        return sumInt(a, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final T[] a, final ToIntFunction<? super T> func) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return sumInt(a, 0, a.length, func);
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsInt(a[i]);
        }

        return Numbers.toIntExact(sum);
    }

    /**
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumInt(c, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                sum += func.applyAsInt(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return Numbers.toIntExact(sum);
    }

    /**
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final Iterable<? extends T> c) {
        return sumInt(c, Fn.numToInt());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        return Numbers.toIntExact(sumIntToLong(c, func));
    }

    /**
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#sumIntToLong(Iterable)
     */
    public static <T extends Number> long sumIntToLong(final Iterable<? extends T> c) {
        return sumIntToLong(c, Fn.numToInt());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#sumIntToLong(Iterable, ToIntFunction)
     */
    public static <T> long sumIntToLong(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        if (c == null) {
            return 0;
        }

        long sum = 0;

        for (final T e : c) {
            sum += func.applyAsInt(e);
        }

        return sum;
    }

    /**
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final T[] a) {
        return sumLong(a, Fn.numToLong());
    }

    /**
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final T[] a, final int fromIndex, final int toIndex) {
        return sumLong(a, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final T[] a, final ToLongFunction<? super T> func) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0L;
        }

        return sumLong(a, 0, a.length, func);
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0L;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsLong(a[i]);
        }

        return sum;
    }

    /**
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumLong(c, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0L;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsLong(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                sum += func.applyAsLong(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return sum;
    }

    /**
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final Iterable<? extends T> c) {
        return sumLong(c, Fn.numToLong());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final Iterable<? extends T> c, final ToLongFunction<? super T> func) {
        if (c == null) {
            return 0L;
        }

        long sum = 0;

        for (final T e : c) {
            sum += func.applyAsLong(e);
        }

        return sum;
    }

    /**
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final T[] a) {
        return sumDouble(a, Fn.numToDouble());
    }

    /**
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final T[] a, final int fromIndex, final int toIndex) {
        return sumDouble(a, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final T[] a, final ToDoubleFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0D;
        }

        return sumDouble(a, 0, a.length, func);
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0D;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(func.applyAsDouble(a[i]));
        }

        return summation.sum();
    }

    /**
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumDouble(c, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0D;
        }

        final KahanSummation summation = new KahanSummation();

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                summation.add(func.applyAsDouble(list.get(i)));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                summation.add(func.applyAsDouble(e));

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return summation.sum();
    }

    /**
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final Iterable<? extends T> c) {
        return sumDouble(c, Fn.numToDouble());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final Iterable<? extends T> c, final ToDoubleFunction<? super T> func) {
        if (c == null) {
            return 0D;
        }

        final Iterator<? extends T> iter = c.iterator();
        final KahanSummation summation = new KahanSummation();

        while (iter.hasNext()) {
            summation.add(func.applyAsDouble(iter.next()));
        }

        return summation.sum();
    }

    /**
     * Sums the BigInteger values in the provided iterable.
     * If the iterable is {@code null}, {@code BigInteger.ZERO} is returned.
     *
     * @param c The iterable of BigInteger values to be summed. This can be any iterable of BigInteger.
     * @return The sum of the BigInteger values in the iterable.
     * @see Iterables#sumBigInteger(Iterable)
     */
    public static BigInteger sumBigInteger(final Iterable<? extends BigInteger> c) {
        return sumBigInteger(c, Fn.identity());
    }

    /**
     * Returns the sum of the BigInteger values extracted from the elements in the provided iterable by the input {@code func} function.
     * If the iterable is {@code null}, {@code BigInteger.ZERO} is returned.
     *
     * @param <T> The type of elements in the iterable.
     * @param c The iterable of elements to be processed. This can be any iterable of type T.
     * @param func The function to be applied to each element in the iterable. This function should take an instance of type T and return a BigInteger.
     * @return The sum of the BigInteger values extracted from the elements in the iterable by the input function.
     * @see Iterables#sumBigInteger(Iterable, Function)
     */
    public static <T> BigInteger sumBigInteger(final Iterable<? extends T> c, final Function<? super T, BigInteger> func) {
        if (c == null) {
            return BigInteger.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigInteger result = BigInteger.ZERO;
        BigInteger next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                result = result.add(next);
            }
        }

        return result;
    }

    /**
     * Sums the BigDecimal values in the provided iterable.
     * If the iterable is {@code null}, {@code BigDecimal.ZERO} is returned.
     *
     * @param c The iterable of BigDecimal values to be summed. This can be any iterable of BigDecimal.
     * @return The sum of the BigDecimal values in the iterable.
     * @see Iterables#sumBigDecimal(Iterable)
     */
    public static BigDecimal sumBigDecimal(final Iterable<? extends BigDecimal> c) {
        return sumBigDecimal(c, Fn.identity());
    }

    /**
     * Returns the sum of the BigDecimal values extracted from the elements in the provided iterable by the input {@code func} function.
     * If the iterable is {@code null}, {@code BigDecimal.ZERO} is returned.
     *
     * @param <T> The type of elements in the iterable.
     * @param c The iterable of elements to be processed. This can be any iterable of type T.
     * @param func The function to be applied to each element in the iterable. This function should take an instance of type T and return a BigDecimal.
     * @return The sum of the BigDecimal values extracted from the elements in the iterable by the input function.
     * @see Iterables#sumBigDecimal(Iterable, Function)
     */
    public static <T> BigDecimal sumBigDecimal(final Iterable<? extends T> c, final Function<? super T, BigDecimal> func) {
        if (c == null) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigDecimal result = BigDecimal.ZERO;
        BigDecimal next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                result = result.add(next);
            }
        }

        return result;
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#averageInt(Number[])
     */
    public static <T extends Number> double averageInt(final T[] a) {
        return averageInt(a, Fn.numToInt());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageInt(Number[], int, int)
     */
    public static <T extends Number> double averageInt(final T[] a, final int fromIndex, final int toIndex) {
        return averageInt(a, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @see Iterables#averageInt(Object[], ToIntFunction)
     */
    public static <T> double averageInt(final T[] a, final ToIntFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageInt(a, 0, a.length, func);
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageInt(Object[], int, int, ToIntFunction)
     */
    public static <T> double averageInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsInt(a[i]);
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageInt(Collection, int, int)
     */
    public static <T extends Number> double averageInt(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageInt(c, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageInt(Collection, int, int, ToIntFunction)
     */
    public static <T> double averageInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                sum += func.applyAsInt(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#averageInt(Iterable)
     */
    public static <T extends Number> double averageInt(final Iterable<? extends T> c) {
        return averageInt(c, Fn.numToInt());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#averageInt(Iterable, ToIntFunction)
     */
    public static <T> double averageInt(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        if (c == null) {
            return 0D;
        }

        long sum = 0;
        long count = 0;

        for (final T e : c) {
            sum += func.applyAsInt(e);
            count++;
        }

        return count == 0 ? 0D : ((double) sum) / count;
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#averageLong(Number[])
     */
    public static <T extends Number> double averageLong(final T[] a) {
        return averageLong(a, Fn.numToLong());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageLong(Number[], int, int)
     */
    public static <T extends Number> double averageLong(final T[] a, final int fromIndex, final int toIndex) {
        return averageLong(a, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @see Iterables#averageLong(Object[], ToLongFunction)
     */
    public static <T> double averageLong(final T[] a, final ToLongFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageLong(a, 0, a.length, func);
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageLong(Object[], int, int, ToLongFunction)
     */
    public static <T> double averageLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sumLong(a, fromIndex, toIndex, func)) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageLong(Collection, int, int)
     */
    public static <T extends Number> double averageLong(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageLong(c, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageLong(Collection, int, int, ToLongFunction)
     */
    public static <T> double averageLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sumLong(c, fromIndex, toIndex, func)) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#averageLong(Iterable)
     */
    public static <T extends Number> double averageLong(final Iterable<? extends T> c) {
        return averageLong(c, Fn.numToLong());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#averageLong(Iterable, ToLongFunction)
     */
    public static <T> double averageLong(final Iterable<? extends T> c, final ToLongFunction<? super T> func) {
        if (c == null) {
            return 0D;
        }

        long sum = 0;
        long count = 0;

        for (final T e : c) {
            sum += func.applyAsLong(e);
            count++;
        }

        return count == 0 ? 0D : ((double) sum) / count;
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @return
     * @see Iterables#averageDouble(Number[])
     */
    public static <T extends Number> double averageDouble(final T[] a) {
        return averageDouble(a, Fn.numToDouble());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageDouble(Number[], int, int)
     */
    public static <T extends Number> double averageDouble(final T[] a, final int fromIndex, final int toIndex) {
        return averageDouble(a, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param func
     * @return
     * @see Iterables#averageDouble(Object[], ToDoubleFunction)
     */
    public static <T> double averageDouble(final T[] a, final ToDoubleFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageDouble(a, 0, a.length, func);
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageDouble(Object[], int, int, ToDoubleFunction)
     */
    public static <T> double averageDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        return Iterables.averageDouble(a, fromIndex, toIndex, func).orElseZero();
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @see Iterables#averageDouble(Collection, int, int)
     */
    public static <T extends Number> double averageDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageDouble(c, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Calculates the average of an Array/Collection within the specified range.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param func
     * @return
     * @throws IndexOutOfBoundsException
     * @see Iterables#averageDouble(Collection, int, int, ToDoubleFunction)
     */
    public static <T> double averageDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0d;
        }

        return Iterables.averageDouble(c, fromIndex, toIndex, func).orElseZero();
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @return
     * @see Iterables#averageDouble(Iterable)
     */
    public static <T extends Number> double averageDouble(final Iterable<? extends T> c) {
        return averageDouble(c, Fn.numToDouble());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#averageDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double averageDouble(final Iterable<? extends T> c, final ToDoubleFunction<? super T> func) {
        if (c == null) {
            return 0d;
        }

        return Iterables.averageDouble(c, func).orElseZero();
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param c
     * @return
     * @see Iterables#averageBigInteger(Iterable)
     */
    public static BigDecimal averageBigInteger(final Iterable<? extends BigInteger> c) {
        return averageBigInteger(c, Fn.identity());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#averageBigInteger(Iterable, Function)
     */
    public static <T> BigDecimal averageBigInteger(final Iterable<? extends T> c, final Function<? super T, BigInteger> func) {
        if (c == null) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigInteger sum = BigInteger.ZERO;
        long cnt = 0;
        BigInteger next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                sum = sum.add(next);
                cnt++;
            }
        }

        return cnt == 0 ? BigDecimal.ZERO : new BigDecimal(sum).divide(BigDecimal.valueOf(cnt));
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param c
     * @return
     * @see Iterables#averageBigDecimal(Iterable)
     */
    public static BigDecimal averageBigDecimal(final Iterable<? extends BigDecimal> c) {
        return averageBigDecimal(c, Fn.identity());
    }

    /**
     * Calculates the average of an Array/Collection.
     * <br />
     * Returns {@code 0} if the specified {@code Array/Collection} is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param func
     * @return
     * @see Iterables#averageBigDecimal(Iterable, Function)
     */
    public static <T> BigDecimal averageBigDecimal(final Iterable<? extends T> c, final Function<? super T, BigDecimal> func) {
        if (c == null) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigDecimal sum = BigDecimal.ZERO;
        long cnt = 0;
        BigDecimal next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                sum = sum.add(next);
                cnt++;
            }
        }

        return cnt == 0 ? BigDecimal.ZERO : sum.divide(BigDecimal.valueOf(cnt));
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static char min(final char a, final char b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static byte min(final byte a, final byte b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static short min(final short a, final short b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static int min(final int a, final int b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static long min(final long a, final long b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static float min(final float a, final float b) {
        return Math.min(a, b);
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static double min(final double a, final double b) {
        return Math.min(a, b);
    }

    /**
     * Returns the minimum value among the provided values based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     */
    public static <T extends Comparable<? super T>> T min(final T a, final T b) {
        return min(a, b, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the provided values according to the provided comparator.
     *
     * @param <T> the type of the objects to be compared
     * @param a the first object to be compared
     * @param b the second object to be compared
     * @param cmp the comparator to determine the order of the objects
     * @return the minimum of a and b according to the provided comparator
     */
    public static <T> T min(final T a, final T b, final Comparator<? super T> cmp) {
        if (cmp == null) {
            return ((Comparator<T>) NULL_MAX_COMPARATOR).compare(a, b) <= 0 ? a : b;
        } else {
            return cmp.compare(a, b) <= 0 ? a : b;
        }
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static char min(final char a, final char b, final char c) {
        final char m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static byte min(final byte a, final byte b, final byte c) {
        final byte m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static short min(final short a, final short b, final short c) {
        final short m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static int min(final int a, final int b, final int c) {
        final int m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long min(final long a, final long b, final long c) {
        final long m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static float min(final float a, final float b, final float c) {
        return Math.min(Math.min(a, b), c);
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static double min(final double a, final double b, final double c) {
        return Math.min(Math.min(a, b), c);
    }

    /**
     * Returns the minimum value among the three provided values based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T> the type of the values, which must be a subtype of Comparable
     * @param a the first value to compare
     * @param b the second value to compare
     * @param c the third value to compare
     * @return the minimum value among a, b, and c based on their natural ordering
     */
    public static <T extends Comparable<? super T>> T min(final T a, final T b, final T c) {
        return min(a, b, c, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the provided values according to the provided comparator.
     *
     * @param <T> the type of the values
     * @param a the first value to compare
     * @param b the second value to compare
     * @param c the third value to compare
     * @param cmp the Comparator to compare the values
     * @return the minimum value among a, b, and c based on the provided Comparator
     */
    public static <T> T min(final T a, final T b, final T c, final Comparator<? super T> cmp) {
        return min(min(a, b, cmp), c, cmp);
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static char min(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty"); //NOSONAR

        if (isEmpty(a)) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a the char array to find the minimum value from.
     * @param fromIndex the start index (inclusive) of the subarray.
     * @param toIndex the end index (exclusive) of the subarray.
     * @return the minimum value in the specified subarray of the char array.
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static char min(final char[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        char min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static byte min(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static byte min(final byte[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        byte min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static short min(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static short min(final short[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        short min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static int min(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static int min(final int[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        int min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static long min(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static long min(final long[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        long min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see IEEE754rUtil#min(float[]) IEEE754rUtils for a version of this method
     *      that handles NaN differently
     */
    @SafeVarargs
    public static float min(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static float min(final float[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        float min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            min = Math.min(min, a[i]);

            if (Float.isNaN(min)) {
                return min;
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values.
     *
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see IEEE754rUtil#min(double[]) IEEE754rUtils for a version of this
     *      method that handles NaN differently
     */
    @SafeVarargs
    public static double min(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static double min(final double[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        double min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            min = Math.min(min, a[i]);

            if (Double.isNaN(min)) {
                return min;
            }
        }

        return min;
    }

    /**
     * Returns the minimum value among the provided values based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param a
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Comparable[])
     */
    public static <T extends Comparable<? super T>> T min(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static <T extends Comparable<? super T>> T min(final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        return min(a, fromIndex, toIndex, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param a an {@code Array} which must not be {@code null} or empty
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Object[], Comparator)
     */
    public static <T> T min(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return min(a, 0, a.length, cmp);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection according to the provided comparator.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static <T> T min(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        T candidate = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (cmp.compare(a[i], candidate) < 0) {
                candidate = a[i];
            }

            if (candidate == null && cmp == NULL_MIN_COMPARATOR) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Iterable)
     */
    public static <T extends Comparable<? super T>> T min(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return min(c, fromIndex, toIndex, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection according to the provided comparator.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static <T> T min(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c) || toIndex - fromIndex < 1 || fromIndex >= c.size()) {
            throw new IllegalArgumentException("The size of collection can not be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        T candidate = null;
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            candidate = list.get(fromIndex);

            for (int i = fromIndex + 1; i < toIndex; i++) {
                e = list.get(i);

                if (cmp.compare(e, candidate) < 0) {
                    candidate = e;
                }

                if (candidate == null && cmp == NULL_MIN_COMPARATOR) { // NOSONAR
                    return null;
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex; i++) {
                if (i < fromIndex) {
                    it.next();
                } else if (i == fromIndex) {
                    candidate = it.next();
                } else {
                    e = it.next();

                    if (cmp.compare(e, candidate) < 0) {
                        candidate = e;
                    }

                    if (candidate == null && cmp == NULL_MIN_COMPARATOR) { // NOSONAR
                        return null;
                    }
                }
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum value among the provided values based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param c
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Iterable)
     */
    public static <T extends Comparable<? super T>> T min(final Iterable<? extends T> c) throws IllegalArgumentException {
        return min(c, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Iterable, Comparator)
     */
    public static <T> T min(final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return min(coll, 0, coll.size(), cmp);
        }

        final Iterator<? extends T> iter = Iterables.iterateNonEmpty(c, "The spcified Collection/Iterable/Iterator can not be null or empty"); //NOSONAR

        return min(iter, cmp);
    }

    /**
     * Returns the minimum value among the provided values based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param iter
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Iterator)
     */
    public static <T extends Comparable<? super T>> T min(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return min(iter, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the minimum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param iter
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#min(Iterator, Comparator)
     */
    public static <T> T min(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(!isEmpty(iter), "The spcified Collection/Iterable/Iterator can not be null or empty");
        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        T candidate = iter.next();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (cmp.compare(e, candidate) < 0) {
                candidate = e;
            }

            if (candidate == null && cmp == NULL_MIN_COMPARATOR) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns a list of all the minimum values in the provided values, based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T> the type of the values, which must be a subtype of Comparable
     * @param a the array to find the minimum values from
     * @return a list of the minimum values in the provided array
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final T[] a) {
        return minAll(a, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list of all the minimum values in the provided array, based on the provided comparator.
     *
     * @param <T> the type of the values
     * @param a the array to find the minimum values from
     * @param cmp the comparator to determine the order of the values
     * @return a list of the minimum values in the provided array
     */
    public static <T> List<T> minAll(final T[] a, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candicate = a[0];
        int cp = 0;

        result.add(candicate);

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], candicate);

            if (cp == 0) {
                result.add(a[i]);
            } else if (cp < 0) {
                result.clear();
                result.add(a[i]);
                candicate = a[i];
            }
        }

        return result;
    }

    /**
     * Returns a list of all the minimum values in the provided values, based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param c
     * @return
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final Iterable<? extends T> c) {
        return minAll(c, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list of all the minimum values in the provided array, based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     */
    public static <T> List<T> minAll(final Iterable<? extends T> c, final Comparator<? super T> cmp) {
        if (c == null) {
            return new ArrayList<>();
        }

        return minAll(c.iterator(), cmp);
    }

    /**
     * Returns a list of all the minimum values in the provided values, based on their natural ordering.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param iter
     * @return
     * @see Iterables#min(Iterator)
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final Iterator<? extends T> iter) {
        return maxAll(iter, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list of all the minimum values in the provided array, based on the provided comparator.
     *
     * @param <T>
     * @param iter
     * @param cmp
     * @return
     * @see Iterables#min(Iterator, Comparator)
     */
    public static <T> List<T> minAll(final Iterator<? extends T> iter, Comparator<? super T> cmp) {
        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candicate = iter.next();
        T next = null;
        int cp = 0;

        result.add(candicate);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candicate);

            if (cp == 0) {
                result.add(next);
            } else if (cp < 0) {
                result.clear();
                result.add(next);
                candicate = next;
            }
        }

        return result;
    }

    /**
     * Returns the minimum value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final T[] a, final Function<? super T, ? extends R> valueExtractor,
            final R defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        R candicate = valueExtractor.apply(a[0]);
        R next = null;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.apply(a[i]);

            if (candicate == null || (next != null && (next.compareTo(candicate) < 0))) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum value extracted from the specified collection <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>c</i> is {@code null} or empty.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final Iterable<? extends T> c,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return minOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>iter</i> is {@code null} or empty.
     * Null values are considered to be maximum.
     *
     * @param <T>
     * @param <R>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final Iterator<? extends T> iter,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        R candicate = valueExtractor.apply(iter.next());
        R next = null;

        while (iter.hasNext()) {
            next = valueExtractor.apply(iter.next());

            if (candicate == null || (next != null && (next.compareTo(candicate) < 0))) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code int} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final T[] a, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        int candicate = valueExtractor.applyAsInt(a[0]);
        int next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsInt(a[i]);

            if (next < candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code int} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final Iterable<? extends T> c, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return minIntOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum {@code int} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        int candicate = valueExtractor.applyAsInt(iter.next());
        int next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsInt(iter.next());

            if (next < candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code long} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final T[] a, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        long candicate = valueExtractor.applyAsLong(a[0]);
        long next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsLong(a[i]);

            if (next < candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code long} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final Iterable<? extends T> c, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return minLongOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum {@code long} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        long candicate = valueExtractor.applyAsLong(iter.next());
        long next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsLong(iter.next());

            if (next < candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code double} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final T[] a, final ToDoubleFunction<? super T> valueExtractor, final double defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        double candicate = valueExtractor.applyAsDouble(a[0]);
        double next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsDouble(a[i]);

            if (compare(next, candicate) < 0) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the minimum {@code double} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final Iterable<? extends T> c, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return minDoubleOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum {@code double} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        double candicate = valueExtractor.applyAsDouble(iter.next());
        double next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsDouble(iter.next());

            if (compare(next, candicate) < 0) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified array.
     *
     * @param <T> the type of the values, which must be a subtype of Comparable
     * @param a the array to find the minimum and maximum values from
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified array
     * @throws IllegalArgumentException if the specified array is {@code null} or
     * @see Iterables#minMax(Iterable)
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final T[] a) throws IllegalArgumentException {
        return minMax(a, NATURAL_COMPARATOR);
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified array, based on the provided comparator.
     *
     * @param <T> the type of the values
     * @param a the array to find the minimum and maximum values from
     * @param cmp the comparator to determine the order of the values
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified array
     * @throws IllegalArgumentException if the specified array is {@code null} or empty
     * @see Iterables#minMax(Iterable, Comparator)
     */
    public static <T> Pair<T, T> minMax(final T[] a, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        if (a.length == 1) {
            return Pair.of(a[0], a[0]);
        }

        cmp = checkComparator(cmp);

        T min = a[0];
        T max = a[0];
        int cp = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], min);

            if (cp < 0) {
                min = a[i];
            } else if ((cp > 0) && (cmp.compare(a[i], max) > 0)) {
                max = a[i];
            }
        }

        return Pair.of(min, max);
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified Iterable.
     *
     * @param <T>
     * @param c
     * @return
     * @throws IllegalArgumentException if <i>c</i> is {@code null} or empty.
     * @see Iterables#minMax(Iterable)
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final Iterable<? extends T> c) throws IllegalArgumentException {
        return minMax(c, NATURAL_COMPARATOR);
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified Iterable, based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     * @throws IllegalArgumentException if <i>c</i> is {@code null} or empty.
     * @see Iterables#minMax(Iterable, Comparator)
     */
    public static <T> Pair<T, T> minMax(@NotNull final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotNull(c, "The spcified iterable can not be null or empty");

        return minMax(c.iterator(), cmp);
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified Iterator.
     *
     * @param <T>
     * @param iter
     * @return
     * @throws IllegalArgumentException if <i>iter</i> is {@code null} or empty.
     * @see Iterables#minMax(Iterator)
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return minMax(iter, NATURAL_COMPARATOR);
    }

    /**
     * Returns a pair of the minimum and maximum values in the specified Iterator, based on the provided comparator.
     *
     * @param <T>
     * @param iter
     * @param cmp
     * @return
     * @throws IllegalArgumentException if <i>iter</i> is {@code null} or empty.
     * @see Iterables#minMax(Iterator, Comparator)
     */
    public static <T> Pair<T, T> minMax(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(iter != null && iter.hasNext(), "The spcified iterator can not be null or empty");

        cmp = checkComparator(cmp);

        T next = iter.next();
        T min = next;
        T max = next;
        int cp = 0;

        while (iter.hasNext()) {
            next = iter.next();

            cp = cmp.compare(next, min);

            if (cp < 0) {
                min = next;
            } else if ((cp > 0) && (cmp.compare(next, max) > 0)) {
                max = next;
            }
        }

        return Pair.of(min, max);
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static char max(final char a, final char b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static byte max(final byte a, final byte b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static short max(final short a, final short b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static int max(final int a, final int b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static long max(final long a, final long b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static float max(final float a, final float b) {
        return Math.max(a, b);
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @return
     */
    public static double max(final double a, final double b) {
        return Math.max(a, b);
    }

    /**
     * Returns the maximum value among the provided values based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param a
     * @param b
     * @return
     */
    public static <T extends Comparable<? super T>> T max(final T a, final T b) {
        return max(a, b, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param a
     * @param b
     * @param cmp
     * @return
     */
    public static <T> T max(final T a, final T b, final Comparator<? super T> cmp) {
        if (cmp == null) {
            return ((Comparator<T>) NULL_MIN_COMPARATOR).compare(a, b) >= 0 ? a : b;
        } else {
            return cmp.compare(a, b) >= 0 ? a : b;
        }
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static char max(final char a, final char b, final char c) {
        final char m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static byte max(final byte a, final byte b, final byte c) {
        final byte m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static short max(final short a, final short b, final short c) {
        final short m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static int max(final int a, final int b, final int c) {
        final int m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static long max(final long a, final long b, final long c) {
        final long m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static float max(final float a, final float b, final float c) {
        return Math.max(Math.max(a, b), c);
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static double max(final double a, final double b, final double c) {
        return Math.max(Math.max(a, b), c);
    }

    /**
     * Returns the maximum value among the provided values based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param a
     * @param b
     * @param c
     * @return
     */
    public static <T extends Comparable<? super T>> T max(final T a, final T b, final T c) {
        return max(a, b, c, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param a
     * @param b
     * @param c
     * @param cmp
     * @return
     */
    public static <T> T max(final T a, final T b, final T c, final Comparator<? super T> cmp) {
        return max(max(a, b, cmp), c, cmp);
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static char max(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static char max(final char[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        char max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static byte max(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static byte max(final byte[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        byte max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static short max(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static short max(final short[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        short max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static int max(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static int max(final int[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        int max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    @SafeVarargs
    public static long max(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static long max(final long[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        long max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see IEEE754rUtil#max(float[]) IEEE754rUtils for a version of this method
     *      that handles NaN differently
     */
    @SafeVarargs
    public static float max(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static float max(final float[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        float max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            max = Math.max(max, a[i]);

            if (Float.isNaN(max)) {
                return max;
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see IEEE754rUtil#max(double[]) IEEE754rUtils for a version of this
     *      method that handles NaN differently
     */
    @SafeVarargs
    public static double max(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static double max(final double[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        double max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            max = Math.max(max, a[i]);

            if (Double.isNaN(max)) {
                return max;
            }
        }

        return max;
    }

    /**
     * Returns the maximum value among the provided values based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Comparable[])
     */
    public static <T extends Comparable<? super T>> T max(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Comparable[])
     */
    public static <T extends Comparable<? super T>> T max(final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        return max(a, fromIndex, toIndex, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param a an {@code Array} which must not be {@code null} or empty
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Object[], Comparator)
     */
    public static <T> T max(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return max(a, 0, a.length, cmp);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection according to the provided comparator.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Object[], Comparator)
     */
    public static <T> T max(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        T candidate = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (cmp.compare(a[i], candidate) > 0) {
                candidate = a[i];
            }

            if (candidate == null && cmp == NULL_MAX_COMPARATOR) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum value among the given range in the specified Array/Collection based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterable)
     */
    public static <T extends Comparable<? super T>> T max(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return max(c, fromIndex, toIndex, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the given range in the specified Array/Collection according to the provided comparator.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterable, Comparator)
     */
    public static <T> T max(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c) || toIndex - fromIndex < 1 || fromIndex >= c.size()) {
            throw new IllegalArgumentException("The size of collection can not be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        T candidate = null;
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            candidate = list.get(fromIndex);

            for (int i = fromIndex + 1; i < toIndex; i++) {
                e = list.get(i);

                if (cmp.compare(e, candidate) > 0) {
                    candidate = e;
                }

                if (candidate == null && cmp == NULL_MAX_COMPARATOR) { // NOSONAR
                    return null;
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex; i++) {
                if (i < fromIndex) {
                    it.next();
                    continue;
                } else if (i == fromIndex) {
                    candidate = it.next();
                } else {
                    e = it.next();

                    if (cmp.compare(e, candidate) > 0) {
                        candidate = e;
                    }
                }

                if (candidate == null && cmp == NULL_MAX_COMPARATOR) { // NOSONAR
                    return null;
                }
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum value among the provided values based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param c
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterable)
     */
    public static <T extends Comparable<? super T>> T max(final Iterable<? extends T> c) throws IllegalArgumentException {
        return max(c, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterable, Comparator)
     */
    public static <T> T max(final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return max(coll, 0, coll.size(), cmp);
        }

        final Iterator<? extends T> iter = Iterables.iterateNonEmpty(c, "The spcified Collection/Iterable/Iterator can not be null or empty"); //NOSONAR

        return max(iter, cmp);
    }

    /**
     * Returns the maximum value among the provided values based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param iter
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterator)
     */
    public static <T extends Comparable<? super T>> T max(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return max(iter, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the maximum value among the provided values according to the provided comparator.
     *
     * @param <T>
     * @param iter
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see Iterables#max(Iterator, Comparator)
     */
    public static <T> T max(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(!isEmpty(iter), "The spcified Collection/Iterable/Iterator can not be null or empty");
        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        T candidate = iter.next();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (cmp.compare(e, candidate) > 0) {
                candidate = e;
            }

            if (candidate == null && cmp == NULL_MAX_COMPARATOR) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param a
     * @return
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final T[] a) {
        return maxAll(a, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on the provided comparator.
     *
     * @param <T>
     * @param a
     * @param cmp
     * @return
     */
    public static <T> List<T> maxAll(final T[] a, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candicate = a[0];
        int cp = 0;

        result.add(candicate);

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], candicate);

            if (cp == 0) {
                result.add(a[i]);
            } else if (cp > 0) {
                result.clear();
                result.add(a[i]);
                candicate = a[i];
            }
        }

        return result;
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param c
     * @return
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final Iterable<? extends T> c) {
        return maxAll(c, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     */
    public static <T> List<T> maxAll(final Iterable<? extends T> c, final Comparator<? super T> cmp) {
        if (c == null) {
            return new ArrayList<>();
        }

        return maxAll(c.iterator(), cmp);
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on their natural ordering.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param iter
     * @return
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final Iterator<? extends T> iter) {
        return maxAll(iter, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list of all the maximum values in the provided values, based on the provided comparator.
     *
     * @param <T>
     * @param iter
     * @param cmp
     * @return
     */
    public static <T> List<T> maxAll(final Iterator<? extends T> iter, Comparator<? super T> cmp) {
        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candicate = iter.next();
        T next = null;
        int cp = 0;

        result.add(candicate);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candicate);

            if (cp == 0) {
                result.add(next);
            } else if (cp > 0) {
                result.clear();
                result.add(next);
                candicate = next;
            }
        }

        return result;
    }

    /**
     * Returns the maximum value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final T[] a, final Function<? super T, ? extends R> valueExtractor,
            final R defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        R candicate = valueExtractor.apply(a[0]);
        R next = null;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.apply(a[i]);

            if (candicate == null || (next != null && (next.compareTo(candicate) > 0))) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum value extracted from the specified collection <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>c</i> is {@code null} or empty.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final Iterable<? extends T> c,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return maxOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>iter</i> is {@code null} or empty.
     * Null values are considered to be minimum.
     *
     * @param <T>
     * @param <R>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final Iterator<? extends T> iter,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        R candicate = valueExtractor.apply(iter.next());
        R next = null;

        while (iter.hasNext()) {
            next = valueExtractor.apply(iter.next());

            if (candicate == null || (next != null && (next.compareTo(candicate) > 0))) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code int} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final T[] a, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        int candicate = valueExtractor.applyAsInt(a[0]);
        int next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsInt(a[i]);

            if (next > candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code int} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final Iterable<? extends T> c, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return maxIntOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum {@code int} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        int candicate = valueExtractor.applyAsInt(iter.next());
        int next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsInt(iter.next());

            if (next > candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code long} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final T[] a, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        long candicate = valueExtractor.applyAsLong(a[0]);
        long next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsLong(a[i]);

            if (next > candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code long} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final Iterable<? extends T> c, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return maxLongOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum {@code long} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        long candicate = valueExtractor.applyAsLong(iter.next());
        long next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsLong(iter.next());

            if (next > candicate) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code double} value extracted from the specified array <i>a</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param a
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final T[] a, final ToDoubleFunction<? super T> valueExtractor, final double defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        double candicate = valueExtractor.applyAsDouble(a[0]);
        double next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsDouble(a[i]);

            if (compare(next, candicate) > 0) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the maximum {@code double} value extracted from the specified iterable <i>c</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param c
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final Iterable<? extends T> c, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (c == null) {
            return defaultValue;
        }

        return maxDoubleOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum {@code double} value extracted from the specified iterator <i>iter</i> by {@code valueExtractor}, or {@code defaultValue} if <i>a</i> is {@code null} or empty.
     *
     * @param <T>
     * @param iter
     * @param valueExtractor
     * @param defaultValue
     * @return
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (iter == null || iter.hasNext() == false) {
            return defaultValue;
        }

        double candicate = valueExtractor.applyAsDouble(iter.next());
        double next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsDouble(iter.next());

            if (compare(next, candicate) > 0) {
                candicate = next;
            }
        }

        return candicate;
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static char median(final char a, final char b, final char c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static byte median(final byte a, final byte b, final byte c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static short median(final short a, final short b, final short c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static int median(final int a, final int b, final int c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static long median(final long a, final long b, final long c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static float median(final float a, final float b, final float c) {
        final int ab = Float.compare(a, b);
        final int ac = Float.compare(a, c);
        int bc = 0;

        if ((ab >= 0 && ac <= 0) || (ac >= 0 && ab <= 0)) {
            return a;
        } else if ((((bc = Float.compare(b, c)) <= 0) && ab <= 0) || (bc >= 0 && ab >= 0)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static double median(final double a, final double b, final double c) {
        final int ab = Double.compare(a, b);
        final int ac = Double.compare(a, c);
        int bc = 0;

        if ((ab >= 0 && ac <= 0) || (ac >= 0 && ab <= 0)) {
            return a;
        } else if ((((bc = Double.compare(b, c)) <= 0) && ab <= 0) || (bc >= 0 && ab >= 0)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of provided values.
     *
     * @param <T>
     * @param a
     * @param b
     * @param c
     * @return
     * @see #median(int...)
     */
    public static <T extends Comparable<? super T>> T median(final T a, final T b, final T c) {
        return (T) median(a, b, c, NATURAL_COMPARATOR);
    }

    /**
     * Returns the median of the provided values based on the provided comparator.
     *
     * @param <T>
     * @param a
     * @param b
     * @param c
     * @param cmp
     * @return
     * @see #median(int...)
     */
    public static <T> T median(final T a, final T b, final T c, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        final int ab = cmp.compare(a, b);
        final int ac = cmp.compare(a, c);
        int bc = 0;

        if ((ab >= 0 && ac <= 0) || (ac >= 0 && ab <= 0)) {
            return a;
        } else if ((((bc = cmp.compare(b, c)) <= 0) && ab <= 0) || (bc >= 0 && ab >= 0)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static char median(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a the array of char values
     * @param fromIndex the start index (inclusive) of the range to consider in the array
     * @param toIndex the end index (exclusive) of the range to consider in the array
     * @return the median of the char values in the specified range of the array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     * @throws IllegalArgumentException if the specified array is {@code null} or empty, or if fromIndex equals toIndex
     */
    public static char median(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static byte median(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static byte median(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static short median(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static short median(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static int median(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static int median(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static long median(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static long median(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static float median(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static float median(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     */
    @SafeVarargs
    public static double median(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     */
    public static double median(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the specified array.
     *
     * @param <T>
     * @param a an {@code Array} which must not be {@code null} or empty
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection)
     * @see Median#of(Comparable[])
     * @see Median#of(Object[], Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection)
     * @see Median#of(Comparable[], int, int)
     * @see Median#of(Object[], int, int, Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        return (T) median(a, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the provided values based on the provided comparator.
     *
     * @param <T>
     * @param a an {@code Array} which must not be {@code null} or empty
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Comparable[])
     * @see Median#of(Object[], Comparator)
     */
    public static <T> T median(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return median(a, 0, a.length, cmp);
    }

    /**
     * Returns the median of the specified values within the given range based on the provided comparator.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Comparable[], int, int)
     * @see Median#of(Object[], int, int, Comparator)
     */
    public static <T> T median(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        cmp = checkComparator(cmp);

        final int len = toIndex - fromIndex;

        return kthLargest(a, fromIndex, toIndex, len / 2 + 1, cmp);
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the provided values based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection)
     * @see Median#of(Collection)
     * @see Median#of(Collection, Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final Collection<? extends T> c) throws IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return median(c, 0, c.size());
    }

    /**
     * Returns the median of the specified values within the given range
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException {
        return (T) median(c, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Returns the <code>length / 2 + 1</code> largest value in the provided values based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Collection)
     * @see Median#of(Collection, Comparator)
     */
    public static <T> T median(final Collection<? extends T> c, final Comparator<? super T> cmp) throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return median(c, 0, c.size(), cmp);
    }

    /**
     * Returns the median of the specified values within the given range based on the provided comparator.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param cmp
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or {@code fromIndex == toIndex}.
     * @see #median(int...)
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T> T median(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection can not be null or empty"); //NOSONAR
        }

        checkFromToIndex(fromIndex, toIndex, c.size());

        cmp = checkComparator(cmp);

        final int len = toIndex - fromIndex;

        return kthLargest(c, fromIndex, toIndex, len / 2 + 1, cmp);
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static char kthLargest(final char[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static char kthLargest(final char[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex); //NOSONAR

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Character> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek().charValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] < queue.peek().charValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static byte kthLargest(final byte[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static byte kthLargest(final byte[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Byte> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek().byteValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] < queue.peek().byteValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static short kthLargest(final short[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static short kthLargest(final short[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Short> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek().shortValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] < queue.peek().shortValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static int kthLargest(final int[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static int kthLargest(final int[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Integer> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek().intValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] < queue.peek().intValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static long kthLargest(final long[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static long kthLargest(final long[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Long> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek().longValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] < queue.peek().longValue()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static float kthLargest(final float[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static float kthLargest(final float[] a, final int fromIndex, final int toIndex, int k) throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Float> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Float.compare(a[i], queue.peek()) > 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Float.compare(a[i], queue.peek()) < 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param a
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static double kthLargest(final double[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     */
    public static double kthLargest(final double[] a, final int fromIndex, final int toIndex, int k)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Double> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Double.compare(a[i], queue.peek()) > 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> o2.compareTo(o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Double.compare(a[i], queue.peek()) < 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param <T> The type of the elements in the array. It must be a type that implements Comparable.
     * @param a The array from which to find the kth largest element.
     * @param k The position from the largest element to return.
     * @return The kth largest element from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or its length is less than k.
     * @see Iterables#kthLargest(Comparable[], int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final T[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     * @see Iterables#kthLargest(Comparable[], int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final T[] a, final int fromIndex, final int toIndex, final int k)
            throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        return kthLargest(a, fromIndex, toIndex, k, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param <T>
     * @param a
     * @param k
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     * @see Iterables#kthLargest(Object[], int, Comparator)
     */
    public static <T> T kthLargest(final T[] a, final int k, final Comparator<? super T> cmp) throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotEmpty(a, "The spcified array can not be null or empty");

        return kthLargest(a, 0, a.length, k, cmp);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param <T> The type of the elements in the array.
     * @param a The array from which to find the kth largest element.
     * @param fromIndex The start index for the range to be searched.
     * @param toIndex The end index for the range to be searched.
     * @param k The position from the largest element to return.
     * @param cmp The comparator to determine the order of the array.
     * @return The kth largest element from the array.
     * @throws IllegalArgumentException if the provided array is {@code null}, its length is less than k, or the range fromIndex to toIndex is less than k.
     * @see Iterables#kthLargest(Object[], int, Comparator)
     */
    public static <T> T kthLargest(final T[] a, final int fromIndex, final int toIndex, int k, final Comparator<? super T> cmp)
            throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The spcified array can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex, comparator);
        } else if (k == len) {
            return min(a, fromIndex, toIndex, comparator);
        }

        Queue<T> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k, comparator);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (comparator.compare(a[i], queue.peek()) > 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> comparator.compare(o2, o1));

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (comparator.compare(a[i], queue.peek()) < 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        return queue.peek();
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param <T> The type of the elements in the collection. It must be a type that implements Comparable.
     * @param c The collection from which to find the kth largest element.
     * @param k The position from the largest element to return.
     * @return The kth largest element from the collection.
     * @throws IllegalArgumentException if the provided collection is {@code null} or its size is less than k.
     * @see Iterables#kthLargest(Collection, int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final Collection<? extends T> c, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return kthLargest(c, 0, c.size(), k);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param k
     * @return
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     * @see Iterables#kthLargest(Collection, int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int k)
            throws IllegalArgumentException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection can not be null or empty");
        }

        return kthLargest(c, fromIndex, toIndex, k, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the kth largest element in the specified array/collection.
     *
     * @param <T>
     * @param c
     * @param k
     * @param cmp
     * @return
     * @throws IndexOutOfBoundsException
     * @throws IllegalArgumentException if the specified {@code Array/Collection} is {@code null} or empty, or its length/size is less than {@code k}, or {@code toIndex - fromIndex < k}.
     * @see Iterables#kthLargest(Collection, int, Comparator)
     */
    public static <T> T kthLargest(final Collection<? extends T> c, final int k, final Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotEmpty(c, "The spcified collection can not be null or empty");

        return kthLargest(c, 0, c.size(), k, cmp);
    }

    /**
     * Returns the kth largest element in the specified array/collection within the given range.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The collection from which to find the kth largest element.
     * @param fromIndex The start index for the range to be searched.
     * @param toIndex The end index for the range to be searched.
     * @param k The position from the largest element to return.
     * @param cmp The comparator to determine the order of the collection.
     * @return The kth largest element from the collection.
     * @throws IllegalArgumentException if the provided collection is {@code null}, its size is less than k, or the range fromIndex to toIndex is less than k.
     * @see Iterables#kthLargest(Collection, int, Comparator)
     */
    public static <T> T kthLargest(final Collection<? extends T> c, final int fromIndex, final int toIndex, int k, final Comparator<? super T> cmp)
            throws IllegalArgumentException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection can not be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, c == null ? 0 : c.size());
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(c, fromIndex, toIndex, comparator);
        } else if (k == len) {
            return min(c, fromIndex, toIndex, comparator);
        }

        final Iterator<? extends T> iter = c.iterator();
        Queue<T> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);
            int cursor = 0;

            while (cursor < fromIndex && iter.hasNext()) {
                cursor++;
                iter.next();
            }

            T e = null;
            while (cursor < toIndex && iter.hasNext()) {
                e = iter.next();

                if (queue.size() < k) {
                    queue.add(e);
                } else {
                    if (comparator.compare(e, queue.peek()) > 0) {
                        queue.remove();
                        queue.add(e);
                    }
                }

                cursor++;
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, (o1, o2) -> comparator.compare(o2, o1));

            int cursor = 0;

            while (cursor < fromIndex && iter.hasNext()) {
                cursor++;
                iter.next();
            }

            T e = null;
            while (cursor < toIndex && iter.hasNext()) {
                e = iter.next();

                if (queue.size() < k) {
                    queue.add(e);
                } else {
                    if (comparator.compare(e, queue.peek()) < 0) {
                        queue.remove();
                        queue.add(e);
                    }
                }

                cursor++;
            }
        }

        return queue.peek();
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return A short array containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static short[] top(final short[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @param cmp
     * @return
     */
    public static short[] top(final short[] a, final int n, final Comparator<? super Short> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative.
     */
    public static short[] top(final short[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array, sorted according to the provided comparator.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @param cmp the comparator to determine the order of the array.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative or if 'fromIndex' or 'toIndex' are out of the array's bounds.
     */
    public static short[] top(final short[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Short> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY_SHORT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Short> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Short> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Short> iter = heap.iterator();
        final short[] res = new short[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @return
     */
    public static int[] top(final int[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @param cmp
     * @return
     */
    public static int[] top(final int[] a, final int n, final Comparator<? super Integer> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative.
     */
    public static int[] top(final int[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array, sorted according to the provided comparator.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @param cmp the comparator to determine the order of the array.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative or if 'fromIndex' or 'toIndex' are out of the array's bounds.
     */
    public static int[] top(final int[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Integer> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY_INT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Integer> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Integer> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Integer> iter = heap.iterator();
        final int[] res = new int[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @return
     */
    public static long[] top(final long[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @param cmp
     * @return
     */
    public static long[] top(final long[] a, final int n, final Comparator<? super Long> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative.
     */
    public static long[] top(final long[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array, sorted according to the provided comparator.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @param cmp the comparator to determine the order of the array.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative or if 'fromIndex' or 'toIndex' are out of the array's bounds.
     */
    public static long[] top(final long[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Long> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY_LONG_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Long> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Long> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Long> iter = heap.iterator();
        final long[] res = new long[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @return
     */
    public static float[] top(final float[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a
     * @param n
     * @param cmp
     * @return
     */
    public static float[] top(final float[] a, final int n, final Comparator<? super Float> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative.
     */
    public static float[] top(final float[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from a specified range of the array, sorted according to the provided comparator.
     *
     * @param a the array to select the top elements from.
     * @param fromIndex the start index (inclusive) of the range.
     * @param toIndex the end index (exclusive) of the range.
     * @param n the number of top elements to select.
     * @param cmp the comparator to determine the order of the array.
     * @return a array containing the top <i>n</i> elements from the specified range of the input array.
     * @throws IllegalArgumentException if <i>n</i> is negative or if 'fromIndex' or 'toIndex' are out of the array's bounds.
     */
    public static float[] top(final float[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Float> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY_FLOAT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Float> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Float> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Float> iter = heap.iterator();
        final float[] res = new float[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return An array containing the top <i>n</i> elements from the original array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static double[] top(final double[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, a copy of the input array is returned.
     *
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements. If {@code null}, the natural ordering of the elements will be used.
     * @return An array containing the top <i>n</i> elements from the original array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static double[] top(final double[] a, final int n, final Comparator<? super Double> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on their natural ordering.
     * The elements are selected from the specified range (fromIndex, toIndex) in the array.
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned array.
     *
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the array from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the array to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return An array containing the top <i>n</i> elements from the original array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static double[] top(final double[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on the provided comparator.
     * The elements are selected from the specified range (fromIndex, toIndex) in the array.
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned array.
     *
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the array from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the array to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @return An array containing the top <i>n</i> elements from the original array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static double[] top(final double[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Double> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Double> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Double> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Double> iter = heap.iterator();
        final double[] res = new double[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, all the elements will be included to returned list.
     *
     * @param <T> The type of the elements in the array. It must be a type that implements Comparable.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int n) {
        return top(a, n, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array.
     * If there are less than <i>n</i> elements in the array, all the elements will be included to returned list.
     *
     * @param <T> The type of the elements in the array.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The Comparator to determine the order of the elements.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final T[] a, final int n, final Comparator<? super T> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on their natural ordering.
     * If there are less than <i>n</i> elements in the range specified by {@code fromIndex} and {@code toIndex}, all the elements from that range will be included to returned list.
     *
     * @param <T> The type of the elements in the array. It must be a type that implements Comparable.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index for the range to be searched.
     * @param toIndex The end index for the range to be searched.
     * @param n The number of top elements to return.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n) {
        return top(a, fromIndex, toIndex, n, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on the provided comparator.
     * The elements are selected from the range specified by {@code fromIndex} and {@code toIndex}.
     * If there are less than <i>n</i> elements in the range, all the elements from that range will be included in the returned list.
     *
     * @param <T> The type of the elements in the array.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index for the range to be searched.
     * @param toIndex The end index for the range to be searched.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    @SuppressWarnings("deprecation")
    public static <T> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            return toList(a, fromIndex, toIndex);
        }

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<T> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        return InternalUtil.createList((T[]) heap.toArray(EMPTY_OBJECT_ARRAY));
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on natural ordering of the elements.
     * The elements are selected based on their natural ordering (from smallest to largest). If there are less than <i>n</i> elements in the collection,
     * all the elements from the collection will be included in the returned list.
     *
     * @param <T> The type of the elements in the collection. The type must be a subclass of {@link Comparable}.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int n) {
        return top(c, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the provided comparator.
     * The elements are selected based on the order determined by the comparator. If there are less than <i>n</i> elements in the collection,
     * all the elements from the collection will be included in the returned list.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int n, final Comparator<? super T> cmp) {
        return top(c, 0, size(c), n, cmp);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on natural ordering of the elements.
     * The elements are selected based on their natural ordering (from smallest to largest). If there are less than <i>n</i> elements in the collection,
     * all the elements from the collection will be included in the returned list.
     *
     * @param <T> The type of the elements in the collection. The type must be a subclass of {@link Comparable}.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the collection from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the collection to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n) {
        return top(c, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the provided comparator.
     * The elements are selected based on the order determined by the comparator. If there are less than <i>n</i> elements in the collection,
     * all the elements from the collection will be included in the returned list.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the collection from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the collection to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    @SuppressWarnings("deprecation")
    public static <T> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            if (fromIndex == 0 && toIndex == c.size()) {
                return new ArrayList<>(c);
            } else {
                final List<T> res = new ArrayList<>(toIndex - fromIndex);
                final Iterator<? extends T> iter = c.iterator();
                T e = null;

                for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                    e = iter.next();

                    if (i < fromIndex) {
                        continue;
                    }

                    res.add(e);
                }

                return res;
            }
        }

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<T> heap = new PriorityQueue<>(n, comparator);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), e) < 0) {
                        heap.poll();
                        heap.add(e);
                    }
                } else {
                    heap.offer(e);
                }
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();
            T e = null;

            for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                e = iter.next();

                if (i < fromIndex) {
                    continue;
                }

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), e) < 0) {
                        heap.poll();
                        heap.add(e);
                    }
                } else {
                    heap.offer(e);
                }
            }
        }

        return InternalUtil.createList((T[]) heap.toArray(EMPTY_OBJECT_ARRAY));
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on natural ordering of the elements.
     * The elements are selected based on their natural ordering (from smallest to largest). If there are less than <i>n</i> elements in the array,
     * all the elements from the array will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the array if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the array. The type must be a subclass of {@link Comparable}.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the array is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int n, final boolean keepEncounterOrder) {
        return top(a, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on the provided comparator.
     * The elements are selected based on the order determined by the comparator. If there are less than <i>n</i> elements in the array,
     * all the elements from the array will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the array if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the array.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the array is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final T[] a, final int n, final Comparator<? super T> cmp, final boolean keepEncounterOrder) {
        return top(a, 0, len(a), n, cmp, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on the natural ordering of the elements.
     * The elements are selected from the specified range in the array (from 'fromIndex' inclusive to 'toIndex' exclusive).
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the array if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the array. The type must be a subclass of {@link Comparable}.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index (inclusive) in the array to consider for the operation.
     * @param toIndex The end index (exclusive) in the array to consider for the operation.
     * @param n The number of top elements to return.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the array is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the specified range in the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n,
            final boolean keepEncounterOrder) {
        return top(a, fromIndex, toIndex, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided array, based on the provided comparator.
     * The elements are selected from the specified range in the array (from 'fromIndex' inclusive to 'toIndex' exclusive).
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the array if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the array.
     * @param a The array from which to find the top <i>n</i> elements.
     * @param fromIndex The start index (inclusive) in the array to consider for the operation.
     * @param toIndex The end index (exclusive) in the array to consider for the operation.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the array is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the specified range in the array.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp,
            final boolean keepEncounterOrder) throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (!keepEncounterOrder) {
            return top(a, fromIndex, toIndex, n, cmp);
        }

        if (n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            return toList(a, fromIndex, toIndex);
        }

        final Comparator<Indexed<T>> comparator = createComparatorForIndexedObject(cmp);

        final Queue<Indexed<T>> heap = new PriorityQueue<>(n, comparator);
        Indexed<T> indexed = null;

        for (int i = fromIndex; i < toIndex; i++) {
            indexed = Indexed.of(a[i], i);

            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), indexed) < 0) {
                    heap.poll();
                    heap.add(indexed);
                }
            } else {
                heap.offer(indexed);
            }
        }

        final Indexed<T>[] arrayOfIndexed = heap.toArray(new Indexed[heap.size()]);

        sort(arrayOfIndexed, (Comparator<Indexed<T>>) (o1, o2) -> o1.index() - o2.index());

        final List<T> res = new ArrayList<>(arrayOfIndexed.length);

        for (final Indexed<T> element : arrayOfIndexed) {
            res.add(element.value());
        }

        return res;
    }

    @SuppressWarnings("rawtypes")
    private static <T> Comparator<Indexed<T>> createComparatorForIndexedObject(final Comparator<? super T> cmp) {
        Comparator<Indexed<T>> pairCmp = null;

        if (cmp != null) {
            final Comparator<? super T> cmp2 = cmp;
            pairCmp = (a, b) -> cmp2.compare(a.value(), b.value());
        } else {
            final Comparator<Indexed<Comparable>> tmp = (a, b) -> compare(a.value(), b.value());
            pairCmp = (Comparator) tmp;
        }

        return pairCmp;
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the natural ordering of the elements.
     * The elements are selected based on their natural ordering (from smallest to largest). If there are less than <i>n</i> elements in the Collection,
     * all the elements from the array will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the collection if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the collection. The type must be a subclass of {@link Comparable}.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the collection is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int n, final boolean keepEncounterOrder) {
        return top(c, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the provided comparator.
     * The elements are selected based on their ordering defined by the comparator (from smallest to largest). If there are less than <i>n</i> elements in the Collection,
     * all the elements from the collection will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the collection if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the collection is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int n, final Comparator<? super T> cmp, final boolean keepEncounterOrder) {
        return top(c, 0, size(c), n, cmp, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the natural ordering of the elements.
     * The elements are selected from the specified range (fromIndex, toIndex) in the collection.
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the collection if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the collection. The type must be a subclass of {@link Comparable}.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the collection from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the collection to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the collection is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n,
            final boolean keepEncounterOrder) {
        return top(c, fromIndex, toIndex, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top <i>n</i> elements from the provided collection, based on the provided comparator.
     * The elements are selected from the specified range (fromIndex, toIndex) in the collection.
     * If there are less than <i>n</i> elements in the specified range, all the elements from the range will be included in the returned list.
     * The order of the elements in the returned list is based on their encounter order in the collection if 'keepEncounterOrder' is {@code true}.
     *
     * @param <T> The type of the elements in the collection.
     * @param c The collection from which to find the top <i>n</i> elements.
     * @param fromIndex The start index in the collection from which to select the top <i>n</i> elements.
     * @param toIndex The end index in the collection to which to select the top <i>n</i> elements.
     * @param n The number of top elements to return.
     * @param cmp The comparator to determine the order of the elements.
     * @param keepEncounterOrder If {@code true}, the encounter order of the elements in the collection is preserved in the returned list.
     * @return A list containing the top <i>n</i> elements from the collection.
     * @throws IllegalArgumentException if the specified <i>n</i> is negative.
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp,
            final boolean keepEncounterOrder) throws IllegalArgumentException {
        checkArgNotNegative(n, cs.n);

        if (!keepEncounterOrder) {
            return top(c, fromIndex, toIndex, n, cmp);
        }

        if (n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            if (fromIndex == 0 && toIndex == c.size()) {
                return new ArrayList<>(c);
            } else {
                final List<T> res = new ArrayList<>(toIndex - fromIndex);
                final Iterator<? extends T> iter = c.iterator();
                T e = null;

                for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                    e = iter.next();

                    if (i < fromIndex) {
                        continue;
                    }

                    res.add(e);
                }

                return res;
            }
        }

        final Comparator<Indexed<T>> comparator = createComparatorForIndexedObject(cmp);

        final Queue<Indexed<T>> heap = new PriorityQueue<>(n, comparator);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            Indexed<T> indexed = null;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                indexed = Indexed.of(e, i);

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), indexed) < 0) {
                        heap.poll();
                        heap.add(indexed);
                    }
                } else {
                    heap.offer(indexed);
                }
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();
            Indexed<T> indexed = null;
            T e = null;

            for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                e = iter.next();

                if (i < fromIndex) {
                    continue;
                }

                indexed = Indexed.of(e, i);

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), indexed) < 0) {
                        heap.poll();
                        heap.add(indexed);
                    }
                } else {
                    heap.offer(indexed);
                }
            }
        }

        final Indexed<T>[] arrayOfIndexed = heap.toArray(new Indexed[heap.size()]);

        sort(arrayOfIndexed, (Comparator<Indexed<T>>) (o1, o2) -> o1.index() - o2.index());

        final List<T> res = new ArrayList<>(arrayOfIndexed.length);

        for (final Indexed<T> element : arrayOfIndexed) {
            res.add(element.value());
        }

        return res;
    }

    /**
     * Calculates the percentiles of the provided sorted array of characters.
     *
     * @param sortedArray The sorted array of characters for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding characters from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Character> percentiles(final char[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty"); //NOSONAR

        final int len = sortedArray.length;
        final Map<Percentage, Character> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of bytes.
     *
     * @param sortedArray The sorted array of bytes for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding bytes from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Byte> percentiles(final byte[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Byte> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of shorts.
     *
     * @param sortedArray The sorted array of shorts for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding shorts from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Short> percentiles(final short[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Short> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of integers.
     *
     * @param sortedArray The sorted array of integers for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding integers from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Integer> percentiles(final int[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Integer> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of longs.
     *
     * @param sortedArray The sorted array of longs for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding longs from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Long> percentiles(final long[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Long> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of floats.
     *
     * @param sortedArray The sorted array of floats for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding floats from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Float> percentiles(final float[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Float> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of doubles.
     *
     * @param sortedArray The sorted array of doubles for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding doubles from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Double> percentiles(final double[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Double> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array.
     *
     * @param <T> The type of elements in the array.
     * @param sortedArray The array for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding elements from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty.
     */
    public static <T> Map<Percentage, T> percentiles(final T[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The spcified 'sortedArray' can not be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, T> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted list.
     *
     * @param <T> The type of elements in the list.
     * @param sortedList The sorted list for which to calculate the percentiles.
     * @return A map where the keys are the percentiles and the values are the corresponding elements from the list.
     * @throws IllegalArgumentException if the provided list is {@code null} or empty.
     */
    public static <T> Map<Percentage, T> percentiles(final List<T> sortedList) throws IllegalArgumentException {
        checkArgNotEmpty(sortedList, "The spcified 'sortedList' can not be null or empty");

        final int size = sortedList.size();
        final Map<Percentage, T> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedList.get((int) (size * p.doubleValue())));
        }

        return m;
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static boolean[] filter(final boolean[] a, final BooleanPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param max
     * @param filter
     * @return
     */
    public static boolean[] filter(final boolean[] a, final int max, final BooleanPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static boolean[] filter(final boolean[] a, final int fromIndex, final int toIndex, final BooleanPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static boolean[] filter(final boolean[] a, final int fromIndex, final int toIndex, final BooleanPredicate filter, final int max)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] result = new boolean[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static char[] filter(final char[] a, final CharPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static char[] filter(final char[] a, final CharPredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static char[] filter(final char[] a, final int fromIndex, final int toIndex, final CharPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static char[] filter(final char[] a, final int fromIndex, final int toIndex, final CharPredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] result = new char[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static byte[] filter(final byte[] a, final BytePredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static byte[] filter(final byte[] a, final BytePredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static byte[] filter(final byte[] a, final int fromIndex, final int toIndex, final BytePredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static byte[] filter(final byte[] a, final int fromIndex, final int toIndex, final BytePredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] result = new byte[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static short[] filter(final short[] a, final ShortPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static short[] filter(final short[] a, final ShortPredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static short[] filter(final short[] a, final int fromIndex, final int toIndex, final ShortPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static short[] filter(final short[] a, final int fromIndex, final int toIndex, final ShortPredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] result = new short[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static int[] filter(final int[] a, final IntPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static int[] filter(final int[] a, final IntPredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static int[] filter(final int[] a, final int fromIndex, final int toIndex, final IntPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static int[] filter(final int[] a, final int fromIndex, final int toIndex, final IntPredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        int[] result = new int[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static long[] filter(final long[] a, final LongPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static long[] filter(final long[] a, final LongPredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static long[] filter(final long[] a, final int fromIndex, final int toIndex, final LongPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static long[] filter(final long[] a, final int fromIndex, final int toIndex, final LongPredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        long[] result = new long[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static float[] filter(final float[] a, final FloatPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static float[] filter(final float[] a, final FloatPredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static float[] filter(final float[] a, final int fromIndex, final int toIndex, final FloatPredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static float[] filter(final float[] a, final int fromIndex, final int toIndex, final FloatPredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] result = new float[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @return
     */
    public static double[] filter(final double[] a, final DoublePredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     *
     *
     * @param a
     * @param filter
     * @param max
     * @return
     * @throws IllegalArgumentException
     */
    public static double[] filter(final double[] a, final DoublePredicate filter, final int max) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     *
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static double[] filter(final double[] a, final int fromIndex, final int toIndex, final DoublePredicate filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max maximum return result.
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static double[] filter(final double[] a, final int fromIndex, final int toIndex, final DoublePredicate filter, final int max)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] result = new double[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to filter
     * @param filter the predicate to apply to each element in the array
     * @return a list containing the elements of the array that match the predicate
     */
    public static <T> List<T> filter(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return filter(a, filter, Integer.MAX_VALUE);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T>
     * @param <C>
     * @param a
     * @param filter
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final Predicate<? super T> filter, final IntFunction<C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return filter(a, filter, Integer.MAX_VALUE, supplier);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T>
     * @param a
     * @param filter
     * @param max
     * @return
     */
    public static <T> List<T> filter(final T[] a, final Predicate<? super T> filter, final int max) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return filter(a, 0, a.length, filter, max);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T>
     * @param <C>
     * @param a
     * @param filter
     * @param max
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final Predicate<? super T> filter, final int max, final IntFunction<C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return filter(a, 0, a.length, filter, max, supplier);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static <T> List<T> filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     * Returns a list of values filtered by the specified predicate.
     *
     * @param <T>
     * @param <C>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter,
            final IntFunction<C> supplier) {
        return filter(a, fromIndex, toIndex, filter, Integer.MAX_VALUE, supplier);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max
     * @return
     */
    public static <T> List<T> filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter, final int max) {
        return filter(a, fromIndex, toIndex, filter, max, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <C>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max
     * @param supplier
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter, final int max,
            final IntFunction<C> supplier) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(min(9, max, (toIndex - fromIndex)));

        for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
            if (filter.test(a[i])) {
                result.add(a[i]);
                cnt++;
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param filter
     * @return
     */
    public static <T> List<T> filter(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        return filter(c, filter, Integer.MAX_VALUE);
    }

    /**
     *
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param filter
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C filter(final Iterable<? extends T> c, final Predicate<? super T> filter, final IntFunction<C> supplier) {
        return filter(c, filter, Integer.MAX_VALUE, supplier);
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param filter
     * @param max
     * @return
     */
    public static <T> List<T> filter(final Iterable<? extends T> c, final Predicate<? super T> filter, final int max) {
        return filter(c, filter, max, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param filter
     * @param max
     * @param supplier
     * @return
     * @throws IllegalArgumentException
     */
    public static <T, C extends Collection<T>> C filter(final Iterable<? extends T> c, final Predicate<? super T> filter, final int max,
            final IntFunction<C> supplier) throws IllegalArgumentException {
        if (c == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getMinSize(c));
        int count = 0;

        for (final T e : c) {
            if (filter.test(e)) {
                result.add(e);

                if (++count == max) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     */
    public static <T> List<T> filter(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Predicate<? super T> filter) {
        return filter(c, fromIndex, toIndex, filter, Integer.MAX_VALUE);
    }

    /**
     *
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C filter(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Predicate<? super T> filter, final IntFunction<C> supplier) {
        return filter(c, fromIndex, toIndex, filter, Integer.MAX_VALUE, supplier);
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max
     * @return
     */
    public static <T> List<T> filter(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Predicate<? super T> filter,
            final int max) {
        return filter(c, fromIndex, toIndex, filter, max, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @param max
     * @param supplier
     * @return
     * @throws IllegalArgumentException
     * @throws IndexOutOfBoundsException
     */
    public static <T, C extends Collection<T>> C filter(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Predicate<? super T> filter, final int max, final IntFunction<C> supplier) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(min(9, max, (toIndex - fromIndex)));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || (fromIndex == toIndex && fromIndex < c.size())) {
            return result;
        }

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            T e = null;

            for (int i = fromIndex, cnt = 0; i < toIndex && cnt < max; i++) {
                e = list.get(i);

                if (filter.test(e)) {
                    result.add(e);
                    cnt++;
                }
            }
        } else {
            int idx = 0;
            int cnt = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                if (filter.test(e)) {
                    result.add(e);

                    if (++cnt >= max) {
                        break;
                    }
                }

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param iter
    //     * @param filter
    //     * @return
    //     * @see {@code Iterators.filter(Iterator, Predicate)}
    //     */
    //    public static <T> List<T> filter(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
    //        return filter(iter, 0, Integer.MAX_VALUE, filter);
    //    }
    //
    //    public static <T> List<T> filter(final Iterator<? extends T> iter, final Predicate<? super T> filter, final int max)
    //            {
    //        return filter(iter, 0, Integer.MAX_VALUE, filter, max);
    //    }
    //
    //    public static <T> List<T> filter(final Iterator<? extends T> iter, final int fromIndex, final int toIndex,
    //            final Predicate<? super T> filter) {
    //        checkFromToIndex(fromIndex, toIndex, Integer.MAX_VALUE);
    //
    //        if (iter == null || fromIndex == toIndex) {
    //            return new ArrayList<>();
    //        }
    //
    //        final List<T> result = new ArrayList<>(min(9, toIndex - fromIndex));
    //        int idx = 0;
    //        T e = null;
    //
    //        while (iter.hasNext()) {
    //            e = iter.next();
    //
    //            if (idx++ < fromIndex) {
    //                continue;
    //            }
    //
    //            if (filter.test(e)) {
    //                result.add(e);
    //            }
    //
    //            if (idx >= toIndex) {
    //                break;
    //            }
    //        }
    //
    //        return result;
    //    }
    //
    //    public static <T> List<T> filter(final Iterator<? extends T> iter, final int fromIndex, final int toIndex,
    //            final Predicate<? super T> filter, final int max) {
    //        checkFromToIndex(fromIndex, toIndex, Integer.MAX_VALUE);
    //
    //        if (iter == null || fromIndex == toIndex) {
    //            return new ArrayList<>();
    //        }
    //
    //        final List<T> result = new ArrayList<>(min(9, max, (toIndex - fromIndex)));
    //        int idx = 0;
    //        int cnt = 0;
    //        T e = null;
    //
    //        while (iter.hasNext()) {
    //            e = iter.next();
    //
    //            if (idx++ < fromIndex) {
    //                continue;
    //            }
    //
    //            if (filter.test(e)) {
    //                result.add(e);
    //
    //                if (++cnt >= max) {
    //                    break;
    //                }
    //            }
    //
    //            if (idx >= toIndex) {
    //                break;
    //            }
    //        }
    //
    //        return result;
    //    }

    /**
     * Map to boolean.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> boolean[] mapToBoolean(final T[] a, final ToBooleanFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return mapToBoolean(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> boolean[] mapToBoolean(final T[] a, final int fromIndex, final int toIndex, final ToBooleanFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] result = new boolean[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsBoolean(a[i]);
        }

        return result;
    }

    /**
     * Map to boolean.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> boolean[] mapToBoolean(final Collection<? extends T> c, final ToBooleanFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return mapToBoolean(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> boolean[] mapToBoolean(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToBooleanFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] result = new boolean[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsBoolean(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsBoolean(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Map to char.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> char[] mapToChar(final T[] a, final ToCharFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return mapToChar(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> char[] mapToChar(final T[] a, final int fromIndex, final int toIndex, final ToCharFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] result = new char[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsChar(a[i]);
        }

        return result;
    }

    /**
     * Map to char.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> char[] mapToChar(final Collection<? extends T> c, final ToCharFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_CHAR_ARRAY;
        }

        return mapToChar(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> char[] mapToChar(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToCharFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] result = new char[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsChar(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsChar(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Map to byte.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> byte[] mapToByte(final T[] a, final ToByteFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return mapToByte(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> byte[] mapToByte(final T[] a, final int fromIndex, final int toIndex, final ToByteFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] result = new byte[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsByte(a[i]);
        }

        return result;
    }

    /**
     * Map to byte.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> byte[] mapToByte(final Collection<? extends T> c, final ToByteFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_BYTE_ARRAY;
        }

        return mapToByte(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> byte[] mapToByte(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToByteFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] result = new byte[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsByte(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsByte(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Map to short.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> short[] mapToShort(final T[] a, final ToShortFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return mapToShort(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> short[] mapToShort(final T[] a, final int fromIndex, final int toIndex, final ToShortFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] result = new short[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsShort(a[i]);
        }

        return result;
    }

    /**
     * Map to short.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> short[] mapToShort(final Collection<? extends T> c, final ToShortFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_SHORT_ARRAY;
        }

        return mapToShort(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> short[] mapToShort(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToShortFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] result = new short[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsShort(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsShort(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Map to int.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> int[] mapToInt(final T[] a, final ToIntFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return mapToInt(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> int[] mapToInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        final int[] result = new int[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Map to int.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> int[] mapToInt(final Collection<? extends T> c, final ToIntFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_INT_ARRAY;
        }

        return mapToInt(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> int[] mapToInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        final int[] result = new int[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsInt(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static int[] mapToInt(final long[] a, final LongToIntFunction mapper) {
        if (a == null) {
            return EMPTY_INT_ARRAY;
        }

        final int len = len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static int[] mapToInt(final double[] a, final DoubleToIntFunction mapper) {
        if (a == null) {
            return EMPTY_INT_ARRAY;
        }

        final int len = len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Map to long.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> long[] mapToLong(final T[] a, final ToLongFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return mapToLong(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> long[] mapToLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] result = new long[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Map to long.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> long[] mapToLong(final Collection<? extends T> c, final ToLongFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_LONG_ARRAY;
        }

        return mapToLong(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> long[] mapToLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] result = new long[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsLong(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsLong(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static long[] mapToLong(final int[] a, final IntToLongFunction mapper) {
        if (a == null) {
            return EMPTY_LONG_ARRAY;
        }

        final int len = len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static long[] mapToLong(final double[] a, final DoubleToLongFunction mapper) {
        if (a == null) {
            return EMPTY_LONG_ARRAY;
        }

        final int len = len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Map to float.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> float[] mapToFloat(final T[] a, final ToFloatFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return mapToFloat(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> float[] mapToFloat(final T[] a, final int fromIndex, final int toIndex, final ToFloatFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] result = new float[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsFloat(a[i]);
        }

        return result;
    }

    /**
     * Map to float.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> float[] mapToFloat(final Collection<? extends T> c, final ToFloatFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return mapToFloat(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> float[] mapToFloat(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToFloatFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] result = new float[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsFloat(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsFloat(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Map to double.
     *
     * @param <T>
     * @param a
     * @param mapper
     * @return
     */
    public static <T> double[] mapToDouble(final T[] a, final ToDoubleFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return mapToDouble(a, 0, a.length, mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> double[] mapToDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] result = new double[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Map to double.
     *
     * @param <T>
     * @param c
     * @param mapper
     * @return
     */
    public static <T> double[] mapToDouble(final Collection<? extends T> c, final ToDoubleFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return mapToDouble(c, 0, c.size(), mapper);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> double[] mapToDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] result = new double[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsDouble(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsDouble(e);

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static double[] mapToDouble(final int[] a, final IntToDoubleFunction mapper) {
        if (a == null) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int len = len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     *
     *
     * @param a
     * @param mapper
     * @return
     */
    @Beta
    public static double[] mapToDouble(final long[] a, final LongToDoubleFunction mapper) {
        if (a == null) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int len = len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Transforms an array of elements into a list by applying a given function to each element.
     *
     * @param <T> The type of the elements in the input array.
     * @param <R> The type of the elements in the resulting list.
     * @param a The input array to be transformed. Must not be {@code null}.
     * @param mapper The function to apply to each element in the input array. Must not be {@code null}.
     * @return A list containing the transformed elements.
     */
    public static <T, R> List<R> map(final T[] a, final Function<? super T, ? extends R> mapper) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return map(a, 0, a.length, mapper);
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param mapper
     * @param supplier
     * @return
     */
    public static <T, R, C extends Collection<R>> C map(final T[] a, final Function<? super T, ? extends R> mapper, final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return map(a, 0, a.length, mapper, supplier);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> map(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper) {
        return map(a, fromIndex, toIndex, mapper, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C map(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(mapper.apply(a[i]));
        }

        return result;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> map(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper) {
        return map(c, fromIndex, toIndex, mapper, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C map(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends R> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result.add(mapper.apply(list.get(i)));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                result.add(mapper.apply(e));

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param <U>
    //     * @param iter
    //     * @param mapper
    //     * @return
    //     * @see {@code Iterators.map(Iterator, Function)}
    //     */
    //    public static <T, R> List<R> map(final Iterator<? extends T> iter, final Function<? super T, ? extends R> mapper)
    //            {
    //        return map(iter, 0, Integer.MAX_VALUE, mapper);
    //    }
    //
    //    public static <T, R> List<R> map(final Iterator<? extends T> iter, final int fromIndex, final int toIndex,
    //            final Function<? super T, ? extends R> mapper) {
    //        checkFromToIndex(fromIndex, toIndex, Integer.MAX_VALUE);
    //
    //        if (iter == null || fromIndex == toIndex) {
    //            return new ArrayList<>();
    //        }
    //
    //        final List<R> result = new ArrayList<>(min(9, toIndex - fromIndex));
    //
    //        int idx = 0;
    //        T e = null;
    //
    //        while (iter.hasNext()) {
    //            e = iter.next();
    //
    //            if (idx++ < fromIndex) {
    //                continue;
    //            }
    //
    //            result.add(mapper.apply(e));
    //
    //            if (idx >= toIndex) {
    //                break;
    //            }
    //        }
    //
    //        return result;
    //    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param mapper
     * @return
     */
    public static <T, R> List<R> map(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper) {
        return map(c, mapper, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param mapper
     * @param supplier
     * @return
     */
    public static <T, R, C extends Collection<R>> C map(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper,
            final IntFunction<? extends C> supplier) {
        if (c == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0));

        for (final T e : c) {
            result.add(mapper.apply(e));
        }

        return result;
    }

    /**
     * Transforms an array of elements into a list by applying a given function to each element and flattening the result.
     *
     * @param <T> The type of the elements in the input array.
     * @param <R> The type of the elements in the resulting list.
     * @param a The input array to be transformed. Must not be {@code null}.
     * @param mapper The function to apply to each element in the input array. Must not be {@code null}.
     * @return A list containing the transformed elements.
     */
    public static <T, R> List<R> flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends R>> mapper) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return flatMap(a, 0, a.length, mapper);
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param mapper
     * @param supplier
     * @return
     */
    public static <T, R, C extends Collection<R>> C flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends R>> mapper,
            final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return flatMap(a, 0, a.length, mapper, supplier);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatMap(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(a, fromIndex, toIndex, mapper, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C flatMap(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        Collection<? extends R> mr = null;

        for (int i = fromIndex; i < toIndex; i++) {
            if (notEmpty(mr = mapper.apply(a[i]))) {
                result.addAll(mr);
            }
        }

        return result;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatMap(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(c, fromIndex, toIndex, mapper, Factory.<R> ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C flatMap(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        Collection<? extends R> mr = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                if (notEmpty(mr = mapper.apply(list.get(i)))) {
                    result.addAll(mr);
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                if (notEmpty(mr = mapper.apply(e))) {
                    result.addAll(mr);
                }

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(c, mapper, Factory.<R> ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends R>> mapper,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        if (c == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(initSizeForFlatMap(c));
        Collection<? extends R> mr = null;

        for (final T e : c) {
            if (notEmpty(mr = mapper.apply(e))) {
                result.addAll(mr);
            }
        }

        return result;
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param <U>
    //     * @param iter
    //     * @param mapper
    //     * @return
    //     * @see {@code Iterators.flatMap(Iterator, Function)}
    //     */
    //    public static <T, R> List<R> flatMap(final Iterator<? extends T> iter,
    //            final Function<? super T, ? extends Collection<? extends R>> mapper) {
    //        return flatMap(iter, 0, Integer.MAX_VALUE, mapper);
    //    }
    //
    //    public static <T, R> List<R> flatMap(final Iterator<? extends T> iter, final int fromIndex, final int toIndex,
    //            final Function<? super T, ? extends Collection<? extends R>> mapper) {
    //        checkFromToIndex(fromIndex, toIndex, Integer.MAX_VALUE);
    //
    //        if (iter == null || fromIndex == toIndex) {
    //            return new ArrayList<>();
    //        }
    //
    //        final List<R> result = new ArrayList<>(min(9, toIndex - fromIndex));
    //        Collection<? extends R> mr = null;
    //
    //        int idx = 0;
    //        T e = null;
    //
    //        while (iter.hasNext()) {
    //            e = iter.next();
    //
    //            if (idx++ < fromIndex) {
    //                continue;
    //            }
    //
    //            if (notEmpty(mr = mapper.apply(e))) {
    //                result.addAll(mr);
    //            }
    //
    //            if (idx >= toIndex) {
    //                break;
    //            }
    //        }
    //
    //        return result;
    //    }

    /**
     *
     *
     * @param <T>
     * @param <U>
     * @param <R>
     * @param a
     * @param mapper
     * @param mapper2
     * @return
     */
    public static <T, U, R> List<R> flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2) {

        return flatMap(a, mapper, mapper2, Factory.<R> ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <U>
     * @param <R>
     * @param <C>
     * @param a
     * @param mapper
     * @param mapper2
     * @param supplier
     * @return
     */
    public static <T, U, R, C extends Collection<R>> C flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2, final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        final int len = a.length > MAX_ARRAY_SIZE / LOAD_FACTOR_FOR_TWO_FLAT_MAP ? MAX_ARRAY_SIZE : a.length * LOAD_FACTOR_FOR_TWO_FLAT_MAP;
        final C result = supplier.apply(len);

        for (final T e : a) {
            final Collection<? extends U> c1 = mapper.apply(e);

            if (notEmpty(c1)) {
                for (final U e2 : c1) {
                    final Collection<? extends R> c2 = mapper2.apply(e2);

                    if (notEmpty(c2)) {
                        result.addAll(c2);
                    }
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param <U>
     * @param <R>
     * @param c
     * @param mapper
     * @param mapper2
     * @return
     */
    public static <T, U, R> List<R> flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2) {

        return flatMap(c, mapper, mapper2, Factory.<R> ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <U>
     * @param <R>
     * @param <C>
     * @param c
     * @param mapper
     * @param mapper2
     * @param supplier
     * @return
     */
    public static <T, U, R, C extends Collection<R>> C flatMap(final Iterable<? extends T> c,
            final Function<? super T, ? extends Collection<? extends U>> mapper, final Function<? super U, ? extends Collection<? extends R>> mapper2,
            final IntFunction<? extends C> supplier) {
        if (c == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(initSizeForFlatMap(c));

        for (final T e : c) {
            final Collection<? extends U> c1 = mapper.apply(e);

            if (notEmpty(c1)) {
                for (final U e2 : c1) {
                    final Collection<? extends R> c2 = mapper2.apply(e2);

                    if (notEmpty(c2)) {
                        result.addAll(c2);
                    }
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatmap(final T[] a, final Function<? super T, ? extends R[]> mapper) { //NOSONAR

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return flatmap(a, 0, a.length, mapper);
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param mapper
     * @param supplier
     * @return
     */
    public static <T, R, C extends Collection<R>> C flatmap(final T[] a, final Function<? super T, ? extends R[]> mapper, //NOSONAR
            final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return flatmap(a, 0, a.length, mapper, supplier);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatmap(final T[] a, final int fromIndex, final int toIndex, //NOSONAR
            final Function<? super T, ? extends R[]> mapper) {
        return flatmap(a, fromIndex, toIndex, mapper, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C flatmap(final T[] a, final int fromIndex, final int toIndex, //NOSONAR
            final Function<? super T, ? extends R[]> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        R[] mr = null;

        for (int i = fromIndex; i < toIndex; i++) {
            if (notEmpty(mr = mapper.apply(a[i]))) {
                result.addAll(Arrays.asList(mr));
            }
        }

        return result;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatmap(final Collection<? extends T> c, final int fromIndex, final int toIndex, //NOSONAR
            final Function<? super T, ? extends R[]> mapper) {
        return flatmap(c, fromIndex, toIndex, mapper, Factory.ofList());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param mapper
     * @param supplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T, R, C extends Collection<R>> C flatmap(final Collection<? extends T> c, final int fromIndex, final int toIndex, //NOSONAR
            final Function<? super T, ? extends R[]> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        R[] mr = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                if (notEmpty(mr = mapper.apply(list.get(i)))) {
                    result.addAll(Arrays.asList(mr));
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                if (notEmpty(mr = mapper.apply(e))) {
                    result.addAll(Arrays.asList(mr));
                }

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param c
     * @param mapper
     * @return
     */
    public static <T, R> List<R> flatmap(final Iterable<? extends T> c, final Function<? super T, ? extends R[]> mapper) //NOSONAR
    {
        return flatmap(c, mapper, Factory.<R> ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <R>
     * @param <C>
     * @param c
     * @param mapper
     * @param supplier
     * @return
     */
    public static <T, R, C extends Collection<R>> C flatmap(final Iterable<? extends T> c, //NOSONAR
            final Function<? super T, ? extends R[]> mapper, final IntFunction<? extends C> supplier) {
        if (c == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(initSizeForFlatMap(c));
        R[] mr = null;

        for (final T e : c) {
            if (notEmpty(mr = mapper.apply(e))) {
                result.addAll(Arrays.asList(mr));
            }
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input array until the provided predicate returns {@code false}.
     *
     * @param <T>
     * @param a the array to process.
     * @param filter the predicate to apply to elements of the array.
     * @return a list of elements from the input array starting from the first element until the predicate returns {@code false}.
     */
    public static <T> List<T> takeWhile(final T[] a, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, len(a)));

        if (isEmpty(a)) {
            return result;
        }

        for (final T e : a) {
            if (filter.test(e)) {
                result.add(e);
            } else {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input {@code iterable} until the provided predicate returns {@code false}.
     *
     * @param <T>
     * @param c the {@code iterable} to process.
     * @param filter the predicate to apply to elements of the {@code iterable}.
     * @return a list of elements from the input {@code iterable} starting from the first element until the predicate returns {@code false}.
     */
    public static <T> List<T> takeWhile(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, getSizeOrDefault(c, 0)));

        if (c == null) {
            return result;
        }

        for (final T e : c) {
            if (filter.test(e)) {
                result.add(e);
            } else {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input array until the provided predicate returns {@code false}, including the element that fails the predicate.
     *
     * @param a the array to process.
     * @param filter the predicate to apply to elements of the array.
     * @return a list of elements from the input array starting from the first element until the predicate returns {@code false}, including the element that fails the predicate.
     */
    public static <T> List<T> takeWhileInclusive(final T[] a, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, len(a)));

        if (isEmpty(a)) {
            return result;
        }

        for (final T e : a) {
            result.add(e);

            if (!filter.test(e)) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input {@code iterable} until the provided predicate returns {@code false}, including the element that fails the predicate.
     *
     * @param c the {@code iterable} to process.
     * @param filter the predicate to apply to elements of the {@code iterable}.
     * @return a list of elements from the input {@code iterable} starting from the first element until the predicate returns {@code false}, including the element that fails the predicate.
     */
    public static <T> List<T> takeWhileInclusive(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, getSizeOrDefault(c, 0)));

        if (c == null) {
            return result;
        }

        for (final T e : c) {
            result.add(e);

            if (!filter.test(e)) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input array after dropping the elements that satisfy the provided predicate.
     *
     * @param a the array to process.
     * @param filter the predicate to apply to elements of the array.
     * @return a list of elements from the input array starting from the first element that fails the predicate.
     */
    public static <T> List<T> dropWhile(final T[] a, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, len(a)));

        if (isEmpty(a)) {
            return result;
        }

        final int len = a.length;
        int idx = 0;

        while (idx < len && filter.test(a[idx])) {
            idx++;
        }

        while (idx < len) {
            result.add(a[idx++]);
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input {@code iterable} after dropping the elements that satisfy the provided predicate.
     *
     * @param c the {@code iterable} to process.
     * @param filter the predicate to apply to elements of the {@code iterable}.
     * @return a list of elements from the input {@code iterable} starting from the first element that fails the predicate.
     */
    public static <T> List<T> dropWhile(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, getSizeOrDefault(c, 0)));

        if (c == null) {
            return result;
        }

        final Iterator<? extends T> iter = c.iterator();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (!filter.test(e)) {
                result.add(e);
                break;
            }
        }

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input array starting from the first element that satisfies the provided predicate.
     *
     * @param a the array to process.
     * @param filter the predicate to apply to elements of the array.
     * @return a list of elements from the input array starting from the first element that satisfies the predicate.
     */
    public static <T> List<T> skipUntil(final T[] a, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(min(9, len(a)));

        if (isEmpty(a)) {
            return result;
        }

        final int len = a.length;
        int idx = 0;

        while (idx < len && !filter.test(a[idx])) {
            idx++;
        }

        while (idx < len) {
            result.add(a[idx++]);
        }

        return result;
    }

    /**
     * Returns a list containing the elements of the input {@code iterable} starting from the first element that satisfies the provided predicate.
     *
     * @param c the {@code iterable} to process.
     * @param filter the predicate to apply to elements of the {@code iterable}.
     * @return a list of elements from the input {@code iterable} starting from the first element that satisfies the predicate.
     */
    public static <T> List<T> skipUntil(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        final List<T> result = new ArrayList<>(getMinSize(c));

        if (c == null) {
            return result;
        }

        final Iterator<? extends T> iter = c.iterator();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (filter.test(e)) {
                result.add(e);
                break;
            }
        }

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    private static int getSizeOrDefault(final Iterable<?> c, final int defaultSize) {
        return c instanceof Collection ? ((Collection<?>) c).size() : defaultSize;
    }

    private static int getMinSize(final Iterable<?> c) {
        return min(9, getSizeOrDefault(c, 0));
    }

    private static int initSizeForFlatMap(final Iterable<?> c) {
        return c instanceof Collection ? initSizeForFlatMap(((Collection<?>) c).size()) : 0;
    }

    private static int initSizeForFlatMap(final int size) {
        return size > MAX_ARRAY_SIZE / LOAD_FACTOR_FOR_FLAT_MAP ? MAX_ARRAY_SIZE : (int) (size * LOAD_FACTOR_FOR_FLAT_MAP); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static boolean[] distinct(final boolean[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static boolean[] distinct(final boolean[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static char[] distinct(final char[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static char[] distinct(final char[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static byte[] distinct(final byte[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static byte[] distinct(final byte[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static short[] distinct(final short[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static short[] distinct(final short[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static int[] distinct(final int[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static int[] distinct(final int[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static long[] distinct(final long[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static long[] distinct(final long[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static float[] distinct(final float[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static float[] distinct(final float[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @return
     */
    public static double[] distinct(final double[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     */
    public static double[] distinct(final double[] a, final int fromIndex, final int toIndex) {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @return
     */
    public static <T> List<T> distinct(final T[] a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return distinct(a, 0, a.length);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> List<T> distinct(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);

        for (int i = fromIndex; i < toIndex; i++) {
            if (set.add(hashKey(a[i]))) {
                result.add(a[i]);
            }
        }

        return result;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @return
     */
    public static <T> List<T> distinct(final Iterable<? extends T> c) {
        if (c == null) {
            return new ArrayList<>();
        } else if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return distinct(coll, 0, coll.size());
        } else {
            final List<T> result = new ArrayList<>();
            final Set<Object> set = new HashSet<>();

            for (final T e : c) {
                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }

            return result;
        }
    }

    /**
     *
     * @param <T>
     * @param iter
     * @return
     * @see Iterators#distinct(Iterator)
     * @see Iterators#distinct(Iterable)
     * @see Iterators#distinctBy(Iterator, Function)
     * @see Iterators#distinctBy(Iterable, Function)
     */
    public static <T> List<T> distinct(final Iterator<? extends T> iter) {
        return distinctBy(iter, Fn.identity());
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> List<T> distinct(final Collection<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex && it.hasNext(); i++) {
                e = it.next();

                if (i < fromIndex) {
                    continue;
                }

                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }
        }

        return result;
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param keyMapper don't change value of the input parameter.
     * @return
     */
    public static <T> List<T> distinctBy(final T[] a, final Function<? super T, ?> keyMapper) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return distinctBy(a, 0, a.length, keyMapper);
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param keyMapper don't change value of the input parameter.
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> List<T> distinctBy(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ?> keyMapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);

        for (int i = fromIndex; i < toIndex; i++) {
            if (set.add(hashKey(keyMapper.apply(a[i])))) {
                result.add(a[i]);
            }
        }

        return result;
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <C>
     * @param a
     * @param keyMapper don't change value of the input parameter.
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C distinctBy(final T[] a, final Function<? super T, ?> keyMapper, final Supplier<C> supplier) {
        if (isEmpty(a)) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = newHashSet(len(a) / 2 + 1);

        for (final T e : a) {
            if (set.add(hashKey(keyMapper.apply(e)))) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param keyMapper don't change value of the input parameter.
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> List<T> distinctBy(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Function<? super T, ?> keyMapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (set.add(hashKey(keyMapper.apply(e)))) {
                    result.add(e);
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex && it.hasNext(); i++) {
                e = it.next();

                if (i < fromIndex) {
                    continue;
                }

                if (set.add(hashKey(keyMapper.apply(e)))) {
                    result.add(e);
                }
            }
        }

        return result;
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param keyMapper don't change value of the input parameter.
     * @return
     */
    public static <T> List<T> distinctBy(final Iterable<? extends T> c, final Function<? super T, ?> keyMapper) {
        return distinctBy(c, keyMapper, Suppliers.ofList());
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param keyMapper don't change value of the input parameter.
     * @param supplier
     * @return
     */
    public static <T, C extends Collection<T>> C distinctBy(final Iterable<? extends T> c, final Function<? super T, ?> keyMapper, final Supplier<C> supplier) {
        if (c == null) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = newHashSet(c instanceof Collection ? ((Collection<T>) c).size() / 2 + 1 : 0);

        for (final T e : c) {
            if (set.add(hashKey(keyMapper.apply(e)))) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param iter
     * @param keyMapper don't change value of the input parameter.
     * @return
     * @see Iterators#distinct(Iterator)
     * @see Iterators#distinct(Iterable)
     * @see Iterators#distinctBy(Iterator, Function)
     * @see Iterators#distinctBy(Iterable, Function)
     */
    public static <T> List<T> distinctBy(final Iterator<? extends T> iter, final Function<? super T, ?> keyMapper) {
        return distinctBy(iter, keyMapper, Suppliers.ofList());
    }

    /**
     * Distinct by the value mapped from {@code keyMapper}.
     *
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param <C>
     * @param iter
     * @param keyMapper don't change value of the input parameter.
     * @param supplier
     * @return
     * @see Iterators#distinct(Iterator)
     * @see Iterators#distinct(Iterable)
     * @see Iterators#distinctBy(Iterator, Function)
     * @see Iterators#distinctBy(Iterable, Function)
     */
    public static <T, C extends Collection<T>> C distinctBy(final Iterator<? extends T> iter, final Function<? super T, ?> keyMapper,
            final Supplier<C> supplier) {
        if (iter == null) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = new HashSet<>();

        T next = null;

        while (iter.hasNext()) {
            next = iter.next();

            if (set.add(hashKey(keyMapper.apply(next)))) {
                result.add(next);
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param filter
     * @return
     */
    public static <T> boolean allMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return true;
        }

        for (final T e : a) {
            if (!filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param filter
     * @return
     */
    public static <T> boolean allMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (c == null) {
            return true;
        }

        for (final T e : c) {
            if (!filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param <T>
     * @param iter
     * @param filter
     * @return
     */
    public static <T> boolean allMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return true;
        }

        while (iter.hasNext()) {
            if (!filter.test(iter.next())) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param filter
     * @return
     */
    public static <T> boolean anyMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return false;
        }

        for (final T e : a) {
            if (filter.test(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param filter
     * @return
     */
    public static <T> boolean anyMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (c == null) {
            return false;
        }

        for (final T e : c) {
            if (filter.test(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     *
     *
     * @param <T>
     * @param iter
     * @param filter
     * @return
     */
    public static <T> boolean anyMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return false;
        }

        while (iter.hasNext()) {
            if (filter.test(iter.next())) {
                return true;
            }
        }

        return false;
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param filter
     * @return
     */
    public static <T> boolean noneMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return true;
        }

        for (final T e : a) {
            if (filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param filter
     * @return
     */
    public static <T> boolean noneMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (c == null) {
            return true;
        }

        for (final T e : c) {
            if (filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param <T>
     * @param iter
     * @param filter
     * @return
     */
    public static <T> boolean noneMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return true;
        }

        while (iter.hasNext()) {
            if (filter.test(iter.next())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if a certain number of elements in the array match the provided predicate.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be checked
     * @param atLeast the minimum number of elements that should match the predicate
     * @param atMost the maximum number of elements that should match the predicate
     * @param filter the predicate to apply to elements in the array
     * @return {@code true} if the number of matching elements is within the specified range (inclusive), {@code false} otherwise
     */
    public static <T> boolean nMatch(final T[] a, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, "atLeast"); //NOSONAR
        checkArgNotNegative(atMost, "atMost"); //NOSONAR
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'"); //NOSONAR
        if (isEmpty(a)) {
            return atLeast == 0;
        }

        final int len = len(a);

        if (len < atLeast) {
            return false;
        }

        long cnt = 0;

        for (int i = 0; i < len; i++) {
            if (filter.test(a[i]) && (++cnt > atMost)) {
                return false;
            }
        }

        return cnt >= atLeast && cnt <= atMost;
    }

    /**
     * Checks if a certain number of elements in the {@code iterable} match the provided predicate.
     *
     * @param <T> the type of elements in the {@code iterable}
     * @param c the {@code iterable} to be checked
     * @param atLeast the minimum number of elements that should match the predicate
     * @param atMost the maximum number of elements that should match the predicate
     * @param filter the predicate to apply to elements in the {@code iterable}
     * @return {@code true} if the number of matching elements is within the specified range (inclusive), {@code false} otherwise
     */
    public static <T> boolean nMatch(final Iterable<? extends T> c, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, cs.atLeast);
        checkArgNotNegative(atMost, cs.atMost);
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'");
        if (c == null) {
            return atLeast == 0;
        }

        return nMatch(c.iterator(), atLeast, atMost, filter);
    }

    /**
     * Checks if a certain number of elements in the iterator match the provided predicate.
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to be checked
     * @param atLeast the minimum number of elements that should match the predicate
     * @param atMost the maximum number of elements that should match the predicate
     * @param filter the predicate to apply to elements in the iterator
     * @return {@code true} if the number of matching elements is within the specified range (inclusive), {@code false} otherwise
     */
    public static <T> boolean nMatch(final Iterator<? extends T> iter, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, cs.atLeast);
        checkArgNotNegative(atMost, cs.atMost);
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'");
        if (iter == null) {
            return atLeast == 0;
        }

        long cnt = 0;

        while (iter.hasNext()) {
            if (filter.test(iter.next()) && (++cnt > atMost)) {
                return false;
            }
        }

        return cnt >= atLeast && cnt <= atMost;
    }

    /**
     *
     *
     * @param a
     * @return
     */
    public static boolean allTrue(final boolean[] a) {
        if (isEmpty(a)) {
            return true;
        }

        for (final boolean b : a) {
            if (!b) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param a
     * @return
     */
    public static boolean allFalse(final boolean[] a) {
        if (isEmpty(a)) {
            return true;
        }

        for (final boolean b : a) {
            if (b) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     *
     * @param a
     * @return
     */
    public static boolean anyTrue(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        for (final boolean b : a) {
            if (b) {
                return true;
            }
        }

        return false;
    }

    /**
     *
     *
     * @param a
     * @return
     */
    public static boolean anyFalse(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        for (final boolean b : a) {
            if (!b) {
                return true;
            }
        }

        return false;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final boolean[] a, final BooleanPredicate filter) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final boolean[] a, final int fromIndex, final int toIndex, final BooleanPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final char[] a, final CharPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final char[] a, final int fromIndex, final int toIndex, final CharPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final byte[] a, final BytePredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final byte[] a, final int fromIndex, final int toIndex, final BytePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final short[] a, final ShortPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final short[] a, final int fromIndex, final int toIndex, final ShortPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final int[] a, final IntPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final int[] a, final int fromIndex, final int toIndex, final IntPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final long[] a, final LongPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final long[] a, final int fromIndex, final int toIndex, final LongPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     */
    public static int count(final float[] a, final FloatPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final float[] a, final int fromIndex, final int toIndex, final FloatPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final double[] a, final DoublePredicate filter) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static int count(final double[] a, final int fromIndex, final int toIndex, final DoublePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> int count(final T[] a, final Predicate<? super T> filter) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> int count(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param filter
     * @return
     * @throws IndexOutOfBoundsException
     */
    public static <T> int count(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Predicate<? super T> filter)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || (fromIndex == toIndex && fromIndex < c.size())) {
            return 0;
        }

        int count = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                if (filter.test(list.get(i))) {
                    count++;
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx++ < fromIndex) {
                    continue;
                }

                if (filter.test(e)) {
                    count++;
                }

                if (idx >= toIndex) {
                    break;
                }
            }
        }

        return count;
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * @param <T>
     * @param c
     * @param filter
     * @return
     */
    public static <T> int count(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (c == null) {
            return 0;
        }

        int count = 0;

        for (final T e : c) {
            if (filter.test(e)) {
                count++;
            }
        }

        return count;
    }

    /**
     * Counts the number of elements in the given iterator.
     *
     * @param iter
     * @return
     * @throws ArithmeticException if the total {@code count} overflows an {@code int}.
     * @see Iterators#count(Iterator)
     * @see #count(Iterator, Predicate)
     * @see Iterators#count(Iterator, Predicate)
     */
    public static int count(final Iterator<?> iter) throws ArithmeticException {
        if (iter == null) {
            return 0;
        }

        long res = 0;

        while (iter.hasNext()) {
            iter.next();
            res++;
        }

        return Numbers.toIntExact(res);
    }

    /**
     * Counts the number of elements in the given iterator that match the provided predicate.
     *
     * @param <T> The type of the elements in the iterator.
     * @param iter The iterator to be counted.
     * @param filter The predicate to apply to each element.
     * @return The number of elements that match the predicate.
     * @throws ArithmeticException if the total matched {@code count} overflows an {@code int}.
     * @see #count(Iterator)
     * @see Iterators#count(Iterator, Predicate)
     */
    public static <T> int count(final Iterator<? extends T> iter, final Predicate<? super T> filter) throws ArithmeticException {
        if (iter == null) {
            return 0;
        }

        long res = 0;

        while (iter.hasNext()) {
            if (filter.test(iter.next())) {
                res++;
            }
        }

        return Numbers.toIntExact(res);
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param b
     * @param nextSelector
     * @return
     */
    public static <T> List<T> merge(final T[] a, final T[] b, final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        if (isEmpty(a)) {
            return isEmpty(b) ? new ArrayList<>() : asList(b);
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final List<T> result = new ArrayList<>(a.length + b.length);
        final int lenA = a.length;
        final int lenB = b.length;
        int cursorA = 0;
        int cursorB = 0;

        while (cursorA < lenA || cursorB < lenB) {
            if ((cursorA < lenA) && ((cursorB >= lenB) || (nextSelector.apply(a[cursorA], b[cursorB]) == MergeResult.TAKE_FIRST))) {
                result.add(a[cursorA++]);
            } else {
                result.add(b[cursorB++]);
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param a
     * @param b
     * @param nextSelector
     * @return
     */
    public static <T> List<T> merge(final Iterable<? extends T> a, final Iterable<? extends T> b,
            final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        return merge(N.asList(a, b), nextSelector, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param c
     * @param nextSelector
     * @return
     */
    public static <T> List<T> merge(final Collection<? extends Iterable<? extends T>> c, final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        return merge(c, nextSelector, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <C>
     * @param c
     * @param nextSelector
     * @param supplier
     * @return
     * @
     */
    public static <T, C extends Collection<T>> C merge(final Collection<? extends Iterable<? extends T>> c,
            final BiFunction<? super T, ? super T, MergeResult> nextSelector, final IntFunction<? extends C> supplier) {
        if (N.isEmpty(c)) {
            return supplier.apply(0);
        } else if (c.size() == 1) {
            final Iterable<? extends T> a = N.firstOrNullIfEmpty(c);
            return a == null ? supplier.apply(0) : N.toCollection(a, supplier);
        } else if (c.size() == 2) {
            final Iterator<? extends Iterable<? extends T>> iter = c.iterator();
            final Iterable<? extends T> a = iter.next();
            final Iterable<? extends T> b = iter.next();

            if (a == null) {
                return b == null ? supplier.apply(0) : N.toCollection(b, supplier);
            } else if (b == null) {
                return N.toCollection(a, supplier);
            }

            final C ret = supplier.apply(getSizeOrDefault(a, 0) + getSizeOrDefault(b, 0));
            final Iterator<? extends T> iterA = a.iterator();
            final Iterator<? extends T> iterB = b.iterator();

            T nextA = null;
            T nextB = null;
            boolean hasNextA = false;
            boolean hasNextB = false;

            while (hasNextA || hasNextB || iterA.hasNext() || iterB.hasNext()) {
                if (hasNextA) {
                    if (iterB.hasNext()) {
                        if (nextSelector.apply(nextA, (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                            hasNextA = false;
                            hasNextB = true;
                            ret.add(nextA);
                        } else {
                            ret.add(nextB);
                        }
                    } else {
                        hasNextA = false;
                        ret.add(nextA);
                    }
                } else if (hasNextB) {
                    if (iterA.hasNext()) {
                        if (nextSelector.apply((nextA = iterA.next()), nextB) == MergeResult.TAKE_FIRST) {
                            ret.add(nextA);
                        } else {
                            hasNextA = true;
                            hasNextB = false;
                            ret.add(nextB);
                        }
                    } else {
                        hasNextB = false;
                        ret.add(nextB);
                    }
                } else if (iterA.hasNext()) {
                    if (iterB.hasNext()) {
                        if (nextSelector.apply((nextA = iterA.next()), (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                            hasNextB = true;
                            ret.add(nextA);
                        } else {
                            hasNextA = true;
                            ret.add(nextB);
                        }
                    } else {
                        ret.add(iterA.next());
                    }
                } else {
                    ret.add(iterB.next());
                }
            }

            return ret;
        } else {
            int totalSize = 0;
            Iterator<T> mergedIter = ObjIterator.empty();
            Iterator<? extends T> iter = null;

            for (final Iterable<? extends T> e : c) {
                iter = e == null ? null : e.iterator();

                if (iter == null || iter.hasNext() == false) {
                    continue;
                }

                totalSize += getSizeOrDefault(e, 0);

                final Iterator<T> iterA = mergedIter;
                final Iterator<? extends T> iterB = iter;

                mergedIter = new Iterator<>() {
                    private T nextA = null;
                    private T nextB = null;
                    private boolean hasNextA = false;
                    private boolean hasNextB = false;

                    @Override
                    public boolean hasNext() {
                        return hasNextA || hasNextB || iterA.hasNext() || iterB.hasNext();
                    }

                    @Override
                    public T next() {
                        if (hasNextA) {
                            if (iterB.hasNext()) {
                                if (nextSelector.apply(nextA, (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                                    hasNextA = false;
                                    hasNextB = true;
                                    return nextA;
                                } else {
                                    return nextB;
                                }
                            } else {
                                hasNextA = false;
                                return nextA;
                            }
                        } else if (hasNextB) {
                            if (iterA.hasNext()) {
                                if (nextSelector.apply((nextA = iterA.next()), nextB) == MergeResult.TAKE_FIRST) {
                                    return nextA;
                                } else {
                                    hasNextA = true;
                                    hasNextB = false;
                                    return nextB;
                                }
                            } else {
                                hasNextB = false;
                                return nextB;
                            }
                        } else if (iterA.hasNext()) {
                            if (iterB.hasNext()) {
                                if (nextSelector.apply((nextA = iterA.next()), (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                                    hasNextB = true;
                                    return nextA;
                                } else {
                                    hasNextA = true;
                                    return nextB;
                                }
                            } else {
                                return iterA.next();
                            }
                        } else {
                            return iterB.next();
                        }
                    }
                };
            }

            final C ret = supplier.apply(totalSize);

            while (mergedIter.hasNext()) {
                ret.add(mergedIter.next());
            }

            return ret;
        }
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param a
    //     * @param b
    //     * @param nextSelector
    //     * @return
    //     * @see {@code Iterators.merge(Iterator, Iterator, BiFunction)}
    //     */
    //    public static <T, E extends Exception> List<T> merge(final Iterator<? extends T> a, final Iterator<? extends T> b,
    //            final Throwables.BiFunction<? super T, ? super T, MergeResult, E> nextSelector) throws E {
    //        if (a == null) {
    //            return b == null ? new ArrayList<>() : toList(b);
    //        } else if (b == null) {
    //            return toList(a);
    //        }
    //
    //        final List<T> result = new ArrayList<>(9);
    //        final Iterator<? extends T> iterA = a;
    //        final Iterator<? extends T> iterB = b;
    //
    //        T nextA = null;
    //        T nextB = null;
    //        boolean hasNextA = false;
    //        boolean hasNextB = false;
    //
    //        while (hasNextA || hasNextB || iterA.hasNext() || iterB.hasNext()) {
    //            if (hasNextA) {
    //                if (iterB.hasNext()) {
    //                    if (nextSelector.apply(nextA, (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
    //                        hasNextA = false;
    //                        hasNextB = true;
    //                        result.add(nextA);
    //                    } else {
    //                        result.add(nextB);
    //                    }
    //                } else {
    //                    hasNextA = false;
    //                    result.add(nextA);
    //                }
    //            } else if (hasNextB) {
    //                if (iterA.hasNext()) {
    //                    if (nextSelector.apply((nextA = iterA.next()), nextB) == MergeResult.TAKE_FIRST) {
    //                        result.add(nextA);
    //                    } else {
    //                        hasNextA = true;
    //                        hasNextB = false;
    //                        result.add(nextB);
    //                    }
    //                } else {
    //                    hasNextB = false;
    //                    result.add(nextB);
    //                }
    //            } else if (iterA.hasNext()) {
    //                if (iterB.hasNext()) {
    //                    if (nextSelector.apply((nextA = iterA.next()), (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
    //                        hasNextB = true;
    //                        result.add(nextA);
    //                    } else {
    //                        hasNextA = true;
    //                        result.add(nextB);
    //                    }
    //                } else {
    //                    result.add(iterA.next());
    //                }
    //            } else {
    //                result.add(iterB.next());
    //            }
    //        }
    //
    //        return result;
    //    }

    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, BiFunction)}
    //     */
    //    public static <A, B, R, E extends Exception> List<R> zip(final Iterator<A> a, final Iterator<B> b,
    //            final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction) throws E {
    //        if (a == null || b == null) {
    //            return new ArrayList<>();
    //        }
    //
    //        final Iterator<A> iterA = a;
    //        final Iterator<B> iterB = b;
    //        final List<R> result = new ArrayList<>(9);
    //
    //        while (iterA.hasNext() && iterB.hasNext()) {
    //            result.add(zipFunction.apply(iterA.next(), iterB.next()));
    //        }
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <C>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param c
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Iterator, TriFunction)}
    //     */
    //    public static <A, B, C, R, E extends Exception> List<R> zip(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c,
    //            final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction) throws E {
    //        if (a == null || b == null || c == null) {
    //            return new ArrayList<>();
    //        }
    //
    //        final Iterator<A> iterA = a;
    //        final Iterator<B> iterB = b;
    //        final Iterator<C> iterC = c;
    //        final List<R> result = new ArrayList<>(9);
    //
    //        while (iterA.hasNext() && iterB.hasNext() && iterC.hasNext()) {
    //            result.add(zipFunction.apply(iterA.next(), iterB.next(), iterC.next()));
    //        }
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param valueForNoneA
    //     * @param valueForNoneB
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Object, Object, BiFunction)}
    //     */
    //    public static <A, B, R, E extends Exception> List<R> zip(final Iterator<A> a, final Iterator<B> b, final A valueForNoneA, final B valueForNoneB,
    //            final Throwables.BiFunction<? super A, ? super B, ? extends R, E> zipFunction) throws E {
    //        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
    //        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;
    //
    //        final List<R> result = new ArrayList<>(9);
    //        boolean hasA = true;
    //
    //        do {
    //            if (hasA && (hasA = iterA.hasNext())) {
    //                result.add(zipFunction.apply(iterA.next(), iterB.hasNext() ? iterB.next() : valueForNoneB));
    //            } else if (iterB.hasNext()) {
    //                result.add(zipFunction.apply(valueForNoneA, iterB.next()));
    //            } else {
    //                break;
    //            }
    //        } while (true);
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <C>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param c
    //     * @param valueForNoneA
    //     * @param valueForNoneB
    //     * @param valueForNoneC
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Iterator, Object, Object, Object, TriFunction)}
    //     */
    //    public static <A, B, C, R, E extends Exception> List<R> zip(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c, final A valueForNoneA,
    //            final B valueForNoneB, final C valueForNoneC, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, E> zipFunction) throws E {
    //        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
    //        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;
    //        final Iterator<C> iterC = c == null ? ObjIterator.<C> empty() : c;
    //
    //        final List<R> result = new ArrayList<>(9);
    //        boolean hasA = true;
    //        boolean hasB = true;
    //
    //        do {
    //            if (hasA && (hasA = iterA.hasNext())) {
    //                result.add(zipFunction.apply(iterA.next(), iterB.hasNext() ? iterB.next() : valueForNoneB, iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else if (hasB && (hasB = iterB.hasNext())) {
    //                result.add(zipFunction.apply(valueForNoneA, iterB.next(), iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else if (iterC.hasNext()) {
    //                result.add(zipFunction.apply(valueForNoneA, valueForNoneB, iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else {
    //                break;
    //            }
    //        } while (true);
    //
    //        return result;
    //    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param <L>
    //     * @param <R>
    //     * @param iter
    //     * @param unzip the second parameter is an output parameter.
    //     * @return
    //     * @see {@code Iterators.unzip(Iterator, BiConsumer)}
    //     */
    //    public static <T, L, R, E extends Exception> Pair<List<L>, List<R>> unzip(final Iterator<? extends T> iter,
    //            final Throwables.BiConsumer<? super T, Pair<L, R>, E> unzip) throws E {
    //        final int len = 9;
    //
    //        final List<L> l = new ArrayList<>(len);
    //        final List<R> r = new ArrayList<>(len);
    //        final Pair<L, R> p = new Pair<>();
    //
    //        if (iter != null) {
    //            T e = null;
    //
    //            while (iter.hasNext()) {
    //                e = iter.next();
    //
    //                unzip.accept(e, p);
    //
    //                l.add(p.left);
    //                r.add(p.right);
    //            }
    //        }
    //
    //        return Pair.of(l, r);
    //    }
    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param zipFunction
     * @return
     */
    public static <A, B, R> List<R> zip(final A[] a, final B[] b, final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final int minLen = min(a.length, b.length);
        final List<R> result = new ArrayList<>(minLen);

        for (int i = 0; i < minLen; i++) {
            result.add(zipFunction.apply(a[i], b[i]));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param zipFunction
     * @return
     */
    public static <A, B, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        if (a == null || b == null) {
            return new ArrayList<>();
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final int minLen = min(getSizeOrDefault(a, 0), getSizeOrDefault(b, 0));
        final List<R> result = new ArrayList<>(minLen);

        while (iterA.hasNext() && iterB.hasNext()) {
            result.add(zipFunction.apply(iterA.next(), iterB.next()));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @return
     */
    public static <A, B, C, R> List<R> zip(final A[] a, final B[] b, final C[] c, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        if (isEmpty(a) || isEmpty(b) || isEmpty(c)) {
            return new ArrayList<>();
        }

        final int minLen = min(a.length, b.length, c.length);
        final List<R> result = new ArrayList<>(minLen);

        for (int i = 0; i < minLen; i++) {
            result.add(zipFunction.apply(a[i], b[i], c[i]));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @return
     */
    public static <A, B, C, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        if (a == null || b == null || c == null) {
            return new ArrayList<>();
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final Iterator<C> iterC = c.iterator();
        final int minLen = min(getSizeOrDefault(a, 0), getSizeOrDefault(b, 0), getSizeOrDefault(c, 0));
        final List<R> result = new ArrayList<>(minLen);

        while (iterA.hasNext() && iterB.hasNext() && iterC.hasNext()) {
            result.add(zipFunction.apply(iterA.next(), iterB.next(), iterC.next()));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     */
    public static <A, B, R> List<R> zip(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int maxLen = max(lenA, lenB);
        final List<R> result = new ArrayList<>(maxLen);

        for (int i = 0; i < maxLen; i++) {
            result.add(zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @return
     */
    public static <A, B, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a.iterator();
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b.iterator();
        final int lenA = getSizeOrDefault(a, 0);
        final int lenB = getSizeOrDefault(b, 0);
        final int maxLen = max(lenA, lenB);
        final List<R> result = new ArrayList<>(maxLen);

        if (a == null || a instanceof Collection) {
            if (b == null || b instanceof Collection) {
                for (int i = 0; i < maxLen; i++) {
                    result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB));
                }
            } else {
                for (int i = 0; i < lenA || iterB.hasNext(); i++) {
                    result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB));
                }
            }
        } else if (b == null || b instanceof Collection) {
            for (int i = 0; i < lenB || iterA.hasNext(); i++) {
                result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB));
            }
        } else {
            while (iterA.hasNext() || iterB.hasNext()) {
                result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB));
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     */
    public static <A, B, C, R> List<R> zip(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB, final C valueForNoneC,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int maxLen = max(lenA, lenB, lenC);
        final List<R> result = new ArrayList<>(maxLen);

        for (int i = 0; i < maxLen; i++) {
            result.add(zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC));
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @return
     */
    public static <A, B, C, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c, final A valueForNoneA, final B valueForNoneB,
            final C valueForNoneC, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a.iterator();
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b.iterator();
        final Iterator<C> iterC = c == null ? ObjIterator.<C> empty() : c.iterator();
        final int lenA = getSizeOrDefault(a, 0);
        final int lenB = getSizeOrDefault(b, 0);
        final int lenC = getSizeOrDefault(c, 0);
        final int maxLen = max(lenA, lenB, lenC);
        final List<R> result = new ArrayList<>(maxLen);

        if (a == null || a instanceof Collection) {
            if (b == null || b instanceof Collection) {
                if (c == null || c instanceof Collection) {
                    for (int i = 0; i < maxLen; i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                                i < lenC ? iterC.next() : valueForNoneC));
                    }
                } else {
                    for (int i = 0; i < lenA || i < lenB || iterC.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                                iterC.hasNext() ? iterC.next() : valueForNoneC));
                    }
                }
            } else {
                if (c == null || c instanceof Collection) {
                    for (int i = 0; i < lenA || i < lenC || iterB.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                                i < lenC ? iterC.next() : valueForNoneC));
                    }
                } else {
                    for (int i = 0; i < lenA || iterB.hasNext() || iterC.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                                iterC.hasNext() ? iterC.next() : valueForNoneC));
                    }
                }
            }
        } else if (b == null || b instanceof Collection) {
            if (c == null || c instanceof Collection) {
                for (int i = 0; i < lenB || i < lenC || iterA.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                            i < lenC ? iterC.next() : valueForNoneC));
                }
            } else {
                for (int i = 0; i < lenB || iterA.hasNext() || iterC.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                            iterC.hasNext() ? iterC.next() : valueForNoneC));
                }
            }
        } else {
            if (c == null || c instanceof Collection) {
                for (int i = 0; i < lenC || iterA.hasNext() || iterB.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                            i < lenC ? iterC.next() : valueForNoneC));
                }
            } else {
                while (iterA.hasNext() || iterB.hasNext() || iterC.hasNext()) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                            iterC.hasNext() ? iterC.next() : valueForNoneC));
                }
            }
        }

        return result;
    }

    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, BiFunction)}
    //     */
    //    public static <A, B, R> List<R> zip(final Iterator<A> a, final Iterator<B> b,
    //            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
    //        if (a == null || b == null) {
    //            return new ArrayList<>();
    //        }
    //
    //        final Iterator<A> iterA = a;
    //        final Iterator<B> iterB = b;
    //        final List<R> result = new ArrayList<>(9);
    //
    //        while (iterA.hasNext() && iterB.hasNext()) {
    //            result.add(zipFunction.apply(iterA.next(), iterB.next()));
    //        }
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <C>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param c
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Iterator, TriFunction)}
    //     */
    //    public static <A, B, C, R> List<R> zip(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c,
    //            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
    //        if (a == null || b == null || c == null) {
    //            return new ArrayList<>();
    //        }
    //
    //        final Iterator<A> iterA = a;
    //        final Iterator<B> iterB = b;
    //        final Iterator<C> iterC = c;
    //        final List<R> result = new ArrayList<>(9);
    //
    //        while (iterA.hasNext() && iterB.hasNext() && iterC.hasNext()) {
    //            result.add(zipFunction.apply(iterA.next(), iterB.next(), iterC.next()));
    //        }
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param valueForNoneA
    //     * @param valueForNoneB
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Object, Object, BiFunction)}
    //     */
    //    public static <A, B, R> List<R> zip(final Iterator<A> a, final Iterator<B> b, final A valueForNoneA, final B valueForNoneB,
    //            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
    //        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
    //        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;
    //
    //        final List<R> result = new ArrayList<>(9);
    //        boolean hasA = true;
    //
    //        do {
    //            if (hasA && (hasA = iterA.hasNext())) {
    //                result.add(zipFunction.apply(iterA.next(), iterB.hasNext() ? iterB.next() : valueForNoneB));
    //            } else if (iterB.hasNext()) {
    //                result.add(zipFunction.apply(valueForNoneA, iterB.next()));
    //            } else {
    //                break;
    //            }
    //        } while (true);
    //
    //        return result;
    //    }
    //
    //    /**
    //     *
    //     * @param <A>
    //     * @param <B>
    //     * @param <C>
    //     * @param <R>
    //     * @param a
    //     * @param b
    //     * @param c
    //     * @param valueForNoneA
    //     * @param valueForNoneB
    //     * @param valueForNoneC
    //     * @param zipFunction
    //     * @return
    //     * @see {@code Iterators.zip(Iterator, Iterator, Iterator, Object, Object, Object, TriFunction)}
    //     */
    //    public static <A, B, C, R> List<R> zip(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c, final A valueForNoneA,
    //            final B valueForNoneB, final C valueForNoneC, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
    //        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
    //        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;
    //        final Iterator<C> iterC = c == null ? ObjIterator.<C> empty() : c;
    //
    //        final List<R> result = new ArrayList<>(9);
    //        boolean hasA = true;
    //        boolean hasB = true;
    //
    //        do {
    //            if (hasA && (hasA = iterA.hasNext())) {
    //                result.add(zipFunction.apply(iterA.next(), iterB.hasNext() ? iterB.next() : valueForNoneB, iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else if (hasB && (hasB = iterB.hasNext())) {
    //                result.add(zipFunction.apply(valueForNoneA, iterB.next(), iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else if (iterC.hasNext()) {
    //                result.add(zipFunction.apply(valueForNoneA, valueForNoneB, iterC.hasNext() ? iterC.next() : valueForNoneC));
    //            } else {
    //                break;
    //            }
    //        } while (true);
    //
    //        return result;
    //    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param zipFunction
     * @param targetElementType
     * @return
     */
    public static <A, B, R> R[] zip(final A[] a, final B[] b, final BiFunction<? super A, ? super B, ? extends R> zipFunction,
            final Class<R> targetElementType) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int minLen = min(lenA, lenB);

        final R[] result = newArray(targetElementType, minLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <R>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param zipFunction
     * @param targetElementType
     * @return
     */
    public static <A, B, R> R[] zip(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction, final Class<R> targetElementType) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int minLen = min(lenA, lenB);
        final int maxLen = max(lenA, lenB);

        final R[] result = newArray(targetElementType, maxLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < maxLen) {
            for (int i = lenA; i < maxLen; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < maxLen) {
            for (int i = lenB; i < maxLen; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param zipFunction
     * @param targetElementType
     * @return
     */
    public static <A, B, C, R> R[] zip(final A[] a, final B[] b, final C[] c, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction,
            final Class<R> targetElementType) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int minLen = min(lenA, lenB, lenC);

        final R[] result = newArray(targetElementType, minLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <R>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param zipFunction
     * @param targetElementType
     * @return
     */
    public static <A, B, C, R> R[] zip(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB, final C valueForNoneC,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction, final Class<R> targetElementType) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int minLen = min(lenA, lenB, lenC);
        final int maxLen = max(lenA, lenB, lenC);

        final R[] result = newArray(targetElementType, maxLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (minLen < maxLen) {
            for (int i = minLen; i < maxLen; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     *
     *
     * @param <T>
     * @param <A>
     * @param <B>
     * @param c
     * @param unzip the second parameter is an output parameter.
     * @return
     */
    public static <T, A, B> Pair<List<A>, List<B>> unzip(final Iterable<? extends T> c, final BiConsumer<? super T, Pair<A, B>> unzip) {
        return unzip(c, unzip, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <A>
     * @param <B>
     * @param <LC>
     * @param <RC>
     * @param c
     * @param unzip the second parameter is an output parameter.
     * @param supplier
     * @return
     */
    public static <T, A, B, LC extends Collection<A>, RC extends Collection<B>> Pair<LC, RC> unzip(final Iterable<? extends T> c,
            final BiConsumer<? super T, Pair<A, B>> unzip, final IntFunction<? extends Collection<?>> supplier) {
        final int len = getSizeOrDefault(c, 0);

        final LC l = (LC) supplier.apply(len);
        final RC r = (RC) supplier.apply(len);
        final Pair<A, B> p = new Pair<>();

        if (c != null) {
            for (final T e : c) {
                unzip.accept(e, p);

                l.add(p.left);
                r.add(p.right);
            }
        }

        return Pair.of(l, r);
    }

    //    /**
    //     *
    //     * @param <T>
    //     * @param <L>
    //     * @param <R>
    //     * @param iter
    //     * @param unzip the second parameter is an output parameter.
    //     * @return
    //     * @see {@code Iterators.unzip(Iterator, BiConsumer)}
    //     */
    //    public static <T, L, R> Pair<List<L>, List<R>> unzip(final Iterator<? extends T> iter,
    //            final BiConsumer<? super T, Pair<L, R>> unzip) {
    //        final int len = 9;
    //
    //        final List<L> l = new ArrayList<>(len);
    //        final List<R> r = new ArrayList<>(len);
    //        final Pair<L, R> p = new Pair<>();
    //
    //        if (iter != null) {
    //            T e = null;
    //
    //            while (iter.hasNext()) {
    //                e = iter.next();
    //
    //                unzip.accept(e, p);
    //
    //                l.add(p.left);
    //                r.add(p.right);
    //            }
    //        }
    //
    //        return Pair.of(l, r);
    //    }

    /**
     *
     *
     * @param <T>
     * @param <A>
     * @param <B>
     * @param <C>
     * @param c
     * @param unzip the second parameter is an output parameter.
     * @return
     * @see TriIterator#unzip(Iterable, BiConsumer)
     * @see TriIterator#toMultiList(Supplier)
     * @see TriIterator#toMultiSet(Supplier)
     * @deprecated replaced by {@link TriIterator#unzip(Iterable, BiConsumer)}
     */
    @Deprecated
    public static <T, A, B, C> Triple<List<A>, List<B>, List<C>> unzipp(final Iterable<? extends T> c, final BiConsumer<? super T, Triple<A, B, C>> unzip) {
        return unzipp(c, unzip, Factory.ofList());
    }

    /**
     *
     *
     * @param <T>
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <LC>
     * @param <MC>
     * @param <RC>
     * @param c
     * @param unzip the second parameter is an output parameter.
     * @param supplier
     * @return
     * @see TriIterator#unzip(Iterable, BiConsumer)
     * @see TriIterator#toMultiList(Supplier)
     * @see TriIterator#toMultiSet(Supplier)
     * @deprecated replaced by {@link TriIterator#unzip(Iterable, BiConsumer)}
     */
    @Deprecated
    public static <T, A, B, C, LC extends Collection<A>, MC extends Collection<B>, RC extends Collection<C>> Triple<LC, MC, RC> unzipp(
            final Iterable<? extends T> c, final BiConsumer<? super T, Triple<A, B, C>> unzip, final IntFunction<? extends Collection<?>> supplier) {
        final int len = getSizeOrDefault(c, 0);

        final LC l = (LC) supplier.apply(len);
        final MC m = (MC) supplier.apply(len);
        final RC r = (RC) supplier.apply(len);
        final Triple<A, B, C> t = new Triple<>();

        if (c != null) {
            for (final T e : c) {
                unzip.accept(e, t);

                l.add(t.left);
                m.add(t.middle);
                r.add(t.right);
            }
        }

        return Triple.of(l, m, r);
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param a
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final T[] a, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(a, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param a
     * @param keyExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final T[] a, final Function<? super T, ? extends K> keyExtractor, final Supplier<M> mapSupplier) {
        return groupBy(a, 0, len(a), keyExtractor, mapSupplier);
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(a, fromIndex, toIndex, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param keyExtractor
     * @param mapSupplier
     * @return
     * @throws IndexOutOfBoundsException
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends K> keyExtractor, final Supplier<M> mapSupplier) throws IndexOutOfBoundsException {
        final int length = len(a);

        checkFromToIndex(fromIndex, toIndex, length);

        final M ret = mapSupplier.get();
        K key = null;
        List<T> val = null;

        for (int i = fromIndex; i < toIndex; i++) {
            key = keyExtractor.apply(a[i]);
            val = ret.get(key);

            if (val == null) {
                val = new ArrayList<>();

                ret.put(key, val);
            }

            val.add(a[i]);
        }

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param c
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(c, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param c
     * @param keyExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        K key = null;
        List<T> val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = ret.get(key);

            if (val == null) {
                val = new ArrayList<>();

                ret.put(key, val);
            }

            val.add(e);
        }

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param iter
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(iter, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param iter
     * @param keyExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        K key = null;
        List<T> val = null;
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);
            val = ret.get(key);

            if (val == null) {
                val = new ArrayList<>();

                ret.put(key, val);
            }

            val.add(e);
        }

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <V>
     * @param c
     * @param keyExtractor
     * @param valueExtractor
     * @return
     */
    @Beta
    public static <T, K, V> Map<K, List<V>> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        return groupBy(c, keyExtractor, valueExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <V>
     * @param <M>
     * @param c
     * @param keyExtractor
     * @param valueExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, V, M extends Map<K, List<V>>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        K key = null;
        List<V> val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = ret.get(key);

            if (val == null) {
                val = new ArrayList<>();

                ret.put(key, val);
            }

            val.add(valueExtractor.apply(e));
        }

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <V>
     * @param iter
     * @param keyExtractor
     * @param valueExtractor
     * @return
     */
    @Beta
    public static <T, K, V> Map<K, List<V>> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        return groupBy(iter, keyExtractor, valueExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <V>
     * @param <M>
     * @param iter
     * @param keyExtractor
     * @param valueExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, V, M extends Map<K, List<V>>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        K key = null;
        List<V> val = null;
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);
            val = ret.get(key);

            if (val == null) {
                val = new ArrayList<>();

                ret.put(key, val);
            }

            val.add(valueExtractor.apply(e));
        }

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <R>
     * @param c
     * @param keyExtractor
     * @param collector
     * @return
     */
    @Beta
    public static <T, K, R> Map<K, R> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector) {
        return groupBy(c, keyExtractor, collector, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <R>
     * @param <M>
     * @param c
     * @param keyExtractor
     * @param collector
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, R, M extends Map<K, R>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        final Supplier<Object> downstreamSupplier = (Supplier<Object>) collector.supplier();
        final BiConsumer<Object, ? super T> downstreamAccumulator = (BiConsumer<Object, ? super T>) collector.accumulator();
        final Function<Object, R> downstreamFinisher = (Function<Object, R>) collector.finisher();

        final Map<K, Object> intermediate = (Map<K, Object>) ret;

        if (c == null) {
            return ret;
        }

        K key = null;
        Object val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);

            if (((val = intermediate.get(key)) == null) && ((val = downstreamSupplier.get()) != null)) {
                intermediate.put(key, val);
            }

            downstreamAccumulator.accept(val, e);
        }

        updateIntermediateValue(intermediate, downstreamFinisher);

        return ret;
    }

    /**
     *
     *
     * @param <K>
     * @param <T>
     * @param <R>
     * @param iter
     * @param keyExtractor
     * @param collector
     * @return
     */
    @Beta
    public static <K, T, R> Map<K, R> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector) {
        return groupBy(iter, keyExtractor, collector, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <K>
     * @param <T>
     * @param <R>
     * @param <M>
     * @param iter
     * @param keyExtractor
     * @param collector
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <K, T, R, M extends Map<K, R>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        final Supplier<Object> downstreamSupplier = (Supplier<Object>) collector.supplier();
        final BiConsumer<Object, ? super T> downstreamAccumulator = (BiConsumer<Object, ? super T>) collector.accumulator();
        final Function<Object, R> downstreamFinisher = (Function<Object, R>) collector.finisher();

        final Map<K, Object> intermediate = (Map<K, Object>) ret;

        if (iter == null) {
            return ret;
        }

        T e = null;
        K key = null;
        Object val = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);

            if (((val = intermediate.get(key)) == null) && ((val = downstreamSupplier.get()) != null)) {
                intermediate.put(key, val);
            }

            downstreamAccumulator.accept(val, e);
        }

        updateIntermediateValue(intermediate, downstreamFinisher);

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param c
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, Integer> countBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return countBy(c, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param c
     * @param keyExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, M extends Map<K, Integer>> M countBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        @SuppressWarnings("rawtypes")
        final Map<K, MutableInt> intermediateMap = (Map) ret;

        K key = null;
        MutableInt val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = intermediateMap.get(key);

            if (val == null) {
                intermediateMap.put(key, MutableInt.of(1));
            } else {
                val.increment();
            }
        }

        updateIntermediateValue(intermediateMap, MutableInt::value);

        return ret;
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param iter
     * @param keyExtractor
     * @return
     */
    @Beta
    public static <T, K> Map<K, Integer> countBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor) {
        return countBy(iter, keyExtractor, Suppliers.ofMap());
    }

    /**
     *
     *
     * @param <T>
     * @param <K>
     * @param <M>
     * @param iter
     * @param keyExtractor
     * @param mapSupplier
     * @return
     */
    @Beta
    public static <T, K, M extends Map<K, Integer>> M countBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        @SuppressWarnings("rawtypes")
        final Map<K, MutableInt> intermediateMap = (Map) ret;

        K key = null;
        MutableInt val = null;

        while (iter.hasNext()) {
            key = keyExtractor.apply(iter.next());
            val = intermediateMap.get(key);

            if (val == null) {
                intermediateMap.put(key, MutableInt.of(1));
            } else {
                val.increment();
            }
        }

        updateIntermediateValue(intermediateMap, MutableInt::value);

        return ret;
    }

    static <V> void updateIntermediateValue(final Map<?, V> intermediate, final Function<? super V, ?> downstreamFinisher) {
        for (final Map.Entry<?, V> entry : intermediate.entrySet()) {
            entry.setValue((V) downstreamFinisher.apply(entry.getValue()));
        }
    }

    /**
     * Returns an iterator over the elements in the specified array.
     *
     * @param a the array to iterate over.
     * @return an iterator over the elements in the specified array. If the array is {@code null}, an empty iterator is returned.
     * @see ObjIterator#of(Object...)
     */
    @Beta
    public static <T> ObjIterator<T> iterate(final T[] a) {
        return ObjIterator.of(a);
    }

    /**
     * Returns an iterator over the elements in the specified array, starting from the 'fromIndex' and ending before the 'toIndex'.
     *
     * @param a the array to iterate over.
     * @param fromIndex the index of the first element to be returned from the iterator.
     * @param toIndex the index after the last element to be returned from the iterator.
     * @return an iterator over the elements in the specified range of the array.
     * @throws IndexOutOfBoundsException if the indices are out of range.
     * @see ObjIterator#of(Object[], int, int)
     */
    @Beta
    public static <T> ObjIterator<T> iterate(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return ObjIterator.of(a, fromIndex, toIndex);
    }

    /**
     * Returns an iterator over the elements in the specified iterable.
     *
     * @param iterable the {@code iterable} to iterate over.
     * @return an iterator over the elements in the specified iterable. If the {@code iterable} is {@code null}, an empty iterator is returned.
     */
    @Beta
    public static <T> Iterator<T> iterate(final Iterable<? extends T> iterable) {
        return iterable == null ? ObjIterator.<T> empty() : (Iterator<T>) iterable.iterator();
    }

    /**
     * Returns {@code true} if the two specified arrays/collections have no elements in common.
     *
     * @param a
     * @param b
     * @return
     */
    public static boolean disjoint(final Object[] a, final Object[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return true;
        }

        return a.length >= b.length ? disjoint(Arrays.asList(a), asSet(b)) : disjoint(asSet(a), Arrays.asList(b));
    }

    /**
     * Returns {@code true} if the two specified arrays/collections have no elements in common.
     *
     * @param c1
     * @param c2
     * @return {@code true} if the two specified arrays have no elements in common.
     * @see Collections#disjoint(Collection, Collection)
     */
    public static boolean disjoint(final Collection<?> c1, final Collection<?> c2) {
        if (isEmpty(c1) || isEmpty(c2)) {
            return true;
        }

        if (c1 instanceof Set || (!(c2 instanceof Set) && c1.size() > c2.size())) {
            for (final Object e : c2) {
                if (c1.contains(e)) {
                    return false;
                }
            }
        } else {
            for (final Object e : c1) {
                if (c2.contains(e)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Converts the given object into a JSON string.
     *
     * @param obj the object to be converted into a JSON string.
     * @return a JSON string representation of the given object.
     */
    public static String toJson(final Object obj) {
        return Utils.jsonParser.serialize(obj, Utils.jsc);
    }

    /**
     * Converts the given object into a JSON string with optional pretty formatting.
     *
     * @param obj the object to be converted into a JSON string.
     * @param prettyFormat a boolean flag that indicates whether the JSON string should be pretty formatted or not.
     * @return a JSON string representation of the given object. If prettyFormat is {@code true}, the JSON string is formatted with indents and line breaks for easier reading.
     */
    public static String toJson(final Object obj, final boolean prettyFormat) {
        return Utils.jsonParser.serialize(obj, prettyFormat ? Utils.jscPrettyFormat : Utils.jsc);
    }

    /**
     *
     * @param obj
     * @param config
     * @return
     */
    public static String toJson(final Object obj, final JSONSerializationConfig config) {
        return Utils.jsonParser.serialize(obj, config);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toJson(final Object obj, final File output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final File output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toJson(final Object obj, final OutputStream output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final OutputStream output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toJson(final Object obj, final Writer output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final Writer output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param defaultIfNull
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final T defaultIfNull, final Class<? extends T> targetType) {
        final T ret = fromJson(json, targetType);

        return ret == null ? defaultIfNull : ret;
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final File json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final File json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final InputStream json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final InputStream json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final Reader json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final Reader json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param fromIndex
     * @param toIndex
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param fromIndex
     * @param toIndex
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final JSONDeserializationConfig config,
            final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param defaultIfNull
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final T defaultIfNull, final Type<? extends T> targetType) {
        final T ret = fromJson(json, targetType);

        return ret == null ? defaultIfNull : ret;
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final File json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final File json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final InputStream json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final InputStream json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final Reader json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final Reader json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param fromIndex
     * @param toIndex
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final Type<? extends T> targetType) {
        return fromJson(json, fromIndex, toIndex, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param json
     * @param fromIndex
     * @param toIndex
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final JSONDeserializationConfig config,
            final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final String jsonArray, final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param config
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final String jsonArray, final JSONDeserializationConfig config,
            final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, config, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final File jsonArray, final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param config
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final File jsonArray, final JSONDeserializationConfig config,
            final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, config, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final InputStream jsonArray, final Class<? extends T> elementClass) {
        return streamJson(jsonArray, false, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param closeInputStreamWhenStreamIsClosed
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final InputStream jsonArray, final boolean closeInputStreamWhenStreamIsClosed,
            final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, closeInputStreamWhenStreamIsClosed, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param config
     * @param closeInputStreamWhenStreamIsClosed
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final InputStream jsonArray, final JSONDeserializationConfig config,
            final boolean closeInputStreamWhenStreamIsClosed, final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, config, closeInputStreamWhenStreamIsClosed, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final Reader jsonArray, final Class<? extends T> elementClass) {
        return streamJson(jsonArray, false, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param closeReaderWhenStreamIsClosed
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final Reader jsonArray, final boolean closeReaderWhenStreamIsClosed,
            final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, closeReaderWhenStreamIsClosed, elementClass);
    }

    /**
     *
     *
     * @param <T>
     * @param jsonArray must be a json array/list.
     * @param config
     * @param closeReaderWhenStreamIsClosed
     * @param elementClass Only Bean/Map/Collection/Array/DataSet element types are supported at present.
     * @return
     */
    public static <T> CheckedStream<T, IOException> streamJson(final Reader jsonArray, final JSONDeserializationConfig config,
            final boolean closeReaderWhenStreamIsClosed, final Class<? extends T> elementClass) {
        return Utils.jsonParser.stream(jsonArray, config, closeReaderWhenStreamIsClosed, elementClass);
    }

    /**
     *
     * @param json
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json) {
        return formatJson(json, Utils.jscPrettyFormat, Object.class);
    }

    /**
     *
     * @param json
     * @param config
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json, final JSONSerializationConfig config) {
        return formatJson(json, config, Object.class);
    }

    /**
     *
     * @param json
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json, final Class<?> transferType) {
        return toJson(fromJson(json, transferType), Utils.jscPrettyFormat);
    }

    /**
     *
     * @param json
     * @param config
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json, final JSONSerializationConfig config, final Class<?> transferType) {
        final JSONSerializationConfig configToUse = config == null ? Utils.jscPrettyFormat
                : (config.prettyFormat() == false ? config.copy().prettyFormat(true) : config);

        return toJson(fromJson(json, transferType), configToUse);
    }

    /**
     *
     * @param json
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json, final Type<?> transferType) {
        return toJson(fromJson(json, transferType), Utils.jscPrettyFormat);
    }

    /**
     *
     * @param json
     * @param config
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatJson(final String json, final JSONSerializationConfig config, final Type<?> transferType) {
        final JSONSerializationConfig configToUse = config == null ? Utils.jscPrettyFormat
                : (config.prettyFormat() == false ? config.copy().prettyFormat(true) : config);

        return toJson(fromJson(json, transferType), configToUse);
    }

    /**
     * Converts the given object into an XML string.
     *
     * @param obj the object to be converted into an XML string.
     * @return an XML string representation of the given object.
     */
    public static String toXml(final Object obj) {
        return Utils.xmlParser.serialize(obj);
    }

    /**
     * Converts the given object into an XML string with optional pretty formatting.
     *
     * @param obj the object to be converted into an XML string.
     * @param prettyFormat a boolean flag that indicates whether the XML string should be pretty formatted or not.
     * @return an XML string representation of the given object. If prettyFormat is {@code true}, the XML string is formatted with indents and line breaks for easier reading.
     */
    public static String toXml(final Object obj, final boolean prettyFormat) {
        return Utils.xmlParser.serialize(obj, prettyFormat ? Utils.xscPrettyFormat : Utils.xsc);
    }

    /**
     *
     * @param obj
     * @param config
     * @return
     */
    public static String toXml(final Object obj, final XMLSerializationConfig config) {
        return Utils.xmlParser.serialize(obj, config);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toXml(final Object obj, final File output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final File output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toXml(final Object obj, final OutputStream output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final OutputStream output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     *
     * @param obj
     * @param output
     */
    public static void toXml(final Object obj, final Writer output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     *
     * @param obj
     * @param config
     * @param output
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final Writer output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final String xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final String xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final File xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final File xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final InputStream xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final InputStream xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final Reader xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final Reader xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final String xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final String xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final File xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final File xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final InputStream xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final InputStream xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final Reader xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     *
     *
     * @param <T>
     * @param xml
     * @param config
     * @param targetType can be the {@code Type} of {@code Bean/Array/Collection/Map}.
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static <T> T fromXml(final Reader xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     * Sets the config.
     *
     * @param <C>
     * @param targetType
     * @param config
     * @param isJSON
     * @return
     */
    private static <C extends DeserializationConfig<C>> C setConfig(final Type<?> targetType, final C config, final boolean isJSON) {
        C configToReturn = config;

        if (targetType.isCollection() || targetType.isArray()) {
            if (config == null || config.getElementType() == null) {
                configToReturn = config == null ? (C) (isJSON ? JDC.create() : XDC.create()) : (C) config.copy();

                configToReturn.setElementType(targetType.getParameterTypes()[0]);
            }
        } else if (targetType.isMap() && (config == null || config.getMapKeyType() == null || config.getMapValueType() == null)) {
            configToReturn = config == null ? (C) (isJSON ? JDC.create() : XDC.create()) : (C) config.copy();

            if (configToReturn.getMapKeyType() == null) {
                configToReturn.setMapKeyType(targetType.getParameterTypes()[0]);
            }

            if (configToReturn.getMapValueType() == null) {
                configToReturn.setMapValueType(targetType.getParameterTypes()[1]);
            }
        }

        return configToReturn;
    }

    /**
     *
     * @param xml
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml) {
        return formatXml(xml, MapEntity.class);
    }

    /**
     *
     * @param xml
     * @param config
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config) {
        return formatXml(xml, config, MapEntity.class);
    }

    /**
     *
     * @param xml
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml, final Class<?> transferType) {
        return toXml(fromXml(xml, transferType), Utils.xscPrettyFormat);
    }

    /**
     *
     * @param xml
     * @param config
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config, final Class<?> transferType) {
        final XMLSerializationConfig configToUse = config == null ? Utils.xscPrettyFormat
                : (config.prettyFormat() == false ? config.copy().prettyFormat(true) : config);

        return toXml(fromXml(xml, transferType), configToUse);
    }

    /**
     *
     * @param xml
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml, final Type<?> transferType) {
        return toXml(fromXml(xml, transferType), Utils.xscPrettyFormat);
    }

    /**
     *
     * @param xml
     * @param config
     * @param transferType
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config, final Type<?> transferType) {
        final XMLSerializationConfig configToUse = config == null ? Utils.xscPrettyFormat
                : (config.prettyFormat() == false ? config.copy().prettyFormat(true) : config);

        return toXml(fromXml(xml, transferType), configToUse);
    }

    /**
     * Xml 2 JSO.
     *
     * @param xml
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String xml2Json(final String xml) {
        return xml2Json(xml, Map.class);
    }

    /**
     * Xml 2 JSO.
     * @param xml
     * @param transferType
     *
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String xml2Json(final String xml, final Class<?> transferType) {
        return Utils.jsonParser.serialize(Utils.xmlParser.deserialize(xml, transferType), Utils.jsc);
    }

    /**
     * Json 2 XML.
     *
     * @param json
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String json2Xml(final String json) {
        return json2Xml(json, Map.class);
    }

    /**
     * Json 2 XML.
     * @param json
     * @param transferType
     *
     * @return
     * @see com.landawn.abacus.util.TypeReference
     * @see com.landawn.abacus.util.TypeReference.TypeToken
     */
    public static String json2Xml(final String json, final Class<?> transferType) {
        return Utils.xmlParser.serialize(Utils.jsonParser.deserialize(json, transferType));
    }

    /**
     * Executes the provided {@code action} for each value in the range defined by {@code startInclusive} and {@code endExclusive}.
     *
     * @param <E> the type of the exception that the action may throw
     * @param startInclusive the start value of the range (inclusive)
     * @param endExclusive the end value of the range (exclusive)
     * @param action the action to be performed for each value in the range
     * @throws E if the action throws an exception
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final Throwables.Runnable<E> action) throws E {
        forEach(startInclusive, endExclusive, 1, action);
    }

    /**
     * Executes the provided {@code action} for each value in the range defined by {@code startInclusive}, {@code endExclusive} and {@code step}.
     *
     * @param <E> the type of the exception that the action may throw
     * @param startInclusive the start value of the range (inclusive)
     * @param endExclusive the end value of the range (exclusive)
     * @param step the increment value for each iteration in the range
     * @param action the action to be performed for each value in the range
     * @throws IllegalArgumentException if the step is less than 1
     * @throws E if the action throws an exception
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final Throwables.Runnable<E> action)
            throws IllegalArgumentException, E {
        checkArgument(step != 0, "The input parameter 'step' can not be zero"); //NOSONAR

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = (endExclusive * 1L - startInclusive) / step + ((endExclusive * 1L - startInclusive) % step == 0 ? 0 : 1);

        while (len-- > 0) {
            action.run();
        }
    }

    /**
     *
     *
     * @param <E>
     * @param startInclusive
     * @param endExclusive
     * @param action
     * @throws E the e
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final Throwables.IntConsumer<E> action) throws E {
        forEach(startInclusive, endExclusive, 1, action);
    }

    /**
     *
     * @param <E>
     * @param startInclusive
     * @param endExclusive
     * @param step
     * @param action
     * @throws E the e
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final Throwables.IntConsumer<E> action)
            throws E {
        checkArgument(step != 0, "The input parameter 'step' can not be zero");

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = (endExclusive * 1L - startInclusive) / step + ((endExclusive * 1L - startInclusive) % step == 0 ? 0 : 1);
        int start = startInclusive;

        while (len-- > 0) {
            action.accept(start);
            start += step;
        }
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param startInclusive
     * @param endExclusive
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final int startInclusive, final int endExclusive, final T a,
            final Throwables.IntObjConsumer<? super T, E> action) throws E {
        forEach(startInclusive, endExclusive, 1, a, action);
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param startInclusive
     * @param endExclusive
     * @param step
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final T a,
            final Throwables.IntObjConsumer<? super T, E> action) throws E {
        checkArgument(step != 0, "The input parameter 'step' can not be zero");

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = (endExclusive * 1L - startInclusive) / step + ((endExclusive * 1L - startInclusive) % step == 0 ? 0 : 1);
        int start = startInclusive;

        while (len-- > 0) {
            action.accept(start, a);
            start += step;
        }
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param action
     * @throws IndexOutOfBoundsException
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final T[] a, final Throwables.Consumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        if (isEmpty(a)) {
            return;
        }

        for (final T e : a) {
            action.accept(e);
        }
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final T[] a, final int fromIndex, final int toIndex, final Throwables.Consumer<? super T, E> action)
            throws E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), fromIndex < toIndex ? toIndex : fromIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (fromIndex <= toIndex) {
            for (int i = fromIndex; i < toIndex; i++) {
                action.accept(a[i]);
            }
        } else {
            for (int i = min(a.length - 1, fromIndex); i > toIndex; i--) {
                action.accept(a[i]);
            }
        }
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> action) throws E {
        if (c == null) {
            return;
        }

        for (final T e : c) {
            action.accept(e);
        }
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> action) throws E {
        if (iter == null) {
            return;
        }

        while (iter.hasNext()) {
            action.accept(iter.next());
        }
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * Note: This is NOT a replacement of traditional for loop statement.
     * The traditional for loop is still recommended in regular programming.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param action
     * @throws IndexOutOfBoundsException
     * @throws E the e
     */
    public static <T, E extends Exception> void forEach(final Collection<? extends T> c, int fromIndex, final int toIndex,
            final Throwables.Consumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), fromIndex < toIndex ? toIndex : fromIndex, size(c));
        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        fromIndex = min(c.size() - 1, fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            if (fromIndex <= toIndex) {
                for (int i = fromIndex; i < toIndex; i++) {
                    action.accept(list.get(i));
                }
            } else {
                for (int i = fromIndex; i > toIndex; i--) {
                    action.accept(list.get(i));
                }
            }
        } else {
            if (fromIndex <= toIndex) {
                final Iterator<? extends T> iter = c.iterator();
                int idx = 0;

                while (idx < fromIndex && iter.hasNext()) {
                    iter.next();
                    idx++;
                }

                while (iter.hasNext()) {
                    action.accept(iter.next());

                    if (++idx >= toIndex) {
                        break;
                    }
                }
            } else {
                final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

                if (descendingIterator != null) {
                    int idx = c.size() - 1;

                    while (idx > fromIndex && descendingIterator.hasNext()) {
                        descendingIterator.next();
                        idx--;
                    }

                    while (descendingIterator.hasNext()) {
                        action.accept(descendingIterator.next());

                        if (--idx <= toIndex) {
                            break;
                        }
                    }
                } else {
                    final Iterator<? extends T> iter = c.iterator();
                    int idx = 0;

                    while (idx <= toIndex && iter.hasNext()) {
                        iter.next();
                        idx++;
                    }

                    final T[] a = (T[]) new Object[fromIndex - toIndex];

                    while (iter.hasNext()) {
                        a[idx - 1 - toIndex] = iter.next();

                        if (idx++ >= fromIndex) {
                            break;
                        }
                    }

                    for (int i = a.length - 1; i >= 0; i--) {
                        action.accept(a[i]);
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @param <K>
     * @param <V>
     * @param <E>
     * @param map
     * @param action
     * @throws E the e
     */
    public static <K, V, E extends Exception> void forEach(final Map<K, V> map, final Throwables.Consumer<? super Map.Entry<K, V>, E> action) throws E {
        if (isEmpty(map)) {
            return;
        }

        forEach(map.entrySet(), action);
    }

    /**
     *
     *
     * @param <K>
     * @param <V>
     * @param <E>
     * @param map
     * @param action
     * @throws E the e
     */
    public static <K, V, E extends Exception> void forEach(final Map<K, V> map, final Throwables.BiConsumer<? super K, ? super V, E> action) throws E {
        if (isEmpty(map)) {
            return;
        }

        for (final Map.Entry<K, V> entry : map.entrySet()) {
            action.accept(entry.getKey(), entry.getValue());
        }
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param elementConsumer
     * @param processThreadNum
     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEach(c, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param elementConsumer
     * @param processThreadNum
     * @param executor
     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) {
        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;

        forEach(c == null ? ObjIterator.<T> empty() : c.iterator(), elementConsumer, N.min(size, processThreadNum), executor);
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param elementConsumer
     * @param processThreadNum
     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEach(iter, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param elementConsumer
     * @param processThreadNum
     * @param executor
     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) {
        final Iterator<? extends T> iteratorII = iter == null ? ObjIterator.<T> empty() : iter;
        final CountDownLatch countDownLatch = new CountDownLatch(processThreadNum);
        final Holder<Exception> errorHolder = new Holder<>();

        for (int i = 0; i < processThreadNum; i++) {
            executor.execute(() -> {
                T element = null;

                try {
                    while (errorHolder.value() == null) {
                        synchronized (iteratorII) {
                            if (iteratorII.hasNext()) {
                                element = iteratorII.next();
                            } else {
                                break;
                            }
                        }

                        elementConsumer.accept(element);
                    }
                } catch (final Exception e) {
                    synchronized (errorHolder) {
                        if (errorHolder.value() == null) {
                            errorHolder.setValue(e);
                        } else {
                            errorHolder.value().addSuppressed(e);
                        }
                    }
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (final InterruptedException e) {
            N.toRuntimeException(e);
        }

        if (errorHolder.value() != null) {
            throw ExceptionUtil.toRuntimeException(errorHolder.value());
        }
    }

    // commented out because of ambiguous and not be consistent with other forEach methods because it has return values.
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param c
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
    //     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEach(final Iterable<? extends T> c, final Throwables.Function<? super T, R, E> elementMapper,
    //            final int processThreadNum) {
    //        return forEach(c, elementMapper, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param c
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @param executor
    //     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
    //     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEach(final Iterable<? extends T> c, final Throwables.Function<? super T, R, E> elementMapper,
    //            final int processThreadNum, final Executor executor) {
    //        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;
    //
    //        return forEach(c == null ? ObjIterator.<T> empty() : c.iterator(), elementMapper, N.min(size, processThreadNum), executor);
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param iter
    //     * @param elementConsumer
    //     * @param processThreadNum
    //     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
    //     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEach(final Iterator<? extends T> iter, final Throwables.Function<? super T, R, E> elementMapper,
    //            final int processThreadNum) {
    //        return forEach(iter, elementMapper, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param iter
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @see {@link Fnn#f(com.landawn.abacus.util.Throwables.Function)
    //     * @see {@link Fnn#c(com.landawn.abacus.util.Throwables.Consumer)}
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEach(final Iterator<? extends T> iter, final Throwables.Function<? super T, R, E> elementMapper,
    //            final int processThreadNum, final Executor executor) {
    //        final Iterator<? extends T> iterToUse = iter == null ? ObjIterator.<T> empty() : iter;
    //        final CountDownLatch latch = new CountDownLatch(processThreadNum);
    //        final AtomicInteger index = new AtomicInteger(0);
    //        final Holder<Exception> errorHolder = new Holder<>();
    //        final List<Indexed<R>> result = new ArrayList<>();
    //
    //        for (int i = 0; i < processThreadNum; i++) {
    //            executor.execute(() -> {
    //                int idx = 0;
    //                T element = null;
    //                R ret = null;
    //
    //                try {
    //                    while (errorHolder.value() == null) {
    //                        synchronized (iterToUse) {
    //                            if (iterToUse.hasNext()) {
    //                                idx = index.getAndIncrement();
    //                                element = iterToUse.next();
    //                            } else {
    //                                break;
    //                            }
    //                        }
    //
    //                        ret = elementMapper.apply(element);
    //
    //                        synchronized (result) {
    //                            result.add(Indexed.of(ret, idx));
    //                        }
    //                    }
    //                } catch (Exception e) {
    //                    synchronized (errorHolder) {
    //                        if (errorHolder.value() == null) {
    //                            errorHolder.setValue(e);
    //                        } else {
    //                            errorHolder.value().addSuppressed(e);
    //                        }
    //                    }
    //                } finally {
    //                    latch.countDown();
    //                }
    //            });
    //        }
    //
    //        try {
    //            latch.await();
    //        } catch (InterruptedException e) {
    //            N.toRuntimeException(e);
    //        }
    //
    //        if (errorHolder.value() != null) {
    //            throw ExceptionUtil.toRuntimeException(errorHolder.value());
    //        }
    //
    //        N.sort(result, Comparators.comparingInt(Indexed::index));
    //
    //        return N.map(result, Indexed::value);
    //    }

    /**
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param a
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param c
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (c == null) {
            return;
        }

        for (final T t : c) {
            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param iter
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param a
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param c
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (c == null) {
            return;
        }

        for (final T t : c) {
            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param iter
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final A[] a, final B[] b, final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (isEmpty(a) || isEmpty(b)) {
            return;
        }

        for (int i = 0, minLen = min(a.length, b.length); i < minLen; i++) {
            action.accept(a[i], b[i]);
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (a == null || b == null) {
            return;
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();

        forEach(iterA, iterB, action);
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (a == null || b == null) {
            return;
        }

        while (a.hasNext() && b.hasNext()) {
            action.accept(a.next(), b.next());
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final A[] a, final B[] b, final C[] c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (isEmpty(a) || isEmpty(b) || isEmpty(c)) {
            return;
        }

        for (int i = 0, minLen = min(a.length, b.length, c.length); i < minLen; i++) {
            action.accept(a[i], b[i], c[i]);
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (a == null || b == null || c == null) {
            return;
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final Iterator<C> iterC = c.iterator();

        forEach(iterA, iterB, iterC, action);
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (a == null || b == null || c == null) {
            return;
        }

        while (a.hasNext() && b.hasNext() && c.hasNext()) {
            action.accept(a.next(), b.next(), c.next());
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final int lenA = len(a);
        final int lenB = len(b);

        for (int i = 0, maxLen = max(lenA, lenB); i < maxLen; i++) {
            action.accept(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB);
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a.iterator();
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b.iterator();

        forEach(iterA, iterB, valueForNoneA, valueForNoneB, action);
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <E>
     * @param a
     * @param b
     * @param valueForNoneA
     * @param valueForNoneB
     * @param action
     * @throws E the e
     */
    public static <A, B, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;

        A nextA = null;
        B nextB = null;

        while (iterA.hasNext() || iterB.hasNext()) {
            nextA = iterA.hasNext() ? iterA.next() : valueForNoneA;
            nextB = iterB.hasNext() ? iterB.next() : valueForNoneB;

            action.accept(nextA, nextB);
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB,
            final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);

        for (int i = 0, maxLen = max(lenA, lenB, lenC); i < maxLen; i++) {
            action.accept(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
        }
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c, final A valueForNoneA,
            final B valueForNoneB, final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a.iterator();
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b.iterator();
        final Iterator<C> iterC = c == null ? ObjIterator.<C> empty() : c.iterator();

        forEach(iterA, iterB, iterC, valueForNoneA, valueForNoneB, valueForNoneC, action);
    }

    /**
     *
     *
     * @param <A>
     * @param <B>
     * @param <C>
     * @param <E>
     * @param a
     * @param b
     * @param c
     * @param valueForNoneA
     * @param valueForNoneB
     * @param valueForNoneC
     * @param action
     * @throws E the e
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c, final A valueForNoneA,
            final B valueForNoneB, final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.<A> empty() : a;
        final Iterator<B> iterB = b == null ? ObjIterator.<B> empty() : b;
        final Iterator<C> iterC = b == null ? ObjIterator.<C> empty() : c;

        A nextA = null;
        B nextB = null;
        C nextC = null;

        while (iterA.hasNext() || iterB.hasNext() || iterC.hasNext()) {
            nextA = iterA.hasNext() ? iterA.next() : valueForNoneA;
            nextB = iterB.hasNext() ? iterB.next() : valueForNoneB;
            nextC = iterC.hasNext() ? iterC.next() : valueForNoneC;

            action.accept(nextA, nextB, nextC);
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachNonNull(final T[] a, final Throwables.Consumer<? super T, E> action) throws E {
        if (isEmpty(a)) {
            return;
        }

        for (final T e : a) {
            if (e != null) {
                action.accept(e);
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachNonNull(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> action) throws E {
        if (c == null) {
            return;
        }

        for (final T e : c) {
            if (e != null) {
                action.accept(e);
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param a
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param c
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (c == null) {
            return;
        }

        for (final T t : c) {
            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <U>
     * @param <E>
     * @param <E2>
     * @param iter
     * @param flatMapper
     * @param action
     * @throws E the e
     * @throws E2 the e2
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param a
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param c
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (c == null) {
            return;
        }

        for (final T t : c) {
            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * For each non {@code null}.
     *
     * @param <T>
     * @param <T2>
     * @param <T3>
     * @param <E>
     * @param <E2>
     * @param <E3>
     * @param iter
     * @param flatMapper
     * @param flatMapper2
     * @param action
     * @throws E the e
     * @throws E2 the e2
     * @throws E3 the e3
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachIndexed(final T[] a, final Throwables.IntObjConsumer<? super T, E> action) throws E {
        if (isEmpty(a)) {
            return;
        }

        forEachIndexed(a, 0, a.length, action);
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param fromIndex
     * @param toIndex
     * @param action
     * @throws IndexOutOfBoundsException
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachIndexed(final T[] a, final int fromIndex, final int toIndex,
            final Throwables.IntObjConsumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), fromIndex < toIndex ? toIndex : fromIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (fromIndex <= toIndex) {
            for (int i = fromIndex; i < toIndex; i++) {
                action.accept(i, a[i]);
            }
        } else {
            for (int i = min(a.length - 1, fromIndex); i > toIndex; i--) {
                action.accept(i, a[i]);
            }
        }
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> action) throws E {
        if (c == null) {
            return;
        }

        int idx = 0;

        for (final T e : c) {
            action.accept(idx++, e);
        }
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> action)
            throws E {
        if (iter == null) {
            return;
        }

        int idx = 0;

        while (iter.hasNext()) {
            action.accept(idx++, iter.next());
        }
    }

    /**
     * Mostly it's designed for one-step operation to complete the operation in one step.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     *
     * Note: This is NOT a replacement of traditional for loop statement.
     * The traditional for loop is still recommended in regular programming.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param fromIndex
     * @param toIndex
     * @param action
     * @throws IndexOutOfBoundsException
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachIndexed(final Collection<? extends T> c, int fromIndex, final int toIndex,
            final Throwables.IntObjConsumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), fromIndex < toIndex ? toIndex : fromIndex, size(c));
        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        fromIndex = min(c.size() - 1, fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            if (fromIndex <= toIndex) {
                for (int i = fromIndex; i < toIndex; i++) {
                    action.accept(i, list.get(i));
                }
            } else {
                for (int i = fromIndex; i > toIndex; i--) {
                    action.accept(i, list.get(i));
                }
            }
        } else {
            if (fromIndex < toIndex) {
                final Iterator<? extends T> iter = c.iterator();
                int idx = 0;

                while (idx < fromIndex && iter.hasNext()) {
                    iter.next();
                    idx++;
                }

                while (iter.hasNext()) {
                    action.accept(idx, iter.next());

                    if (++idx >= toIndex) {
                        break;
                    }
                }
            } else {
                final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

                if (descendingIterator != null) {
                    int idx = c.size() - 1;

                    while (idx > fromIndex && descendingIterator.hasNext()) {
                        descendingIterator.next();
                        idx--;
                    }

                    while (descendingIterator.hasNext()) {
                        action.accept(idx, descendingIterator.next());

                        if (--idx <= toIndex) {
                            break;
                        }
                    }
                } else {
                    final Iterator<? extends T> iter = c.iterator();
                    int idx = 0;

                    while (idx <= toIndex && iter.hasNext()) {
                        iter.next();
                        idx++;
                    }

                    final T[] a = (T[]) new Object[fromIndex - toIndex];

                    while (iter.hasNext()) {
                        a[idx - 1 - toIndex] = iter.next();

                        if (idx++ >= fromIndex) {
                            break;
                        }
                    }

                    for (int i = a.length - 1; i >= 0; i--) {
                        action.accept(i + toIndex + 1, a[i]);
                    }
                }
            }
        }
    }

    /**
     *
     * @param <K>
     * @param <V>
     * @param <E>
     * @param map
     * @param action
     * @throws E the e
     */
    public static <K, V, E extends Exception> void forEachIndexed(final Map<K, V> map, final Throwables.IntObjConsumer<? super Map.Entry<K, V>, E> action)
            throws E {
        if (isEmpty(map)) {
            return;
        }

        forEachIndexed(map.entrySet(), action);
    }

    /**
     *
     * @param <K>
     * @param <V>
     * @param <E>
     * @param map
     * @param action
     * @throws E the e
     */
    public static <K, V, E extends Exception> void forEachIndexed(final Map<K, V> map, final Throwables.IntBiObjConsumer<? super K, ? super V, E> action)
            throws E {
        if (isEmpty(map)) {
            return;
        }

        int idx = 0;

        for (final Map.Entry<K, V> entry : map.entrySet()) {
            action.accept(idx++, entry.getKey(), entry.getValue());
        }
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param elementConsumer
     * @param processThreadNum
     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEachIndexed(c, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param elementConsumer
     * @param processThreadNum
     * @param executor
     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) {
        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;

        forEachIndexed(c == null ? ObjIterator.<T> empty() : c.iterator(), elementConsumer, N.min(size, processThreadNum), executor);
    }

    /**
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param elementConsumer
     * @param processThreadNum
     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEachIndexed(iter, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     *
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param elementConsumer
     * @param processThreadNum
     * @param executor
     * @throws IllegalArgumentException
     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) throws IllegalArgumentException {
        final Iterator<? extends T> iteratorII = iter == null ? ObjIterator.<T> empty() : iter;
        final CountDownLatch countDownLatch = new CountDownLatch(processThreadNum);
        final AtomicInteger index = new AtomicInteger(0);
        final Holder<Exception> errorHolder = new Holder<>();

        for (int i = 0; i < processThreadNum; i++) {
            executor.execute(() -> {
                int idx = 0;
                T element = null;

                try {
                    while (errorHolder.value() == null) {
                        synchronized (iteratorII) {
                            if (iteratorII.hasNext()) {
                                idx = index.getAndIncrement();
                                element = iteratorII.next();
                            } else {
                                break;
                            }
                        }

                        elementConsumer.accept(idx, element);
                    }
                } catch (final Exception e) {
                    synchronized (errorHolder) {
                        if (errorHolder.value() == null) {
                            errorHolder.setValue(e);
                        } else {
                            errorHolder.value().addSuppressed(e);
                        }
                    }
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (final InterruptedException e) {
            N.toRuntimeException(e);
        }

        if (errorHolder.value() != null) {
            throw ExceptionUtil.toRuntimeException(errorHolder.value());
        }
    }

    // commented out because of ambiguous and not be consistent with other forEach methods because it has return values.
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param c
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
    //     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEachIndexed(final Iterable<? extends T> c,
    //            final Throwables.IntObjFunction<? super T, R, E> elementMapper, final int processThreadNum) {
    //        return forEachIndexed(c, elementMapper, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param c
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @param executor
    //     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
    //     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEachIndexed(final Iterable<? extends T> c,
    //            final Throwables.IntObjFunction<? super T, R, E> elementMapper, final int processThreadNum, final Executor executor) {
    //        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;
    //
    //        return forEachIndexed(c == null ? ObjIterator.<T> empty() : c.iterator(), elementMapper, N.min(size, processThreadNum), executor);
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param iter
    //     * @param elementConsumer
    //     * @param processThreadNum
    //     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
    //     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEachIndexed(final Iterator<? extends T> iter,
    //            final Throwables.IntObjFunction<? super T, R, E> elementMapper, final int processThreadNum) {
    //        return forEachIndexed(iter, elementMapper, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    //    }
    //
    //    /**
    //     * Returns a result list kept the same order as the input {@code Iterable/Iterator}.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param iter
    //     * @param elementMapper
    //     * @param processThreadNum
    //     * @see Throwables.IntObjFunction#of(com.landawn.abacus.util.Throwables.IntObjFunction)
    //     * @see Throwables.IntObjConsumer#of(com.landawn.abacus.util.Throwables.IntObjConsumer)
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> List<R> forEachIndexed(final Iterator<? extends T> iter,
    //            final Throwables.IntObjFunction<? super T, R, E> elementMapper, final int processThreadNum, final Executor executor) {
    //        final Iterator<? extends T> iterToUse = iter == null ? ObjIterator.<T> empty() : iter;
    //        final CountDownLatch latch = new CountDownLatch(processThreadNum);
    //        final AtomicInteger index = new AtomicInteger(0);
    //        final Holder<Exception> errorHolder = new Holder<>();
    //        final List<Indexed<R>> result = new ArrayList<>();
    //
    //        for (int i = 0; i < processThreadNum; i++) {
    //            executor.execute(() -> {
    //                int idx = 0;
    //                T element = null;
    //                R ret = null;
    //
    //                try {
    //                    while (errorHolder.value() == null) {
    //                        synchronized (iterToUse) {
    //                            if (iterToUse.hasNext()) {
    //                                idx = index.getAndIncrement();
    //                                element = iterToUse.next();
    //                            } else {
    //                                break;
    //                            }
    //                        }
    //
    //                        ret = elementMapper.apply(idx, element);
    //
    //                        synchronized (result) {
    //                            result.add(Indexed.of(ret, idx));
    //                        }
    //                    }
    //                } catch (Exception e) {
    //                    synchronized (errorHolder) {
    //                        if (errorHolder.value() == null) {
    //                            errorHolder.setValue(e);
    //                        } else {
    //                            errorHolder.value().addSuppressed(e);
    //                        }
    //                    }
    //                } finally {
    //                    latch.countDown();
    //                }
    //            });
    //        }
    //
    //        try {
    //            latch.await();
    //        } catch (InterruptedException e) {
    //            N.toRuntimeException(e);
    //        }
    //
    //        if (errorHolder.value() != null) {
    //            throw ExceptionUtil.toRuntimeException(errorHolder.value());
    //        }
    //
    //        N.sort(result, Comparators.comparingInt(Indexed::index));
    //
    //        return N.map(result, Indexed::value);
    //    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final T[] a, final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        forEachPair(a, 1, action);
    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final T[] a, final int increment, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        final int windowSize = 2;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment); //NOSONAR

        if (isEmpty(a)) {
            return;
        }

        final Iterator<? extends T> iter = ObjIterator.of(a);
        forEachPair(iter, increment, action);
    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final Iterable<? extends T> c, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        forEachPair(c, 1, action);
    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final Iterable<? extends T> c, final int increment,
            final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        final int windowSize = 2;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment);

        if (c == null) {
            return;
        }

        final Iterator<? extends T> iter = c.iterator();
        forEachPair(iter, increment, action);
    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final Iterator<? extends T> iter, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        forEachPair(iter, 1, action);
    }

    /**
     * For each pair.
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachPair(final Iterator<? extends T> iter, final int increment,
            final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        final int windowSize = 2;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment);

        if (iter == null) {
            return;
        }

        boolean isFirst = true;
        T prev = null;

        while (iter.hasNext()) {
            if (increment > windowSize && !isFirst) {
                int skipNum = increment - windowSize;

                while (skipNum-- > 0 && iter.hasNext()) {
                    iter.next();
                }

                if (!iter.hasNext()) {
                    break;
                }
            }

            if (increment == 1) {
                action.accept(isFirst ? iter.next() : prev, (prev = (iter.hasNext() ? iter.next() : null)));
            } else {
                action.accept(iter.next(), iter.hasNext() ? iter.next() : null);
            }

            isFirst = false;
        }
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final T[] a, final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(a, 1, action);
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final T[] a, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        final int windowSize = 3;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment);

        if (isEmpty(a)) {
            return;
        }

        final Iterator<? extends T> iter = ObjIterator.of(a);
        forEachTriple(iter, increment, action);
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final Iterable<? extends T> c,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(c, 1, action);
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final Iterable<? extends T> c, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        final int windowSize = 3;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment);

        if (c == null) {
            return;
        }

        final Iterator<? extends T> iter = c.iterator();
        forEachTriple(iter, increment, action);
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final Iterator<? extends T> iter,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(iter, 1, action);
    }

    /**
     * For each triple.
     *
     * @param <T>
     * @param <E>
     * @param iter
     * @param increment
     * @param action
     * @throws E the e
     */
    public static <T, E extends Exception> void forEachTriple(final Iterator<? extends T> iter, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        final int windowSize = 3;
        checkArgument(windowSize > 0 && increment > 0, "windowSize=%s and increment=%s must be bigger than 0", windowSize, increment);

        if (iter == null) {
            return;
        }

        boolean isFirst = true;
        T prev = null;
        T prev2 = null;

        while (iter.hasNext()) {
            if (increment > windowSize && !isFirst) {
                int skipNum = increment - windowSize;

                while (skipNum-- > 0 && iter.hasNext()) {
                    iter.next();
                }

                if (!iter.hasNext()) {
                    break;
                }
            }

            if (increment == 1) {
                action.accept(isFirst ? iter.next() : prev2, (prev2 = (isFirst ? (iter.hasNext() ? iter.next() : null) : prev)),
                        (prev = (iter.hasNext() ? iter.next() : null)));
            } else if (increment == 2) {
                action.accept(isFirst ? iter.next() : prev, iter.hasNext() ? iter.next() : null, (prev = (iter.hasNext() ? iter.next() : null)));
            } else {
                action.accept(iter.next(), iter.hasNext() ? iter.next() : null, iter.hasNext() ? iter.next() : null);
            }

            isFirst = false;
        }
    }

    /**
     * Executes a command with the possibility of retrying in case of failure.
     *
     * @param cmd The command to be executed. It's a functional interface where the execution logic should be implemented.
     * @param retryTimes The number of times to retry the command execution if it fails.
     * @param retryIntervallInMillis The interval in milliseconds to wait between each retry.
     * @param retryCondition The condition to be checked after each execution failure to decide whether to retry or not.
     * @throws RuntimeException if the command execution fails and no more retries are allowed.
     * @see Retry#of(int, long, Predicate)
     * @see Retry#of(int, long, Predicate)
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static void execute(final Throwables.Runnable<? extends Exception> cmd, final int retryTimes, final long retryIntervallInMillis,
            final Predicate<? super Exception> retryCondition) {
        try {
            Retry.of(retryTimes, retryIntervallInMillis, retryCondition).run(cmd);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        }
    }

    /**
     * Executes a Callable task with the possibility of retrying in case of failure.
     *
     * @param <R> The type of the result returned by the Callable task.
     * @param cmd The Callable task to be executed.
     * @param retryTimes The number of times to retry the task execution if it fails.
     * @param retryIntervallInMillis The interval in milliseconds to wait between each retry.
     * @return The result returned by the Callable task.
     * @throws RuntimeException if the task execution fails and no more retries are allowed.
     * @see Retry#of(int, long, Predicate)
     * @see Retry#of(int, long, Predicate)
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> R execute(final Callable<R> cmd, final int retryTimes, final long retryIntervallInMillis,
            final BiPredicate<? super R, ? super Exception> retryCondition) {
        try {
            final Retry<R> retry = Retry.of(retryTimes, retryIntervallInMillis, retryCondition);
            return retry.call(cmd);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        }
    }

    /**
     * Executes the provided command asynchronously.
     *
     * @param command The runnable command to be executed asynchronously. It should be an instance of Throwables.Runnable which can throw exceptions.
     * @return A ContinuableFuture representing the result of the asynchronous computation. The computation is void, hence the future returns {@code null} upon completion.
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command) {
        return ASYNC_EXECUTOR.execute(command);
    }

    /**
     * Executes the provided command asynchronously after a specified delay.
     *
     * @param command The runnable command to be executed asynchronously. It should be an instance of Throwables.Runnable which can throw exceptions.
     * @param delayInMillis The delay before the command is executed, in milliseconds.
     * @return A ContinuableFuture representing the result of the asynchronous computation. The computation is void, hence the future returns {@code null} upon completion.
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    @MayReturnNull
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command, final long delayInMillis) {
        return new ContinuableFuture<>(SCHEDULED_EXECUTOR.schedule(() -> {
            command.run();
            return null;
        }, delayInMillis, TimeUnit.MILLISECONDS));
    }

    //    /**
    //     *
    //     * @param commands
    //     * @return
    //     * @see Futures
    //     * @see Fn#jr(Runnable)
    //     * @see Fn#jc(Callable)
    //     */
    //    @SuppressWarnings("deprecation")
    //    @SafeVarargs
    //    public static List<ContinuableFuture<Void>> asyncExecute(final Throwables.Runnable<? extends Exception>... commands) {
    //        return ASYNC_EXECUTOR.execute(commands);
    //    }

    /**
     *
     * @param commands
     * @return
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static List<ContinuableFuture<Void>> asyncExecute(final List<? extends Throwables.Runnable<? extends Exception>> commands) {
        return ASYNC_EXECUTOR.execute(commands);
    }

    /**
     *
     * @param commands
     * @param executor
     * @return
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static List<ContinuableFuture<Void>> asyncExecute(final List<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final List<ContinuableFuture<Void>> results = new ArrayList<>(commands.size());

        for (final Throwables.Runnable<? extends Exception> cmd : commands) {
            results.add(ContinuableFuture.run(cmd, executor));
        }

        return results;
    }

    /**
     * Executes the provided command asynchronously.
     *
     * @param command The callable command to be executed asynchronously. It should be an instance of Callable which can return a result and throw exceptions.
     * @return A ContinuableFuture representing the result of the asynchronous computation. The computation's result is the return value of the Callable command.
     * @see Futures
     * @see Fn#jc(Callable)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command) {
        return ASYNC_EXECUTOR.execute(command);
    }

    /**
     * Executes the provided command asynchronously after a specified delay.
     *
     * @param command The callable command to be executed asynchronously. It should be an instance of Callable which can return a result and throw exceptions.
     * @param delayInMillis The delay before the command is executed, in milliseconds.
     * @return A ContinuableFuture representing the result of the asynchronous computation. The computation's result is the return value of the Callable command.
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command, final long delayInMillis) {
        return new ContinuableFuture<>(SCHEDULED_EXECUTOR.schedule(command, delayInMillis, TimeUnit.MILLISECONDS));
    }

    //    /**
    //     *
    //     * @param <R>
    //     * @param commands
    //     * @return
    //     * @see Futures
    //     * @see Fn#jr(Runnable)
    //     * @see Fn#jc(Callable)
    //     */
    //    @SuppressWarnings("deprecation")
    //    @SafeVarargs
    //    public static <R> List<ContinuableFuture<R>> asyncExecute(final Callable<R>... commands) {
    //        return ASYNC_EXECUTOR.execute(commands);
    //    }

    /**
     *
     * @param <R>
     * @param commands
     * @return
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> List<ContinuableFuture<R>> asyncExecute(final Collection<? extends Callable<R>> commands) {
        return ASYNC_EXECUTOR.execute(commands);
    }

    /**
     *
     * @param <R>
     * @param commands
     * @param executor
     * @return
     * @see Futures
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> List<ContinuableFuture<R>> asyncExecute(final Collection<? extends Callable<R>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final List<ContinuableFuture<R>> results = new ArrayList<>(commands.size());

        for (final Callable<R> cmd : commands) {
            results.add(ContinuableFuture.call(cmd, executor));
        }

        return results;
    }

    /**
     * Executes a Runnable task asynchronously with the possibility of retrying in case of failure.
     *
     * @param cmd The Runnable task to be executed. It's a functional interface where the execution logic should be implemented.
     * @param retryTimes The number of times to retry the task execution if it fails.
     * @return A ContinuableFuture representing pending completion of the task, and whose {@code get()} method will return {@code null} upon completion.
     * @throws Exception if the task execution fails and no more retries are allowed.
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    @MayReturnNull
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> cmd, final int retryTimes,
            final long retryIntervallInMillisInMillis, final Predicate<? super Exception> retryCondition) {
        return ASYNC_EXECUTOR.execute((Callable<Void>) () -> {
            Retry.of(retryTimes, retryIntervallInMillisInMillis, retryCondition).run(cmd);
            return null;
        });
    }

    /**
     * Executes a Runnable task asynchronously with the possibility of retrying in case of failure.
     *
     * @param cmd The Runnable task to be executed. It's a functional interface where the execution logic should be implemented.
     * @param retryTimes The number of times to retry the task execution if it fails.
     * @param retryIntervallInMillisInMillis The interval in milliseconds to wait between each retry.
     * @param retryCondition The condition to be met for the task to be retried. It's a functional interface where the condition logic should be implemented.
     * @return A ContinuableFuture representing pending completion of the task, and whose {@code get()} method will return {@code R} upon completion.
     * @throws Exception if the task execution fails and no more retries are allowed.
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> cmd, final int retryTimes, final long retryIntervallInMillisInMillis,
            final BiPredicate<? super R, ? super Exception> retryCondition) {
        return ASYNC_EXECUTOR.execute((Callable<R>) () -> {
            final Retry<R> retry = Retry.of(retryTimes, retryIntervallInMillisInMillis, retryCondition);
            return retry.call(cmd);
        });
    }

    /**
     *
     *
     * @param command
     * @param executor
     * @return
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command, final Executor executor) {
        return ContinuableFuture.run(command, executor);
    }

    /**
     *
     *
     * @param <R>
     * @param command
     * @param executor
     * @return
     * @see Fn#jr(Runnable)
     * @see Fn#jc(Callable)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command, final Executor executor) {
        return ContinuableFuture.call(command, executor);
    }

    /**
     * Executes the specified commands/tasks asynchronous and immediately returns an {@code iterator} for iterating the result lazily.
     * The first element will be the result of the command/task which is completed first.
     * <br />
     * If error happens in one command/task, iteration will be interrupted and error will be thrown. But other commands/tasks won't be impacted or cancelled.
     *
     * @param commands
     * @return
     * @see Futures#iterate(Collection)
     * @see Futures#iterate(Collection, Function)
     */
    public static ObjIterator<Void> asynRun(final Collection<? extends Throwables.Runnable<? extends Exception>> commands) {
        return asynRun(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the specified commands/tasks asynchronous and immediately returns an {@code iterator} for iterating the result lazily.
     * The first element will be the result of the command/task which is completed first.
     * <br />
     * If error happens in one command/task, iteration will be interrupted and error will be thrown. But other commands/tasks won't be impacted or cancelled.
     *
     * @param commands
     * @param executor
     * @return
     * @throws IllegalArgumentException
     * @see Futures#iterate(Collection)
     * @see Futures#iterate(Collection, Function)
     */
    public static ObjIterator<Void> asynRun(final Collection<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return ObjIterator.empty();
        }

        final int cmdCount = commands.size();
        final List<FutureTask<Object>> futures = new LinkedList<>();
        final ArrayBlockingQueue<Object> queue = new ArrayBlockingQueue<>(cmdCount);
        final Object none = NULL_MASK;

        for (final Throwables.Runnable<? extends Exception> cmd : commands) {
            final FutureTask<Object> futureTask = new FutureTask<>(() -> {
                cmd.run();

                queue.add(none);

                return null;
            });

            executor.execute(futureTask);

            futures.add(futureTask);
        }

        return new ObjIterator<>() {
            @Override
            public boolean hasNext() {
                if (queue.size() > 0) {
                    return true;
                }

                while (true) {
                    final Iterator<FutureTask<Object>> iter = futures.iterator();

                    while (iter.hasNext()) {
                        final FutureTask<Object> future = iter.next();

                        if (future.isDone()) {
                            try {
                                future.get();
                            } catch (InterruptedException | ExecutionException e) {
                                // cause inconsistent if iterate result or not. Secondly, asynchronized execution should not impact each other.
                                //    while (iter.hasNext()) {
                                //        iter.next().cancel(false);
                                //    }

                                throw toRuntimeException(e);
                            }

                            iter.remove();

                            if (queue.size() > 0) {
                                return true;
                            }
                        }
                    }

                    if (queue.size() > 0) {
                        return true;
                    }

                    if (futures.size() == 0) {
                        break;
                    }

                    sleepUninterruptibly(1);
                }

                return queue.size() > 0;
            }

            @Override
            public Void next() {
                if (hasNext() == false) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                queue.poll();

                return null;
            }
        };
    }

    /**
     * Executes the specified commands/tasks asynchronous and immediately returns an {@code iterator} for iterating the result lazily.
     * The first element will be the result of the command/task which is completed first.
     * <br />
     * If error happens in one command/task, iteration will be interrupted and error will be thrown. But other commands/tasks won't be impacted or cancelled.
     *
     *
     * @param <R>
     * @param commands
     * @return
     * @see Futures#iterate(Collection)
     * @see Futures#iterate(Collection, Function)
     */
    public static <R> ObjIterator<R> asynCall(final Collection<? extends Callable<? extends R>> commands) {
        return asynCall(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the specified commands/tasks asynchronous and immediately returns an {@code iterator} for iterating the result lazily.
     * The first element will be the result of the command/task which is completed first.
     * <br />
     * If error happens in one command/task, iteration will be interrupted and error will be thrown. But other commands/tasks won't be impacted or cancelled.
     *
     * @param <R>
     * @param commands
     * @param executor
     * @return
     * @throws IllegalArgumentException
     * @see Futures#iterate(Collection)
     * @see Futures#iterate(Collection, Function)
     */
    public static <R> ObjIterator<R> asynCall(final Collection<? extends Callable<? extends R>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return ObjIterator.empty();
        }

        final int cmdCount = commands.size();
        final List<FutureTask<R>> futures = new LinkedList<>();
        final ArrayBlockingQueue<R> queue = new ArrayBlockingQueue<>(cmdCount);
        final R none = (R) NULL_MASK;

        for (final Callable<? extends R> cmd : commands) {
            final FutureTask<R> futureTask = new FutureTask<>(() -> {
                final R ret = cmd.call();

                if (ret == null) {
                    queue.add(none);
                } else {
                    queue.add(ret);
                }

                return ret;
            });

            executor.execute(futureTask);

            futures.add(futureTask);
        }

        return new ObjIterator<>() {
            private R next = null;

            @Override
            public boolean hasNext() {
                if (queue.size() > 0) {
                    return true;
                }

                while (true) {
                    final Iterator<FutureTask<R>> iter = futures.iterator();

                    while (iter.hasNext()) {
                        final FutureTask<R> future = iter.next();

                        if (future.isDone()) {
                            try {
                                future.get();
                            } catch (InterruptedException | ExecutionException e) {
                                // cause inconsistent if iterate result or not. Secondly, asynchronized execution should not impact each other.
                                //    while (iter.hasNext()) {
                                //        iter.next().cancel(false);
                                //    }

                                throw toRuntimeException(e);
                            }

                            iter.remove();

                            if (queue.size() > 0) {
                                return true;
                            }
                        }
                    }

                    if (queue.size() > 0) {
                        return true;
                    }

                    if (futures.size() == 0) {
                        break;
                    }

                    sleepUninterruptibly(1);
                }

                return queue.size() > 0;
            }

            @Override
            public R next() {
                if (hasNext() == false) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                next = queue.poll();
                return next == none ? null : next;
            }
        };
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     *
     * @see Fn#jc2r(Callable)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        boolean hasException = true;

        try {
            command.run();
            f2.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException && (f2.isDone() == false)) { // NOSONAR
                f2.cancel(false);
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     *
     * @see Fn#jc2r(Callable)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     * @param command4 to be completed in another thread.
     *
     * @see Fn#jc2r(Callable)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3, final Throwables.Runnable<? extends Exception> command4) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        final ContinuableFuture<Void> f4 = asyncExecute(command4);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();
            f4.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }

                if (f4.isDone() == false) {
                    f4.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     * @param command4 to be completed in another thread.
     * @param command5 to be completed in another thread.
     *
     * @see Fn#jc2r(Callable)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3, final Throwables.Runnable<? extends Exception> command4,
            final Throwables.Runnable<? extends Exception> command5) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        final ContinuableFuture<Void> f4 = asyncExecute(command4);
        final ContinuableFuture<Void> f5 = asyncExecute(command5);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();
            f4.get();
            f5.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }

                if (f4.isDone() == false) {
                    f4.cancel(false);
                }

                if (f5.isDone() == false) {
                    f5.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param commands
     */
    public static void runInParallel(final Collection<? extends Throwables.Runnable<? extends Exception>> commands) {
        runInParallel(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param commands
     * @param executor
     * @throws IllegalArgumentException
     */
    public static void runInParallel(final Collection<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return;
        }

        final int cmdSize = commands.size();
        final List<ContinuableFuture<Void>> futures = new ArrayList<>(cmdSize - 1);
        boolean hasException = true;

        try {
            final Iterator<? extends Throwables.Runnable<? extends Exception>> iter = commands.iterator();

            for (int i = 0, toIndex = cmdSize - 1; i < toIndex; i++) {
                futures.add(asyncExecute(iter.next(), executor));
            }

            iter.next().run();

            for (final ContinuableFuture<Void> f : futures) {
                f.get();
            }

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                for (final ContinuableFuture<Void> f : futures) {
                    if (f.isDone() == false) {
                        f.cancel(false);
                    }
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param <R2>
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @return
     * @see Fn#r2c(Runnable)
     */
    public static <R, R2> Tuple2<R, R2> callInParallel(final Callable<R> command, final Callable<R2> command2) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();

            hasException = false;

            return Tuple.of(r, r2);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException && (f2.isDone() == false)) { // NOSONAR
                f2.cancel(false);
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param <R2>
     * @param <R3>
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     * @return
     * @see Fn#r2c(Runnable)
     */
    public static <R, R2, R3> Tuple3<R, R2, R3> callInParallel(final Callable<R> command, final Callable<R2> command2, final Callable<R3> command3) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();

            hasException = false;

            return Tuple.of(r, r2, r3);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param <R2>
     * @param <R3>
     * @param <R4>
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     * @param command4 to be completed in another thread.
     * @return
     * @see Fn#r2c(Runnable)
     */
    public static <R, R2, R3, R4> Tuple4<R, R2, R3, R4> callInParallel(final Callable<R> command, final Callable<R2> command2, final Callable<R3> command3,
            final Callable<R4> command4) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        final ContinuableFuture<R4> f4 = asyncExecute(command4);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();
            final R4 r4 = f4.get();

            hasException = false;

            return Tuple.of(r, r2, r3, r4);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }

                if (f4.isDone() == false) {
                    f4.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param <R2>
     * @param <R3>
     * @param <R4>
     * @param <R5>
     * @param command to be completed in current thread.
     * @param command2 to be completed in another thread.
     * @param command3 to be completed in another thread.
     * @param command4 to be completed in another thread.
     * @param command5 to be completed in another thread.
     * @return
     * @see Fn#r2c(Runnable)
     */
    public static <R, R2, R3, R4, R5> Tuple5<R, R2, R3, R4, R5> callInParallel(final Callable<R> command, final Callable<R2> command2,
            final Callable<R3> command3, final Callable<R4> command4, final Callable<R5> command5) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        final ContinuableFuture<R4> f4 = asyncExecute(command4);
        final ContinuableFuture<R5> f5 = asyncExecute(command5);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();
            final R4 r4 = f4.get();
            final R5 r5 = f5.get();

            hasException = false;

            return Tuple.of(r, r2, r3, r4, r5);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                if (f2.isDone() == false) {
                    f2.cancel(false);
                }

                if (f3.isDone() == false) {
                    f3.cancel(false);
                }

                if (f4.isDone() == false) {
                    f4.cancel(false);
                }

                if (f5.isDone() == false) {
                    f5.cancel(false);
                }
            }
        }
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param commands
     * @return
     */
    public static <R> List<R> callInParallel(final Collection<? extends Callable<? extends R>> commands) {
        return callInParallel(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes and complete the input commands in parallel.
     * <br />
     * if error happens in one task, {@code cancel} will be called for other unfinished tasks.
     *
     * @param <R>
     * @param commands
     * @param executor
     * @return
     * @throws IllegalArgumentException
     */
    public static <R> List<R> callInParallel(final Collection<? extends Callable<? extends R>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final int cmdSize = commands.size();
        final List<ContinuableFuture<? extends R>> futures = new ArrayList<>(cmdSize - 1);
        boolean hasException = true;

        try {
            final Iterator<? extends Callable<? extends R>> iter = commands.iterator();

            for (int i = 0, toIndex = cmdSize - 1; i < toIndex; i++) {
                futures.add(asyncExecute(iter.next(), executor));
            }

            final R r = iter.next().call();

            final List<R> result = new ArrayList<>(cmdSize);

            for (final ContinuableFuture<? extends R> f : futures) {
                result.add(f.get());
            }

            result.add(r);

            hasException = false;

            return result;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e);
        } finally {
            if (hasException) {
                for (final ContinuableFuture<? extends R> f : futures) {
                    if (f.isDone() == false) {
                        f.cancel(false);
                    }
                }
            }
        }
    }

    /**
     * Executes a given action on batches of elements from the provided array.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the array.
     * @param <E> The type of the exception that the action may throw.
     * @param a The array whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, E extends Exception> void runByBatch(final T[] a, final int batchSize, final Throwables.Consumer<? super List<T>, E> batchAction)
            throws IllegalArgumentException, E {
        if (isEmpty(a)) {
            return;
        }

        runByBatch(Arrays.asList(a), batchSize, batchAction);
    }

    /**
     * Executes a given action on batches of elements from the provided {@code iterable}.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the {@code iterable}.
     * @param <E> The type of the exception that the action may throw.
     * @param iter The iterable whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, E extends Exception> void runByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.Consumer<? super List<T>, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null) {
            return;
        }

        if (iter instanceof List) {
            final List<T> list = (List<T>) iter;
            final int totalSize = list.size();

            if (totalSize <= batchSize) {
                batchAction.accept(list);
            } else {
                for (int i = 0; i < totalSize; i += batchSize) {
                    batchAction.accept(list.subList(i, min(i + batchSize, totalSize)));
                }
            }
        } else {
            runByBatch(iter.iterator(), batchSize, batchAction);
        }
    }

    /**
     * Executes a given action on batches of elements from the provided iterator.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the iterator.
     * @param <E> The type of the exception that the action may throw.
     * @param iter The iterator whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, E extends Exception> void runByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.Consumer<? super List<T>, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || iter.hasNext() == false) {
            return;
        }

        final T[] a = (T[]) new Object[batchSize];
        int cnt = 0;

        while (iter.hasNext()) {
            a[cnt++ % batchSize] = iter.next();

            if (cnt % batchSize == 0) {
                batchAction.accept(ImmutableList.of(a));
            }
        }

        if (cnt % batchSize != 0) {
            batchAction.accept(ImmutableList.of(copyOfRange(a, 0, cnt % batchSize)));
        }
    }

    /**
     * Executes a given action on batches of elements from the provided array.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the array.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param a The array whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The action to be executed on each element. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final T[] a, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        if (isEmpty(a)) {
            return;
        }

        runByBatch(Arrays.asList(a), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes a given action on batches of elements from the provided {@code iterable}.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the {@code iterable}.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param iter The iterable whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The action to be executed on each element. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        if (iter == null) {
            return;
        }

        runByBatch(iter.iterator(), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes a given action on batches of elements from the provided iterator.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the iterator.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param iter The iterator whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The action to be executed on each element. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || iter.hasNext() == false) {
            return;
        }

        int cnt = 0;

        while (iter.hasNext()) {
            elementConsumer.accept(cnt, iter.next());
            cnt++;

            if (cnt % batchSize == 0) {
                batchAction.run();
            }
        }

        if (cnt % batchSize != 0) {
            batchAction.run();
        }
    }

    /**
     * Executes a given function on batches of elements from the provided array.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the array.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the batchAction may throw.
     * @param a The array whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @return A list of results returned by the batchAction function for each batch of elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final T[] a, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return callByBatch(Arrays.asList(a), batchSize, batchAction);
    }

    /**
     * Executes a given function on batches of elements from the provided {@code iterable}.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the {@code iterable}.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the batchAction may throw.
     * @param iter The iterable whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @return A list of results returned by the batchAction function for each batch of elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null) {
            return new ArrayList<>();
        }

        if (iter instanceof List) {
            final List<T> list = (List<T>) iter;
            final int totalSize = list.size();
            final List<R> result = new ArrayList<>(totalSize % batchSize == 0 ? totalSize / batchSize : totalSize / batchSize + 1);

            if (totalSize <= batchSize) {
                result.add(batchAction.apply(list));
            } else {
                for (int i = 0; i < totalSize; i += batchSize) {
                    result.add(batchAction.apply(list.subList(i, min(i + batchSize, totalSize))));
                }
            }

            return result;
        } else {
            return callByBatch(iter.iterator(), batchSize, batchAction);
        }
    }

    /**
     * Executes a given function on batches of elements from the provided iterator.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the iterator.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the batchAction may throw.
     * @param iter The iterator whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @return A list of results returned by the batchAction function for each batch of elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || iter.hasNext() == false) {
            return new ArrayList<>();
        }

        final T[] a = (T[]) new Object[batchSize];
        final List<R> result = new ArrayList<>();
        int cnt = 0;

        while (iter.hasNext()) {
            a[cnt++ % batchSize] = iter.next();

            if (cnt % batchSize == 0) {
                result.add(batchAction.apply(ImmutableList.of(a)));
            }
        }

        if (cnt % batchSize != 0) {
            result.add(batchAction.apply(ImmutableList.of(copyOfRange(a, 0, cnt % batchSize))));
        }

        return result;
    }

    /**
     * Executes a given consumer on batches of elements from the provided array, then executes a batch action after each batch.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the array.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param a The array whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The consumer to be executed on each element in the batch. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @return A list of results returned by the batchAction function for each batch of elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final T[] a, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return callByBatch(Arrays.asList(a), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes a given consumer on each element from the provided {@code iterable} in batches, then executes a batch action after each batch.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the {@code iterable}.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param iter The iterable whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The consumer to be executed on each element in the batch. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        if (iter == null) {
            return new ArrayList<>();
        }

        return callByBatch(iter.iterator(), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes a given consumer on each element from the provided iterator in batches, then executes a batch action after each batch.
     * <br />
     * The {@code batchAction} must not update or cache the input batch elements.
     *
     * @param <T> The type of the elements in the iterator.
     * @param <R> The type of the result returned by the batchAction function.
     * @param <E> The type of the exception that the elementConsumer may throw.
     * @param <E2> The type of the exception that the batchAction may throw.
     * @param iter The iterator whose elements are to be processed.
     * @param batchSize The size of the batches to be processed at a time.
     * @param elementConsumer The consumer to be executed on each element in the batch. It's a functional interface where the execution logic should be implemented.
     * @param batchAction The action to be executed on each batch of elements. The {@code batchAction} must not update or cache the input batch elements.
     * @return A list of results returned by the batchAction function for each batch of elements.
     * @throws IllegalArgumentException if the batchSize is not positive or batchAction is {@code null}.
     * @throws E if the elementConsumer throws an exception.
     * @throws E2 if the batchAction throws an exception.
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || iter.hasNext() == false) {
            return new ArrayList<>();
        }

        final List<R> result = new ArrayList<>();
        int cnt = 0;

        while (iter.hasNext()) {
            elementConsumer.accept(cnt++, iter.next());

            if (cnt % batchSize == 0) {
                result.add(batchAction.call());
            }
        }

        if (cnt % batchSize != 0) {
            result.add(batchAction.call());
        }

        return result;
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param cmd
     * @throws IllegalArgumentException
     */
    public static void runUninterruptibly(final Throwables.Runnable<InterruptedException> cmd) throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            while (true) {
                try {
                    cmd.run();
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param timeoutInMillis
     * @param cmd
     * @throws IllegalArgumentException
     */
    public static void runUninterruptibly(final long timeoutInMillis, final Throwables.LongConsumer<InterruptedException> cmd) throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            long remainingMillis = timeoutInMillis;
            final long sysMillis = System.currentTimeMillis();
            final long end = remainingMillis >= Long.MAX_VALUE - sysMillis ? Long.MAX_VALUE : sysMillis + remainingMillis;

            while (true) {
                try {
                    cmd.accept(remainingMillis);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingMillis = end - System.currentTimeMillis();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param timeout
     * @param unit
     * @param cmd
     * @throws IllegalArgumentException if the specified {@code unit/cmd} is {@code null}.
     */
    public static void runUninterruptibly(final long timeout, @NotNull final TimeUnit unit,
            @NotNull final Throwables.BiConsumer<Long, TimeUnit, InterruptedException> cmd) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    cmd.accept(remainingNanos, TimeUnit.NANOSECONDS);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param <T>
     * @param cmd
     * @return
     * @throws IllegalArgumentException
     */
    public static <T> T callUninterruptibly(final Throwables.Callable<T, InterruptedException> cmd) throws IllegalArgumentException {
        boolean interrupted = false;
        try {
            while (true) {
                try {
                    return cmd.call();
                } catch (final InterruptedException e) {
                    interrupted = true;
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param <T>
     * @param timeoutInMillis
     * @param cmd
     * @return
     * @throws IllegalArgumentException
     */
    public static <T> T callUninterruptibly(final long timeoutInMillis, final Throwables.LongFunction<? extends T, InterruptedException> cmd)
            throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            long remainingMillis = timeoutInMillis;
            final long sysMillis = System.currentTimeMillis();
            final long end = remainingMillis >= Long.MAX_VALUE - sysMillis ? Long.MAX_VALUE : sysMillis + remainingMillis;

            while (true) {
                try {
                    return cmd.apply(remainingMillis);
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingMillis = end - System.currentTimeMillis();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param <T>
     * @param timeout
     * @param unit
     * @param cmd
     * @return
     * @throws IllegalArgumentException if the specified {@code unit/cmd} is {@code null}.
     */
    public static <T> T callUninterruptibly(final long timeout, @NotNull final TimeUnit unit,
            @NotNull final Throwables.BiFunction<Long, TimeUnit, T, InterruptedException> cmd) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    return cmd.apply(remainingNanos, TimeUnit.NANOSECONDS);
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Pauses the execution of the current thread for a specified time.
     *
     * @param timeoutInMillis The time, in milliseconds, to pause the thread.
     */
    public static void sleep(final long timeoutInMillis) {
        if (timeoutInMillis <= 0) {
            return;
        }

        try {
            TimeUnit.MILLISECONDS.sleep(timeoutInMillis);
        } catch (final InterruptedException e) {
            throw toRuntimeException(e);
        }
    }

    /**
     * Pauses the execution of the current thread for a specified time.
     *
     * @param timeout The time to pause the thread. The unit of time is determined by the 'unit' parameter.
     * @param unit The unit of time for the 'timeout' parameter. This should be a valid TimeUnit enumeration value.
     * @throws IllegalArgumentException if the specified {@code unit} is {@code null}.
     */
    public static void sleep(final long timeout, @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        if (timeout <= 0) {
            return;
        }

        try {
            unit.sleep(timeout);
        } catch (final InterruptedException e) {
            throw toRuntimeException(e);
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param timeoutInMillis
     */
    public static void sleepUninterruptibly(final long timeoutInMillis) {
        if (timeoutInMillis <= 0) {
            return;
        }

        boolean interrupted = false;

        try {
            long remainingNanos = TimeUnit.MILLISECONDS.toNanos(timeoutInMillis);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    // TimeUnit.sleep() treats negative timeouts just like zero.
                    TimeUnit.NANOSECONDS.sleep(remainingNanos);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Note: Copied from Google Guava under Apache License v2.0
     * <br />
     * <br />
     *
     * If a thread is interrupted during such a call, the call continues to block until the result is available or the
     * timeout elapses, and only then re-interrupts the thread.
     *
     * @param timeout
     * @param unit
     * @throws IllegalArgumentException if the specified {@code unit} is {@code null}.
     */
    public static void sleepUninterruptibly(final long timeout, @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        if (timeout <= 0) {
            return;
        }

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    // TimeUnit.sleep() treats negative timeouts just like zero.
                    TimeUnit.NANOSECONDS.sleep(remainingNanos);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    //    /**
    //     *
    //     * @param e
    //     * @param type
    //     * @return
    //     * @see ExceptionUtil#hasCause(Throwable, Class)
    //     */
    //    @Beta
    //    public static boolean hasCause(final Throwable e, final Class<? extends Throwable> type) {
    //        return ExceptionUtil.hasCause(e, type);
    //    }
    //
    //    /**
    //     * Returns the specified {@code Throwable e} if there is no cause found in it ({@code e.getCause() == null}).
    //     *
    //     * @param e
    //     * @return
    //     * @see ExceptionUtil#firstCause(Throwable)
    //     */
    //    @Beta
    //    public static Throwable firstCause(final Throwable e) {
    //        return ExceptionUtil.firstCause(e);
    //    }

    /**
     * Returns a {@code Nullable} with the value returned by {@code action} or an empty {@code Nullable} if exception happens.
     *
     * @param <R>
     * @param cmd
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     */
    @Beta
    public static <R> Nullable<R> tryOrEmptyIfExceptionOccurred(final Callable<R> cmd) {
        try {
            return Nullable.of(cmd.call());
        } catch (final Exception e) {
            return Nullable.<R> empty();
        }
    }

    /**
     * Returns a {@code Nullable} with the value returned by {@code func.apply(init)} or an empty {@code Nullable} if exception happens.
     *
     * @param <T>
     * @param <R>
     * @param init
     * @param func
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     */
    @Beta
    public static <T, R> Nullable<R> tryOrEmptyIfExceptionOccurred(final T init, final Throwables.Function<? super T, ? extends R, ? extends Exception> func) {
        try {
            return Nullable.of(func.apply(init));
        } catch (final Exception e) {
            return Nullable.<R> empty();
        }
    }

    /**
     * Returns the value returned by {@code action} or {@code defaultIfExceptionOccurred} if exception happens.
     *
     * @param <R>
     * @param cmd
     * @param defaultIfExceptionOccurred
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     */
    @Beta
    public static <R> R tryOrDefaultIfExceptionOccurred(final Callable<R> cmd, final R defaultIfExceptionOccurred) {
        try {
            return cmd.call();
        } catch (final Exception e) {
            return defaultIfExceptionOccurred;
        }
    }

    /**
     * Returns the value returned by {@code action} or {@code defaultIfExceptionOccurred} if exception happens.
     *
     * @param <T>
     * @param <R>
     * @param init
     * @param func
     * @param defaultIfExceptionOccurred
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     */
    @Beta
    public static <T, R> R tryOrDefaultIfExceptionOccurred(final T init, final Throwables.Function<? super T, ? extends R, ? extends Exception> func,
            final R defaultIfExceptionOccurred) {
        try {
            return func.apply(init);
        } catch (final Exception e) {
            return defaultIfExceptionOccurred;
        }
    }

    /**
     * Returns the value returned by {@code action} or {@code {@code supplierForDefaultIfExceptionOccurred}} if exception happens.
     *
     * @param <R>
     * @param cmd
     * @param supplierForDefaultIfExceptionOccurred
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     * @see Try#call(Throwables.Function, Supplier)
     */
    @Beta
    public static <R> R tryOrDefaultIfExceptionOccurred(final Callable<R> cmd, final Supplier<R> supplierForDefaultIfExceptionOccurred) {
        try {
            return cmd.call();
        } catch (final Exception e) {
            return supplierForDefaultIfExceptionOccurred.get();
        }
    }

    /**
     * Returns the value returned by {@code action} or {@code defaultIfExceptionOccurred} if exception happens.
     *
     * @param <T>
     * @param <R>
     * @param init
     * @param func
     * @param supplierForDefaultIfExceptionOccurred
     * @return
     * @see Try#call(Throwables.Function)
     * @see Try#call(Throwables.Function, Object)
     * @see Try#call(Throwables.Function, Supplier)
     */
    @Beta
    public static <T, R> R tryOrDefaultIfExceptionOccurred(final T init, final Throwables.Function<? super T, ? extends R, ? extends Exception> func,
            final Supplier<R> supplierForDefaultIfExceptionOccurred) {
        try {
            return func.apply(init);
        } catch (final Exception e) {
            return supplierForDefaultIfExceptionOccurred.get();
        }
    }

    /**
     * Returns a {@code Nullable} with value got from the specified {@code supplier} if <i>b</i> is {@code true},
     * otherwise returns an empty {@code Nullable} if <i>b</i> is {@code false}.
     *
     * @param <R>
     * @param <E>
     * @param b
     * @param supplier
     * @return
     * @throws E the e
     */
    @Beta
    public static <R, E extends Exception> Nullable<R> ifOrEmpty(final boolean b, final Throwables.Supplier<R, E> supplier) throws E {
        if (b) {
            return Nullable.of(supplier.get());
        } else {
            return Nullable.empty();
        }
    }

    // Maybe misused: N.ifOrElse(user != null, user.getFirstName(), firstName -> N.println(firstName));
    //    /**
    //     * Returns a {@code Nullable} with value returned by {@code func.apply(init)} if <i>b</i> is {@code true},
    //     * otherwise returns an empty {@code Nullable} if <i>b</i> is false.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param b
    //     * @param init
    //     * @param func
    //     * @return
    //     * @throws E the e
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> Nullable<R> ifOrEmpty(final boolean b, final T init, final Throwables.Function<? super T, ? extends R, E> func)
    //            throws E {
    //        if (b) {
    //            return Nullable.of(func.apply(init));
    //        } else {
    //            return Nullable.empty();
    //        }
    //    }
    //
    //    /**
    //     * Returns a {@code Nullable} with value returned by {@code func.apply(initSupplier.get())} if <i>b</i> is {@code true},
    //     * otherwise returns an empty {@code Nullable} if <i>b</i> is false.
    //     *
    //     * @param <T>
    //     * @param <R>
    //     * @param <E>
    //     * @param b
    //     * @param initSupplier
    //     * @param func
    //     * @return
    //     * @throws E the e
    //     */
    //    @Beta
    //    public static <T, R, E extends Exception> Nullable<R> ifOrEmpty(final boolean b, final Supplier<? extends T> initSupplier,
    //            final Throwables.Function<? super T, ? extends R, E> func) throws E {
    //        if (b) {
    //            return Nullable.of(func.apply(initSupplier.get()));
    //        } else {
    //            return Nullable.empty();
    //        }
    //    }

    /**
     * Executes the provided actions based on the boolean condition.
     *
     * @param <E1> The type of exception that the first action may throw.
     * @param <E2> The type of exception that the second action may throw.
     * @param b The boolean condition to test.
     * @param actionForTrue The action to be executed if the condition is {@code true}.
     * @param actionForFalse The action to be executed if the condition is {@code false}.
     * @throws E1 if the condition is {@code true} and the execution of actionForTrue throws this exception.
     * @throws E2 if the condition is {@code false} and the execution of actionForFalse throws this exception.
     */
    @Beta
    public static <E1 extends Exception, E2 extends Exception> void ifOrElse(final boolean b, final Throwables.Runnable<E1> actionForTrue,
            final Throwables.Runnable<E2> actionForFalse) throws E1, E2 {
        if (b) {
            if (actionForTrue != null) {
                actionForTrue.run();
            }
        } else {
            if (actionForFalse != null) {
                actionForFalse.run();
            }
        }
    }

    // Maybe misused: N.ifOrElse(user != null, user.getFirstName(), firstName -> N.println(firstName));
    //    /**
    //     * Executes the provided actions based on the boolean condition.
    //     *
    //     * @param <T> The type of the initial object to be consumed by the actions.
    //     * @param <E1> The type of exception that the first action may throw.
    //     * @param <E2> The type of exception that the second action may throw.
    //     * @param b The boolean condition to test.
    //     * @param init The initial object to be consumed by the actions.
    //     * @param actionForTrue The action to be executed if the condition is true.
    //     * @param actionForFalse The action to be executed if the condition is false.
    //     * @throws E1 if the condition is true and the execution of actionForTrue throws this exception.
    //     * @throws E2 if the condition is false and the execution of actionForFalse throws this exception.
    //     */
    //    @Beta
    //    public static <T, E1 extends Exception, E2 extends Exception> void ifOrElse(final boolean b, final T init,
    //            final Throwables.Consumer<? super T, E1> actionForTrue, final Throwables.Consumer<? super T, E2> actionForFalse) throws E1, E2 {
    //        if (b) {
    //            if (actionForTrue != null) {
    //                actionForTrue.accept(init);
    //            }
    //        } else {
    //            if (actionForFalse != null) {
    //                actionForFalse.accept(init);
    //            }
    //        }
    //    }
    //
    //    /**
    //     * Executes the provided actions based on the boolean condition.
    //     *
    //     * @param <T> The type of the initial object to be consumed by the actions.
    //     * @param <E1> The type of exception that the first action may throw.
    //     * @param <E2> The type of exception that the second action may throw.
    //     * @param b The boolean condition to test.
    //     * @param initSupplier The supplier of initial object to be consumed by the actions.
    //     * @param actionForTrue The action to be executed if the condition is true.
    //     * @param actionForFalse The action to be executed if the condition is false.
    //     * @throws E1 if the condition is true and the execution of actionForTrue throws this exception.
    //     * @throws E2 if the condition is false and the execution of actionForFalse throws this exception.
    //     */
    //    @Beta
    //    public static <T, E1 extends Exception, E2 extends Exception> void ifOrElse(final boolean b, final Supplier<? extends T> initSupplier,
    //            final Throwables.Consumer<? super T, E1> actionForTrue, final Throwables.Consumer<? super T, E2> actionForFalse) throws E1, E2 {
    //        if (b) {
    //            if (actionForTrue != null) {
    //                actionForTrue.accept(initSupplier.get());
    //            }
    //        } else {
    //            if (actionForFalse != null) {
    //                actionForFalse.accept(initSupplier.get());
    //            }
    //        }
    //    }

    @Beta
    public static <T, E extends Exception> void ifNotNull(final T obj, final Throwables.Consumer<? super T, E> cmd) throws E {
        if (obj != null) {
            cmd.accept(obj);
        }
    }

    /**
     * Executes the provided action if the given {@code CharSequence} is not empty.
     *
     * @param <C> The type of the {@code CharSequence}.
     * @param <E> The type of exception that the action may throw.
     * @param c The {@code CharSequence} to be tested for emptiness.
     * @param cmd The action to be executed if the {@code CharSequence} is not empty.
     * @throws E if the execution of the action throws this exception.
     */
    @Beta
    public static <C extends CharSequence, E extends Exception> void ifNotEmpty(final C c, final Throwables.Consumer<? super C, E> cmd) throws E {
        if (notEmpty(c)) {
            cmd.accept(c);
        }
    }

    /**
     * Executes the provided action if the given collection is not empty.
     *
     * @param <C> The type of the collection.
     * @param <E> The type of exception that the action may throw.
     * @param c The collection to be tested for emptiness.
     * @param cmd The action to be executed if the collection is not empty.
     * @throws E if the execution of the action throws this exception.
     */
    @SuppressWarnings("rawtypes")
    @Beta
    public static <C extends Collection, E extends Exception> void ifNotEmpty(final C c, final Throwables.Consumer<? super C, E> cmd) throws E {
        if (notEmpty(c)) {
            cmd.accept(c);
        }
    }

    /**
     * Executes the provided action if the given map is not empty.
     *
     * @param <M> The type of the map.
     * @param <E> The type of exception that the action may throw.
     * @param m The map to be tested for emptiness.
     * @param cmd The action to be executed if the map is not empty.
     * @throws E if the execution of the action throws this exception.
     */
    @SuppressWarnings("rawtypes")
    @Beta
    public static <M extends Map, E extends Exception> void ifNotEmpty(final M m, final Throwables.Consumer<? super M, E> cmd) throws E {
        if (notEmpty(m)) {
            cmd.accept(m);
        }
    }

    /**
     * Updates each element in the specified array with specified function {@code converter}.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param converter
     * @throws IllegalArgumentException
     * @throws E
     */
    @Beta
    public static <T, E extends Exception> void applyToEach(final T[] a, final Throwables.Function<? super T, ? extends T, E> converter)
            throws IllegalArgumentException, E {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, len = a.length; i < len; i++) {
            a[i] = converter.apply(a[i]);
        }
    }

    /**
     * Updates each element in the specified List with specified function {@code converter}.
     *
     * @param <T>
     * @param <E>
     * @param c
     * @param converter
     * @throws IllegalArgumentException
     * @throws E
     */
    @Beta
    public static <T, E extends Exception> void applyToEach(final List<T> c, final Throwables.Function<? super T, ? extends T, E> converter)
            throws IllegalArgumentException, E {
        if (isEmpty(c)) {
            return;
        }

        if (c instanceof ArrayList) {
            for (int i = 0, size = c.size(); i < size; i++) {
                c.set(i, converter.apply(c.get(i)));
            }
        } else {
            final ListIterator<T> iter = c.listIterator();

            while (iter.hasNext()) {
                iter.set(converter.apply(iter.next()));
            }
        }
    }

    /**
     * Copy the specified array first, then call {@code converter} on the copy.
     *
     * @param <T>
     * @param <E>
     * @param a
     * @param converter
     * @return
     * @throws IllegalArgumentException
     * @throws E
     * @see {@link #map(Object[], com.landawn.abacus.util.Throwables.Function)}
     * @see {@link N#map(Iterable, com.landawn.abacus.util.Throwables.Function)}
     */
    @MayReturnNull
    public static <T, E extends Exception> T[] copyThenApplyToEach(final T[] a, final Throwables.Function<? super T, ? extends T, E> converter)
            throws IllegalArgumentException, E {
        if (a == null) {
            return null; // NOSONAR
        } else if (a.length == 0) {
            return a.clone();
        }

        final T[] copy = a.clone();

        for (int i = 0, len = a.length; i < len; i++) {
            copy[i] = converter.apply(a[i]);
        }

        return a;
    }

    /**
     * Creates a lazy-initialized supplier from the provided supplier.
     * The supplier's get() method will not be called until necessary and only be called only because the returned value will be cached.
     *
     * @param <T> The type of results supplied by this supplier
     * @param supplier The supplier to be lazily initialized
     * @return A lazy-initialized supplier
     */
    @Beta
    public static <T> com.landawn.abacus.util.function.Supplier<T> lazyInit(final Supplier<T> supplier) {
        return LazyInitializer.of(supplier);
    }

    /**
     * Creates a lazy-initialized supplier from the provided supplier.
     * The supplier's get() method will not be called until necessary and only be called only because the returned value will be cached.
     *
     * @param <T> The type of results supplied by this supplier
     * @param supplier The supplier to be lazily initialized
     * @return A lazy-initialized supplier
     */
    @Beta
    public static <T, E extends Exception> Throwables.Supplier<T, E> lazyInitialize(final Throwables.Supplier<T, E> supplier) {
        return Throwables.LazyInitializer.of(supplier);
    }

    static <T> Iterator<T> getDescendingIteratorIfPossible(final Iterable<? extends T> c) {
        if (c instanceof Deque) {
            return ((Deque<T>) c).descendingIterator();
        } else {
            try {
                Method m = null;

                if ((m = ClassUtil.getDeclaredMethod(c.getClass(), "descendingIterator")) != null && Modifier.isPublic(m.getModifiers())
                        && Iterator.class.isAssignableFrom(m.getReturnType())) {

                    return (Iterator<T>) ClassUtil.invokeMethod(c, m);
                }
            } catch (final Exception e) {
                // continue
            }
        }

        return null; // NOSONAR
    }

    /**
     * Converts the provided exception to a runtime exception.
     *
     * @param e The exception to be converted to a runtime exception.
     * @return A RuntimeException that represents the provided exception.
     * @see ExceptionUtil#toRuntimeException(Throwable)
     * @see ExceptionUtil#registerRuntimeExceptionMapper(Class,Function)
     */
    @Beta
    public static RuntimeException toRuntimeException(final Exception e) {
        return ExceptionUtil.toRuntimeException(e);
    }

    /**
     * Converts the specified {@code Throwable} to a {@code RuntimeException} if it's a checked {@code exception} or an {@code Error}, otherwise returns itself.
     *
     * @param e
     * @return
     * @see ExceptionUtil#toRuntimeException(Throwable)
     * @see ExceptionUtil#registerRuntimeExceptionMapper(Class,Function)
     */
    @Beta
    public static RuntimeException toRuntimeException(final Throwable e) {
        return ExceptionUtil.toRuntimeException(e);
    }

    /**
     * Converts the specified {@code Throwable} to a {@code RuntimeException} if it's a checked {@code exception}, or throw it if it's an {@code Error}. Otherwise returns itself.
     *
     * @param e
     * @param throwIfItIsError
     * @return
     * @see ExceptionUtil#toRuntimeException(Throwable, boolean)
     * @see ExceptionUtil#registerRuntimeExceptionMapper(Class,Function)
     */
    @Beta
    public static RuntimeException toRuntimeException(final Throwable e, final boolean throwIfItIsError) {
        return ExceptionUtil.toRuntimeException(e, throwIfItIsError);
    }

    //    /**
    //     *
    //     * @param e
    //     * @param type
    //     * @return
    //     * @see ExceptionUtil#hasCause(Throwable, Class)
    //     */
    //    @Beta
    //    public static boolean hasCause(final Throwable e, final Class<? extends Throwable> type) {
    //        return ExceptionUtil.hasCause(e, type);
    //    }
    //
    //    /**
    //     * Returns the specified {@code Throwable e} if there is no cause found in it ({@code e.getCause() == null}).
    //     *
    //     * @param e
    //     * @return
    //     * @see ExceptionUtil#firstCause(Throwable)
    //     */
    //    @Beta
    //    public static Throwable firstCause(final Throwable e) {
    //        return ExceptionUtil.firstCause(e);
    //    }

    /**
     * Prints the given object to the standard output stream (System.out) and returns the object.
     * The object's string representation is obtained by calling {@code N.toString(Object)} method.
     *
     * @param <T> The type of the object to be printed.
     * @param obj The object to be printed.
     * @return The same object that was printed.
     */
    @SuppressWarnings("rawtypes")
    public static <T> T println(final T obj) {
        if (obj instanceof Collection) {
            System.out.println(Joiner.with(Strings.ELEMENT_SEPARATOR, "[", "]").reuseCachedBuffer().appendAll((Collection) obj).toString()); //NOSONAR
        } else if (obj instanceof Map) {
            System.out.println(Joiner.with(Strings.ELEMENT_SEPARATOR, "=", "{", "}").reuseCachedBuffer().appendEntries((Map) obj).toString()); //NOSONAR
        } else {
            System.out.println(toString(obj)); //NOSONAR
        }

        return obj;
    }

    //    public static void printlnForEach(final Object[] a) {
    //        if (a == null) {
    //            println("null");
    //        } else if (a.length == 0) {
    //            println("[]");
    //        } else {
    //            for (Object e : a) {
    //                println(e);
    //            }
    //        }
    //    }
    //
    //    public static void printlnForEach(final Iterable<?> iter) {
    //        if (iter == null) {
    //            println("null");
    //        } else {
    //            printlnForEach(iter.iterator());
    //        }
    //    }
    //
    //    public static void printlnForEach(final Iterator<?> iter) {
    //        if (iter == null) {
    //            println("null");
    //        } else if (!iter.hasNext()) {
    //            println("[]");
    //        } else {
    //            while (iter.hasNext()) {
    //                println(iter.next());
    //            }
    //        }
    //    }

    /**
     * Prints a formatted string and an array of arguments, following the syntax rules of {@link java.lang.String#format(String, Object...)}.
     * The result string is then printed to the standard output stream (System.out) and returned as an array of the provided arguments.
     *
     * @param <T> The type of the arguments.
     * @param format A format string as described in Format string syntax.
     * @param args Arguments referenced by the format specifiers in the format string.
     * @return The same array of arguments that was printed.
     */
    @SafeVarargs
    public static <T> T[] fprintln(final String format, final T... args) {
        System.out.printf(format, args); //NOSONAR
        System.out.println(); //NOSONAR
        return args;
    }
}
