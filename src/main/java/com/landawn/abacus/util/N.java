/*
 * Copyright (c) 2015, Haiyang Li.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.landawn.abacus.util;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IllegalFormatException;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.RandomAccess;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.DoublePredicate;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.Function;
import java.util.function.IntBinaryOperator;
import java.util.function.IntFunction;
import java.util.function.IntPredicate;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongPredicate;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.function.LongUnaryOperator;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Collector;

import com.landawn.abacus.annotation.Beta;
import com.landawn.abacus.annotation.MayReturnNull;
import com.landawn.abacus.annotation.NotNull;
import com.landawn.abacus.parser.DeserializationConfig;
import com.landawn.abacus.parser.JSONDeserializationConfig;
import com.landawn.abacus.parser.JSONDeserializationConfig.JDC;
import com.landawn.abacus.parser.JSONSerializationConfig;
import com.landawn.abacus.parser.XMLDeserializationConfig;
import com.landawn.abacus.parser.XMLDeserializationConfig.XDC;
import com.landawn.abacus.parser.XMLSerializationConfig;
import com.landawn.abacus.type.Type;
import com.landawn.abacus.util.Iterables.Slice;
import com.landawn.abacus.util.Tuple.Tuple2;
import com.landawn.abacus.util.Tuple.Tuple3;
import com.landawn.abacus.util.Tuple.Tuple4;
import com.landawn.abacus.util.Tuple.Tuple5;
import com.landawn.abacus.util.u.Nullable;
import com.landawn.abacus.util.function.BooleanPredicate;
import com.landawn.abacus.util.function.BooleanUnaryOperator;
import com.landawn.abacus.util.function.BytePredicate;
import com.landawn.abacus.util.function.ByteUnaryOperator;
import com.landawn.abacus.util.function.CharPredicate;
import com.landawn.abacus.util.function.CharUnaryOperator;
import com.landawn.abacus.util.function.FloatPredicate;
import com.landawn.abacus.util.function.FloatUnaryOperator;
import com.landawn.abacus.util.function.IntBiFunction;
import com.landawn.abacus.util.function.IntToBooleanFunction;
import com.landawn.abacus.util.function.IntToByteFunction;
import com.landawn.abacus.util.function.IntToCharFunction;
import com.landawn.abacus.util.function.IntToFloatFunction;
import com.landawn.abacus.util.function.IntToShortFunction;
import com.landawn.abacus.util.function.ShortPredicate;
import com.landawn.abacus.util.function.ShortUnaryOperator;
import com.landawn.abacus.util.function.ToBooleanFunction;
import com.landawn.abacus.util.function.ToByteFunction;
import com.landawn.abacus.util.function.ToCharFunction;
import com.landawn.abacus.util.function.ToFloatFunction;
import com.landawn.abacus.util.function.ToShortFunction;
import com.landawn.abacus.util.function.TriFunction;
import com.landawn.abacus.util.stream.IntStream;
import com.landawn.abacus.util.stream.Stream;

/**
 * A comprehensive utility class providing commonly used operations for primitive types, Objects, Strings,
 * Arrays, Collections, Maps, and JavaBeans. This class serves as the primary entry point for the Abacus
 * utility library.
 *
 * <h2>Core Functional Areas</h2>
 * <ul>
 *   <li><b>Array Operations:</b> occurrencesOf, contains, indexOf, concat, split, add, remove, reverse, rotate, shuffle, sort, etc.</li>
 *   <li><b>Collection Operations:</b> groupBy, partition, toMap, intersection, union, difference, etc.</li>
 *   <li><b>String Operations:</b> String manipulation, parsing, and formatting utilities</li>
 *   <li><b>Math Operations:</b> min, max, sum, average, median, percentiles for arrays and collections</li>
 *   <li><b>Functional Operations:</b> forEach, map, filter, reduce operations with exception handling support</li>
 *   <li><b>Null-Safe Operations:</b> Comprehensive null-safe methods for common operations</li>
 *   <li><b>Type Conversion:</b> Safe conversion between primitive types and objects</li>
 *   <li><b>Async Operations:</b> sleep, async execution utilities</li>
 * </ul>
 *
 * <h2>Design Philosophy</h2>
 * <ul>
 *   <li><b>Null Safety:</b> Methods are designed to handle {@code null} inputs gracefully. Operations on
 *       {@code null} or empty inputs typically return {@code null}, empty collections, or default values
 *       rather than throwing exceptions.</li>
 *   <li><b>Empty over Null:</b> Methods prefer returning empty String/Array/Collection/Map/Iterator/Iterable
 *       over {@code null} when appropriate.</li>
 *   <li><b>Exception Philosophy:</b> Exceptions are thrown only when the method contract is violated
 *       (e.g., adding to a {@code null} array). Safe operations (e.g., reversing a {@code null} String)
 *       return the input unchanged.</li>
 *   <li><b>Index Conventions:</b> Methods use {@code fromIndex/startIndex} and {@code toIndex/endIndex}
 *       parameters (half-open ranges [fromIndex, toIndex)), NOT {@code offset/count} parameters.</li>
 * </ul>
 *
 * <h2>Thread Safety</h2>
 * All static methods in this class are thread-safe unless explicitly documented otherwise. However,
 * mutable objects passed to methods must be handled carefully in concurrent contexts.
 *
 * <h2>Usage Examples</h2>
 * <p><b>Usage Examples:</b></p>
 * <pre>{@code
 * // Array operations
 * int[] numbers = {1, 2, 3, 4, 5};
 * int count = N.occurrencesOf(numbers, 3);  // Returns 1
 * boolean hasThree = N.contains(numbers, 3); // Returns true
 *
 * // Collection operations
 * List<String> list = Arrays.asList("apple", "banana", "apple");
 * Map<String, Integer> freq = N.occurrencesMap(list); // {apple=2, banana=1}
 *
 * // Null-safe operations
 * String result = N.reverse(null); // Returns null, not exception
 *
 * // Functional operations with exception handling
 * N.forEach(list, item -> processItem(item)); // Supports checked exceptions
 * }</pre>
 *
 * <h2>Related Classes</h2>
 * <ul>
 *   <li>{@link Array} - Advanced array manipulation operations</li>
 *   <li>{@link Strings} - String-specific utilities</li>
 *   <li>{@link Numbers} - Number-specific operations and conversions</li>
 *   <li>{@link Maps} - Map-specific utilities</li>
 *   <li>{@link Iterables} - Iterable utilities</li>
 *   <li>{@link Iterators} - Iterator utilities</li>
 *   <li>{@link Stream} - Stream processing utilities</li>
 * </ul>
 *
 * <p><b>Note:</b> This class includes code copied from Apache Commons Lang, Google Guava, and other
 * open source projects under the Apache License 2.0. Methods from these libraries may have been
 * modified for consistency with this API.</p>
 *
 * @see com.landawn.abacus.util.Comparators
 * @see com.landawn.abacus.util.Fn
 * @see com.landawn.abacus.util.Fnn
 * @see com.landawn.abacus.util.Array
 * @see com.landawn.abacus.util.CommonUtil
 * @see com.landawn.abacus.util.Iterables
 * @see com.landawn.abacus.util.Iterators
 * @see com.landawn.abacus.util.Index
 * @see com.landawn.abacus.util.Median
 * @see com.landawn.abacus.util.Strings
 * @see com.landawn.abacus.util.Numbers
 * @see com.landawn.abacus.util.Maps
 * @see com.landawn.abacus.util.Beans
 * @see com.landawn.abacus.util.IOUtil
 * @see java.lang.reflect.Array
 * @see java.util.Arrays
 * @see java.util.Collections
 *
 * @version $Revision: 0.8 $ 07/03/10
 */
@SuppressWarnings({ "java:S1192", "java:S6539" })
public final class N extends CommonUtil { // public final class N extends π implements ℕ, ℂ, ℚ, ℝ, ℤ { //  Error while storing the mojo status in Maven

    static final AsyncExecutor ASYNC_EXECUTOR = new AsyncExecutor(//
            max(64, InternalUtil.CPU_CORES * 8), // coreThreadPoolSize
            max(128, InternalUtil.CPU_CORES * 16), // maxThreadPoolSize
            180L, TimeUnit.SECONDS);

    static final ScheduledExecutorService SCHEDULED_EXECUTOR;

    static {
        final ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(Math.max(64, InternalUtil.CPU_CORES));
        //    executor.setKeepAliveTime(180, TimeUnit.SECONDS);
        //    executor.allowCoreThreadTimeOut(true);
        //    executor.setRemoveOnCancelPolicy(true);
        SCHEDULED_EXECUTOR = MoreExecutors.getExitingScheduledExecutorService(executor);
    }

    private static final float LOAD_FACTOR_FOR_FLAT_MAP = 1.75f;

    private static final int LOAD_FACTOR_FOR_TWO_FLAT_MAP = 2;

    private N() {
        // Utility class.
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, true, false};
     * int result = N.occurrencesOf(flags, true);  // Returns 3
     * }</pre>
     *
     * @param a the boolean array to search in
     * @param valueToFind the boolean value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(char[], char)
     */
    public static int occurrencesOf(final boolean[] a, final boolean valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final boolean element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'c', 'a', 'b', 'a'};
     * int result = N.occurrencesOf(letters, 'a');  // Returns 3
     * }</pre>
     *
     * @param a the char array to search in
     * @param valueToFind the char value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(byte[], byte)
     */
    public static int occurrencesOf(final char[] a, final char valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final char element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3, 1, 2, 1};
     * int result = N.occurrencesOf(data, (byte) 1);  // Returns 3
     * }</pre>
     *
     * @param a the byte array to search in
     * @param valueToFind the byte value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(short[], short)
     */
    public static int occurrencesOf(final byte[] a, final byte valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final byte element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] values = {10, 20, 30, 10, 20, 10};
     * int result = N.occurrencesOf(values, (short) 10);  // Returns 3
     * }</pre>
     *
     * @param a the short array to search in
     * @param valueToFind the short value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(int[], int)
     */
    public static int occurrencesOf(final short[] a, final short valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final short element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 2, 4, 2, 5};
     * int result = N.occurrencesOf(numbers, 2);  // Returns 3
     * }</pre>
     *
     * @param a the int array to search in
     * @param valueToFind the int value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(long[], long)
     */
    public static int occurrencesOf(final int[] a, final int valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final int element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] ids = {1000L, 2000L, 3000L, 1000L, 2000L, 1000L};
     * int result = N.occurrencesOf(ids, 1000L);  // Returns 3
     * }</pre>
     *
     * @param a the long array to search in
     * @param valueToFind the long value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(float[], float)
     */
    public static int occurrencesOf(final long[] a, final long valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final long element : a) {
            if (element == valueToFind) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p>Note: Uses Float.compare() for proper handling of NaN and -0.0/+0.0 comparisons.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] prices = {1.5f, 2.3f, 1.5f, 3.7f, 1.5f};
     * int result = N.occurrencesOf(prices, 1.5f);  // Returns 3
     * }</pre>
     *
     * @param a the float array to search in
     * @param valueToFind the float value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(double[], double)
     */
    public static int occurrencesOf(final float[] a, final float valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final float element : a) {
            if (Float.compare(element, valueToFind) == 0) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p>Note: Uses Double.compare() for proper handling of NaN and -0.0/+0.0 comparisons.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] measurements = {1.5, 2.3, 1.5, 3.7, 1.5};
     * int result = N.occurrencesOf(measurements, 1.5);  // Returns 3
     * }</pre>
     *
     * @param a the double array to search in
     * @param valueToFind the double value to count occurrences of
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(Object[], Object)
     */
    public static int occurrencesOf(final double[] a, final double valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        for (final double element : a) {
            if (Double.compare(element, valueToFind) == 0) {
                occurrences++;
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the array.
     *
     * <p>Note: Uses null-safe equality comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"hello", "world", "hello", "java", "hello"};
     * int result = N.occurrencesOf(words, "hello");  // Returns 3
     * }</pre>
     *
     * @param a the Object array to search in
     * @param valueToFind the Object value to count occurrences of (may be {@code null})
     * @return the number of occurrences (0 if array is {@code null} or empty)
     * @see #occurrencesOf(Iterable, Object)
     */
    public static int occurrencesOf(final Object[] a, final Object valueToFind) {
        if (isEmpty(a)) {
            return 0;
        }

        int occurrences = 0;

        if (valueToFind == null) {
            for (final Object element : a) {
                if (element == null) {
                    occurrences++;
                }
            }
        } else {
            for (final Object element : a) {
                if (valueToFind.equals(element)) {
                    occurrences++;
                }
            }
        }

        return occurrences;
    }

    /**
     * Returns the number of occurrences of the specified value in the iterable.
     *
     * <p>Note: Uses null-safe equality comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("hello", "world", "hello", "java");
     * int result = N.occurrencesOf(words, "hello");  // Returns 2
     * }</pre>
     *
     * @param c the Iterable to search in
     * @param valueToFind the Object value to count occurrences of (may be {@code null})
     * @return the number of occurrences (0 if iterable is {@code null} or empty)
     * @throws ArithmeticException if the number of occurrences exceeds Integer.MAX_VALUE
     * @see #occurrencesOf(Iterator, Object)
     */
    public static int occurrencesOf(final Iterable<?> c, final Object valueToFind) {
        if (isEmptyCollection(c)) {
            return 0;
        }

        long occurrences = 0;

        if (valueToFind == null) {
            for (final Object e : c) {
                if (e == null) {
                    occurrences++;
                }
            }
        } else {
            for (final Object e : c) {
                if (equals(e, valueToFind)) {
                    occurrences++;
                }
            }
        }

        return Numbers.toIntExact(occurrences);
    }

    /**
     * Returns the number of occurrences of the specified value in the iterator.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("hello", "world", "hello", "java");
     * Iterator<String> iter = words.iterator();
     * int result = N.occurrencesOf(iter, "hello");  // Returns 2 (iterator is now exhausted)
     * }</pre>
     *
     * @param iter the Iterator to search in
     * @param valueToFind the Object value to count occurrences of (may be {@code null})
     * @return the number of occurrences (0 if iterator is {@code null})
     * @throws ArithmeticException if the number of occurrences exceeds Integer.MAX_VALUE
     * @see Iterators#occurrencesOf(Iterator, Object)
     * @see #occurrencesOf(String, char)
     */
    public static int occurrencesOf(final Iterator<?> iter, final Object valueToFind) throws ArithmeticException {
        return Numbers.toIntExact(Iterators.occurrencesOf(iter, valueToFind));
    }

    /**
     * Returns the number of occurrences of the specified character in the string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String text = "hello world";
     * int result = N.occurrencesOf(text, 'l');  // Returns 3
     * }</pre>
     *
     * @param str the String to search in
     * @param valueToFind the char value to count occurrences of
     * @return the number of occurrences (0 if string is {@code null} or empty)
     * @see Strings#countMatches(String, char)
     * @see #occurrencesOf(String, String)
     */
    public static int occurrencesOf(final String str, final char valueToFind) {
        return Strings.countMatches(str, valueToFind);
    }

    /**
     * Returns the number of occurrences of the specified substring in the string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String text = "hello hello world hello";
     * int result = N.occurrencesOf(text, "hello");  // Returns 3
     * }</pre>
     *
     * @param str the String to search in
     * @param valueToFind the String value to count occurrences of
     * @return the number of occurrences (0 if string is {@code null} or empty)
     * @see Strings#countMatches(String, String)
     */
    public static int occurrencesOf(final String str, final String valueToFind) {
        return Strings.countMatches(str, valueToFind);
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry", "banana", "apple"};
     * Map<String, Integer> result = N.occurrencesMap(words);
     * // Returns {apple=3, banana=2, cherry=1}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to count occurrences from
     * @return the map with elements as keys and occurrence counts as values (empty if array is {@code null} or empty)
     * @see #occurrencesMap(Object[], Supplier)
     */
    public static <T> Map<T, Integer> occurrencesMap(final T[] a) {
        return occurrencesMap(a, Suppliers.ofMap());
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"c", "a", "b", "a", "c"};
     * Map<String, Integer> result = N.occurrencesMap(words, TreeMap::new);
     * // Returns map with keys in order: [a, b, c]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to count occurrences from
     * @param mapSupplier the supplier for the map to use (e.g., TreeMap::new for sorted keys)
     * @return the map with elements as keys and occurrence counts as values
     * @see #occurrencesMap(Iterable)
     */
    public static <T> Map<T, Integer> occurrencesMap(final T[] a, final Supplier<Map<T, Integer>> mapSupplier) {
        if (isEmpty(a)) {
            return mapSupplier.get();
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : a) {
            map.merge(e, 1, Integer::sum);
        }

        return map;
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "apple", "cherry");
     * Map<String, Integer> result = N.occurrencesMap(words);
     * // Returns {apple=2, banana=1, cherry=1}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable to count occurrences from
     * @return the map with elements as keys and occurrence counts as values (empty if iterable is {@code null} or empty)
     * @see #occurrencesMap(Iterable, Supplier)
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterable<? extends T> c) {
        return occurrencesMap(c, Suppliers.ofMap());
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("c", "a", "b", "a", "c");
     * Map<String, Integer> result = N.occurrencesMap(words, TreeMap::new);
     * // Returns map with keys in order: [a, b, c]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable to count occurrences from
     * @param mapSupplier the supplier for the map to use (e.g., TreeMap::new for sorted keys)
     * @return the map with elements as keys and occurrence counts as values
     * @see #occurrencesMap(Iterator)
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterable<? extends T> c, final Supplier<Map<T, Integer>> mapSupplier) {
        if (isEmptyCollection(c)) {
            return mapSupplier.get();
        }

        final Multiset<T> multiset = new Multiset<>();

        for (final T e : c) {
            multiset.add(e, 1);
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : multiset) {
            map.put(e, multiset.getCount(e));
        }

        return map;
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the iterator.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "apple", "cherry");
     * Iterator<String> iter = words.iterator();
     * Map<String, Integer> result = N.occurrencesMap(iter);
     * // Returns {apple=2, banana=1, cherry=1} (iterator is now exhausted)
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to count occurrences from
     * @return the map with elements as keys and occurrence counts as values (empty if iterator is {@code null})
     * @see #occurrencesMap(Iterator, Supplier)
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterator<? extends T> iter) {
        return occurrencesMap(iter, Suppliers.ofMap());
    }

    /**
     * Returns a map containing the occurrence count of each distinct element in the iterator.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("c", "a", "b", "a", "c");
     * Iterator<String> iter = words.iterator();
     * Map<String, Integer> result = N.occurrencesMap(iter, TreeMap::new);
     * // Returns map with keys in order: [a, b, c]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to count occurrences from
     * @param mapSupplier the supplier for the map to use (e.g., TreeMap::new for sorted keys)
     * @return the map with elements as keys and occurrence counts as values
     * @throws ArithmeticException if any occurrence count exceeds Integer.MAX_VALUE
     */
    public static <T> Map<T, Integer> occurrencesMap(final Iterator<? extends T> iter, final Supplier<Map<T, Integer>> mapSupplier) {
        if (iter == null) {
            return mapSupplier.get();
        }

        final Multiset<T> multiset = new Multiset<>();

        while (iter.hasNext()) {
            multiset.add(iter.next(), 1);
        }

        final Map<T, Integer> map = mapSupplier.get();

        for (final T e : multiset) {
            map.put(e, Numbers.toIntExact(multiset.getCount(e)));
        }

        return map;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true};
     * boolean result = N.contains(flags, true);  // Returns true
     * }</pre>
     *
     * @param a the boolean array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(boolean[], boolean)
     */
    public static boolean contains(final boolean[] a, final boolean valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'c', 'd'};
     * boolean result = N.contains(letters, 'c');  // Returns true
     * }</pre>
     *
     * @param a the char array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(char[], char)
     */
    public static boolean contains(final char[] a, final char valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3, 4, 5};
     * boolean result = N.contains(data, (byte) 3);  // Returns true
     * }</pre>
     *
     * @param a the byte array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(byte[], byte)
     */
    public static boolean contains(final byte[] a, final byte valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] values = {10, 20, 30, 40, 50};
     * boolean result = N.contains(values, (short) 30);  // Returns true
     * }</pre>
     *
     * @param a the short array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(short[], short)
     */
    public static boolean contains(final short[] a, final short valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * boolean result = N.contains(numbers, 3);  // Returns true
     * }</pre>
     *
     * @param a the int array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(int[], int)
     */
    public static boolean contains(final int[] a, final int valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] ids = {1000L, 2000L, 3000L, 4000L};
     * boolean result = N.contains(ids, 1000L);  // Returns true
     * }</pre>
     *
     * @param a the long array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(long[], long)
     */
    public static boolean contains(final long[] a, final long valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p>Note: Uses Float.compare() for proper handling of NaN and -0.0/+0.0 comparisons.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.3f, 3.7f, 4.1f};
     * boolean result = N.contains(values, 1.5f);  // Returns true
     * }</pre>
     *
     * @param a the float array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(float[], float)
     */
    public static boolean contains(final float[] a, final float valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p>Note: Uses Double.compare() for proper handling of NaN and -0.0/+0.0 comparisons.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] values = {1.5, 2.3, 3.7, 4.1};
     * boolean result = N.contains(values, 1.5);  // Returns true
     * }</pre>
     *
     * @param a the double array
     * @param valueToFind the value to search for
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(double[], double)
     */
    public static boolean contains(final double[] a, final double valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the array contains the specified value.
     *
     * <p>Note: Uses null-safe equality comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"hello", "world", null, "test"};
     * boolean result = N.contains(words, "hello");  // Returns true
     * }</pre>
     *
     * @param a the Object array
     * @param valueToFind the value to search for (may be {@code null})
     * @return {@code true} if the array contains the value ({@code false} if array is {@code null} or empty)
     * @see #indexOf(Object[], Object)
     */
    public static boolean contains(final Object[] a, final Object valueToFind) {
        return indexOf(a, valueToFind) != INDEX_NOT_FOUND;
    }

    /**
     * Returns {@code true} if the collection contains the specified value.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "cherry");
     * boolean result = N.contains(words, "apple");  // Returns true
     * }</pre>
     *
     * @param c the Collection to search in
     * @param valueToFind the value to search for (may be {@code null})
     * @return {@code true} if the collection contains the value ({@code false} if collection is {@code null} or empty)
     * @see Collection#contains(Object)
     * @see #contains(Iterable, Object)
     */
    public static boolean contains(final Collection<?> c, final Object valueToFind) {
        if (isEmpty(c)) {
            return false;
        }

        return c.contains(valueToFind);
    }

    /**
     * Returns {@code true} if the iterable contains the specified value.
     *
     * <p>Note: Uses null-safe equality comparison.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", null, "cherry");
     * boolean result = N.contains(words, "apple");  // Returns true
     * }</pre>
     *
     * @param c the Iterable to search in
     * @param valueToFind the value to search for (may be {@code null})
     * @return {@code true} if the iterable contains the value ({@code false} if iterable is {@code null} or empty)
     * @see #contains(Collection, Object)
     */
    public static boolean contains(final Iterable<?> c, final Object valueToFind) {
        if (isEmptyCollection(c)) {
            return false;
        }

        for (final Object e : c) {
            if (equals(e, valueToFind)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the iterator contains the specified value.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iterator = Arrays.asList("a", "b", "c").iterator();
     * boolean result = N.contains(iterator, "b");  // Returns true (iterator is now exhausted)
     * }</pre>
     *
     * @param iter the Iterator to search in
     * @param valueToFind the value to search for (may be {@code null})
     * @return {@code true} if the iterator contains the value ({@code false} if iterator is {@code null})
     * @see #contains(Iterable, Object)
     */
    public static boolean contains(final Iterator<?> iter, final Object valueToFind) {
        if (iter == null) {
            return false;
        }

        while (iter.hasNext()) {
            if (equals(iter.next(), valueToFind)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the collection contains all the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> colors = Set.of("red", "green", "blue", "yellow");
     * List<String> primary = Arrays.asList("red", "blue", "yellow");
     * boolean result = N.containsAll(colors, primary);  // Returns true
     * }</pre>
     *
     * @param c the Collection to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if collection contains all values ({@code true} if valuesToFind is {@code null}/empty; {@code false} if collection is {@code null}/empty)
     * @see Collection#containsAll(Collection)
     * @see #containsAll(Collection, Object...)
     */
    public static boolean containsAll(final Collection<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (isEmpty(c)) {
            return false;
        }

        //noinspection SuspiciousMethodCalls
        return c.containsAll(valuesToFind);
    }

    /**
     * Returns {@code true} if the collection contains all the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> colors = Set.of("red", "green", "blue", "yellow");
     * boolean result = N.containsAll(colors, "red", "green", "blue");  // Returns true
     * }</pre>
     *
     * @param c the Collection to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if collection contains all values ({@code true} if valuesToFind is {@code null}/empty; {@code false} if collection is {@code null}/empty)
     * @see #containsAll(Collection, Collection)
     */
    public static boolean containsAll(final Collection<?> c, final Object... valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (isEmpty(c)) {
            return false;
        }

        //noinspection SuspiciousMethodCalls
        return c.containsAll(Array.asList(valuesToFind));
    }

    /**
     * Returns {@code true} if the iterable contains all the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date");
     * Set<String> searchFor = Set.of("apple", "banana");
     * boolean result = N.containsAll(fruits, searchFor);  // Returns true
     * }</pre>
     *
     * @param c the Iterable to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if iterable contains all values ({@code true} if valuesToFind is {@code null}/empty; {@code false} if iterable is {@code null}/empty)
     * @see #containsAll(Collection, Collection)
     */
    public static boolean containsAll(final Iterable<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (isEmptyCollection(c)) {
            return false;
        }

        final Set<?> set = new HashSet<>(valuesToFind);

        for (final Object e : c) {
            if (set.remove(e) && (set.size() == 0)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the iterator contains all the specified values.
     *
     * <p>Note: This method consumes the iterator, stopping early once all values are found.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Stream<String> words = Stream.of("hello", "world", "java", "stream");
     * Set<String> searchFor = Set.of("hello", "java");
     * boolean result = N.containsAll(words.iterator(), searchFor);  // Returns true (iterator consumed)
     * }</pre>
     *
     * @param iter the Iterator to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if iterator contains all values ({@code true} if valuesToFind is {@code null}/empty; {@code false} if iterator is {@code null})
     * @see #containsAll(Iterable, Collection)
     */
    public static boolean containsAll(final Iterator<?> iter, final Collection<?> valuesToFind) {
        if (isEmpty(valuesToFind)) {
            return true;
        } else if (iter == null) {
            return false;
        }

        final Set<?> set = new HashSet<>(valuesToFind);

        while (iter.hasNext()) {
            if (set.remove(iter.next()) && (set.size() == 0)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the collection contains any of the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> colors = Set.of("red", "green", "blue");
     * List<String> warm = Arrays.asList("red", "orange", "yellow");
     * boolean result = N.containsAny(colors, warm);  // Returns true (found "red")
     * }</pre>
     *
     * @param c the Collection to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if collection contains any value ({@code false} if either collection is {@code null} or empty)
     * @see #disjoint(Collection, Collection)
     * @see #containsAll(Collection, Collection)
     */
    public static boolean containsAny(final Collection<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return false;
        }

        return !disjoint(c, valuesToFind);
    }

    /**
     * Returns {@code true} if the collection contains any of the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> colors = Set.of("red", "green", "blue");
     * boolean result = N.containsAny(colors, "red", "orange", "yellow");  // Returns true
     * }</pre>
     *
     * @param c the Collection to search in
     * @param valuesToFind the values to check for
     * @return {@code true} if collection contains any value ({@code false} if collection is {@code null}/empty or no values provided)
     * @see #containsAny(Collection, Collection)
     */
    public static boolean containsAny(final Collection<?> c, final Object... valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return false;
        }

        return !disjoint(c, Array.asList(valuesToFind));
    }

    /**
     * Returns {@code true} if the iterable contains any of the specified values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date");
     * Set<String> common = Set.of("apple", "grape");
     * boolean result = N.containsAny(fruits, common);  // Returns true (found "apple")
     * }</pre>
     *
     * @param c the Iterable to search in
     * @param valuesToFind the Set of values to check for
     * @return {@code true} if iterable contains any value ({@code false} if either parameter is {@code null} or empty)
     * @see #containsAny(Collection, Collection)
     */
    public static boolean containsAny(final Iterable<?> c, final Set<?> valuesToFind) {
        if (isEmptyCollection(c) || isEmpty(valuesToFind)) {
            return false;
        }

        for (final Object e : c) {
            if (valuesToFind.contains(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the iterator contains any of the specified values.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Stream<String> words = Stream.of("hello", "world", "java", "stream");
     * Set<String> keywords = Set.of("java", "python", "c++");
     * boolean result = N.containsAny(words.iterator(), keywords);  // Returns true (iterator consumed)
     * }</pre>
     *
     * @param iter the Iterator to search in
     * @param valuesToFind the Set of values to check for
     * @return {@code true} if iterator contains any value ({@code false} if iterator is {@code null} or valuesToFind is {@code null}/empty)
     * @see #containsAny(Iterable, Set)
     */
    public static boolean containsAny(final Iterator<?> iter, final Set<?> valuesToFind) {
        if (iter == null || isEmpty(valuesToFind)) {
            return false;
        }

        while (iter.hasNext()) {
            if (valuesToFind.contains(iter.next())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if the collection contains none of the specified values.
     * Returns {@code true} if either collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> allowedColors = Set.of("red", "green", "blue");
     * List<String> invalidColors = Arrays.asList("yellow");
     * boolean result = N.containsNone(allowedColors, invalidColors);  // Returns true
     * }</pre>
     *
     * @param c the Collection to check
     * @param valuesToFind the values to check for absence
     * @return {@code true} if the collection contains none of the specified values, {@code false} otherwise
     * @see #containsAny(Collection, Collection)
     */
    public static boolean containsNone(final Collection<?> c, final Collection<?> valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(c, valuesToFind);
    }

    /**
     * Returns {@code true} if the collection contains none of the specified values.
     * Returns {@code true} if the collection is {@code null} or empty, or if no values are provided.
     * Provides a convenient varargs interface for exclusion checks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Set<String> userInput = Set.of("safe", "clean", "valid");
     * boolean result = N.containsNone(userInput, "script", "eval", "exec");  // Returns true
     * }</pre>
     *
     * @param c the Collection to check
     * @param valuesToFind the values to check for absence
     * @return {@code true} if the collection contains none of the specified values, {@code false} otherwise
     * @see #containsNone(Collection, Collection)
     */
    public static boolean containsNone(final Collection<?> c, final Object... valuesToFind) {
        if (isEmpty(c) || isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(c, valuesToFind);
    }

    /**
     * Returns {@code true} if the iterable contains none of the specified values.
     * Returns {@code true} if either parameter is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> document = Arrays.asList("the", "quick", "brown", "fox");
     * Set<String> stopWords = Set.of("and", "or", "but", "if");
     * boolean result = N.containsNone(document, stopWords);  // Returns true
     * }</pre>
     *
     * @param c the Iterable to check
     * @param valuesToFind the Set of values to check for absence
     * @return {@code true} if the iterable contains none of the specified values, {@code false} otherwise
     * @see #containsAny(Iterable, Set)
     */
    public static boolean containsNone(final Iterable<?> c, final Set<?> valuesToFind) {
        if (isEmptyCollection(c) || isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(c, valuesToFind);
    }

    /**
     * Returns {@code true} if the iterator contains none of the specified values.
     * Returns {@code true} if either parameter is {@code null} or empty.
     *
     * <p>Note: This method consumes the iterator completely.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Stream<String> userInput = Stream.of("hello", "world", "test");
     * Set<String> forbidden = Set.of("admin", "root", "system");
     * boolean result = N.containsNone(userInput.iterator(), forbidden);  // Returns true (iterator consumed)
     * }</pre>
     *
     * @param iter the Iterator to check
     * @param valuesToFind the Set of values to check for absence
     * @return {@code true} if the iterator contains none of the specified values, {@code false} otherwise
     * @see #containsAny(Iterator, Set)
     */
    public static boolean containsNone(final Iterator<?> iter, final Set<?> valuesToFind) {
        if (iter == null || isEmpty(valuesToFind)) {
            return true;
        }

        return !containsAny(iter, valuesToFind);
    }

    /**
     * Returns an immutable slice of the array from the specified range [fromIndex, toIndex).
     * Returns ImmutableList.empty() if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry", "date", "elderberry"};
     * ImmutableList<String> slice = N.slice(words, 1, 4);
     * // Returns ["banana", "cherry", "date"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to slice
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @return an immutable list containing the slice, or ImmutableList.empty() if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #slice(List, int, int)
     */
    public static <T> ImmutableList<T> slice(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a)) {
            return ImmutableList.empty();
        }

        return slice(Array.asList(a), fromIndex, toIndex);
    }

    /**
     * Returns an immutable slice of the list from the specified range [fromIndex, toIndex).
     * Returns ImmutableList.empty() if the list is {@code null} or empty.
     * Uses List.subList() for O(1) view creation without copying elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
     * ImmutableList<String> slice = N.slice(words, 1, 4);
     * // Returns ["banana", "cherry", "date"]
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param c the list to slice
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @return an immutable list containing the slice, or ImmutableList.empty() if the list is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see List#subList(int, int)
     */
    public static <T> ImmutableList<T> slice(final List<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return ImmutableList.empty();
        } else if (fromIndex == 0 && toIndex == size(c)) {
            return ImmutableList.wrap(c);
        }

        return ImmutableList.wrap(((List<T>) c).subList(fromIndex, toIndex));
    }

    /**
     * Returns an immutable slice of the collection from the specified range [fromIndex, toIndex).
     * Returns ImmutableList.empty() if the collection is {@code null} or empty.
     * For List collections, uses List.subList() for O(1) view creation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> list = Arrays.asList("a", "b", "c", "d", "e");
     * ImmutableCollection<String> slice = N.slice(list, 1, 4);
     * // Returns ["b", "c", "d"]
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to slice
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @return an immutable collection containing the slice, or ImmutableList.empty() if the collection is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #slice(List, int, int)
     */
    public static <T> ImmutableCollection<T> slice(final Collection<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c)) {
            return ImmutableList.empty();
        }

        if (c instanceof List) {
            return slice((List<T>) c, fromIndex, toIndex);
        }

        return new Slice<>(c, fromIndex, toIndex);
    }

    /**
     * Returns a slice of the iterator from the specified range [fromIndex, toIndex).
     * Returns an empty iterator if iter is {@code null} or fromIndex equals toIndex.
     * This method consumes elements from the iterator up to toIndex.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
     * ObjIterator<Integer> slice = N.slice(stream.iterator(), 2, 7);
     * // Returns [3, 4, 5, 6, 7]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to slice
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @return an iterator containing the slice, or an empty iterator if iter is {@code null} or fromIndex equals toIndex
     * @throws IllegalArgumentException if fromIndex is negative or fromIndex &gt; toIndex
     * @see Iterators#skipAndLimit(Iterator, long, long)
     */
    public static <T> ObjIterator<T> slice(final Iterator<? extends T> iter, final int fromIndex, final int toIndex) {
        if (fromIndex < 0 || fromIndex > toIndex) {
            throw new IllegalArgumentException("Invalid fromIndex/toIndex: [" + fromIndex + ", " + toIndex + "]");
        }

        if (iter == null || fromIndex == toIndex) {
            return ObjIterator.empty();
        }

        return Iterators.skipAndLimit(iter, fromIndex, toIndex - fromIndex); // NOSONAR
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, false, true, false, true};
     * List<boolean[]> chunks = N.split(flags, 3);
     * // Returns [[true, false, true], [false, true, false], [true]]
     * }</pre>
     *
     * @param a the boolean array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(boolean[], int, int, int)
     */
    public static List<boolean[]> split(final boolean[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, "chunkSize"); //NOSONAR

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<boolean[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, false, true, false, true, false};
     * List<boolean[]> chunks = N.split(flags, 1, 7, 2);
     * // Returns [[false, true], [false, true], [false, true]]
     * }</pre>
     *
     * @param a the boolean array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(boolean[], int)
     */
    public static List<boolean[]> split(final boolean[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<boolean[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'a', 'b', 'c', 'd', 'e'};
     * List<char[]> chunks = N.split(chars, 2);
     * // Returns [['a', 'b'], ['c', 'd'], ['e']]
     * }</pre>
     *
     * @param a the char array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(char[], int, int, int)
     */
    public static List<char[]> split(final char[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<char[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'a', 'b', 'c', 'd', 'e'};
     * List<char[]> chunks = N.split(chars, 1, 4, 2);
     * // Returns [['b', 'c'], ['d']]
     * }</pre>
     *
     * @param a the char array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(char[], int)
     */
    public static List<char[]> split(final char[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<char[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3, 4, 5, 6, 7};
     * List<byte[]> chunks = N.split(data, 3);
     * // Returns [[1, 2, 3], [4, 5, 6], [7]]
     * }</pre>
     *
     * @param a the byte array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(byte[], int, int, int)
     */
    public static List<byte[]> split(final byte[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<byte[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3, 4, 5, 6, 7, 8};
     * List<byte[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2, 3], [4, 5], [6, 7]]
     * }</pre>
     *
     * @param a the byte array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(byte[], int)
     */
    public static List<byte[]> split(final byte[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<byte[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] data = {1, 2, 3, 4, 5, 6, 7};
     * List<short[]> chunks = N.split(data, 3);
     * // Returns [[1, 2, 3], [4, 5, 6], [7]]
     * }</pre>
     *
     * @param a the short array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(short[], int, int, int)
     */
    public static List<short[]> split(final short[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<short[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] data = {1, 2, 3, 4, 5, 6, 7, 8};
     * List<short[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2, 3], [4, 5], [6, 7]]
     * }</pre>
     *
     * @param a the short array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(short[], int)
     */
    public static List<short[]> split(final short[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<short[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] data = {1, 2, 3, 4, 5, 6, 7};
     * List<int[]> chunks = N.split(data, 3);
     * // Returns [[1, 2, 3], [4, 5, 6], [7]]
     * }</pre>
     *
     * @param a the int array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(int[], int, int, int)
     */
    public static List<int[]> split(final int[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<int[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] data = {1, 2, 3, 4, 5, 6, 7, 8};
     * List<int[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2, 3], [4, 5], [6, 7]]
     * }</pre>
     *
     * @param a the int array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(int[], int)
     */
    public static List<int[]> split(final int[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<int[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] data = {1L, 2L, 3L, 4L, 5L, 6L, 7L};
     * List<long[]> chunks = N.split(data, 3);
     * // Returns [[1L, 2L, 3L], [4L, 5L, 6L], [7L]]
     * }</pre>
     *
     * @param a the long array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(long[], int, int, int)
     */
    public static List<long[]> split(final long[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<long[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] data = {1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L};
     * List<long[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2L, 3L], [4L, 5L], [6L, 7L]]
     * }</pre>
     *
     * @param a the long array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(long[], int)
     */
    public static List<long[]> split(final long[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<long[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] data = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f};
     * List<float[]> chunks = N.split(data, 3);
     * // Returns [[1.0f, 2.0f, 3.0f], [4.0f, 5.0f, 6.0f], [7.0f]]
     * }</pre>
     *
     * @param a the float array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(float[], int, int, int)
     */
    public static List<float[]> split(final float[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<float[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] data = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f};
     * List<float[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2.0f, 3.0f], [4.0f, 5.0f], [6.0f, 7.0f]]
     * }</pre>
     *
     * @param a the float array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(float[], int)
     */
    public static List<float[]> split(final float[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<float[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] data = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0};
     * List<double[]> chunks = N.split(data, 3);
     * // Returns [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0]]
     * }</pre>
     *
     * @param a the double array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(double[], int, int, int)
     */
    public static List<double[]> split(final double[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<double[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] data = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};
     * List<double[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [[2.0, 3.0], [4.0, 5.0], [6.0, 7.0]]
     * }</pre>
     *
     * @param a the double array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(double[], int)
     */
    public static List<double[]> split(final double[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<double[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty.
     * The last chunk may be smaller if the array length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] data = {"a", "b", "c", "d", "e", "f", "g"};
     * List<String[]> chunks = N.split(data, 3);
     * // Returns [["a", "b", "c"], ["d", "e", "f"], ["g"]]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to split
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(Object[], int, int, int)
     */
    public static <T> List<T[]> split(final T[] a, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        final int len = a.length;
        final List<T[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int fromIndex = 0, toIndex = a.length; fromIndex < toIndex; fromIndex += chunkSize) {
            res.add(copyOfRange(a, fromIndex, fromIndex <= toIndex - chunkSize ? fromIndex + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of subarrays by splitting a range of the array into chunks of the specified size.
     * Returns an empty list if the array is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] data = {"a", "b", "c", "d", "e", "f", "g", "h"};
     * List<String[]> chunks = N.split(data, 1, 7, 2);
     * // Returns [["b", "c"], ["d", "e"], ["f", "g"]]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of subarrays, or an empty list if the array is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(Object[], int)
     */
    public static <T> List<T[]> split(final T[] a, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<T[]> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(copyOfRange(a, i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
        }

        return res;
    }

    /**
     * Returns a list of sub-collections by splitting the collection into chunks of the specified size.
     * Returns an empty list if the collection is {@code null} or empty.
     * The last chunk may be smaller if the collection size is not evenly divisible.
     * For List collections, returns views (subLists) with O(1) per chunk; for other collections, creates new ArrayLists.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
     * List<List<Integer>> chunks = N.split(numbers, 3);
     * // Returns [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to split
     * @param chunkSize the size of each chunk
     * @return a list of sub-collections, or an empty list if the collection is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(Collection, int, int, int)
     */
    public static <T> List<List<T>> split(final Collection<? extends T> c, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        return split(c, 0, c.size(), chunkSize);
    }

    /**
     * Returns a list of sub-collections by splitting a range of the collection into chunks of the specified size.
     * Returns an empty list if the collection is {@code null} or empty, or if fromIndex equals toIndex.
     * The last chunk may be smaller if the range length is not evenly divisible.
     * For List collections, returns views (subLists); for other collections, creates new ArrayLists.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
     * List<List<Integer>> chunks = N.split(numbers, 2, 8, 2);
     * // Returns [[3, 4], [5, 6], [7, 8]]
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of sub-collections, or an empty list if the collection is {@code null}/empty or fromIndex equals toIndex
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(Collection, int)
     */
    public static <T> List<List<T>> split(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmpty(c) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<List<T>> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        if (c instanceof List) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
                res.add(list.subList(i, i <= toIndex - chunkSize ? i + chunkSize : toIndex));
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();

            for (int i = 0; i < toIndex;) {
                if (i < fromIndex) {
                    iter.next();
                    i++;
                    continue;
                }

                final List<T> subList = new ArrayList<>(min(chunkSize, toIndex - i));

                for (final int j = i <= toIndex - chunkSize ? i + chunkSize : toIndex; i < j; i++) {
                    subList.add(iter.next());
                }

                res.add(subList);
            }
        }

        return res;
    }

    /**
     * Returns a list of sub-collections by splitting the iterable into chunks of the specified size.
     * Returns an empty list if the iterable is {@code null} or empty.
     * The last chunk may be smaller if the iterable size is not evenly divisible.
     * For Collection instances, delegates to the more efficient Collection variant.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<Integer> custom = () -> Arrays.asList(1, 2, 3, 4, 5, 6, 7).iterator();
     * List<List<Integer>> chunks = N.split(custom, 3);
     * // Returns [[1, 2, 3], [4, 5, 6], [7]]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable to split
     * @param chunkSize the size of each chunk
     * @return a list of sub-collections, or an empty list if the iterable is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(Collection, int)
     * @see #split(Iterator, int)
     */
    public static <T> List<List<T>> split(final Iterable<? extends T> c, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (isEmptyCollection(c)) {
            return new ArrayList<>();
        } else if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;

            return split(coll, 0, coll.size(), chunkSize);
        } else {
            return toList(split(c.iterator(), chunkSize));
        }
    }

    /**
     * Returns a lazy iterator that splits the input iterator into chunks of the specified size.
     * Returns an empty iterator if the input iterator is {@code null}.
     * The last chunk may be smaller if the total element count is not evenly divisible.
     * The input iterator is consumed progressively as chunks are accessed, making this memory-efficient for large or infinite iterators.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9).iterator();
     * ObjIterator<List<Integer>> chunks = N.split(numbers, 3);
     * chunks.next();  // Returns [1, 2, 3]
     * chunks.next();  // Returns [4, 5, 6]
     * chunks.next();  // Returns [7, 8, 9]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator to split
     * @param chunkSize the size of each chunk
     * @return a lazy iterator producing lists of elements, or an empty iterator if the input is {@code null}
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(Iterable, int)
     * @see #toList(Iterator)
     */
    public static <T> ObjIterator<List<T>> split(final Iterator<? extends T> iter, final int chunkSize) throws IllegalArgumentException {
        checkArgument(chunkSize > 0, "'chunkSize' must be greater than 0, can't be: %s", chunkSize);

        if (iter == null) {
            return ObjIterator.empty();
        }

        return new ObjIterator<>() {
            private final Iterator<? extends T> iterator = iter;

            @Override
            public boolean hasNext() {
                return iterator.hasNext();
            }

            @Override
            public List<T> next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                final List<T> next = new ArrayList<>(chunkSize);

                for (int i = 0; i < chunkSize && iterator.hasNext(); i++) {
                    next.add(iterator.next());
                }

                return next;
            }
        };
    }

    /**
     * Returns a list of substrings by splitting the string into chunks of the specified size.
     * Returns an empty list if the string is {@code null} or empty.
     * The last chunk may be smaller if the string length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String text = "HelloWorld";
     * List<String> chunks = N.split(text, 3);
     * // Returns ["Hel", "loW", "orl", "d"]
     * }</pre>
     *
     * @param str the string to split
     * @param chunkSize the size of each chunk
     * @return a list of string chunks, or an empty list if the string is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @see #split(CharSequence, int, int, int)
     */
    public static List<String> split(final CharSequence str, final int chunkSize) throws IllegalArgumentException {
        checkArgPositive(chunkSize, cs.chunkSize);

        if (Strings.isEmpty(str)) {
            return new ArrayList<>();
        }

        return split(str, 0, str.length(), chunkSize);
    }

    /**
     * Returns a list of substrings by splitting a range of the string into chunks of the specified size.
     * Returns an empty list if the string is {@code null} or empty.
     * The last chunk may be smaller if the range length is not evenly divisible.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String text = "HelloWorldJava";
     * List<String> chunks = N.split(text, 5, 14, 3);
     * // Returns ["Wor", "ldJ", "ava"]
     * }</pre>
     *
     * @param str the string to split
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param chunkSize the size of each chunk
     * @return a list of string chunks, or an empty list if the string is {@code null} or empty
     * @throws IllegalArgumentException if chunkSize is not positive
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #split(CharSequence, int)
     */
    public static List<String> split(final CharSequence str, final int fromIndex, final int toIndex, final int chunkSize)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(str));
        checkArgPositive(chunkSize, cs.chunkSize);

        if (Strings.isEmpty(str)) {
            return new ArrayList<>();
        }

        final int len = toIndex - fromIndex;
        final List<String> res = new ArrayList<>(len % chunkSize == 0 ? len / chunkSize : (len / chunkSize) + 1);

        for (int i = fromIndex; i < toIndex; i = i <= toIndex - chunkSize ? i + chunkSize : toIndex) {
            res.add(str.subSequence(i, i <= toIndex - chunkSize ? i + chunkSize : toIndex).toString());
        }

        return res;
    }

    /**
     * Splits the total size into chunks based on the specified maximum chunk count.
     * <br />
     * The size of the chunks is larger first.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input {@code totalSize} is less than {@code maxChunkCount}.
     *
     * @param <T> the type of the elements in the resulting stream
     * @param totalSize the total size to be split. It could be the size of an array, list, etc.
     * @param maxChunkCount the maximum number of chunks to split into
     * @param func the function to apply to each chunk's start and end indices to produce a result
     * @return a Stream of the mapped chunk values
     * @throws IllegalArgumentException if {@code totalSize} is negative or {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(int, int, boolean, IntBiFunction)
     */
    public static <T> List<T> splitByChunkCount(final int totalSize, final int maxChunkCount, final IntBiFunction<? extends T> func) {
        return splitByChunkCount(totalSize, maxChunkCount, false, func);
    }

    /**
     * Splits the total size into chunks based on the specified maximum chunk count.
     * <br />
     * The size of the chunks can be either smaller or larger first based on the flag.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input {@code totalSize} is less than {@code maxChunkCount}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * final int[] a = Array.rangeClosed(1, 7);
     * splitByChunkCount(7, 5, true, (fromIndex, toIndex) ->  copyOfRange(a, fromIndex, toIndex)); // [[1], [2], [3], [4, 5], [6, 7]]
     * splitByChunkCount(7, 5, false, (fromIndex, toIndex) ->  copyOfRange(a, fromIndex, toIndex)); // [[1, 2], [3, 4], [5], [6], [7]]
     * }</pre>
     *
     * @param <T> the type of the elements in the resulting stream
     * @param totalSize the total size to be split. It could be the size of an array, list, etc.
     * @param maxChunkCount the maximum number of chunks to split into
     * @param sizeSmallerFirst if {@code true}, smaller chunks will be created first; otherwise, larger chunks will be created first
     * @param func a function to map the chunk from and to index to an element in the resulting stream
     * @return a Stream of the mapped chunk values
     * @throws IllegalArgumentException if {@code totalSize} is negative or {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(Collection, int, boolean)
     * @see Stream#splitByChunkCount(int, int, boolean, IntBiFunction)
     * @see IntStream#splitByChunkCount(int, int, IntBinaryOperator)
     */
    public static <T> List<T> splitByChunkCount(final int totalSize, final int maxChunkCount, final boolean sizeSmallerFirst,
            final IntBiFunction<? extends T> func) {
        N.checkArgNotNegative(totalSize, cs.totalSize);
        N.checkArgPositive(maxChunkCount, cs.maxChunkCount);

        //noinspection resource
        return Stream.<T> splitByChunkCount(totalSize, maxChunkCount, sizeSmallerFirst, func).toList();
    }

    /**
     * Splits the input collection into sub-lists based on the specified maximum chunk count.
     * <br />
     * The size of the chunks is larger first.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input Collection size is less than {@code maxChunkCount}.
     *
     * @param <T> the type of elements in the input collection
     * @param c the input collection to be split
     * @param maxChunkCount the maximum number of chunks to split into
     * @return a list of sub-lists.
     * @throws IllegalArgumentException if {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(Collection, int, boolean)
     */
    public static <T> List<List<T>> splitByChunkCount(final Collection<? extends T> c, final int maxChunkCount) {
        return splitByChunkCount(c, maxChunkCount, false);
    }

    /**
     * Splits the input collection into sub-lists based on the specified maximum chunk count.
     * <br />
     * The size of the chunks can be either smaller or larger first based on the flag.
     * <br />
     * The size of returned List may be less than the specified {@code maxChunkCount} if the input Collection size is less than {@code maxChunkCount}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * final List<Integer> c = N.asList(1, 2, 3, 4, 5, 6, 7);
     * splitByChunkCount(c, 5, true); // [[1], [2], [3], [4, 5], [6, 7]]
     * splitByChunkCount(c, 5, false); // [[1, 2], [3, 4], [5], [6], [7]]
     * }</pre>
     *
     * @param <T> the type of elements in the input collection
     * @param c the input collection to be split
     * @param maxChunkCount the maximum number of chunks to split into
     * @param sizeSmallerFirst if {@code true}, smaller chunks will be created first; otherwise, larger chunks will be created first
     * @return a list of sub-lists.
     * @throws IllegalArgumentException if {@code maxChunkCount} is not positive.
     * @see #splitByChunkCount(int, int, boolean, IntBiFunction)
     * @see Stream#splitByChunkCount(int, int, boolean, IntBiFunction)
     * @see IntStream#splitByChunkCount(int, int, boolean, IntBinaryOperator)
     */
    public static <T> List<List<T>> splitByChunkCount(final Collection<? extends T> c, final int maxChunkCount, final boolean sizeSmallerFirst) {
        N.checkArgPositive(maxChunkCount, cs.maxChunkCount);

        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        IntBiFunction<List<T>> func = null;

        if (c instanceof List) { // NOSONAR
            final List<T> list = (List<T>) c; // NOSONAR
            func = list::subList;
        } else {
            final Iterator<? extends T> iter = c.iterator();

            // Only used in below line to call splitByChunkCount.
            func = (fromIndex, toIndex) -> {
                final List<T> subList = new ArrayList<>(toIndex - fromIndex);

                for (int i = fromIndex; i < toIndex; i++) {
                    subList.add(iter.next());
                }

                return subList;
            };
        }

        return splitByChunkCount(c.size(), maxChunkCount, sizeSmallerFirst, func);
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false};
     * boolean[] b = {true, true};
     * boolean[] result = N.concat(a, b);
     * // Returns {true, false, true, true}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(boolean[]...)
     */
    public static boolean[] concat(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BOOLEAN_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_BOOLEAN_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final boolean[] c = new boolean[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false};
     * boolean[] b = {false, true};
     * boolean[] c = {true, true};
     * boolean[] result = N.concat(a, b, c);
     * // Returns {true, false, false, true, true, true}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(boolean[], boolean[])
     */
    public static boolean[] concat(final boolean[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_BOOLEAN_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final boolean[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final boolean[] c = new boolean[len];
        int fromIndex = 0;

        for (final boolean[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'d', 'e'};
     * char[] result = N.concat(a, b);
     * // Returns {'a', 'b', 'c', 'd', 'e'}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(char[]...)
     */
    public static char[] concat(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_CHAR_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_CHAR_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final char[] c = new char[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Concatenates multiple char arrays into a single new array.
     *
     * <p>This method creates a new array containing all elements from each input array in the order they are provided.
     * The original arrays are not modified. This is useful for combining multiple character sequences or building
     * arrays from multiple sources.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'c'};
     * char[] b = {'d', 'e'};
     * char[] c = {'f', 'g', 'h'};
     * char[] result = N.concat(a, b, c);  // Returns {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}
     *
     * // Handles null/empty arrays gracefully
     * char[] withNull = N.concat(a, null, b);  // Returns {'a', 'b', 'c', 'd', 'e'}
     * char[] allNull = N.concat(null, null);    // Returns empty array
     *
     * // Single array returns a clone
     * char[] single = N.concat(a);  // Returns {'a', 'b', 'c'}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(char[], char[])
     */
    public static char[] concat(final char[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_CHAR_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_CHAR_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final char[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final char[] c = new char[len];
        int fromIndex = 0;

        for (final char[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {4, 5};
     * byte[] result = N.concat(a, b);
     * // Returns {1, 2, 3, 4, 5}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(byte[]...)
     */
    public static byte[] concat(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BYTE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_BYTE_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final byte[] c = new byte[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 3};
     * byte[] b = {4, 5};
     * byte[] c = {6, 7, 8};
     * byte[] result = N.concat(a, b, c);
     * // Returns {1, 2, 3, 4, 5, 6, 7, 8}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(byte[], byte[])
     */
    public static byte[] concat(final byte[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_BYTE_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_BYTE_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final byte[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final byte[] c = new byte[len];
        int fromIndex = 0;

        for (final byte[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 3};
     * short[] b = {4, 5};
     * short[] result = N.concat(a, b);
     * // Returns {1, 2, 3, 4, 5}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(short[]...)
     */
    public static short[] concat(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_SHORT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_SHORT_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final short[] c = new short[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 3};
     * short[] b = {4, 5};
     * short[] c = {6, 7, 8};
     * short[] result = N.concat(a, b, c);
     * // Returns {1, 2, 3, 4, 5, 6, 7, 8}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(short[], short[])
     */
    public static short[] concat(final short[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_SHORT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_SHORT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final short[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final short[] c = new short[len];
        int fromIndex = 0;

        for (final short[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 3};
     * int[] b = {4, 5};
     * int[] result = N.concat(a, b);
     * // Returns {1, 2, 3, 4, 5}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(int[]...)
     */
    public static int[] concat(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_INT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_INT_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final int[] c = new int[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a1 = {1, 2, 3};
     * int[] a2 = {4, 5};
     * int[] a3 = {6, 7, 8, 9};
     * int[] result = N.concat(a1, a2, a3);
     * // Returns {1, 2, 3, 4, 5, 6, 7, 8, 9}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(int[], int[])
     */
    public static int[] concat(final int[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_INT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_INT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final int[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final int[] c = new int[len];
        int fromIndex = 0;

        for (final int[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1L, 2L, 3L};
     * long[] b = {4L, 5L};
     * long[] result = N.concat(a, b);
     * // Returns {1L, 2L, 3L, 4L, 5L}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(long[]...)
     */
    public static long[] concat(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_LONG_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_LONG_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final long[] c = new long[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1L, 2L, 3L};
     * long[] b = {4L, 5L};
     * long[] c = {6L, 7L, 8L};
     * long[] result = N.concat(a, b, c);
     * // Returns {1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(long[], long[])
     */
    public static long[] concat(final long[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_LONG_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_LONG_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final long[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final long[] c = new long[len];
        int fromIndex = 0;

        for (final long[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] result = N.concat(a, b);
     * // Returns {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(float[]...)
     */
    public static float[] concat(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_FLOAT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_FLOAT_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final float[] c = new float[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 3.0f};
     * float[] b = {4.0f, 5.0f};
     * float[] c = {6.0f, 7.0f, 8.0f};
     * float[] result = N.concat(a, b, c);
     * // Returns {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(float[], float[])
     */
    public static float[] concat(final float[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_FLOAT_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final float[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final float[] c = new float[len];
        int fromIndex = 0;

        for (final float[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns an empty array if both arrays are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * double[] b = {4.0, 5.0};
     * double[] result = N.concat(a, b);
     * // Returns {1.0, 2.0, 3.0, 4.0, 5.0}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(double[]...)
     */
    public static double[] concat(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_DOUBLE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return isEmpty(a) ? EMPTY_DOUBLE_ARRAY : a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final double[] c = new double[a.length + b.length];

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns an empty array if the input is {@code null} or empty.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 3.0};
     * double[] b = {4.0, 5.0};
     * double[] c = {6.0, 7.0, 8.0};
     * double[] result = N.concat(a, b, c);
     * // Returns {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0}
     * }</pre>
     *
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(double[], double[])
     */
    public static double[] concat(final double[]... aa) {
        if (isEmpty(aa)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (aa.length == 1) {
            return isEmpty(aa[0]) ? EMPTY_DOUBLE_ARRAY : aa[0].clone();
        }

        int len = 0;

        for (final double[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final double[] c = new double[len];
        int fromIndex = 0;

        for (final double[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new array containing all elements from both input arrays.
     * Returns {@code null} if both arrays are {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"A", "B", "C"};
     * String[] b = {"D", "E"};
     * String[] result = N.concat(a, b);
     * // Returns {"A", "B", "C", "D", "E"}
     * }</pre>
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements from both arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(Object[]...)
     * @see #merge(Object[], Object[], BiFunction)
     */
    @MayReturnNull
    public static <T> T[] concat(final T[] a, final T[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? (a == null ? null : a.clone()) : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        if (a.length > Integer.MAX_VALUE - b.length) {
            throw new IllegalArgumentException("Combined array length exceeds maximum array size");
        }

        final T[] c = newArray(a.getClass().getComponentType(), a.length + b.length);

        copy(a, 0, c, 0, a.length);
        copy(b, 0, c, a.length, b.length);

        return c;
    }

    /**
     * Returns a new array containing all elements from all input arrays in order.
     * Returns {@code null} if the input is {@code null}.
     * Null or empty arrays within the input are skipped.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"A", "B", "C"};
     * String[] b = {"D", "E"};
     * String[] c = {"F", "G", "H"};
     * String[] result = N.concat(a, b, c);
     * // Returns {"A", "B", "C", "D", "E", "F", "G", "H"}
     * }</pre>
     *
     * @param <T> the type of elements in the arrays
     * @param aa the arrays to concatenate
     * @return a new array containing all elements from all input arrays
     * @throws IllegalArgumentException if the combined array length would exceed {@code Integer.MAX_VALUE}
     * @see #concat(Object[], Object[])
     * @see System#arraycopy(Object, int, Object, int, int)
     */
    @MayReturnNull
    @SafeVarargs
    public static <T> T[] concat(final T[]... aa) { // throws IllegalArgumentException {
        // checkArgNotNull(aa, cs.arrays); // if aa can't be null, what's about method: concat(final T[] a, final T[] b)? a and b can't be null too?

        if (aa == null) {
            return null; // NOSONAR
        } else if (aa.length == 0) {
            return newArray(aa.getClass().getComponentType().getComponentType(), 0);
        } else if (aa.length == 1) {
            return aa[0] == null ? newArray(aa.getClass().getComponentType().getComponentType(), 0) : aa[0].clone();
        }

        int len = 0;

        for (final T[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            len += a.length;
        }

        final T[] c = newArray(aa.getClass().getComponentType().getComponentType(), len);
        int fromIndex = 0;

        for (final T[] a : aa) {
            if (isEmpty(a)) {
                continue;
            }

            System.arraycopy(a, 0, c, fromIndex, a.length);

            fromIndex += a.length;
        }

        return c;
    }

    /**
     * Returns a new list containing all elements from both iterables.
     * Returns an empty list if both iterables are {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B", "C");
     * List<String> b = Arrays.asList("D", "E");
     * List<String> result = N.concat(a, b);
     * // Returns ["A", "B", "C", "D", "E"]
     * }</pre>
     *
     * @param <T> the type of elements
     * @param a the first iterable
     * @param b the second iterable
     * @return a new list containing elements from both iterables
     * @see #concat(Iterable[])
     * @see #merge(Iterable, Iterable, BiFunction)
     */
    public static <T> List<T> concat(final Iterable<? extends T> a, final Iterable<? extends T> b) {
        return concat(Arrays.asList(a, b));
    }

    /**
     * Returns a new list containing all elements from all iterables in order.
     * Returns an empty list if the input is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B");
     * List<String> b = Arrays.asList("C", "D");
     * List<String> c = Arrays.asList("E", "F");
     * List<String> result = N.concat(a, b, c);
     * // Returns ["A", "B", "C", "D", "E", "F"]
     * }</pre>
     *
     * @param <T> the type of elements
     * @param a the iterables to concatenate
     * @return a new list containing all elements from all iterables
     * @see #concat(Collection)
     * @see #merge(Collection, BiFunction)
     */
    @SafeVarargs
    public static <T> List<T> concat(final Iterable<? extends T>... a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return concat(Arrays.asList(a));
    }

    /**
     * Returns a new list containing all elements from all iterables in the collection in order.
     * Returns an empty list if the collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<List<String>> lists = Arrays.asList(
     *     Arrays.asList("A", "B"),
     *     Arrays.asList("C", "D")
     * );
     * List<String> result = N.concat(lists);
     * // Returns ["A", "B", "C", "D"]
     * }</pre>
     *
     * @param <T> the type of elements
     * @param c the collection of iterables to concatenate
     * @return a new list containing all elements from all iterables
     * @see #concat(Collection, IntFunction)
     * @see #merge(Collection, BiFunction)
     */
    public static <T> List<T> concat(final Collection<? extends Iterable<? extends T>> c) {
        return concat(c, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from all iterables in the collection in order.
     * Returns an empty collection if the input is {@code null} or empty.
     * The type of collection is determined by the supplier function.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<List<String>> lists = Arrays.asList(
     *     Arrays.asList("A", "B"),
     *     Arrays.asList("C", "D")
     * );
     * Set<String> result = N.concat(lists, HashSet::new);
     * // Returns a HashSet containing ["A", "B", "C", "D"]
     * }</pre>
     *
     * @param <T> the type of elements
     * @param <C> the type of collection to return
     * @param c the collection of iterables to concatenate
     * @param supplier the function to create the result collection
     * @return a new collection containing all elements from all iterables
     * @see #concat(Collection)
     * @see #merge(Collection, BiFunction, IntFunction)
     */
    public static <T, C extends Collection<T>> C concat(final Collection<? extends Iterable<? extends T>> c, final IntFunction<? extends C> supplier) {
        if (isEmpty(c)) {
            return supplier.apply(0);
        }

        long count = 0;

        for (final Iterable<? extends T> e : c) {
            count += getSizeOrDefault(e, 0);
        }

        final C result = supplier.apply(Numbers.toIntExact(count));

        for (final Iterable<? extends T> e : c) {
            if (e != null) {
                if (e instanceof Collection) {
                    result.addAll((Collection<T>) e);
                } else {
                    for (final T t : e) {
                        result.add(t);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Concatenates two iterators into a new ObjIterator.
     *
     * @param <T> the type of the elements in the iterators.
     * @param a the first iterator.
     * @param b the second iterator.
     * @return a new ObjIterator that contains the elements of <i>a</i> followed by the elements of <i>b</i>.
     * @see Iterators#concat(Iterator...)
     */
    public static <T> ObjIterator<T> concat(final Iterator<? extends T> a, final Iterator<? extends T> b) {
        return Iterators.concat(a, b);
    }

    /**
     * Concatenates multiple iterators into a new ObjIterator.
     *
     * @param <T> the type of the elements in the iterators.
     * @param a the array of iterators to be concatenated.
     * @return a new ObjIterator that contains the elements of each iterator in <i>a</i> in the same order.
     * @see Iterators#concat(Iterator...)
     */
    @SafeVarargs
    public static <T> ObjIterator<T> concat(final Iterator<? extends T>... a) {
        return Iterators.concat(a);
    }

    /**
     * Flattens a two-dimensional boolean array into a one-dimensional boolean array.
     * Converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[][] matrix = {
     *     {true, false},
     *     {true, true},
     *     {false, false}
     * };
     * boolean[] flattened = N.flatten(matrix);
     * // Returns {true, false, true, true, false, false}
     * }</pre>
     *
     * @param a the two-dimensional array to flatten
     * @return a one-dimensional array containing all elements from all {@code non-null} rows
     * @see #flatten(char[][])
     */
    public static boolean[] flatten(final boolean[][] a) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        int count = 0;

        for (final boolean[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final boolean[] ret = new boolean[count];
        int from = 0;

        for (final boolean[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional char array into a one-dimensional char array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[][] matrix = {
     *     {'a', 'b'},
     *     {'c', 'd'},
     *     {'e', 'f'}
     * };
     * char[] flattened = N.flatten(matrix);  // Returns {'a', 'b', 'c', 'd', 'e', 'f'}
     *
     * // Handles null rows gracefully
     * char[][] withNull = {{'a', 'b'}, null, {'c'}};
     * char[] result = N.flatten(withNull);  // Returns {'a', 'b', 'c'}
     *
     * // Empty or null input
     * char[] empty = N.flatten(null);  // Returns empty array
     * }</pre>
     *
     * @param a the two-dimensional char array to be flattened, may be {@code null} or empty
     * @return a one-dimensional char array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static char[] flatten(final char[][] a) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        int count = 0;

        for (final char[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final char[] ret = new char[count];
        int from = 0;

        for (final char[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional byte array into a one-dimensional byte array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[][] matrix = {
     *     {1, 2},
     *     {3, 4},
     *     {5, 6}
     * };
     * byte[] flattened = N.flatten(matrix);  // Returns {1, 2, 3, 4, 5, 6}
     *
     * // Handles null rows gracefully
     * byte[][] withNull = {{1, 2}, null, {3}};
     * byte[] result = N.flatten(withNull);  // Returns {1, 2, 3}
     * }</pre>
     *
     * @param a the two-dimensional byte array to be flattened, may be {@code null} or empty
     * @return a one-dimensional byte array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static byte[] flatten(final byte[][] a) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        int count = 0;

        for (final byte[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final byte[] ret = new byte[count];
        int from = 0;

        for (final byte[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional short array into a one-dimensional short array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[][] matrix = {{1, 2}, {3, 4}, {5, 6}};
     * short[] flattened = N.flatten(matrix);  // Returns {1, 2, 3, 4, 5, 6}
     * }</pre>
     *
     * @param a the two-dimensional short array to be flattened, may be {@code null} or empty
     * @return a one-dimensional short array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static short[] flatten(final short[][] a) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        int count = 0;

        for (final short[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final short[] ret = new short[count];
        int from = 0;

        for (final short[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional int array into a one-dimensional int array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[][] matrix = {{1, 2}, {3, 4}, {5, 6}};
     * int[] flattened = N.flatten(matrix);  // Returns {1, 2, 3, 4, 5, 6}
     * }</pre>
     *
     * @param a the two-dimensional int array to be flattened, may be {@code null} or empty
     * @return a one-dimensional int array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static int[] flatten(final int[][] a) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        int count = 0;

        for (final int[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final int[] ret = new int[count];
        int from = 0;

        for (final int[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional long array into a one-dimensional long array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[][] matrix = {{1L, 2L}, {3L, 4L}, {5L, 6L}};
     * long[] flattened = N.flatten(matrix);  // Returns {1L, 2L, 3L, 4L, 5L, 6L}
     * }</pre>
     *
     * @param a the two-dimensional long array to be flattened, may be {@code null} or empty
     * @return a one-dimensional long array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static long[] flatten(final long[][] a) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        int count = 0;

        for (final long[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final long[] ret = new long[count];
        int from = 0;

        for (final long[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional float array into a one-dimensional float array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[][] matrix = {{1.0f, 2.0f}, {3.0f, 4.0f}, {5.0f, 6.0f}};
     * float[] flattened = N.flatten(matrix);  // Returns {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}
     * }</pre>
     *
     * @param a the two-dimensional float array to be flattened, may be {@code null} or empty
     * @return a one-dimensional float array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static float[] flatten(final float[][] a) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        int count = 0;

        for (final float[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final float[] ret = new float[count];
        int from = 0;

        for (final float[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional double array into a one-dimensional double array.
     *
     * <p>This method converts a 2D array into a 1D array by concatenating all rows in order.
     * Null rows within the input array are skipped. The original array is not modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[][] matrix = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
     * double[] flattened = N.flatten(matrix);  // Returns {1.0, 2.0, 3.0, 4.0, 5.0, 6.0}
     * }</pre>
     *
     * @param a the two-dimensional double array to be flattened, may be {@code null} or empty
     * @return a one-dimensional double array containing all elements from all {@code non-null} rows in the input array.
     *         Returns an empty array if the input array is {@code null} or empty, or if all rows are {@code null}.
     * @see #flatten(Object[][])
     */
    public static double[] flatten(final double[][] a) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        int count = 0;

        for (final double[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final double[] ret = new double[count];
        int from = 0;

        for (final double[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens a two-dimensional array into an one-dimensional array.
     *
     * @param <T> the type of the elements in the array
     * @param a the two-dimensional array to be flattened, may be {@code null}
     * @return a one-dimensional array containing all elements in the input array. Returns {@code null} if the input array is {@code null}
     * @see #flatten(Object[][], Class)
     */
    @MayReturnNull
    public static <T> T[] flatten(final T[][] a) {
        if (a == null) {
            return null; // NOSONAR
        }

        return flatten(a, (Class<T>) a.getClass().getComponentType().getComponentType());
    }

    /**
     * Flattens a two-dimensional array into an one-dimensional array.
     *
     * @param <T> the type of the elements in the array
     * @param a the two-dimensional array to be flattened, may be {@code null} or empty
     * @param componentType the class object representing the component type of the new array, must not be {@code null}
     * @return a one-dimensional array containing all elements in the input array.
     *         Returns an empty array if the input array is {@code null}
     * @see #flatten(Object[][])
     */
    public static <T> T[] flatten(final T[][] a, final Class<T> componentType) {
        if (isEmpty(a)) {
            return newArray(componentType, 0);
        }

        int count = 0;

        for (final T[] element : a) {
            count += (element == null ? 0 : element.length);
        }

        final T[] ret = newArray(componentType, count);
        int from = 0;

        for (final T[] element : a) {
            if (notEmpty(element)) {
                copy(element, 0, ret, from, element.length);
                from += element.length;
            }
        }

        return ret;
    }

    /**
     * Flattens an {@code Iterable} of {@code Iterable<T>} into an one-dimensional List.
     *
     * @param <T> the type of the elements in the {@code Iterable}.
     * @param c the two-dimensional {@code Iterable} to be flattened.
     * @return a one-dimensional List containing all elements in the input {@code Iterable}.
     *         Returns an empty List if the input {@code Iterable} is {@code null} or empty.
     */
    public static <T> List<T> flatten(final Iterable<? extends Iterable<? extends T>> c) {
        return flatten(c, IntFunctions.ofList());
    }

    /**
     * Flattens an {@code Iterable} of {@code Iterable<T>} into an one-dimensional Collection.
     *
     * @param <T> the type of the elements in the {@code Iterable}.
     * @param <C> the type of the Collection to be returned.
     * @param c the two-dimensional {@code Iterable} to be flattened.
     * @param supplier the function that generates the Collection instance.
     * @return a one-dimensional Collection containing all elements in the input {@code Iterable}.
     *         Returns an empty Collection if the input {@code Iterable} is {@code null} or empty.
     */
    @SuppressWarnings("rawtypes")
    public static <T, C extends Collection<T>> C flatten(final Iterable<? extends Iterable<? extends T>> c, final IntFunction<? extends C> supplier) {
        if (isEmpty(c)) {
            return supplier.apply(0);
        }

        int count = 0;

        for (final Iterable<? extends T> e : c) {
            count += e instanceof Collection ? ((Collection) e).size() : DEFAULT_SIZE_FOR_NEW_COLLECTION; //NOSONAR
        }

        final C ret = supplier.apply(count);

        for (final Iterable<? extends T> e : c) {
            if (e == null) {
                //NOSONAR
            } else if (e instanceof Collection) {
                ret.addAll((Collection) e);
            } else {
                for (final T ee : e) {
                    ret.add(ee);
                }
            }
        }

        return ret;
    }

    /**
     * Flattens an {@code Iterator} of {@code Iterator<T>} into an one-dimensional Iterator.
     *
     * @param <T> the type of the elements in the Iterator.
     * @param iters the two-dimensional Iterator to be flattened.
     * @return a one-dimensional Iterator containing all elements in the input {@code Iterator}.
     *         Returns an empty Iterator if the input {@code Iterator} is {@code null}.
     */
    public static <T> ObjIterator<T> flatten(final Iterator<? extends Iterator<? extends T>> iters) {
        if (iters == null) {
            return ObjIterator.empty();
        }

        return new ObjIterator<>() {
            private Iterator<? extends T> cur = null;

            @Override
            public boolean hasNext() {
                if (cur == null || !cur.hasNext()) {
                    while (iters.hasNext()) {
                        cur = iters.next();

                        if (cur != null && cur.hasNext()) {
                            break;
                        }
                    }
                }

                return cur != null && cur.hasNext();
            }

            @Override
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                return cur.next();
            }
        };
    }

    /**
     * Flattens each element of the provided {@code Iterable} if it's an {@code Iterable} itself, otherwise just adds it to the result List.
     * This method is marked as Beta and may be subject to changes or removal in a future versions.
     *
     * @param c the {@code Iterable} to be processed. Each element is checked if it's an {@code Iterable} and flattened if so.
     * @return a List containing the flattened elements of the input {@code Iterable}. If the input {@code Iterable} is {@code null}, an empty List is returned.
     */
    @Beta
    public static List<?> flattenEachElement(final Iterable<?> c) { //NOSONAR
        return flattenEachElement(c, Suppliers.ofList());
    }

    /**
     * Flattens each element of the provided {@code Iterable} if it's an {@code Iterable} itself, otherwise just adds it to the result Collection.
     * This method is marked as Beta and may be subject to changes or removal in a future versions.
     *
     * @param <T> the type of the elements in the {@code Iterable}.
     * @param <C> the type of the Collection to be returned.
     * @param c the {@code Iterable} to be processed. Each element is checked if it's an {@code Iterable} and flattened if so.
     * @param supplier the function that generates the Collection instance.
     * @return a Collection containing the flattened elements of the input {@code Iterable}. If the input {@code Iterable} is {@code null}, an empty Collection is returned.
     */
    @Beta
    public static <T, C extends Collection<T>> C flattenEachElement(final Iterable<?> c, final Supplier<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.get();
        }

        final C result = supplier.get();

        flattenEachElement((Iterable<Object>) c, (Collection<Object>) result);

        return result;
    }

    private static void flattenEachElement(final Iterable<Object> c, final Collection<Object> output) {
        for (final Object next : c) {
            if (next instanceof Iterable) {
                flattenEachElement((Iterable<Object>) next, output);
            } else {
                output.add(next);
            }
        }
    }

    /**
     * Returns the elements that are present in both of the specified boolean arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     * Returns an empty array if either input array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, false, true, false};
     * boolean[] b = {true, true, false};
     * boolean[] result = N.intersection(a, b);
     * // Returns {true, false} (min occurrences from both)
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return a new array containing elements present in both arrays
     * @see BooleanList#intersection(BooleanList)
     * @see #intersection(char[], char[])
     */
    @SuppressWarnings("deprecation")
    public static boolean[] intersection(final boolean[] a, final boolean[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return BooleanList.of(a).intersection(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified char arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'b', 'c'};
     * char[] b = {'a', 'b', 'b', 'b', 'd'};
     * char[] result = intersection(a, b); // result will be {'a', 'b', 'b'}
     *
     * char[] c = {'x', 'y'};
     * char[] d = {'z', 'w'};
     * char[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first char array
     * @param b the second char array
     * @return a new char array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see CharList#intersection(CharList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static char[] intersection(final char[] a, final char[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_CHAR_ARRAY;
        }

        return CharList.of(a).intersection(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified byte arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 2, 3, 4};
     * byte[] b = {1, 2, 2, 2, 5, 6};
     * byte[] result = intersection(a, b); // result will be {1, 2, 2}
     *
     * byte[] c = {1, 2, 3};
     * byte[] d = {4, 5, 6};
     * byte[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first byte array
     * @param b the second byte array
     * @return a new byte array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see ByteList#intersection(ByteList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static byte[] intersection(final byte[] a, final byte[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_BYTE_ARRAY;
        }

        return ByteList.of(a).intersection(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified short arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 2, 3, 4};
     * short[] b = {1, 2, 2, 2, 5, 6};
     * short[] result = intersection(a, b); // result will be {1, 2, 2}
     *
     * short[] c = {1, 2, 3};
     * short[] d = {4, 5, 6};
     * short[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first short array
     * @param b the second short array
     * @return a new short array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see ShortList#intersection(ShortList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static short[] intersection(final short[] a, final short[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_SHORT_ARRAY;
        }

        return ShortList.of(a).intersection(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified int arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 2, 3, 4};
     * int[] b = {1, 2, 2, 2, 5, 6};
     * int[] result = intersection(a, b); // result will be {1, 2, 2}
     * 
     * int[] c = {1, 2, 3};
     * int[] d = {4, 5, 6};
     * int[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first int array
     * @param b the second int array
     * @return a new int array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see IntList#intersection(IntList)
     */
    @SuppressWarnings("deprecation")
    public static int[] intersection(final int[] a, final int[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_INT_ARRAY;
        }

        return IntList.of(a).intersection(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified long arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1, 2, 2, 3, 4};
     * long[] b = {1, 2, 2, 2, 5, 6};
     * long[] result = intersection(a, b); // result will be {1, 2, 2}
     *
     * long[] c = {1, 2, 3};
     * long[] d = {4, 5, 6};
     * long[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first long array
     * @param b the second long array
     * @return a new long array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see LongList#intersection(LongList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static long[] intersection(final long[] a, final long[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_LONG_ARRAY;
        }

        return LongList.of(a).intersection(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified float arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 2.0f, 3.0f, 4.0f};
     * float[] b = {1.0f, 2.0f, 2.0f, 2.0f, 5.0f, 6.0f};
     * float[] result = intersection(a, b); // result will be {1.0f, 2.0f, 2.0f}
     *
     * float[] c = {1.0f, 2.0f, 3.0f};
     * float[] d = {4.0f, 5.0f, 6.0f};
     * float[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first float array
     * @param b the second float array
     * @return a new float array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see FloatList#intersection(FloatList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static float[] intersection(final float[] a, final float[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return FloatList.of(a).intersection(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified double arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 2.0, 3.0, 4.0};
     * double[] b = {1.0, 2.0, 2.0, 2.0, 5.0, 6.0};
     * double[] result = intersection(a, b); // result will be {1.0, 2.0, 2.0}
     *
     * double[] c = {1.0, 2.0, 3.0};
     * double[] d = {4.0, 5.0, 6.0};
     * double[] result2 = intersection(c, d); // result will be {} (empty array)
     * }</pre>
     *
     * @param a the first double array
     * @param b the second double array
     * @return a new double array containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty array if either input array is {@code null} or empty.
     * @see DoubleList#intersection(DoubleList)
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static double[] intersection(final double[] a, final double[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return DoubleList.of(a).intersection(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements that are present in both of the specified arrays.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"A", "B", "B", "C", "D"};
     * String[] b = {"A", "B", "B", "B", "E", "F"};
     * List<String> result = intersection(a, b); // result will be ["A", "B", "B"]
     *
     * Integer[] c = {1, 2, 3};
     * Integer[] d = {4, 5, 6};
     * List<Integer> result2 = intersection(c, d); // result will be [] (empty list)
     * }</pre>
     *
     * @param <T> the type of the elements in the first array
     * @param a the first array
     * @param b the second array
     * @return a new list containing the elements present in both arrays,
     *         considering the minimum number of occurrences in either array.
     *         Returns an empty list if either input array is {@code null} or empty.
     * @see #commonSet(Collection, Collection)
     * @see #intersection(int[], int[])
     */
    public static <T> List<T> intersection(final T[] a, final Object[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final Multiset<?> bOccurrences = Multiset.of(b);
        final List<T> result = new ArrayList<>(min(9, a.length, b.length));

        for (final T e : a) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements that are present in both of the specified collections.
     * For elements that appear multiple times, the intersection contains the lesser number of occurrences.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B", "B", "C", "D");
     * List<String> b = Arrays.asList("A", "B", "B", "B", "E", "F");
     * List<String> result = intersection(a, b); // result will be ["A", "B", "B"]
     *
     * List<Integer> c = Arrays.asList(1, 2, 3);
     * List<Integer> d = Arrays.asList(4, 5, 6);
     * List<Integer> result2 = intersection(c, d); // result will be [] (empty list)
     * }</pre>
     *
     * @param <T> the type of elements in the first collection
     * @param a the first collection
     * @param b the second collection
     * @return a new list containing the elements present in both collections,
     *         considering the minimum number of occurrences in either collection.
     *         Returns an empty list if either input collection is {@code null} or empty.
     * @see #retainAll(Collection, Collection)
     * @see #commonSet(Collection, Collection)
     * @see #intersection(Object[], Object[])
     * @see #intersection(int[], int[])
     */
    public static <T> List<T> intersection(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final Multiset<Object> bOccurrences = Multiset.create(b);

        final List<T> result = new ArrayList<>(min(9, a.size(), b.size()));

        for (final T e : a) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements that are present in all of the specified collections.
     * For elements that appear multiple times, the intersection contains the minimum number of occurrences across all collections.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B", "B", "C");
     * List<String> b = Arrays.asList("A", "B", "B", "B", "D");
     * List<String> c = Arrays.asList("A", "B", "E");
     * List<List<String>> collections = Arrays.asList(a, b, c);
     * List<String> result = intersection(collections); // result will be ["A", "B"]
     *
     * List<Integer> x = Arrays.asList(1, 2, 2, 3);
     * List<Integer> y = Arrays.asList(2, 2, 4);
     * List<Integer> z = Arrays.asList(1, 2, 5);
     * List<List<Integer>> numbers = Arrays.asList(x, y, z);
     * List<Integer> result2 = intersection(numbers); // result will be [2]
     * }</pre>
     *
     * @param <T> the type of elements in the collections
     * @param c the collection of collections to find the intersection of
     * @return a new list containing the elements present in all collections in c,
     *         considering the minimum number of occurrences across all collections.
     *         Returns an empty list if c is {@code null}, empty, or any collection in c is empty.
     *         If c contains only one collection, returns a list with all elements from that collection.
     * @see #intersection(Collection, Collection)
     * @see #intersection(Object[], Object[])
     * @see #commonSet(Collection, Collection)
     * @see #retainAll(Collection, Collection)
     * @see #intersection(int[], int[])
     */
    public static <T> List<T> intersection(final Collection<? extends Collection<? extends T>> c) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        } else if (c.size() == 1) {
            return newArrayList(c.iterator().next());
        }

        for (final Collection<? extends T> e : c) {
            if (isEmpty(e)) {
                return new ArrayList<>();
            }
        }

        final Iterator<? extends Collection<? extends T>> iter = c.iterator();
        List<T> result = intersection(iter.next(), iter.next());

        while (iter.hasNext()) {
            result = intersection(result, iter.next());

            if (result.size() == 0) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns the elements in the first boolean array that are not present in the second boolean array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, true, false, true};
     * boolean[] b = {true, false};
     * boolean[] result = difference(a, b); // result will be {true, true}
     * // Only one 'true' and one 'false' are removed from a
     *
     * boolean[] c = {true, false, false};
     * boolean[] d = {false, false, false};
     * boolean[] result2 = difference(c, d); // result will be {true}
     * // All occurrences of 'false' are removed from c
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(boolean[], boolean[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first boolean array, elements from this array will be in the result if they don't appear in b
     * @param b the second boolean array, elements from this array will be removed from a
     * @return a new boolean array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(boolean[], boolean[])
     * @see BooleanList#difference(BooleanList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(boolean[], boolean[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static boolean[] difference(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return BooleanList.of(a).difference(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first char array that are not present in the second char array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'b', 'c', 'd'};
     * char[] b = {'a', 'b', 'e'};
     * char[] result = difference(a, b); // result will be {'b', 'c', 'd'}
     * // Only one 'a' and one 'b' are removed from a
     *
     * char[] c = {'a', 'b', 'b'};
     * char[] d = {'b', 'b', 'b'};
     * char[] result2 = difference(c, d); // result will be {'a'}
     * // All occurrences of 'b' are removed from c
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(char[], char[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first char array, elements from this array will be in the result if they don't appear in b
     * @param b the second char array, elements from this array will be removed from a
     * @return a new char array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(char[], char[])
     * @see CharList#difference(CharList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(char[], char[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static char[] difference(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return CharList.of(a).difference(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first byte array that are not present in the second byte array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {1, 2, 2, 3, 4};
     * byte[] b = {2, 5};
     * byte[] result = difference(a, b); // result will be {1, 2, 3, 4}
     * // Only one '2' is removed from a because b contains only one '2'
     *
     * byte[] c = {1, 2, 2};
     * byte[] d = {2, 2, 2};
     * byte[] result2 = difference(c, d); // result will be {1}
     * // All occurrences of '2' are removed from c because d contains at least as many
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(byte[], byte[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first byte array, elements from this array will be in the result if they don't appear in b
     * @param b the second byte array, elements from this array will be removed from a
     * @return a new byte array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(byte[], byte[])
     * @see ByteList#difference(ByteList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(byte[], byte[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static byte[] difference(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ByteList.of(a).difference(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first short array that are not present in the second short array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 2, 3, 4};
     * short[] b = {2, 5};
     * short[] result = difference(a, b); // result will be {1, 2, 3, 4}
     * // Only one '2' is removed from a because b contains only one '2'
     *
     * short[] c = {1, 2, 2};
     * short[] d = {2, 2, 2};
     * short[] result2 = difference(c, d); // result will be {1}
     * // All occurrences of '2' are removed from c because d contains at least as many
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(short[], short[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first short array, elements from this array will be in the result if they don't appear in b
     * @param b the second short array, elements from this array will be removed from a
     * @return a new short array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(short[], short[])
     * @see ShortList#difference(ShortList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(short[], short[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static short[] difference(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ShortList.of(a).difference(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the specified int array <i>a</i> but not present in the int array <i>b</i>,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {1, 2, 2, 3, 4};
     * int[] b = {2, 5};
     * int[] result = difference(a, b); // result will be {1, 2, 3, 4}
     * // Only one '2' is removed from a because b contains only one '2'
     *
     * int[] c = {1, 2, 2};
     * int[] d = {2, 2, 2};
     * int[] result2 = difference(c, d); // result will be {1}
     * // All occurrences of '2' are removed from c because d contains at least as many
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(int[], int[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first int array, elements from this array will be in the result if they don't appear in b
     * @param b the second int array, elements from this array will be removed from a
     * @return a new int array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(int[], int[])
     * @see IntList#difference(IntList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static int[] difference(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return IntList.of(a).difference(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first long array that are not present in the second long array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1, 2, 2, 3, 4};
     * long[] b = {2, 5};
     * long[] result = difference(a, b); // result will be {1, 2, 3, 4}
     * // Only one '2' is removed from a because b contains only one '2'
     *
     * long[] c = {1, 2, 2};
     * long[] d = {2, 2, 2};
     * long[] result2 = difference(c, d); // result will be {1}
     * // All occurrences of '2' are removed from c because d contains at least as many
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(long[], long[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first long array, elements from this array will be in the result if they don't appear in b
     * @param b the second long array, elements from this array will be removed from a
     * @return a new long array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(long[], long[])
     * @see LongList#difference(LongList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(long[], long[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static long[] difference(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return LongList.of(a).difference(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first float array that are not present in the second float array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 2.0f, 3.0f, 4.0f};
     * float[] b = {2.0f, 5.0f};
     * float[] result = difference(a, b); // result will be {1.0f, 2.0f, 3.0f, 4.0f}
     * // Only one '2.0f' is removed from a because b contains only one '2.0f'
     *
     * float[] c = {1.0f, 2.0f, 2.0f};
     * float[] d = {2.0f, 2.0f, 2.0f};
     * float[] result2 = difference(c, d); // result will be {1.0f}
     * // All occurrences of '2.0f' are removed from c because d contains at least as many
     * }</pre>
     *
     * <p>Unlike {@link #removeAll(float[], float[])} which removes all occurrences of elements found in the second array,
     * this method considers the count of occurrences, removing only as many as found in the second array.
     *
     * @param a the first float array, elements from this array will be in the result if they don't appear in b
     * @param b the second float array, elements from this array will be removed from a
     * @return a new float array containing the elements that are present in <i>a</i> but not in <i>b</i>,
     *         considering the number of occurrences.
     *         Returns an empty array if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #removeAll(float[], float[])
     * @see FloatList#difference(FloatList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(float[], float[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static float[] difference(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return FloatList.of(a).difference(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first double array that are not present in the second double array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 2.0, 3.0, 4.0};
     * double[] b = {2.0, 5.0};
     * double[] result = N.difference(a, b);  // Returns {1.0, 2.0, 3.0, 4.0}
     * }</pre>
     *
     * <p>Note: Unlike {@link #removeAll(double[], double[])}, this method considers occurrence counts, removing only as many as found in the second array.
     *
     * @param a the first double array
     * @param b the second double array
     * @return elements in <i>a</i> not in <i>b</i> (considering occurrences; empty if <i>a</i> is {@code null}/empty; clone of <i>a</i> if <i>b</i> is {@code null}/empty)
     * @see #removeAll(double[], double[])
     * @see DoubleList#difference(DoubleList)
     * @see #difference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(double[], double[])
     * @see #difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static double[] difference(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return DoubleList.of(a).difference(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements in the first array that are not present in the second array,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"A", "B", "B", "C", "D"};
     * String[] b = {"A", "B", "E"};
     * List<String> result = N.difference(a, b);  // Returns ["B", "C", "D"]
     * }</pre>
     *
     * <p>Note: Unlike {@link #removeAll(Object[], Object[])}, this method considers occurrence counts, removing only as many as found in the second array.
     *
     * @param <T> the type of the elements in the first array
     * @param a the first array
     * @param b the second array
     * @return elements in <i>a</i> not in <i>b</i> (considering occurrences; empty list if <i>a</i> is {@code null}/empty; list of <i>a</i> if <i>b</i> is {@code null}/empty)
     * @see #removeAll(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #symmetricDifference(Object[], Object[])
     * @see #difference(int[], int[])
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #removeAll(Collection, Iterable)
     * @see Iterables#difference(Set, Set)
     */
    public static <T> List<T> difference(final T[] a, final Object[] b) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final Multiset<?> bOccurrences = Multiset.of(b);
        final List<T> result = new ArrayList<>(min(a.length, max(9, a.length - b.length)));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements in the first collection that are not present in the second collection,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B", "B", "C", "D");
     * List<String> b = Arrays.asList("A", "B", "E");
     * List<String> result = N.difference(a, b);  // Returns ["B", "C", "D"]
     * }</pre>
     *
     * <p>Note: Unlike {@link Collection#removeAll(Collection)}, this method considers occurrence counts, removing only as many as found in the second collection.
     *
     * @param <T> the type of elements in the first collection
     * @param a the first collection
     * @param b the second collection
     * @return elements in <i>a</i> not in <i>b</i> (considering occurrences; empty list if <i>a</i> is {@code null}/empty; list of <i>a</i> if <i>b</i> is {@code null}/empty)
     * @see #difference(Object[], Object[])
     * @see #symmetricDifference(Collection, Collection)
     * @see #excludeAll(Collection, Collection)
     * @see #excludeAllToSet(Collection, Collection)
     * @see #intersection(Collection, Collection)
     * @see #difference(int[], int[])
     */
    public static <T> List<T> difference(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        } else if (isEmpty(b)) {
            return new ArrayList<>(a);
        }

        final Multiset<Object> bOccurrences = Multiset.create(b);

        final List<T> result = new ArrayList<>(min(a.size(), max(9, a.size() - b.size())));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns the elements that are present in either the first or second boolean array but not in both,
     * considering the number of occurrences of each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] a = {true, true, false};
     * boolean[] b = {true, false, false};
     * boolean[] result = symmetricDifference(a, b); // result will be {true, false}
     * // One 'true' remains because 'a' has one more occurrence than 'b'
     * // One 'false' remains because 'b' has one more occurrence than 'a'
     *
     * boolean[] c = {true, false};
     * boolean[] d = {true, true, false};
     * boolean[] result2 = symmetricDifference(c, d); // result will be {true}
     * // One 'true' appears in the result because 'd' has one more occurrence than 'c'
     * }</pre>
     *
     * <p>This method effectively combines the differences between both arrays in both directions,
     * returning elements with different numbers of occurrences in each array.
     *
     * @param a the first boolean array
     * @param b the second boolean array
     * @return a new boolean array containing the elements that are present in either <i>a</i> or <i>b</i> but not in both,
     *         considering the number of occurrences.
     *         Returns an empty array if both <i>a</i> and <i>b</i> are {@code null} or empty.
     *         Returns a clone of <i>b</i> if <i>a</i> is {@code null} or empty.
     *         Returns a clone of <i>a</i> if <i>b</i> is {@code null} or empty.
     * @see #difference(boolean[], boolean[])
     * @see #intersection(boolean[], boolean[])
     * @see #symmetricDifference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static boolean[] symmetricDifference(final boolean[] a, final boolean[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BOOLEAN_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return BooleanList.of(a).symmetricDifference(BooleanList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] a = {'a', 'b', 'b', 'c'};
     * char[] b = {'b', 'd', 'a'};
     * char[] result = N.symmetricDifference(a, b);
     * // Returns {'b', 'c', 'd'}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(char[], char[])
     * @see #intersection(char[], char[])
     */
    @SuppressWarnings("deprecation")
    public static char[] symmetricDifference(final char[] a, final char[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_CHAR_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return CharList.of(a).symmetricDifference(CharList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] a = {0, 1, 2, 2, 3};
     * byte[] b = {2, 5, 1};
     * byte[] result = N.symmetricDifference(a, b);
     * // Returns [0, 2, 3, 5]
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(byte[], byte[])
     * @see #intersection(byte[], byte[])
     */
    @SuppressWarnings("deprecation")
    public static byte[] symmetricDifference(final byte[] a, final byte[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_BYTE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ByteList.of(a).symmetricDifference(ByteList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] a = {1, 2, 2, 3, 4};
     * short[] b = {2, 5, 1};
     * short[] result = N.symmetricDifference(a, b);
     * // Returns {2, 3, 4, 5}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(short[], short[])
     * @see #intersection(short[], short[])
     */
    @SuppressWarnings("deprecation")
    public static short[] symmetricDifference(final short[] a, final short[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_SHORT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return ShortList.of(a).symmetricDifference(ShortList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] a = {0, 1, 2, 2, 3};
     * int[] b = {2, 5, 1};
     * int[] result = N.symmetricDifference(a, b);
     * // Returns [0, 2, 3, 5]
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(int[], int[])
     * @see #intersection(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static int[] symmetricDifference(final int[] a, final int[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_INT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return IntList.of(a).symmetricDifference(IntList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] a = {1, 2, 2, 3, 4};
     * long[] b = {2, 5, 1};
     * long[] result = N.symmetricDifference(a, b);
     * // Returns {2, 3, 4, 5}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(long[], long[])
     * @see #intersection(long[], long[])
     */
    @SuppressWarnings("deprecation")
    public static long[] symmetricDifference(final long[] a, final long[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_LONG_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return LongList.of(a).symmetricDifference(LongList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] a = {1.0f, 2.0f, 2.0f, 3.0f, 4.0f};
     * float[] b = {2.0f, 5.0f, 1.0f};
     * float[] result = N.symmetricDifference(a, b);
     * // Returns {2.0f, 3.0f, 4.0f, 5.0f}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(float[], float[])
     * @see #intersection(float[], float[])
     */
    @SuppressWarnings("deprecation")
    public static float[] symmetricDifference(final float[] a, final float[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_FLOAT_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return FloatList.of(a).symmetricDifference(FloatList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty array if both arrays are {@code null} or empty.
     * Returns a clone of the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] a = {1.0, 2.0, 2.0, 3.0, 4.0};
     * double[] b = {2.0, 5.0, 1.0};
     * double[] result = N.symmetricDifference(a, b);
     * // Returns {2.0, 3.0, 4.0, 5.0}
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #difference(double[], double[])
     * @see #intersection(double[], double[])
     */
    @SuppressWarnings("deprecation")
    public static double[] symmetricDifference(final double[] a, final double[] b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? EMPTY_DOUBLE_ARRAY : b.clone();
        } else if (isEmpty(b)) {
            return a.clone();
        }

        return DoubleList.of(a).symmetricDifference(DoubleList.of(b)).trimToSize().array();
    }

    /**
     * Returns the elements present in either array but not in both, considering occurrence counts.
     * Returns an empty list if both arrays are {@code null} or empty.
     * Returns a list of all elements from the non-empty array if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"A", "B", "B", "C", "D"};
     * String[] b = {"B", "E", "A"};
     * List<String> result = N.symmetricDifference(a, b);
     * // Returns ["B", "C", "D", "E"]
     * }</pre>
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array
     * @param b the second array
     * @return elements present in either array but not in both
     * @see #symmetricDifference(Collection, Collection)
     * @see #difference(Object[], Object[])
     * @see #intersection(Object[], Object[])
     */
    public static <T> List<T> symmetricDifference(final T[] a, final T[] b) {
        if (isEmpty(a)) {
            return asList(b);
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final Multiset<T> bOccurrences = Multiset.of(b);

        final List<T> result = new ArrayList<>(max(9, Math.abs(a.length - b.length)));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        for (final T e : b) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }

            if (bOccurrences.isEmpty()) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns the elements present in either collection but not in both, considering occurrence counts.
     * Returns an empty list if both collections are {@code null} or empty.
     * Returns a list of all elements from the non-empty collection if the other is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> a = Arrays.asList("A", "B", "B", "C", "D");
     * List<String> b = Arrays.asList("B", "E", "A");
     * List<String> result = N.symmetricDifference(a, b);
     * // Returns ["B", "C", "D", "E"]
     * }</pre>
     *
     * @param <T> the type of elements in the collections
     * @param a the first collection
     * @param b the second collection
     * @return elements present in either collection but not in both
     * @see #symmetricDifference(Object[], Object[])
     * @see #difference(Collection, Collection)
     * @see #intersection(Collection, Collection)
     */
    public static <T> List<T> symmetricDifference(final Collection<? extends T> a, final Collection<? extends T> b) {
        if (isEmpty(a)) {
            return isEmpty(b) ? new ArrayList<>() : new ArrayList<>(b);
        } else if (isEmpty(b)) {
            return isEmpty(a) ? new ArrayList<>() : new ArrayList<>(a);
        }

        final Multiset<T> bOccurrences = Multiset.create(b);
        final List<T> result = new ArrayList<>(max(9, Math.abs(a.size() - b.size())));

        for (final T e : a) {
            if (!bOccurrences.remove(e)) {
                result.add(e);
            }
        }

        for (final T e : b) {
            if (bOccurrences.remove(e)) {
                result.add(e);
            }

            if (bOccurrences.isEmpty()) {
                break;
            }
        }

        return result;
    }

    //    /**

    /**
     * Returns a set containing the common elements between the specified collections <i>a</i> and <i>b</i>.
     *
     * @param <T> the type of the elements in the collection <i>a</i>.
     * @param a the first collection.
     * @param b the second collection.
     * @return a set containing the elements that are present in both <i>a</i> and <i>b</i>.
     *         If either <i>a</i> or <i>b</i> is empty or {@code null}, an empty set is returned.
     * @see #intersection(Collection, Collection)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> Set<T> commonSet(final Collection<? extends T> a, final Collection<?> b) {
        if (isEmpty(a) || isEmpty(b)) {
            return newHashSet();
        }

        return commonSet(Array.asList(a, (Collection<? extends T>) b));
    }

    /**
     * Returns a set containing the common elements among all the collections within the specified collection of collections.
     *
     * @param <T> the type of the elements in the collections.
     * @param c the collection of collections to find the common elements of.
     * @return a set containing the elements that are present in all collections within <i>c</i>.
     *         If <i>c</i> is empty or {@code null}, an empty set is returned.
     *         If <i>c</i> contains only one collection, a set containing the elements of this collection is returned.
     * @see #intersection(Collection, Collection)
     * @see Collection#retainAll(Collection)
     * @see Iterables#intersection(Set, Set)
     */
    public static <T> Set<T> commonSet(final Collection<? extends Collection<? extends T>> c) {
        if (isEmpty(c)) {
            return newHashSet();
        } else if (c.size() == 1) {
            return newHashSet(c.iterator().next());
        }

        Collection<? extends T> smallest = null;

        for (final Collection<? extends T> e : c) {
            if (isEmpty(e)) {
                return newHashSet();
            }

            if (smallest == null || e.size() < smallest.size()) {
                smallest = e;
            }
        }

        final Map<T, MutableInt> map = new HashMap<>();

        //noinspection DataFlowIssue
        for (final T e : smallest) {
            map.put(e, new MutableInt(1));
        }

        int cnt = 1;
        MutableInt val = null;

        for (final Collection<? extends T> ec : c) {
            if (ec == smallest) { // NOSONAR
                continue;
            }

            for (final T e : ec) {
                val = map.get(e);

                if ((val == null) || (val.value() < cnt)) {
                    // do nothing.
                } else if (val.value() == cnt) {
                    val.increment();
                }
            }

            cnt++;
        }

        final Collection<? extends T> firstSet = N.firstOrNullIfEmpty(c);
        final Set<T> result = firstSet instanceof List || firstSet instanceof LinkedHashSet ? newLinkedHashSet(map.size()) : newHashSet(map.size());

        for (final Map.Entry<T, MutableInt> entry : map.entrySet()) {
            if (entry.getValue().value() == cnt) {
                result.add(entry.getKey());
            }
        }

        return result;
    }

    /**
     * Returns a new {@code List} containing all the elements from the specified collection except all occurrences of specified <i>objToExclude</i>.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection from which to exclude the specified object.
     * @param objToExclude the object to exclude from the collection.
     * @return a new {@code List} with the specified object excluded.
     *         If the collection <i>c</i> is empty or {@code null}, an empty list is returned.
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Iterable)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> exclude(final Collection<? extends T> c, final Object objToExclude) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        }

        final List<T> result = new ArrayList<>(c.size() - 1);

        for (final T e : c) {
            if (!equals(e, objToExclude)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new {@code Set} containing all the elements from the specified collection except all occurrences of specified <i>objToExclude</i>.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection from which to exclude the specified object.
     * @param objToExclude the object to exclude from the collection.
     * @return a new {@code Set} with the specified object excluded.
     *         If the collection <i>c</i> is empty or {@code null}, an empty set is returned.
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Iterable)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> Set<T> excludeToSet(final Collection<? extends T> c, final Object objToExclude) {
        if (isEmpty(c)) {
            return new HashSet<>();
        }

        final Set<T> result = c instanceof List || c instanceof LinkedHashSet ? newLinkedHashSet(c) : newHashSet(c);

        //noinspection SuspiciousMethodCalls
        result.remove(objToExclude);

        return result;
    }

    /**
     * Returns a new {@code List} containing all the elements from the specified collection except all occurrences of elements in the specified <i>objsToExclude</i>.
     * That's to say no more value from <i>objsToExclude</i> will present in the returned {@code Set}.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection from which to exclude the specified objects.
     * @param objsToExclude the objects to exclude from the collection.
     * @return a new {@code List} with the specified objects excluded.
     *         If the collection <i>c</i> is empty or {@code null}, an empty list is returned.
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Iterable)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> List<T> excludeAll(final Collection<? extends T> c, final Collection<?> objsToExclude) {
        if (isEmpty(c)) {
            return new ArrayList<>();
        } else if (isEmpty(objsToExclude)) {
            return new ArrayList<>(c);
        } else if (objsToExclude.size() == 1) {
            return exclude(c, firstOrNullIfEmpty(objsToExclude));
        }

        final Set<Object> set = objsToExclude instanceof Set ? ((Set<Object>) objsToExclude) : new HashSet<>(objsToExclude);
        final List<T> result = new ArrayList<>(max(0, c.size() - set.size()));

        for (final T e : c) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new {@code Set} containing all the elements from the specified collection except all occurrences of elements in the specified <i>objsToExclude</i>.
     * That's to say no more value from <i>objsToExclude</i> will present in the returned {@code Set}.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection from which to exclude the specified objects.
     * @param objsToExclude the objects to exclude from the collection.
     * @return a new {@code Set} with the specified objects excluded.
     *         If the collection <i>c</i> is empty or {@code null}, an empty set is returned.
     * @see #difference(Collection, Collection)
     * @see #removeAll(Collection, Iterable)
     * @see Difference#of(Collection, Collection)
     */
    public static <T> Set<T> excludeAllToSet(final Collection<? extends T> c, final Collection<?> objsToExclude) {
        if (isEmpty(c)) {
            return new HashSet<>();
        } else if (isEmpty(objsToExclude)) {
            return new HashSet<>(c);
        } else if (objsToExclude.size() == 1) {
            return excludeToSet(c, firstOrNullIfEmpty(objsToExclude));
        }

        final Set<Object> set = objsToExclude instanceof Set ? ((Set<Object>) objsToExclude) : new HashSet<>(objsToExclude);
        final Set<T> result = c instanceof List || c instanceof LinkedHashSet ? newLinkedHashSet(max(0, c.size() - set.size()))
                : newHashSet(max(0, c.size() - set.size()));

        for (final T e : c) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns {@code true} if <i>subColl</i> is a sub-collection of <i>coll</i>,
     * that is, if the cardinality of <i>e</i> in <i>subColl</i> is less than or
     * equal to the cardinality of <i>e</i> in <i>coll</i>, for each element <i>e</i>
     * in <i>subColl</i>.
     *
     * @param subColl the first (sub?) collection, must not be null
     * @param coll the second (super?) collection, must not be null
     * @return {@code true} if <i>subColl</i> is a sub-collection of <i>coll</i>
     * @throws IllegalArgumentException if {@code subColl} or {@code coll} is {@code null}
     * @see #isProperSubCollection
     * @see Collection#containsAll
     */
    public static boolean isSubCollection(@NotNull final Collection<?> subColl, @NotNull final Collection<?> coll) throws IllegalArgumentException {
        checkArgNotNull(subColl, cs.subColl);
        checkArgNotNull(coll, cs.coll);

        if (isEmpty(subColl)) {
            return true;
        } else if (isEmpty(coll)) {
            return false;
        }

        if (subColl.size() > coll.size()) {
            return false;
        }

        final Multiset<?> multisetA = Multiset.create(subColl);
        final Multiset<?> multisetB = Multiset.create(coll);

        for (final Object e : multisetA.elementSet()) {
            if (multisetA.occurrencesOf(e) > multisetB.occurrencesOf(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if <i>subColl</i> is a <i>proper</i> sub-collection of <i>coll</i>,
     * that is, if the cardinality of <i>e</i> in <i>subColl</i> is less
     * than or equal to the cardinality of <i>e</i> in <i>coll</i>,
     * for each element <i>e</i> in <i>subColl</i>, and there is at least one
     * element <i>f</i> such that the cardinality of <i>f</i> in <i>coll</i>
     * is strictly greater than the cardinality of <i>f</i> in <i>subColl</i>.
     * <p>
     * The implementation assumes
     * </p>
     * <ul>
     *    <li>{@code subColl.size()} and {@code coll.size()} represent the
     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>
     *    <li>{@code subColl.size() < Integer.MAXVALUE}</li>
     * </ul>
     *
     * @param subColl the first (sub?) collection, must not be null
     * @param coll the second (super?) collection, must not be null
     * @return {@code true} if <i>subColl</i> is a <i>proper</i> sub-collection of <i>coll</i>
     * @throws IllegalArgumentException if {@code subColl} or {@code coll} is {@code null}
     * @see #isSubCollection
     * @see Collection#containsAll
     */
    public static boolean isProperSubCollection(@NotNull final Collection<?> subColl, final @NotNull Collection<?> coll) throws IllegalArgumentException {
        checkArgNotNull(subColl, cs.subColl);
        checkArgNotNull(coll, cs.coll);

        return subColl.size() < coll.size() && isSubCollection(subColl, coll);
    }

    /**
     * Checks whether two collections contain the same elements with the same frequencies,
     * regardless of their order. Two collections are considered to have the same elements if:
     * <ul>
     *   <li>They are the same reference (a == b)</li>
     *   <li>They are both empty or null</li>
     *   <li>They contain exactly the same elements with the same frequencies in any order</li>
     * </ul>
     * 
     * @param a the first collection to compare, may be {@code null}
     * @param b the second collection to compare, may be {@code null}
     * @return {@code true} if both collections contain the same elements with the same frequencies, {@code false} otherwise
     * @see #haveSameElements(Collection, Collection)
     * @see #haveSameElements(int[], int[])
     */
    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {
        return haveSameElements(a, b);
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, false};
     * int count = N.replaceIf(flags, b -> b, false);
     * // flags is now {false, false, false, false}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(boolean[], boolean, boolean)
     */
    public static int replaceIf(final boolean[] a, final BooleanPredicate predicate, final boolean newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'B', 'c', 'D'};
     * int count = N.replaceIf(letters, Character::isUpperCase, 'x');
     * // letters is now {'a', 'x', 'c', 'x'}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(char[], char, char)
     */
    public static int replaceIf(final char[] a, final CharPredicate predicate, final char newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 3, 4, 5};
     * int count = N.replaceIf(numbers, b -> b % 2 == 0, (byte) 0);
     * // numbers is now {1, 0, 3, 0, 5}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(byte[], byte, byte)
     */
    public static int replaceIf(final byte[] a, final BytePredicate predicate, final byte newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30, 40, 50};
     * int count = N.replaceIf(numbers, s -> s > 25, (short) 0);
     * // numbers is now {10, 20, 0, 0, 0}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(short[], short, short)
     */
    public static int replaceIf(final short[] a, final ShortPredicate predicate, final short newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5, 6};
     * int count = N.replaceIf(numbers, n -> n % 2 == 0, 0);
     * // numbers is now {1, 0, 3, 0, 5, 0}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(int[], int, int)
     */
    public static int replaceIf(final int[] a, final IntPredicate predicate, final int newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L};
     * int count = N.replaceIf(numbers, n -> n > 250L, 0L);
     * // numbers is now {100, 200, 0, 0}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(long[], long, long)
     */
    public static int replaceIf(final long[] a, final LongPredicate predicate, final long newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.5f, 3.5f, 4.5f};
     * int count = N.replaceIf(values, f -> f > 3.0f, 0.0f);
     * // values is now {1.5, 2.5, 0.0, 0.0}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(float[], float, float)
     */
    public static int replaceIf(final float[] a, final FloatPredicate predicate, final float newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] values = {1.0, 2.0, 3.0, 4.0, 5.0};
     * int count = N.replaceIf(values, d -> d < 3.0, 0.0);
     * // values is now {0.0, 0.0, 3.0, 4.0, 5.0}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(double[], double, double)
     */
    public static int replaceIf(final double[] a, final DoublePredicate predicate, final double newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry", "date"};
     * int count = N.replaceIf(words, s -> s.length() > 5, "X");
     * // words is now {"apple", "X", "X", "date"}, count is 2
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(Object[], Object, Object)
     */
    public static <T> int replaceIf(final T[] a, final Predicate<? super T> predicate, final T newValue) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = a.length; i < n; i++) {
            if (predicate.test(a[i])) {
                a[i] = newValue;
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the list that satisfy the predicate with the specified value.
     * Returns the number of replacements made.
     * Returns 0 if the list is {@code null} or empty.
     * The list is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "cherry"));
     * int count = N.replaceIf(words, s -> s.startsWith("b"), "REPLACED");
     * // words is now ["apple", "REPLACED", "cherry"], count is 1
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the list to modify
     * @param predicate the predicate to test each element
     * @param newValue the value to replace matching elements with
     * @return the number of elements that were replaced
     * @see #replaceAll(List, Object, Object)
     */
    public static <T> int replaceIf(final List<T> list, final Predicate<? super T> predicate, final T newValue) {
        if (isEmpty(list)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, n = list.size(); i < n; i++) {
            if (predicate.test(list.get(i))) {
                list.set(i, newValue);
                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, false};
     * int count = N.replaceAll(flags, false, true);
     * // flags is now {true, true, true, true}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(boolean[], BooleanUnaryOperator)
     * @see #replaceIf(boolean[], BooleanPredicate, boolean)
     */
    public static int replaceAll(final boolean[] a, final boolean oldVal, final boolean newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'a', 'c', 'a'};
     * int count = N.replaceAll(letters, 'a', 'x');
     * // letters is now {'x', 'b', 'x', 'c', 'x'}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(char[], CharUnaryOperator)
     * @see #replaceIf(char[], CharPredicate, char)
     */
    public static int replaceAll(final char[] a, final char oldVal, final char newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 1, 3, 1};
     * int count = N.replaceAll(data, (byte) 1, (byte) 9);
     * // data is now {9, 2, 9, 3, 9}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(byte[], ByteUnaryOperator)
     * @see #replaceIf(byte[], BytePredicate, byte)
     */
    public static int replaceAll(final byte[] a, final byte oldVal, final byte newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 10, 30, 10};
     * int count = N.replaceAll(numbers, (short) 10, (short) 99);
     * // numbers is now {99, 20, 99, 30, 99}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(short[], ShortUnaryOperator)
     * @see #replaceIf(short[], ShortPredicate, short)
     */
    public static int replaceAll(final short[] a, final short oldVal, final short newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 1, 3, 1};
     * int count = N.replaceAll(numbers, 1, 99);
     * // numbers is now {99, 2, 99, 3, 99}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(int[], IntUnaryOperator)
     * @see #replaceIf(int[], IntPredicate, int)
     */
    public static int replaceAll(final int[] a, final int oldVal, final int newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 100L, 300L, 100L};
     * int count = N.replaceAll(numbers, 100L, 999L);
     * // numbers is now {999L, 200L, 999L, 300L, 999L}, count is 3
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(long[], LongUnaryOperator)
     * @see #replaceIf(long[], LongPredicate, long)
     */
    public static int replaceAll(final long[] a, final long oldVal, final long newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (a[i] == oldVal) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.5f, 1.5f, 3.5f};
     * int count = N.replaceAll(values, 1.5f, 9.9f);
     * // values is now {9.9f, 2.5f, 9.9f, 3.5f}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(float[], FloatUnaryOperator)
     * @see #replaceIf(float[], FloatPredicate, float)
     */
    public static int replaceAll(final float[] a, final float oldVal, final float newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (Float.compare(a[i], oldVal) == 0) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] values = {1.5, 2.5, 1.5, 3.5};
     * int count = N.replaceAll(values, 1.5, 9.9);
     * // values is now {9.9, 2.5, 9.9, 3.5}, count is 2
     * }</pre>
     *
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(double[], DoubleUnaryOperator)
     * @see #replaceIf(double[], DoublePredicate, double)
     */
    public static int replaceAll(final double[] a, final double oldVal, final double newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        for (int i = 0, len = a.length; i < len; i++) {
            if (Double.compare(a[i], oldVal) == 0) {
                a[i] = newVal;

                result++;
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the array.
     * Returns the number of replacements made.
     * Returns 0 if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry"};
     * int count = N.replaceAll(words, "apple", "orange");
     * // words is now {"orange", "banana", "orange", "cherry"}, count is 2
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(Object[], UnaryOperator)
     * @see #replaceIf(Object[], Predicate, Object)
     */
    public static <T> int replaceAll(final T[] a, final Object oldVal, final T newVal) {
        if (isEmpty(a)) {
            return 0;
        }

        int result = 0;

        if (oldVal == null) {
            for (int i = 0, len = a.length; i < len; i++) {
                if (a[i] == null) {
                    a[i] = newVal;

                    result++;
                }
            }
        } else {
            for (int i = 0, len = a.length; i < len; i++) {
                if (equals(a[i], oldVal)) {
                    a[i] = newVal;

                    result++;
                }
            }
        }

        return result;
    }

    /**
     * Replaces all occurrences of the specified old value with the new value in the list.
     * Returns the number of replacements made.
     * Returns 0 if the list is {@code null} or empty.
     * The list is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "apple", "cherry"));
     * int count = N.replaceAll(words, "apple", "orange");
     * // words is now ["orange", "banana", "orange", "cherry"], count is 2
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the list to modify
     * @param oldVal the value to be replaced
     * @param newVal the value to replace with
     * @return the number of elements that were replaced
     * @see #replaceAll(List, UnaryOperator)
     * @see #replaceIf(List, Predicate, Object)
     */
    public static <T> int replaceAll(final List<T> list, final Object oldVal, final T newVal) {
        if (isEmpty(list)) {
            return 0;
        }

        int result = 0;

        final int size = list.size();

        if (size < REPLACE_ALL_THRESHOLD || list instanceof RandomAccess) {
            if (oldVal == null) {
                for (int i = 0; i < size; i++) {
                    if (list.get(i) == null) {
                        list.set(i, newVal);

                        result++;
                    }
                }
            } else {
                for (int i = 0; i < size; i++) {
                    if (oldVal.equals(list.get(i))) {
                        list.set(i, newVal);

                        result++;
                    }
                }
            }
        } else {
            final ListIterator<T> itr = list.listIterator();

            if (oldVal == null) {
                for (int i = 0; i < size; i++) {
                    if (itr.next() == null) {
                        itr.set(newVal);

                        result++;
                    }
                }
            } else {
                for (int i = 0; i < size; i++) {
                    if (oldVal.equals(itr.next())) {
                        itr.set(newVal);

                        result++;
                    }
                }
            }
        }

        return result;
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true};
     * N.replaceAll(flags, b -> !b);
     * // flags is now {false, true, false} (all values negated)
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(boolean[], boolean, boolean)
     * @see #setAll(boolean[], IntToBooleanFunction)
     */
    public static void replaceAll(final boolean[] a, final BooleanUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsBoolean(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'c'};
     * N.replaceAll(letters, c -> Character.toUpperCase(c));
     * // letters is now {'A', 'B', 'C'}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(char[], char, char)
     * @see #setAll(char[], IntToCharFunction)
     */
    public static void replaceAll(final char[] a, final CharUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsChar(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3};
     * N.replaceAll(data, b -> (byte) (b * 10));
     * // data is now {10, 20, 30}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(byte[], byte, byte)
     * @see #setAll(byte[], IntToByteFunction)
     */
    public static void replaceAll(final byte[] a, final ByteUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsByte(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30};
     * N.replaceAll(numbers, s -> (short) (s * 2));
     * // numbers is now {20, 40, 60}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(short[], short, short)
     * @see #setAll(short[], IntToShortFunction)
     */
    public static void replaceAll(final short[] a, final ShortUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsShort(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4};
     * N.replaceAll(numbers, n -> n * n);
     * // numbers is now {1, 4, 9, 16}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(int[], int, int)
     * @see #setAll(int[], IntUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void replaceAll(final int[] a, final IntUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsInt(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L};
     * N.replaceAll(numbers, n -> n / 10);
     * // numbers is now {10L, 20L, 30L}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(long[], long, long)
     * @see #setAll(long[], IntToLongFunction)
     * @see Arrays#setAll(long[], IntToLongFunction)
     * @see Arrays#parallelSetAll(long[], IntToLongFunction)
     */
    public static void replaceAll(final long[] a, final LongUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsLong(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.5f, 3.5f};
     * N.replaceAll(values, f -> f * 2);
     * // values is now {3.0f, 5.0f, 7.0f}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(float[], float, float)
     * @see #setAll(float[], IntToFloatFunction)
     */
    public static void replaceAll(final float[] a, final FloatUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsFloat(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] values = {1.5, 2.5, 3.5};
     * N.replaceAll(values, d -> d * 2);
     * // values is now {3.0, 5.0, 7.0}
     * }</pre>
     *
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(double[], double, double)
     * @see #setAll(double[], IntToDoubleFunction)
     * @see Arrays#setAll(double[], IntToDoubleFunction)
     * @see Arrays#parallelSetAll(double[], IntToDoubleFunction)
     */
    public static void replaceAll(final double[] a, final DoubleUnaryOperator operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.applyAsDouble(a[i]);
        }
    }

    /**
     * Replaces all elements in the array by applying the operator function to each element.
     * Returns without modification if the array is {@code null} or empty.
     * The array is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry"};
     * N.replaceAll(words, String::toUpperCase);
     * // words is now {"APPLE", "BANANA", "CHERRY"}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(Object[], Object, Object)
     * @see #setAll(Object[], IntFunction)
     * @see #setAll(Object[], Throwables.IntObjFunction)
     * @see Arrays#setAll(Object[], IntFunction)
     * @see Arrays#parallelSetAll(Object[], IntFunction)
     */
    public static <T> void replaceAll(final T[] a, final UnaryOperator<T> operator) {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.apply(a[i]);
        }
    }

    /**
     * Replaces all elements in the list by applying the operator function to each element.
     * Returns without modification if the list is {@code null} or empty.
     * The list is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "cherry"));
     * N.replaceAll(words, String::toUpperCase);
     * // words is now ["APPLE", "BANANA", "CHERRY"]
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param list the list to modify
     * @param operator the function to apply to each element
     * @see #replaceAll(List, Object, Object)
     * @see #setAll(List, IntFunction)
     * @see #setAll(List, Throwables.IntObjFunction)
     */
    public static <T> void replaceAll(final List<T> list, final UnaryOperator<T> operator) {
        if (isEmpty(list)) {
            return;
        }

        final int size = list.size();

        if (size < REPLACE_ALL_THRESHOLD || list instanceof RandomAccess) {
            for (int i = 0; i < size; i++) {
                list.set(i, operator.apply(list.get(i)));
            }
        } else {
            final ListIterator<T> itr = list.listIterator();

            for (int i = 0; i < size; i++) {
                itr.set(operator.apply(itr.next()));
            }
        }
    }

    /**
     * Replaces all elements in the given array using the specified {@code UnaryOperator}.
     * If the input array is empty or {@code null}, no replacements are made.
     *
     * @param <T> the type of elements in the array.
     * @param <E> the type of exception may thrown out.
     * @param a the array in which to replace values.
     * @param operator the UnaryOperator to apply to each element. The operator takes a value of type <i>T</i> and returns a value of type <i>T</i>.
     * @throws E the exception may be thrown out.
     * @see #replaceAll(Object[], UnaryOperator)
     * @see #setAll(Object[], IntFunction)
     * @see #setAll(Object[], Throwables.IntObjFunction)
     * @see Arrays#setAll(Object[], IntFunction)
     * @see Arrays#parallelSetAll(Object[], IntFunction)
     */
    @Beta
    public static <T, E extends Exception> void updateAll(final T[] a, final Throwables.UnaryOperator<T, E> operator) throws E {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, n = a.length; i < n; i++) {
            a[i] = operator.apply(a[i]);
        }
    }

    /**
     * Replaces all elements in the given list using the specified {@code UnaryOperator}.
     * If the input list is empty or {@code null}, no replacements are made.
     *
     * @param <T> the type of elements in the list.
     * @param <E> the type of exception may thrown out.
     * @param list the list in which to replace values.
     * @param operator the UnaryOperator to apply to each element. The operator takes a value of type <i>T</i> and returns a value of type <i>T</i>.
     * @throws E the exception may be thrown out.
     * @see #replaceAll(List, UnaryOperator)
     * @see #setAll(List, IntFunction)
     * @see #setAll(List, Throwables.IntObjFunction)
     */
    @Beta
    public static <T, E extends Exception> void updateAll(final List<T> list, final Throwables.UnaryOperator<T, E> operator) throws E {
        if (isEmpty(list)) {
            return;
        }

        final int size = list.size();

        if (size < REPLACE_ALL_THRESHOLD || list instanceof RandomAccess) {
            for (int i = 0; i < size; i++) {
                list.set(i, operator.apply(list.get(i)));
            }
        } else {
            final ListIterator<T> itr = list.listIterator();

            for (int i = 0; i < size; i++) {
                itr.set(operator.apply(itr.next()));
            }
        }
    }

    /**
     * A fake/unsupported method defined to remind user to use {@code replaceAll} when {@code update/updateAll/updateIf} is searched.
     *
     * @throws UnsupportedOperationException always thrown to indicate this method is not supported
     * @see #replaceAll(Object[], UnaryOperator)
     * @see #replaceAll(Object[], Object, Object)
     * @deprecated use {@code replaceAll}
     */
    @Deprecated
    public static void updateAllUsingReplaceAllInstead() throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Dummy method. Please use 'replaceAll'");
    }

    /**
     * A fake/unsupported method defined to remind user to use {@code replaceIf} when {@code update/updateAll/updateIf} is searched.
     *
     * @throws UnsupportedOperationException always thrown to indicate this method is not supported
     * @see #replaceIf(Object[], Predicate, Object)
     * @deprecated use {@code replaceIf}
     */
    @Deprecated
    public static void updateIfUsingReplaceIfInstead() throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Dummy method. Please use 'replaceIf'");
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(boolean[], BooleanUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void setAll(final boolean[] array, final IntToBooleanFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        for (int i = 0, len = array.length; i < len; i++) {
            array[i] = generator.applyAsBoolean(i);
        }
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(char[], CharUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void setAll(final char[] array, final IntToCharFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        for (int i = 0, len = array.length; i < len; i++) {
            array[i] = generator.applyAsChar(i);
        }
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(byte[], ByteUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void setAll(final byte[] array, final IntToByteFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        for (int i = 0, len = array.length; i < len; i++) {
            array[i] = generator.applyAsByte(i);
        }
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(short[], ShortUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void setAll(final short[] array, final IntToShortFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        for (int i = 0, len = array.length; i < len; i++) {
            array[i] = generator.applyAsShort(i);
        }
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(int[], IntUnaryOperator)
     * @see Arrays#setAll(int[], IntUnaryOperator)
     * @see Arrays#parallelSetAll(int[], IntUnaryOperator)
     */
    public static void setAll(final int[] array, final IntUnaryOperator generator) {
        if (isEmpty(array)) {
            return;
        }

        Arrays.setAll(array, generator);
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(long[], LongUnaryOperator)
     * @see Arrays#setAll(long[], IntToLongFunction)
     * @see Arrays#parallelSetAll(long[], IntToLongFunction)
     */
    public static void setAll(final long[] array, final IntToLongFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        Arrays.setAll(array, generator);
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(float[], FloatUnaryOperator)
     * @see Arrays#setAll(double[], IntToDoubleFunction)
     * @see Arrays#parallelSetAll(double[], IntToDoubleFunction)
     */
    public static void setAll(final float[] array, final IntToFloatFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        for (int i = 0, len = array.length; i < len; i++) {
            array[i] = generator.applyAsFloat(i);
        }
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(double[], DoubleUnaryOperator)
     * @see Arrays#setAll(double[], IntToDoubleFunction)
     * @see Arrays#parallelSetAll(double[], IntToDoubleFunction)
     */
    public static void setAll(final double[] array, final IntToDoubleFunction generator) {
        if (isEmpty(array)) {
            return;
        }

        Arrays.setAll(array, generator);
    }

    /**
     * Sets all elements in the given array using the provided generator function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param <T> the type of elements in the input array
     * @param array the array to be modified
     * @param generator the function used to generate new values for the array elements
     * @see #replaceAll(Object[], UnaryOperator)
     * @see #setAll(Object[], Throwables.IntObjFunction)
     * @see Arrays#setAll(Object[], IntFunction)
     * @see Arrays#parallelSetAll(Object[], IntFunction)
     */
    public static <T> void setAll(final T[] array, final IntFunction<? extends T> generator) {
        if (isEmpty(array)) {
            return;
        }

        Arrays.setAll(array, generator);
    }

    /**
     * Sets all elements in the given list using the provided generator function.
     * If the specified list is {@code null} or empty, does nothing.
     *
     * @param <T> the type of elements in the list
     * @param list the list to be modified
     * @param generator the function used to generate new values for the list elements
     * @see #replaceAll(List, UnaryOperator)
     * @see #setAll(List, Throwables.IntObjFunction)
     */
    public static <T> void setAll(final List<T> list, final IntFunction<? extends T> generator) {
        if (isEmpty(list)) {
            return;
        }

        final int size = list.size();

        if (size < REPLACE_ALL_THRESHOLD || list instanceof RandomAccess) {
            for (int i = 0; i < size; i++) {
                list.set(i, generator.apply(i));
            }
        } else {
            final ListIterator<T> iter = list.listIterator();
            final MutableInt idx = MutableInt.of(0);

            for (int i = 0; i < size; i++) {
                iter.next();
                iter.set(generator.apply(idx.getAndIncrement()));
            }
        }
    }

    /**
     * Sets all elements in the given array using the provided converter function.
     * If the specified array is {@code null} or empty, does nothing.
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the converter may throw
     * @param a the array to be modified
     * @param converter the function used to generate new values for the array elements with the index of the element as the first parameter and the original element as the second parameter
     * @throws E if the converter function throws an exception
     * @see #replaceAll(Object[], UnaryOperator)
     * @see #setAll(Object[], IntFunction)
     * @see Arrays#setAll(Object[], IntFunction)
     */
    @Beta
    public static <T, E extends Exception> void setAll(final T[] a, final Throwables.IntObjFunction<? super T, ? extends T, E> converter) throws E {
        if (isEmpty(a)) {
            return;
        }

        for (int i = 0, len = a.length; i < len; i++) {
            a[i] = converter.apply(i, a[i]);
        }
    }

    /**
     * Sets all elements in the given list using the provided converter function.
     * If the specified list is {@code null} or empty, does nothing.
     *
     * @param <T> the type of elements in the list
     * @param <E> the type of exception that the converter may throw
     * @param list the list to be modified
     * @param converter the function used to generate new values for the list elements with the index of the element as the first parameter and the original element as the second parameter
     * @throws E if the converter function throws an exception
     * @see #replaceAll(List, UnaryOperator)
     * @see #setAll(List, IntFunction)
     * @see Arrays#setAll(Object[], IntFunction)
     */
    @Beta
    public static <T, E extends Exception> void setAll(final List<T> list, final Throwables.IntObjFunction<? super T, ? extends T, E> converter) throws E {
        if (isEmpty(list)) {
            return;
        }

        final int size = list.size();

        if (size < REPLACE_ALL_THRESHOLD || list instanceof RandomAccess) {
            for (int i = 0; i < size; i++) {
                list.set(i, converter.apply(i, list.get(i)));
            }
        } else {
            final ListIterator<T> iter = list.listIterator();
            int idx = 0;

            while (iter.hasNext()) {
                iter.set(converter.apply(idx++, iter.next()));
            }
        }
    }

    /**
     * Creates a copy of the given array and sets all elements in the copy using the provided generator function.
     * If the specified array is {@code null}, returns {@code null}.
     * If the specified array is empty, returns itself.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be copied and modified
     * @param generator the function used to generate new values for the array elements
     * @return a new array with elements copied from the specified array and modified by the generator function
     * @see #copyThenSetAll(Object[], Throwables.IntObjFunction)
     * @see #copyThenReplaceAll(Object[], UnaryOperator)
     */
    @Beta
    @MayReturnNull
    public static <T> T[] copyThenSetAll(final T[] a, final IntFunction<? extends T> generator) {
        if (a == null) {
            return null; // NOSONAR
        } else if (a.length == 0) {
            return a.clone();
        }

        final T[] copy = a.clone();

        for (int i = 0, len = a.length; i < len; i++) {
            copy[i] = generator.apply(i);
        }

        return copy;
    }

    /**
     * Creates a copy of the given array and sets all elements in the copy using the provided converter function.
     * If the specified array is {@code null}, returns {@code null}.
     * If the specified array is empty, returns itself.
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the converter may throw
     * @param a the array to be copied and modified
     * @param converter the function used to generate new values for the array elements with the index of the element as the first parameter and the original element as the second parameter
     * @return a new array with elements copied from the specified array and modified by the converter function
     * @throws E if the converter function throws an exception
     * @see #copyThenSetAll(Object[], IntFunction)
     * @see #copyThenReplaceAll(Object[], UnaryOperator)
     */
    @Beta
    @MayReturnNull
    public static <T, E extends Exception> T[] copyThenSetAll(final T[] a, final Throwables.IntObjFunction<? super T, ? extends T, E> converter) throws E {
        if (a == null) {
            return null; // NOSONAR
        } else if (a.length == 0) {
            return a.clone();
        }

        final T[] copy = a.clone();

        for (int i = 0, len = a.length; i < len; i++) {
            copy[i] = converter.apply(i, a[i]);
        }

        return copy;
    }

    /**
     * Creates a copy of the given array and replaces all elements in the copy using the provided {@code UnaryOperator}.
     * If the specified array is {@code null}, returns {@code null}.
     * If the specified array is empty, returns itself.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be copied and modified
     * @param operator the UnaryOperator to apply to each element. The operator takes a value of type <i>T</i> and returns a value of type <i>T</i>.
     * @return a new array with elements copied from the specified array and modified by provided {@code UnaryOperator}
     * @see #copyThenSetAll(Object[], IntFunction)
     * @see #copyThenSetAll(Object[], Throwables.IntObjFunction)
     */
    @Beta
    @MayReturnNull
    public static <T> T[] copyThenReplaceAll(final T[] a, final UnaryOperator<T> operator) {
        if (a == null) {
            return null; // NOSONAR
        } else if (a.length == 0) {
            return a.clone();
        }

        final T[] copy = a.clone();

        for (int i = 0, len = a.length; i < len; i++) {
            copy[i] = operator.apply(copy[i]);
        }

        return copy;
    }

    /**
     * Creates a copy of the given array and replaces all elements in the copy using the provided {@code UnaryOperator}.
     * If the specified array is {@code null}, returns {@code null}.
     * If the specified array is empty, returns itself.
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the operator may throw
     * @param a the array to be copied and modified
     * @param operator the UnaryOperator to apply to each element. The operator takes a value of type <i>T</i> and returns a value of type <i>T</i>.
     * @return a new array with elements copied from the specified array and modified by provided {@code UnaryOperator}
     * @throws E if the operator function throws an exception
     * @see #copyThenSetAll(Object[], IntFunction)
     * @see #copyThenSetAll(Object[], Throwables.IntObjFunction)
     */
    @Beta
    @MayReturnNull
    public static <T, E extends Exception> T[] copyThenUpdateAll(final T[] a, final Throwables.UnaryOperator<T, E> operator) throws E {
        if (a == null) {
            return null; // NOSONAR
        } else if (a.length == 0) {
            return a.clone();
        }

        final T[] copy = a.clone();

        for (int i = 0, len = a.length; i < len; i++) {
            copy[i] = operator.apply(copy[i]);
        }

        return copy;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false};
     * boolean[] result = N.add(flags, true);
     * // Returns {true, false, true}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(boolean[], boolean...)
     * @see #insert(boolean[], int, boolean)
     */
    public static boolean[] add(final boolean[] a, final boolean elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final boolean[] newArray = new boolean[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b'};
     * char[] result = N.add(letters, 'c');
     * // Returns {'a', 'b', 'c'}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(char[], char...)
     * @see #insert(char[], int, char)
     */
    public static char[] add(final char[] a, final char elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final char[] newArray = new char[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 3};
     * byte[] result = N.add(data, (byte) 4);
     * // Returns {1, 2, 3, 4}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(byte[], byte...)
     * @see #insert(byte[], int, byte)
     */
    public static byte[] add(final byte[] a, final byte elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final byte[] newArray = new byte[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] values = {10, 20, 30};
     * short[] result = N.add(values, (short) 40);
     * // Returns {10, 20, 30, 40}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(short[], short...)
     * @see #insert(short[], int, short)
     */
    public static short[] add(final short[] a, final short elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final short[] newArray = new short[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3};
     * int[] result = N.add(numbers, 4);
     * // Returns {1, 2, 3, 4}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(int[], int...)
     * @see #insert(int[], int, int)
     */
    public static int[] add(final int[] a, final int elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final int[] newArray = new int[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] ids = {100L, 200L, 300L};
     * long[] result = N.add(ids, 400L);
     * // Returns {100L, 200L, 300L, 400L}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(long[], long...)
     * @see #insert(long[], int, long)
     */
    public static long[] add(final long[] a, final long elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final long[] newArray = new long[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.5f, 3.5f};
     * float[] result = N.add(values, 4.5f);
     * // Returns {1.5f, 2.5f, 3.5f, 4.5f}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(float[], float...)
     * @see #insert(float[], int, float)
     */
    public static float[] add(final float[] a, final float elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final float[] newArray = new float[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] prices = {10.99, 20.99, 30.99};
     * double[] result = N.add(prices, 40.99);
     * // Returns {10.99, 20.99, 30.99, 40.99}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(double[], double...)
     * @see #insert(double[], int, double)
     */
    public static double[] add(final double[] a, final double elementToAdd) {
        if (isEmpty(a)) {
            return Array.of(elementToAdd);
        }

        final double[] newArray = new double[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * Returns a single-element array if the input array is {@code null} or empty.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana"};
     * String[] result = N.add(words, "cherry");
     * // Returns {"apple", "banana", "cherry"}
     * }</pre>
     *
     * @param a the original array
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @see #addAll(String[], String...)
     * @see #insert(Object[], int, Object)
     */
    public static String[] add(final String[] a, final String elementToAdd) {
        if (isEmpty(a)) {
            return asArray(elementToAdd);
        }

        final String[] newArray = new String[a.length + 1];

        copy(a, 0, newArray, 0, a.length);
        newArray[a.length] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with the specified element added at the end.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {1, 2, 3};
     * Integer[] result = N.add(numbers, 4);
     * // Returns {1, 2, 3, 4}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the original array (must not be {@code null})
     * @param elementToAdd the element to add at the end
     * @return a new array containing the original elements and the added element
     * @throws IllegalArgumentException if the original array is {@code null}
     * @see #addAll(Object[], Object...)
     * @see #insert(Object[], int, Object)
     */
    public static <T> T[] add(@NotNull final T[] a, final T elementToAdd) throws IllegalArgumentException {
        checkArgNotNull(a, cs.a);

        final int len = a.length;
        final T[] newArray = Array.newInstance(a.getClass().getComponentType(), len + 1);

        if (len > 0) {
            copy(a, 0, newArray, 0, len);
        }

        newArray[len] = elementToAdd;

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new boolean array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static boolean[] addAll(final boolean[] a, final boolean... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_BOOLEAN_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final boolean[] newArray = new boolean[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new char array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static char[] addAll(final char[] a, final char... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_CHAR_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final char[] newArray = new char[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new byte array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static byte[] addAll(final byte[] a, final byte... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_BYTE_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final byte[] newArray = new byte[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new short array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static short[] addAll(final short[] a, final short... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_SHORT_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final short[] newArray = new short[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new int array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static int[] addAll(final int[] a, final int... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_INT_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final int[] newArray = new int[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new long array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static long[] addAll(final long[] a, final long... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_LONG_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final long[] newArray = new long[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new float array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static float[] addAll(final float[] a, final float... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_FLOAT_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final float[] newArray = new float[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new double array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static double[] addAll(final double[] a, final double... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_DOUBLE_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final double[] newArray = new double[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the first array whose elements are added to the new array.
     * @param elementsToAdd the additional elements to be added to the new array.
     * @return a new String array containing the elements from <i>a</i> and <i>elementsToAdd</i>.
     */
    public static String[] addAll(final String[] a, final String... elementsToAdd) {
        if (isEmpty(a)) {
            return isEmpty(elementsToAdd) ? EMPTY_STRING_ARRAY : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final String[] newArray = new String[a.length + elementsToAdd.length];

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements added at the end.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array.
     * @param a the original array.
     * @param elementsToAdd the elements to be added to the array.
     * @return a new array containing the original elements and the added elements.
     * @throws IllegalArgumentException if the input array <i>a</i> and <i>elementsToAdd</i> both are {@code null}.
     */
    @SafeVarargs
    public static <T> T[] addAll(@NotNull final T[] a, final T... elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(a, cs.a);

        if (isEmpty(a)) {
            return elementsToAdd == null ? a.clone() : elementsToAdd.clone();
        } else if (isEmpty(elementsToAdd)) {
            return a.clone();
        }

        final T[] newArray = Array.newInstance(a.getClass().getComponentType(), a.length + elementsToAdd.length);

        copy(a, 0, newArray, 0, a.length);
        copy(elementsToAdd, 0, newArray, a.length, elementsToAdd.length);

        return newArray;
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the original collection.
     * @param elementsToAdd the elements to be added to the collection.
     * @return a boolean indicating if the collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    @SafeVarargs
    public static <T> boolean addAll(@NotNull final Collection<T> c, final T... elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (isEmpty(elementsToAdd)) {
            return false;
        }

        return c.addAll(Array.asList(elementsToAdd));
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the original collection where elements are to be added.
     * @param elementsToAdd the collection of elements to be added to the original collection.
     * @return a boolean indicating if the original collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    public static <T> boolean addAll(@NotNull final Collection<T> c, final Iterable<? extends T> elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (elementsToAdd == null) {
            return false;
        }

        if (elementsToAdd instanceof final Collection<? extends T> coll) { // NOSONAR
            return c.addAll(coll);
        } else {
            return addAll(c, elementsToAdd.iterator());
        }
    }

    /**
     * Adds all the elements in <i>elementsToAdd</i> to the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the original collection where elements are to be added.
     * @param elementsToAdd the iterator of elements to be added to the original collection.
     * @return a boolean indicating if the original collection changed as a result of the call.
     * @throws IllegalArgumentException if the original collection is {@code null}.
     */
    public static <T> boolean addAll(@NotNull final Collection<T> c, final Iterator<? extends T> elementsToAdd) throws IllegalArgumentException {
        checkArgNotNull(c, cs.c);

        if (elementsToAdd == null) {
            return false;
        }

        boolean wasModified = false;

        while (elementsToAdd.hasNext()) {
            wasModified |= c.add(elementsToAdd.next());
        }

        return wasModified;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original boolean array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the boolean value to be inserted into the array
     * @return a new boolean array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static boolean[] insert(final boolean[] a, final int index, final boolean elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final boolean[] newArray = new boolean[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original char array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the char value to be inserted into the array
     * @return a new char array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static char[] insert(final char[] a, final int index, final char elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final char[] newArray = new char[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original byte array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the byte value to be inserted into the array
     * @return a new byte array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static byte[] insert(final byte[] a, final int index, final byte elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final byte[] newArray = new byte[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original short array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the short value to be inserted into the array
     * @return a new short array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static short[] insert(final short[] a, final int index, final short elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final short[] newArray = new short[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original int array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the int value to be inserted into the array
     * @return a new int array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static int[] insert(final int[] a, final int index, final int elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final int[] newArray = new int[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original long array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the long value to be inserted into the array
     * @return a new long array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static long[] insert(final long[] a, final int index, final long elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final long[] newArray = new long[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original float array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the float value to be inserted into the array
     * @return a new float array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static float[] insert(final float[] a, final int index, final float elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final float[] newArray = new float[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] arr = {1.0, 2.0, 4.0, 5.0};
     * double[] result = N.insert(arr, 2, 3.0);
     * // Returns: [1.0, 2.0, 3.0, 4.0, 5.0]
     * }</pre>
     *
     * @param a the original double array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the double value to be inserted into the array
     * @return a new double array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static double[] insert(final double[] a, final int index, final double elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return Array.of(elementToInsert);
        }

        final double[] newArray = new double[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original String array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the String value to be inserted into the array
     * @return a new String array with the original elements and the inserted element
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static String[] insert(final String[] a, final int index, final String elementToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return asArray(elementToInsert);
        }

        final String[] newArray = new String[a.length + 1];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified element inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "David"};
     * String[] result = N.insert(names, 2, "Charlie");
     * // Returns: ["Alice", "Bob", "Charlie", "David"]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the original array
     * @param index the position in the array where the new element should be inserted
     * @param elementToInsert the element to be inserted into the array
     * @return a new array with the original elements and the inserted element
     * @throws IllegalArgumentException if the original array is {@code null}
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static <T> T[] insert(@NotNull final T[] a, final int index, final T elementToInsert) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkPositionIndex(index, len(a));

        final T[] newArray = newArray(a.getClass().getComponentType(), a.length + 1);

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        newArray[index] = elementToInsert;

        if (index < a.length) {
            copy(a, index, newArray, index + 1, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new String with chars copied from the specified String and the specified String inserted at the specified index.
     * <br />
     * The original String remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String text = "Hello World";
     * String result = N.insert(text, 6, "Beautiful ");
     * // Returns: "Hello Beautiful World"
     * }</pre>
     *
     * @param str the original string
     * @param index the position in the string where the new string should be inserted
     * @param strToInsert the string to be inserted into the original string
     * @return a new string with the original characters and the inserted string
     * @throws IndexOutOfBoundsException if the index is out of range (index &lt; 0 || index &gt; str.length())
     */
    public static String insert(final String str, final int index, final String strToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(str));

        if (Strings.isEmpty(strToInsert)) {
            return Strings.nullToEmpty(str);
        } else if (Strings.isEmpty(str)) {
            return Strings.nullToEmpty(strToInsert);
        } else if (index == 0) {
            return Strings.concat(strToInsert + str);
        } else if (index == str.length()) {
            return Strings.concat(str + strToInsert);
        } else {
            return Strings.concat(str.substring(0, index), strToInsert, str.substring(index));
        }
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static boolean[] insertAll(final boolean[] a, final int index, final boolean... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final boolean[] newArray = new boolean[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static char[] insertAll(final char[] a, final int index, final char... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final char[] newArray = new char[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static byte[] insertAll(final byte[] a, final int index, final byte... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final byte[] newArray = new byte[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static short[] insertAll(final short[] a, final int index, final short... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final short[] newArray = new short[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static int[] insertAll(final int[] a, final int index, final int... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final int[] newArray = new int[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static long[] insertAll(final long[] a, final int index, final long... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final long[] newArray = new long[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static float[] insertAll(final float[] a, final int index, final float... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final float[] newArray = new float[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static double[] insertAll(final double[] a, final int index, final double... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final double[] newArray = new double[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static String[] insertAll(final String[] a, final int index, final String... elementsToInsert) throws IndexOutOfBoundsException {
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final String[] newArray = new String[a.length + elementsToInsert.length];

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Returns a new array with elements copied from the specified array and the specified elements inserted at the specified index.
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "David", "Eve"};
     * String[] result = N.insertAll(names, 1, "Bob", "Charlie");
     * // Returns: ["Alice", "Bob", "Charlie", "David", "Eve"]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the original array
     * @param index the position in the array where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the array
     * @return a new array with the original elements and the inserted elements
     * @throws IllegalArgumentException if the specified {@code Array} is {@code null}.
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    @SafeVarargs
    public static <T> T[] insertAll(@NotNull final T[] a, final int index, final T... elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(a, cs.a);
        checkPositionIndex(index, len(a));

        if (isEmpty(a) && index == 0) {
            return elementsToInsert.clone();
        } else if (isEmpty(elementsToInsert)) {
            return a.clone();
        }

        final T[] newArray = Array.newInstance(a.getClass().getComponentType(), a.length + elementsToInsert.length);

        if (index > 0) {
            copy(a, 0, newArray, 0, index);
        }

        copy(elementsToInsert, 0, newArray, index, elementsToInsert.length);

        if (index < a.length) {
            copy(a, index, newArray, index + elementsToInsert.length, a.length - index);
        }

        return newArray;
    }

    /**
     * Inserts the specified elements at the specified position in the list.
     * Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
     *
     * @param <T> the type of elements in the list
     * @param list the list to insert into
     * @param index the position in the list where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the list
     * @return {@code true} if the list changed as a result of the call
     * @throws IllegalArgumentException if the list is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index &lt; 0 || index &gt; list.size())
     */
    @SafeVarargs
    public static <T> boolean insertAll(@NotNull final List<T> list, final int index, final T... elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(list, cs.list);
        checkPositionIndex(index, size(list));

        if (isEmpty(elementsToInsert)) {
            return false;
        }

        return list.addAll(index, asList(elementsToInsert));
    }

    /**
     * Inserts the specified elements at the specified position in the list.
     * Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
     *
     * @param <T> the type of elements in the list
     * @param list the list to insert into
     * @param index the position in the list where the new elements should be inserted
     * @param elementsToInsert the elements to be inserted into the list
     * @return {@code true} if the list changed as a result of the call
     * @throws IllegalArgumentException if the list is {@code null}
     * @throws IndexOutOfBoundsException if the index is out of range (index &lt; 0 || index &gt; list.size())
     */
    public static <T> boolean insertAll(@NotNull final List<T> list, final int index, final Collection<? extends T> elementsToInsert)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNull(list, cs.list);
        checkPositionIndex(index, size(list));

        if (isEmpty(elementsToInsert)) {
            return false;
        }

        return list.addAll(index, elementsToInsert);
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original boolean array
     * @param index the position of the element to be removed
     * @return a new boolean array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static boolean[] deleteByIndex(@NotNull final boolean[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] result = new boolean[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original char array
     * @param index the position of the element to be removed
     * @return a new char array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static char[] deleteByIndex(@NotNull final char[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] result = new char[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original byte array
     * @param index the position of the element to be removed
     * @return a new byte array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static byte[] deleteByIndex(@NotNull final byte[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] result = new byte[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original short array
     * @param index the position of the element to be removed
     * @return a new short array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static short[] deleteByIndex(@NotNull final short[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] result = new short[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original int array
     * @param index the position of the element to be removed
     * @return a new int array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static int[] deleteByIndex(@NotNull final int[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        final int[] result = new int[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original long array
     * @param index the position of the element to be removed
     * @return a new long array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static long[] deleteByIndex(@NotNull final long[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] result = new long[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original float array
     * @param index the position of the element to be removed
     * @return a new float array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static float[] deleteByIndex(@NotNull final float[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] result = new float[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original double array
     * @param index the position of the element to be removed
     * @return a new double array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static double[] deleteByIndex(@NotNull final double[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] result = new double[a.length - 1];

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the element at the specified position.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the original array
     * @param index the position of the element to be removed
     * @return a new array containing the existing elements except the element at the specified index
     * @throws IndexOutOfBoundsException if the specified index is out of range
     */
    public static <T> T[] deleteByIndex(@NotNull final T[] a, final int index) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);
        checkElementIndex(index, len(a));

        if (isEmpty(a)) {
            return a;
        }

        final T[] result = newArray(a.getClass().getComponentType(), a.length - 1);

        if (index > 0) {
            copy(a, 0, result, 0, index);
        }

        if (index + 1 < a.length) {
            copy(a, index + 1, result, index, a.length - index - 1);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input boolean array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new boolean array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static boolean[] deleteAllByIndices(final boolean[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_BOOLEAN_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final boolean[] result = new boolean[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input char array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new char array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static char[] deleteAllByIndices(final char[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_CHAR_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final char[] result = new char[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input byte array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new byte array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static byte[] deleteAllByIndices(final byte[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_BYTE_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final byte[] result = new byte[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input short array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new short array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static short[] deleteAllByIndices(final short[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_SHORT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final short[] result = new short[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input int array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new int array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static int[] deleteAllByIndices(final int[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_INT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final int[] result = new int[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input long array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new long array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static long[] deleteAllByIndices(final long[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_LONG_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final long[] result = new long[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input float array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new float array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static float[] deleteAllByIndices(final float[] a, int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_FLOAT_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final float[] result = new float[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input double array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new double array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static double[] deleteAllByIndices(final double[] a, final int... indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;

        if (isEmpty(indices)) {
            return a == null ? EMPTY_DOUBLE_ARRAY : a.clone();
        } else if (countOfIndex == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        final int lastIndex = indexes[countOfIndex - 1];
        final int arrayLen = a.length;

        if (indexes[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + lastIndex); //NOSONAR
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indexes[i] == indexes[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final double[] result = new double[arrayLen - countToDelete];
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indexes[i], i++) {
            if (indexes[i] - preIndex > 1) {
                len = indexes[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input String array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new String array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static String[] deleteAllByIndices(final String[] a, final int... indices) throws IndexOutOfBoundsException {
        if (isEmpty(indices)) {
            return a == null ? EMPTY_STRING_ARRAY : a.clone();
        } else if (indices.length == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        return deleteAllBySortedIndices(a, indexes);
    }

    /**
     * Returns a new array with elements copied from the specified array except the elements at the specified positions.
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"A", "B", "C", "D", "E"};
     * String[] result = N.deleteAllByIndices(arr, 1, 3);
     * // Returns: ["A", "C", "E"] - removed elements at indices 1 and 3
     * }</pre>
     *
     * @param <T> the type of elements in the input array
     * @param a the input array from which elements are to be removed
     * @param indices the positions of the elements to be removed
     * @return a new array containing the remaining elements after removal
     * @throws IndexOutOfBoundsException if any index is out of the array's range
     */
    public static <T> T[] deleteAllByIndices(@NotNull final T[] a, final int... indices) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);

        if (isEmpty(indices)) {
            return isEmpty(a) ? a : a.clone();
        } else if (indices.length == 1) {
            return deleteByIndex(a, indices[0]);
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        return deleteAllBySortedIndices(a, indexes);
    }

    private static <T> T[] deleteAllBySortedIndices(final T[] a, final int[] indices) throws IndexOutOfBoundsException {
        final int countOfIndex = indices.length;
        final int lastIndex = indices[countOfIndex - 1];

        final int arrayLen = a.length;

        if (indices[0] < 0 || lastIndex >= arrayLen) {
            throw new IndexOutOfBoundsException("The specified indices are from: " + indices[0] + " to: " + lastIndex);
        }

        int countToDelete = 1;
        for (int i = 1; i < countOfIndex; i++) {
            if (indices[i] == indices[i - 1]) {
                continue;
            }

            countToDelete++;
        }

        final T[] result = newArray(a.getClass().getComponentType(), arrayLen - countToDelete);
        int dest = 0;
        int len = 0;
        for (int i = 0, preIndex = -1; i < countOfIndex; preIndex = indices[i], i++) {
            if (indices[i] - preIndex > 1) {
                len = indices[i] - preIndex - 1;
                copy(a, preIndex + 1, result, dest, len);
                dest += len;
            }
        }

        if (lastIndex < arrayLen - 1) {
            len = arrayLen - lastIndex - 1;
            copy(a, lastIndex + 1, result, dest, len);
        }

        return result;
    }

    /**
     * Deletes all elements at the specified positions from the given list.
     *
     * @param list the list from which elements are to be removed.
     * @param indices the positions of the elements to be removed.
     * @return {@code true} if the list was modified as a result of the operation, {@code false} otherwise.
     * @throws IllegalArgumentException if the input list is {@code null}.
     */
    @SuppressWarnings("rawtypes")
    public static boolean deleteAllByIndices(@NotNull final List<?> list, final int... indices) throws IllegalArgumentException {
        checkArgNotNull(list);

        if (isEmpty(indices)) {
            return false;
        } else if (indices.length == 1) {
            list.remove(indices[0]);
            return true;
        }

        final int[] indexes = indices.clone();
        sort(indexes);

        if (indexes[0] < 0 || indexes[indexes.length - 1] >= list.size()) {
            throw new IndexOutOfBoundsException("The specified indexes are from: " + indexes[0] + " to: " + indexes[indexes.length - 1]);
        }

        if (list instanceof LinkedList) {
            final Iterator<?> iterator = list.iterator();

            int idx = -1;
            for (int i = 0, len = indexes.length; i < len; i++) {
                if (i > 0 && indexes[i] == indexes[i - 1]) {
                    continue;
                }

                while (idx < indexes[i]) {
                    idx++;
                    iterator.next();
                }

                iterator.remove();
            }
        } else {
            final Object[] a = list.toArray();
            final Object[] res = deleteAllBySortedIndices(a, indexes);
            list.clear();
            list.addAll((List) Arrays.asList(res));
        }

        return true;
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, false};
     * boolean[] result = N.remove(flags, true);
     * // Returns {false, true, false}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(boolean[], boolean...)
     * @see #deleteByIndex(boolean[], int)
     */
    public static boolean[] remove(final boolean[] a, final boolean valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'a', 'c'};
     * char[] result = N.remove(letters, 'a');
     * // Returns {'b', 'a', 'c'}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(char[], char...)
     * @see #deleteByIndex(char[], int)
     */
    public static char[] remove(final char[] a, final char valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] data = {1, 2, 1, 3};
     * byte[] result = N.remove(data, (byte) 1);
     * // Returns {2, 1, 3}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(byte[], byte...)
     * @see #deleteByIndex(byte[], int)
     */
    public static byte[] remove(final byte[] a, final byte valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] values = {10, 20, 10, 30};
     * short[] result = N.remove(values, (short) 10);
     * // Returns {20, 10, 30}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(short[], short...)
     * @see #deleteByIndex(short[], int)
     */
    public static short[] remove(final short[] a, final short valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 1, 3};
     * int[] result = N.remove(numbers, 1);
     * // Returns {2, 1, 3}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(int[], int...)
     * @see #deleteByIndex(int[], int)
     */
    public static int[] remove(final int[] a, final int valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] ids = {100L, 200L, 100L, 300L};
     * long[] result = N.remove(ids, 100L);
     * // Returns {200L, 100L, 300L}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(long[], long...)
     * @see #deleteByIndex(long[], int)
     */
    public static long[] remove(final long[] a, final long valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] values = {1.5f, 2.5f, 1.5f, 3.5f};
     * float[] result = N.remove(values, 1.5f);
     * // Returns {2.5f, 1.5f, 3.5f}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(float[], float...)
     * @see #deleteByIndex(float[], int)
     */
    public static float[] remove(final float[] a, final float valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] prices = {10.99, 20.99, 10.99, 30.99};
     * double[] result = N.remove(prices, 10.99);
     * // Returns {20.99, 10.99, 30.99}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(double[], double...)
     * @see #deleteByIndex(double[], int)
     */
    public static double[] remove(final double[] a, final double valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry"};
     * String[] result = N.remove(words, "apple");
     * // Returns {"banana", "apple", "cherry"}
     * }</pre>
     *
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @see #removeAll(String[], String...)
     * @see #deleteByIndex(Object[], int)
     */
    public static String[] remove(final String[] a, final String valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Returns a new array with the first occurrence of the specified value removed.
     * Returns an empty array if the input array is {@code null} or empty.
     * Returns a clone of the array if the value is not found.
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {1, 2, 1, 3};
     * Integer[] result = N.remove(numbers, 1);
     * // Returns {2, 1, 3}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array from which to remove the value
     * @param valueToRemove the value to remove
     * @return a new array with the first occurrence removed, or empty array if input is null/empty
     * @throws IllegalArgumentException if an illegal argument is provided
     * @see #removeAll(Object[], Object...)
     * @see #deleteByIndex(Object[], int)
     */
    @MayReturnNull
    public static <T> T[] remove(final T[] a, final T valueToRemove) throws IllegalArgumentException {
        if (isEmpty(a)) {
            return a;
        }

        final int index = indexOf(a, valueToRemove, 0);

        return index == INDEX_NOT_FOUND ? a.clone() : deleteByIndex(a, index);
    }

    /**
     * Removes the first occurrence of the specified value from the collection.
     * Returns {@code false} if the collection is {@code null} or empty.
     * The collection is modified in place.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "apple"));
     * boolean removed = N.remove(words, "apple");
     * // removed = true, words = ["banana", "apple"]
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection from which to remove the value
     * @param valueToRemove the value to remove
     * @return {@code true} if the collection changed, {@code false} otherwise
     * @see Collection#remove(Object)
     */
    public static <T> boolean remove(final Collection<T> c, final T valueToRemove) {
        if (isEmpty(c)) {
            return false;
        }

        return c.remove(valueToRemove);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static boolean[] removeAll(final boolean[] a, final boolean... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final BooleanList list = BooleanList.of(a.clone());
        list.removeAll(BooleanList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static char[] removeAll(final char[] a, final char... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final CharList list = CharList.of(a.clone());
        list.removeAll(CharList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static byte[] removeAll(final byte[] a, final byte... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final ByteList list = ByteList.of(a.clone());
        list.removeAll(ByteList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static short[] removeAll(final short[] a, final short... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final ShortList list = ShortList.of(a.clone());
        list.removeAll(ShortList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static int[] removeAll(final int[] a, final int... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final IntList list = IntList.of(a.clone());
        list.removeAll(IntList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static long[] removeAll(final long[] a, final long... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final LongList list = LongList.of(a.clone());
        list.removeAll(LongList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static float[] removeAll(final float[] a, final float... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final FloatList list = FloatList.of(a.clone());
        list.removeAll(FloatList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @SuppressWarnings("deprecation")
    public static double[] removeAll(final double[] a, final double... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final DoubleList list = DoubleList.of(a.clone());
        list.removeAll(DoubleList.of(valuesToRemove));
        return list.trimToSize().array();
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with all occurrences of the specified values removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    public static String[] removeAll(final String[] a, final String... valuesToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final Set<String> set = asSet(valuesToRemove);
        final List<String> result = new ArrayList<>();

        for (final String e : a) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result.toArray(new String[0]);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrences of the specified values.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the array from which the values should be removed.
     * @param valuesToRemove the values to be removed from the array.
     * @return a new array with the first occurrence of the specified value removed. The input array itself is returned if the specified array is {@code null} or empty.
     * @see N#difference(int[], int[])
     */
    @MayReturnNull
    @SafeVarargs
    public static <T> T[] removeAll(final T[] a, final T... valuesToRemove) {
        if (isEmpty(a)) {
            return a;
        } else if (isEmpty(valuesToRemove)) {
            return a.clone();
        } else if (valuesToRemove.length == 1) {
            return removeAllOccurrences(a, valuesToRemove[0]);
        }

        final Set<Object> set = asSet(valuesToRemove);
        final List<T> result = new ArrayList<>();

        for (final T e : a) {
            if (!set.contains(e)) {
                result.add(e);
            }
        }

        return result.toArray((T[]) newArray(a.getClass().getComponentType(), result.size()));
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the collection from which the values should be removed.
     * @param valuesToRemove the values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    @SafeVarargs
    public static <T> boolean removeAll(final Collection<T> c, final T... valuesToRemove) {
        if (isEmpty(c) || isEmpty(valuesToRemove)) {
            return false;
        } else {
            return removeAll(c, asSet(valuesToRemove));
        }
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the collection from which the values should be removed.
     * @param valuesToRemove the collection of values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAll(final Collection<T> c, final Iterable<?> valuesToRemove) {
        if (isEmpty(c) || valuesToRemove == null) {
            return false;
        }

        if (c instanceof HashSet && !(valuesToRemove instanceof Set)) {
            boolean wasModified = false;

            for (final Object e : valuesToRemove) {
                //noinspection SuspiciousMethodCalls
                wasModified |= c.remove(e);

                if (c.size() == 0) {
                    break;
                }
            }

            return wasModified;
        } else {
            if (valuesToRemove instanceof final Collection<?> coll) { // NOSONAR
                //noinspection SuspiciousMethodCalls
                return c.removeAll(coll);
            } else {
                return removeAll(c, valuesToRemove.iterator());
            }
        }
    }

    /**
     * Removes all occurrences of the specified values from the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the collection from which the elements should be removed.
     * @param valuesToRemove the iterator of values to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAll(final Collection<T> c, final Iterator<?> valuesToRemove) {
        if (isEmpty(c) || valuesToRemove == null) {
            return false;
        }

        if (c instanceof final Set<T> set) {
            final int originalSize = set.size();

            while (valuesToRemove.hasNext()) {
                //noinspection SuspiciousMethodCalls
                set.remove(valuesToRemove.next());
            }

            return set.size() != originalSize;
        } else {
            return removeAll(c, toSet(valuesToRemove));
        }
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static boolean[] removeAllOccurrences(final boolean[] a, final boolean valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] copy = a.clone();
        int idx = 0;

        for (final boolean element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] removeAllOccurrences(final char[] a, final char valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] copy = a.clone();
        int idx = 0;

        for (final char element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] removeAllOccurrences(final byte[] a, final byte valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] copy = a.clone();
        int idx = 0;

        for (final byte element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] removeAllOccurrences(final short[] a, final short valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] copy = a.clone();
        int idx = 0;

        for (final short element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] removeAllOccurrences(final int[] a, final int valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        final int[] copy = a.clone();
        int idx = 0;

        for (final int element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] removeAllOccurrences(final long[] a, final long valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] copy = a.clone();
        int idx = 0;

        for (final long element : a) {
            if (element == valueToRemove) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] removeAllOccurrences(final float[] a, final float valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] copy = a.clone();
        int idx = 0;

        for (final float element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] removeAllOccurrences(final double[] a, final double valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] copy = a.clone();
        int idx = 0;

        for (final double element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] removeAllOccurrences(final String[] a, final String valueToRemove) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        final String[] copy = a.clone();
        int idx = 0;

        for (final String element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Returns a new array with elements copied from the specified array except all occurrence of the specified value.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the array from which the value should be removed.
     * @param valueToRemove the value to be removed from the array.
     * @return a new array with all occurrences of the specified value removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] removeAllOccurrences(final T[] a, final T valueToRemove) {
        if (isEmpty(a)) {
            return a;
        }

        final T[] copy = a.clone();
        int idx = 0;

        for (final T element : a) {
            if (equals(element, valueToRemove)) {
                continue;
            }

            copy[idx++] = element;
        }

        return idx == copy.length ? copy : copyOfRange(copy, 0, idx);
    }

    /**
     * Removes all occurrences of the specified value from the given collection.
     *
     * @param <T> the type of elements in the collection.
     * @param c the collection from which the value should be removed.
     * @param valueToRemove the value to be removed from the collection.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     */
    public static <T> boolean removeAllOccurrences(final Collection<T> c, final T valueToRemove) {
        if (isEmpty(c)) {
            return false;
        }

        return removeAll(c, asSet(valueToRemove));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(boolean[])} instead.
     */
    @Deprecated
    public static boolean[] removeDuplicates(final boolean[] a) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return removeDuplicates(a, 0, a.length);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the boolean array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @return a new array with duplicate elements from the given array within the specified range
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     * @deprecated Use {@link #distinct(boolean[], int, int)} instead.
     */
    @Deprecated
    static boolean[] removeDuplicates(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Boolean[] b = new Boolean[2];

        for (int i = fromIndex; i < toIndex; i++) {
            if (b[0] == null) {
                b[0] = a[i];
            } else if (b[0] != a[i]) {
                b[1] = a[i];
                break;
            }
        }

        return b[1] == null ? new boolean[] { b[0] } : new boolean[] { b[0], b[1] };
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(char[])} instead for clearer naming that follows Java Stream API conventions.
     *             This method will be maintained for backward compatibility but new code should use the distinct variant.
     */
    @Deprecated
    public static char[] removeDuplicates(final char[] a) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static char[] removeDuplicates(final char[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range, preserving the order of first occurrence.
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Algorithm:</b></p>
     * <ul>
     *   <li>If {@code isSorted} is true: Uses optimized sequential comparison - O(n) time, O(n) space</li>
     *   <li>If {@code isSorted} is false: Uses LinkedHashSet to maintain order - O(n) time, O(n) space with additional set overhead</li>
     * </ul>
     *
     * <p><b>Performance Tip:</b> If your array is sorted (or you can sort it first), pass {@code isSorted=true}
     * for better performance with improved cache locality.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] sorted = {'a', 'a', 'b', 'b', 'c', 'd', 'd'};
     * char[] distinct1 = N.removeDuplicates(sorted, 0, sorted.length, true);
     * // Result: {'a', 'b', 'c', 'd'} - faster algorithm
     *
     * char[] unsorted = {'d', 'a', 'd', 'b', 'a', 'c'};
     * char[] distinct2 = N.removeDuplicates(unsorted, 0, unsorted.length, false);
     * // Result: {'d', 'a', 'b', 'c'} - preserves first occurrence order
     * }</pre>
     *
     * @param a the array from which duplicates should be removed, may be {@code null} or empty
     * @param fromIndex the initial index of the range to be considered for duplicate removal, inclusive
     * @param toIndex the final index of the range to be considered for duplicate removal, exclusive
     * @param isSorted {@code true} if the input array within the specified range is sorted (enables faster algorithm),
     *                 {@code false} otherwise
     * @return a new array with distinct elements within the specified range, preserving order of first occurrence.
     *         Returns an empty array if the input is {@code null} or empty.
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0} or {@code toIndex > a.length} or {@code fromIndex > toIndex}
     * @see #distinct(char[])
     * @see #removeDuplicates(char[], boolean)
     */
    public static char[] removeDuplicates(final char[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final char[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Character> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final char[] result = new char[set.size()];
                int i = 0;

                for (final char e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(byte[])} instead.
     */
    @Deprecated
    public static byte[] removeDuplicates(final byte[] a) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static byte[] removeDuplicates(final byte[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static byte[] removeDuplicates(final byte[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final byte[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Byte> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final byte[] result = new byte[set.size()];
                int i = 0;

                for (final byte e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(short[])} instead.
     */
    @Deprecated
    public static short[] removeDuplicates(final short[] a) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static short[] removeDuplicates(final short[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static short[] removeDuplicates(final short[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final short[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Short> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final short[] result = new short[set.size()];
                int i = 0;

                for (final short e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(int[])} instead.
     */
    @Deprecated
    public static int[] removeDuplicates(final int[] a) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static int[] removeDuplicates(final int[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static int[] removeDuplicates(final int[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final int[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Integer> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final int[] result = new int[set.size()];
                int i = 0;

                for (final int e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(long[])} instead.
     */
    @Deprecated
    public static long[] removeDuplicates(final long[] a) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static long[] removeDuplicates(final long[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static long[] removeDuplicates(final long[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final long[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (b[i] == b[i - 1]) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Long> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final long[] result = new long[set.size()];
                int i = 0;

                for (final long e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(float[])} instead.
     */
    @Deprecated
    public static float[] removeDuplicates(final float[] a) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static float[] removeDuplicates(final float[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static float[] removeDuplicates(final float[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final float[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {

            final Set<Float> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final float[] result = new float[set.size()];
                int i = 0;

                for (final float e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @deprecated Use {@link #distinct(double[])} instead.
     */
    @Deprecated
    public static double[] removeDuplicates(final double[] a) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static double[] removeDuplicates(final double[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static double[] removeDuplicates(final double[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final double[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<Double> set = newLinkedHashSet(a.length);

            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]);
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final double[] result = new double[set.size()];
                int i = 0;

                for (final double e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     * @see #distinct(Object[])
     */
    public static String[] removeDuplicates(final String[] a) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        return removeDuplicates(a, isSorted(a));
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. An empty array is returned if the specified array is {@code null} or empty.
     */
    public static String[] removeDuplicates(final String[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return EMPTY_STRING_ARRAY;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static String[] removeDuplicates(final String[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_STRING_ARRAY;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final String[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final Set<String> set = newLinkedHashSet(a.length);

            //noinspection ManualArrayToCollectionCopy
            for (int i = fromIndex; i < toIndex; i++) {
                set.add(a[i]); //NOSONAR
            }

            if (set.size() == toIndex - fromIndex) {
                return (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            } else {
                final String[] result = new String[set.size()];
                int i = 0;

                for (final String e : set) {
                    result[i++] = e;
                }

                return result;
            }
        }
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the array from which duplicates should be removed.
     * @return a new array with all duplicates removed. The input array itself is returned if the specified array is {@code null} or empty.
     * @see #distinct(Object[])
     */
    public static <T> T[] removeDuplicates(final T[] a) {
        if (isEmpty(a)) {
            return a;
        }

        return removeDuplicates(a, false);
    }

    /**
     * Returns a new array with elements from the input array but without any duplicates.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the array from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return a new array with all duplicates removed. The input array itself is returned if the specified array is {@code null} or empty.
     */
    public static <T> T[] removeDuplicates(final T[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return a;
        }

        return removeDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Returns a new array with distinct elements within the specified range.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the array from which duplicates should be removed.
     * @param fromIndex the initial index of the range to be considered for duplicate removal.
     * @param toIndex the final index of the range to be considered for duplicate removal.
     * @param isSorted a boolean flag indicating whether the input array within the specified range is sorted. If {@code true}, the algorithm will be faster.
     * @return a new array with distinct elements within the specified range.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds.
     */
    public static <T> T[] removeDuplicates(final T[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return a;
        } else if (toIndex - fromIndex <= 1) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        if (isSorted) {
            final T[] b = (fromIndex == 0 && toIndex == a.length) ? a.clone() : copyOfRange(a, fromIndex, toIndex);
            int idx = 1;

            for (int i = 1, len = b.length; i < len; i++) {
                if (equals(b[i], b[i - 1])) {
                    continue;
                }

                b[idx++] = b[i];
            }

            return idx == b.length ? b : copyOfRange(b, 0, idx);
        } else {
            final List<T> list = distinct(a, fromIndex, toIndex);
            return list.toArray((T[]) newArray(a.getClass().getComponentType(), list.size()));
        }
    }

    /**
     * Removes duplicate elements from the given collection.
     *
     * @param c the collection from which duplicates should be removed.
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     * @see #distinct(Iterable)
     * @see #distinctBy(Iterable, Function)
     */
    public static boolean removeDuplicates(final Collection<?> c) {
        return removeDuplicates(c, false);
    }

    /**
     * Removes duplicate elements from the given collection.
     *
     * @param c the collection from which duplicates should be removed.
     * @param isSorted a boolean flag indicating whether the input array is sorted. If {@code true}, the algorithm will be faster
     * @return {@code true} if the collection changed as a result of this call, {@code false} otherwise.
     * @see #distinct(Iterable)
     * @see #distinctBy(Iterable, Function)
     */
    @SuppressWarnings("rawtypes")
    public static boolean removeDuplicates(final Collection<?> c, final boolean isSorted) {
        if (isEmpty(c) || c.size() == 1 || c instanceof Set) {
            return false;
        } else if (c.size() == 2) {
            final Iterator<?> iter = c.iterator();
            final Object first = iter.next();

            if (equals(first, iter.next())) {
                iter.remove();
                return true;
            } else {
                return false;
            }
        }

        if (isSorted) {
            boolean hasDuplicates = false;
            final Iterator<?> it = c.iterator();
            Object pre = it.next();
            Object next = null;
            while (it.hasNext()) {
                next = it.next();
                if (equals(next, pre)) {
                    it.remove();
                    hasDuplicates = true;
                } else {
                    pre = next;
                }
            }

            return hasDuplicates;
        } else {
            final List<?> list = distinct(c);

            final boolean hasDuplicates = list.size() != c.size();

            if (hasDuplicates) {
                c.clear();
                c.addAll((List) list);
            }

            return hasDuplicates;
        }
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static boolean[] deleteRange(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_BOOLEAN_ARRAY : a.clone();
        }

        final int len = len(a);
        final boolean[] b = new boolean[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static char[] deleteRange(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_CHAR_ARRAY : a.clone();
        }

        final int len = len(a);
        final char[] b = new char[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static byte[] deleteRange(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_BYTE_ARRAY : a.clone();
        }

        final int len = len(a);
        final byte[] b = new byte[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static short[] deleteRange(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_SHORT_ARRAY : a.clone();
        }

        final int len = len(a);
        final short[] b = new short[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static int[] deleteRange(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_INT_ARRAY : a.clone();
        }

        final int len = len(a);
        final int[] b = new int[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static long[] deleteRange(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_LONG_ARRAY : a.clone();
        }

        final int len = len(a);
        final long[] b = new long[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static float[] deleteRange(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_FLOAT_ARRAY : a.clone();
        }

        final int len = len(a);
        final float[] b = new float[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static double[] deleteRange(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_DOUBLE_ARRAY : a.clone();
        }

        final int len = len(a);
        final double[] b = new double[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed. An empty array is returned if the specified array is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static String[] deleteRange(final String[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException, IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return a == null ? EMPTY_STRING_ARRAY : a.clone();
        }

        final int len = len(a);
        final String[] b = new String[len - (toIndex - fromIndex)];

        if (fromIndex > 0) {
            copy(a, 0, b, 0, fromIndex);
        }

        if (toIndex < len) {
            copy(a, toIndex, b, fromIndex, len - toIndex);
        }

        return b;
    }

    /**
     * Returns a new array with the specified range of elements removed
     * <br />
     * The original array remains unchanged.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"A", "B", "C", "D", "E"};
     * String[] result = N.deleteRange(arr, 1, 3);
     * // Returns: ["A", "D", "E"] - removed indices 1 and 2
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the input array from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new array with the specified range of elements removed
     * @throws IllegalArgumentException if the array is {@code null} or the range is invalid
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     * @see #skipRange(Object[], int, int)
     */
    public static <T> T[] deleteRange(@NotNull final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);

        return skipRange(a, fromIndex, toIndex);
    }

    /**
     * Deletes a range of elements from the given list.
     *
     * @param <T> the type of elements in the list
     * @param c the input list from which a range of elements are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return {@code true} if the list is updated; {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of the list bounds
     */
    public static <T> boolean deleteRange(final List<T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return false;
        }

        final int size = size(c);

        if (c instanceof LinkedList || toIndex - fromIndex <= 3) {
            c.subList(fromIndex, toIndex).clear();
        } else {
            final List<T> tmp = new ArrayList<>(size - (toIndex - fromIndex));

            if (fromIndex > 0) {
                tmp.addAll(c.subList(0, fromIndex));
            }

            if (toIndex < size) {
                tmp.addAll(c.subList(toIndex, size));
            }

            c.clear();
            c.addAll(tmp);
        }

        return true;
    }

    /**
     * Returns a new String with the specified range of chars removed
     * <br />
     * The original String remains unchanged.
     *
     * @param str the input string from which a range of characters are to be deleted
     * @param fromIndex the initial index of the range to be deleted, inclusive
     * @param toIndex the final index of the range to be deleted, exclusive
     * @return a new string with the specified range of characters deleted. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if the range is out of the string bounds
     * @see Strings#deleteRange(String, int, int)
     */
    public static String deleteRange(final String str, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return Strings.deleteRange(str, fromIndex, toIndex);
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static boolean[] replaceRange(final boolean[] a, final int fromIndex, final int toIndex, final boolean[] replacement)
            throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_BOOLEAN_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final boolean[] result = new boolean[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static char[] replaceRange(final char[] a, final int fromIndex, final int toIndex, final char[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_CHAR_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final char[] result = new char[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static byte[] replaceRange(final byte[] a, final int fromIndex, final int toIndex, final byte[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_BYTE_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final byte[] result = new byte[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static short[] replaceRange(final short[] a, final int fromIndex, final int toIndex, final short[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_SHORT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final short[] result = new short[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static int[] replaceRange(final int[] a, final int fromIndex, final int toIndex, final int[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_INT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final int[] result = new int[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static long[] replaceRange(final long[] a, final int fromIndex, final int toIndex, final long[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_LONG_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final long[] result = new long[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static float[] replaceRange(final float[] a, final int fromIndex, final int toIndex, final float[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_FLOAT_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final float[] result = new float[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static double[] replaceRange(final double[] a, final int fromIndex, final int toIndex, final double[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_DOUBLE_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final double[] result = new double[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static String[] replaceRange(final String[] a, final int fromIndex, final int toIndex, final String[] replacement) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? EMPTY_STRING_ARRAY : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final String[] result = new String[len - (toIndex - fromIndex) + replacement.length];

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Returns a new array with the specified range replaced with the replacement array.
     * <br />
     * The original array remains unchanged.
     *
     * @param <T> the type of elements in the array
     * @param a the original array
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the array to replace the specified range in the original array
     * @return a new array with the specified range replaced by the replacement array
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     */
    public static <T> T[] replaceRange(@NotNull final T[] a, final int fromIndex, final int toIndex, final T[] replacement)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        // checkArgNotNull(a, cs.a);

        final int len = len(a);

        checkFromToIndex(fromIndex, toIndex, len);

        if (isEmpty(a)) {
            return isEmpty(replacement) ? a : replacement.clone();
        } else if (isEmpty(replacement)) {
            return deleteRange(a, fromIndex, toIndex);
        }

        final T[] result = newArray(a.getClass().getComponentType(), len - (toIndex - fromIndex) + replacement.length);

        if (fromIndex > 0) {
            copy(a, 0, result, 0, fromIndex);
        }

        copy(replacement, 0, result, fromIndex, replacement.length);

        if (toIndex < len) {
            copy(a, toIndex, result, fromIndex + replacement.length, len - toIndex);
        }

        return result;
    }

    /**
     * Replaces a range of elements in the given list with the elements from the replacement collection.
     *
     * @param <T> the type of elements in the list and replacement collection
     * @param c the original list to be modified
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the collection to replace the specified range in the original list
     * @return a boolean indicating whether the list was modified
     * @throws IllegalArgumentException if the replacement collection is {@code null}
     * @throws IndexOutOfBoundsException if the range is out of the list bounds
     */
    public static <T> boolean replaceRange(@NotNull final List<T> c, final int fromIndex, final int toIndex, final Collection<? extends T> replacement)
            throws IllegalArgumentException {
        checkArgNotNull(c, cs.list);

        final int size = size(c);

        checkFromToIndex(fromIndex, toIndex, size);

        if (isEmpty(replacement)) {
            if (fromIndex == toIndex) {
                return false;
            }

            return deleteRange(c, fromIndex, toIndex);
        }

        final List<T> endList = toIndex < size ? new ArrayList<>(c.subList(toIndex, size)) : null;

        if (fromIndex < size) {
            deleteRange(c, fromIndex, size);
        }

        c.addAll(replacement);

        if (notEmpty(endList)) {
            c.addAll(endList);
        }

        return true;
    }

    /**
     * Returns a new String with the specified range replaced with the replacement String.
     * <br />
     * The original String remains unchanged.
     *
     * @param str the original string
     * @param fromIndex the initial index of the range to be replaced, inclusive
     * @param toIndex the final index of the range to be replaced, exclusive
     * @param replacement the string to replace the specified range in the original string
     * @return a new string with the specified range replaced by the replacement string
     * @throws IndexOutOfBoundsException if the range is out of the string bounds
     * @see Strings#replaceRange(String, int, int, String)
     */
    public static String replaceRange(final String str, final int fromIndex, final int toIndex, final String replacement) throws IndexOutOfBoundsException {
        return Strings.replaceRange(str, fromIndex, toIndex, replacement);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final boolean[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final boolean[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final char[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final char[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final byte[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final byte[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final short[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final short[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final int[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final int[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final long[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final long[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final float[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final float[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static void moveRange(final double[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final double[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given array to a new position within the array.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original array maintains its size.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr = {"A", "B", "C", "D", "E"};
     * N.moveRange(arr, 1, 3, 3);  // Move "B","C" to position 3
     * // Result: ["A", "D", "B", "C", "E"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the original array to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfArray - lengthOfRange, inclusive.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the array
     */
    public static <T> void moveRange(final T[] a, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        final int len = len(a);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, len);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return;
        }

        final T[] rangeTmp = copyOfRange(a, fromIndex, toIndex);

        // move ahead
        if (newPositionAfterMove < fromIndex) {
            copy(a, newPositionAfterMove, a, toIndex - (fromIndex - newPositionAfterMove), fromIndex - newPositionAfterMove);
        } else {
            copy(a, toIndex, a, fromIndex, newPositionAfterMove - fromIndex);
        }

        copy(rangeTmp, 0, a, newPositionAfterMove, rangeTmp.length);
    }

    /**
     * Moves a range of elements in the given list to a new position within the list.
     * The new position specified by {@code newPositionAfterMove} is the start index of the specified range after the move operation, not before the move operation.
     * <br />
     * No elements are deleted in the process, the original list maintains its size.
     *
     * @param <T> the type of elements in the list
     * @param c the original list to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move;
     *      must be between 0 and sizeOfList - lengthOfRange, inclusive.
     * @return {@code true} if the list was modified (elements were moved), {@code false} otherwise
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the list
     */
    public static <T> boolean moveRange(final List<T> c, final int fromIndex, final int toIndex, final int newPositionAfterMove)
            throws IndexOutOfBoundsException {
        final int size = size(c);
        checkIndexAndStartPositionForMoveRange(fromIndex, toIndex, newPositionAfterMove, size);

        if (fromIndex == toIndex || fromIndex == newPositionAfterMove) {
            return false;
        }

        final T[] tmp = (T[]) c.toArray();

        moveRange(tmp, fromIndex, toIndex, newPositionAfterMove);
        c.clear();
        c.addAll(Arrays.asList(tmp));

        return true;
    }

    /**
     * Moves a specified range of characters within a string to a new position.
     *
     * <p>This method extracts a substring from the range [fromIndex, toIndex) and moves it to the specified
     * new position. The newPositionAfterMove parameter indicates where the start of the moved range
     * should be positioned in the resulting string. The original string remains unchanged, and a new string
     * with the rearranged characters is returned.</p>
     *
     * <p>The method returns an empty string for {@code null} or empty input.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Moving a range of characters
     * moveRange("ABCDEFGH", 2, 5, 0);      // returns "CDEABFGH" (moves "CDE" to position 0)
     * moveRange("ABCDEFGH", 2, 5, 5);      // returns "ABFGHCDE" (moves "CDE" to position 6)
     * moveRange("Hello World", 0, 5, 5);   // returns " WorldHello" (moves "Hello" after "World")
     *
     * // Edge cases
     * moveRange(null, 0, 0, 0);            // returns ""
     * moveRange("", 0, 0, 0);              // returns ""
     * moveRange("ABC", 1, 1, 2);           // returns "ABC" (no change when fromIndex == toIndex)
     * moveRange("ABC", 0, 2, 0);           // returns "ABC" (no change when already at position)
     * }</pre>
     *
     * @param str the original string to be modified
     * @param fromIndex the starting index (inclusive) of the range to be moved
     * @param toIndex the ending index (exclusive) of the range to be moved
     * @param newPositionAfterMove — the zero-based index where the first element of the range will be placed after the move; 
     *      must be between 0 and lengthOfString - lengthOfRange, inclusive.
     * @return a new string with the specified range moved to the new position. An empty String is returned if the specified String is {@code null} or empty.
     * @throws IndexOutOfBoundsException if any index is out of bounds or if
     *         newPositionAfterMove would cause elements to be moved outside the string
     * @see Strings#moveRange(String, int, int, int)
     */
    public static String moveRange(final String str, final int fromIndex, final int toIndex, final int newPositionAfterMove) throws IndexOutOfBoundsException {
        return Strings.moveRange(str, fromIndex, toIndex, newPositionAfterMove);
    }

    static void checkIndexAndStartPositionForMoveRange(final int fromIndex, final int toIndex, final int newPositionAfterMove, final int len) {
        checkFromToIndex(fromIndex, toIndex, len);

        if (newPositionAfterMove < 0 || newPositionAfterMove > (len - (toIndex - fromIndex))) {
            throw new IndexOutOfBoundsException("newPositionAfterMove " + newPositionAfterMove + " is out-of-bounds: [0, " + (len - (toIndex - fromIndex))
                    + "=(array.length - (toIndex - fromIndex))]");
        }
    }

    //    /**

    /**
     * Returns a new array with the specified range skipped, effectively excluding elements
     * from the given start index (inclusive) to the end index (exclusive).
     *
     * <p>The original array remains unchanged. If the input array is {@code null}, returns {@code null}.
     * If the range is empty (startInclusive == endExclusive), returns a clone of the original array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry", "date", "elderberry"};
     * String[] result = N.skipRange(words, 1, 3);
     * // Returns ["apple", "date", "elderberry"] - skips "banana" and "cherry"
     *
     * Integer[] numbers = {1, 2, 3, 4, 5};
     * Integer[] skipped = N.skipRange(numbers, 0, 2);  // Returns [3, 4, 5]
     * }</pre>
     *
     * @param <T> the type of elements in the input array
     * @param a the original array to be modified; may be {@code null}
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @return a new array with the specified range skipped; {@code null} if the input array is {@code null}.
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     * @see #deleteRange(Object[], int, int)
     */
    @MayReturnNull
    public static <T> T[] skipRange(final T[] a, final int startInclusive, final int endExclusive) throws IndexOutOfBoundsException {
        final int len = len(a);

        checkFromToIndex(startInclusive, endExclusive, len);

        if (a == null) {
            return null;
        } else if (startInclusive == endExclusive) {
            return a.clone();
        }

        final T[] ret = N.newArray(a.getClass().getComponentType(), len - (endExclusive - startInclusive));

        if (startInclusive > 0) {
            N.copy(a, 0, ret, 0, startInclusive);
        }

        if (endExclusive < len) {
            N.copy(a, endExclusive, ret, startInclusive, len - endExclusive);
        }

        return ret;
    }

    /**
     * Returns a new list with the specified range skipped, effectively excluding elements
     * from the given start index (inclusive) to the end index (exclusive).
     *
     * <p>The original collection remains unchanged. This is a convenience method that delegates to
     * {@link #skipRange(Collection, int, int, IntFunction)} with a default list supplier.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("alpha", "beta", "gamma", "delta");
     * List<String> result = N.skipRange(words, 1, 3);
     * // Returns ["alpha", "delta"] - skips "beta" and "gamma"
     *
     * Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
     * List<Integer> skipped = N.skipRange(numbers, 0, 2);  // Returns list excluding first 2 elements
     * }</pre>
     *
     * @param <T> the type of elements in the input collection
     * @param c the original collection to be modified
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @return a new list with the specified range skipped.
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     * @see #skipRange(Collection, int, int, IntFunction)
     */
    public static <T> List<T> skipRange(final Collection<? extends T> c, final int startInclusive, final int endExclusive) throws IndexOutOfBoundsException {
        return skipRange(c, startInclusive, endExclusive, IntFunctions.ofList());
    }

    /**
     * Returns a new collection with the specified range skipped, effectively excluding elements
     * from the given start index (inclusive) to the end index (exclusive).
     * The type of the returned collection is determined by the provided supplier function.
     *
     * <p>The original collection remains unchanged. This method provides flexibility to specify
     * the exact collection type to be returned (e.g., ArrayList, HashSet, LinkedList).
     *
     * <p><b>Performance note:</b> If the input collection is a {@link List}, this method uses
     * {@code subList} for efficient range access. For other collection types, it uses an iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
     * Set<String> resultSet = N.skipRange(words, 1, 3, HashSet::new);
     * // Returns HashSet containing ["apple", "date", "elderberry"]
     *
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
     * LinkedList<Integer> skipped = N.skipRange(numbers, 0, 2, LinkedList::new);
     * // Returns LinkedList [3, 4, 5]
     * }</pre>
     *
     * @param <T> the type of elements in the input collection
     * @param <C> the type of the collection to be returned
     * @param c the original collection to be modified
     * @param startInclusive the initial index of the range to be skipped, inclusive
     * @param endExclusive the final index of the range to be skipped, exclusive
     * @param supplier a function that creates a new instance of the desired collection type
     * @return a new collection with the specified range skipped.
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     * @see #skipRange(Collection, int, int)
     */
    public static <T, C extends Collection<T>> C skipRange(final Collection<? extends T> c, final int startInclusive, final int endExclusive,
            final IntFunction<C> supplier) throws IndexOutOfBoundsException {
        final int size = size(c);

        checkFromToIndex(startInclusive, endExclusive, size);

        final C result = supplier.apply(size - (endExclusive - startInclusive));

        if (size == 0) {
            return result;
        }

        if (c instanceof List) {
            final List<T> list = (List<T>) c;

            if (startInclusive > 0) {
                result.addAll(list.subList(0, startInclusive));
            }

            if (endExclusive < size) {
                result.addAll(list.subList(endExclusive, size));
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();

            for (int i = 0; i < startInclusive; i++) {
                result.add(iter.next());
            }

            if (endExclusive < size) {
                int idx = startInclusive;

                while (idx++ < endExclusive) {
                    iter.next();
                }

                while (iter.hasNext()) {
                    result.add(iter.next());
                }
            }
        }

        return result;
    }

    // Primitive/Object array converters
    // ----------------------------------------------------------------------

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else {
            return true;
        }
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final char[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final char[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final char[] a, final int fromIndex, final int toIndex, final boolean isSorted) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Character> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final byte[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final byte[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final byte[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Byte> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final short[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final short[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final short[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Short> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final int[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final int[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final int[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Integer> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final long[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final long[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final long[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return a[fromIndex] == a[fromIndex + 1];
        } else if (toIndex - fromIndex == 3) {
            return a[fromIndex] == a[fromIndex + 1] || a[fromIndex] == a[fromIndex + 2] || a[fromIndex + 1] == a[fromIndex + 2];
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (a[i] == a[i - 1]) {
                    return true;
                }
            }
        } else {
            final Set<Long> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final float[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final float[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final float[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Float> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final double[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final double[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static boolean hasDuplicates(final double[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Double> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(a[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * @param <T> the type of elements in the array
     * @param a the array to be checked for duplicates
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static <T> boolean hasDuplicates(final T[] a) {
        return hasDuplicates(a, false);
    }

    /**
     * Checks if the given array has duplicate elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] arr1 = {"A", "B", "C"};
     * boolean result1 = N.hasDuplicates(arr1);  // Returns: false
     *
     * String[] arr2 = {"A", "B", "A"};
     * boolean result2 = N.hasDuplicates(arr2);  // Returns: true
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array to be checked for duplicates
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates, {@code false} otherwise
     */
    public static <T> boolean hasDuplicates(final T[] a, final boolean isSorted) {
        if (isEmpty(a)) {
            return false;
        }

        return hasDuplicates(a, 0, a.length, isSorted);
    }

    /**
     * Checks if the given array has duplicate elements within the specified range.
     *
     * @param a the array to be checked for duplicates
     * @param fromIndex the start index (inclusive) of the range to be checked
     * @param toIndex the end index (exclusive) of the range to be checked
     * @param isSorted a boolean that indicates if the array is sorted. If {@code true}, the algorithm will be faster.
     * @return {@code true} if the array has duplicates within the specified range, {@code false} otherwise
     * @throws IndexOutOfBoundsException if the range is out of bounds for the given array
     */
    static <T> boolean hasDuplicates(final T[] a, final int fromIndex, final int toIndex, final boolean isSorted) {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || toIndex - fromIndex < 2) {
            return false;
        } else if (toIndex - fromIndex == 2) {
            return equals(a[fromIndex], a[fromIndex + 1]);
        } else if (toIndex - fromIndex == 3) {
            return equals(a[fromIndex], a[fromIndex + 1]) || equals(a[fromIndex], a[fromIndex + 2]) || equals(a[fromIndex + 1], a[fromIndex + 2]);
        }

        if (isSorted) {
            for (int i = fromIndex + 1; i < toIndex; i++) {
                if (equals(a[i], a[i - 1])) {
                    return true;
                }
            }
        } else {
            final Set<Object> set = newHashSet(toIndex - fromIndex);

            for (int i = fromIndex; i < toIndex; i++) {
                if (!set.add(hashKey(a[i]))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if the given collection has duplicate elements.
     *
     * @param c the collection to be checked for duplicates
     * @return {@code true} if the collection has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final Collection<?> c) {
        return hasDuplicates(c, false);
    }

    /**
     * Checks if the given collection has duplicate elements.
     *
     * @param c the collection to be checked for duplicates
     * @param isSorted a boolean that indicates if the collection is sorted. If {@code true}, the algorithm will be faster
     * @return {@code true} if the collection has duplicates, {@code false} otherwise
     */
    public static boolean hasDuplicates(final Collection<?> c, final boolean isSorted) {
        if (isEmpty(c) || c.size() == 1 || c instanceof Set) {
            return false;
        }

        if (isSorted) {
            final Iterator<?> it = c.iterator();
            Object pre = it.next();
            Object next = null;
            while (it.hasNext()) {
                next = it.next();

                if (equals(next, pre)) {
                    return true;
                }

                pre = next;
            }
        } else {
            final Set<Object> set = newHashSet(c.size());

            for (final Object e : c) {
                if (!set.add(hashKey(e))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Retains only the elements in the specified collection that are present in the specified collection of elements to keep.
     * In other words, removes from the first collection all of its elements that are not contained in the second collection.
     *
     * @param <T> the type of elements in the input collections
     * @param c the collection to be modified.
     * @param objsToKeep the collection containing elements to be retained in the first collection.
     * @return {@code true} if the first collection changed as a result of the call
     * @see Collection#retainAll(Collection)
     */
    public static <T> boolean retainAll(final Collection<T> c, final Collection<? extends T> objsToKeep) {
        if (isEmpty(c)) {
            return false;
        } else if (isEmpty(objsToKeep)) {
            c.clear();
            return true;
        }

        if (c instanceof HashSet && !(objsToKeep instanceof Set) && (c.size() > 9 || objsToKeep.size() > 9)) {
            return c.retainAll(newHashSet(objsToKeep));
        } else {
            return c.retainAll(objsToKeep);
        }
    }

    static Object hashKey(final Object obj) {
        return obj == null ? NULL_MASK : (obj.getClass().isArray() ? Wrapper.of(obj) : obj);
    }

    /**
     * Returns the sum of all elements in the specified char array or varargs.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int sum1 = N.sum('a', 'b', 'c');    // Returns 294 (97 + 98 + 99)
     *
     * char[] chars = {'A', 'B', 'C'};
     * int sum2 = N.sum(chars);            // Returns 198 (65 + 66 + 67)
     * }</pre>
     *
     * @param a the array or varargs of char values
     * @return the sum of all elements, or 0 if the array is {@code null} or empty
     * @see #sum(char[], int, int)
     * @see #average(char...)
     */
    public static int sum(final char... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the char array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'A', 'B', 'C', 'D', 'E'};
     * int sum = N.sum(chars, 1, 4);  // Returns 201 (66 + 67 + 68)
     * }</pre>
     *
     * @param a the array of char values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(char...)
     * @see #average(char[], int, int)
     */
    public static int sum(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Returns the sum of all elements in the specified byte array or varargs.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int sum1 = N.sum((byte) 10, (byte) 20, (byte) 30);    // Returns 60
     *
     * byte[] numbers = {5, 10, 15};
     * int sum2 = N.sum(numbers);                            // Returns 30
     * }</pre>
     *
     * @param a the array or varargs of byte values
     * @return the sum of all elements, or 0 if the array is {@code null} or empty
     * @see #sum(byte[], int, int)
     * @see #average(byte...)
     */
    public static int sum(final byte... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the byte array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {10, 20, 30, 40, 50};
     * int sum = N.sum(numbers, 1, 4);  // Returns 90 (20 + 30 + 40)
     * }</pre>
     *
     * @param a the array of byte values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(byte...)
     * @see #average(byte[], int, int)
     */
    public static int sum(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Returns the sum of all elements in the specified short array or varargs.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int sum1 = N.sum((short) 100, (short) 200, (short) 300);    // Returns 600
     *
     * short[] numbers = {50, 100, 150};
     * int sum2 = N.sum(numbers);                                  // Returns 300
     * }</pre>
     *
     * @param a the array or varargs of short values
     * @return the sum of all elements, or 0 if the array is {@code null} or empty
     * @see #sum(short[], int, int)
     * @see #average(short...)
     */
    public static int sum(final short... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the short array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {100, 200, 300, 400, 500};
     * int sum = N.sum(numbers, 1, 4);  // Returns 900 (200 + 300 + 400)
     * }</pre>
     *
     * @param a the array of short values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(short...)
     * @see #average(short[], int, int)
     */
    public static int sum(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Returns the sum of all elements in the array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {10, 20, 30};
     * int total = N.sum(numbers);  // Returns 60
     * }</pre>
     *
     * @param a the array of int values
     * @return the sum of all elements, or 0 if the array is {@code null} or empty
     * @see #sum(int[], int, int)
     * @see #sumToLong(int...)
     * @see #average(int...)
     */
    public static int sum(final int... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the int array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {100, 200, 300, 400, 500};
     * int sum = N.sum(numbers, 1, 4);  // Returns 900 (200 + 300 + 400)
     * }</pre>
     *
     * @param a the array of int values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(int...)
     * @see #sumToLong(int[], int, int)
     * @see #average(int[], int, int)
     */
    public static int sum(final int[] a, final int fromIndex, final int toIndex) {
        return Numbers.toIntExact(sumToLong(a, fromIndex, toIndex));
    }

    /**
     * Returns the sum of all elements in the array as a long value.
     * Returns 0 if the array is {@code null} or empty.
     * This method prevents overflow by using long arithmetic.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] largeNumbers = {Integer.MAX_VALUE, 10};
     * long total = N.sumToLong(largeNumbers);  // Avoids overflow
     * }</pre>
     *
     * @param a the array of int values
     * @return the sum of all elements as a long, or 0 if the array is {@code null} or empty
     * @see #sumToLong(int[], int, int)
     * @see #sum(int...)
     */
    public static long sumToLong(final int... a) {
        if (isEmpty(a)) {
            return 0;
        }

        return sumToLong(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the array as a long value.
     * Returns 0 if the array is {@code null} or empty.
     * This method prevents overflow by using long arithmetic.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {100, 200, 300, 400, 500};
     * long sum = N.sumToLong(numbers, 1, 4);  // Returns 900L (200 + 300 + 400)
     * }</pre>
     *
     * @param a the array of int values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range as a long, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sumToLong(int...)
     * @see #sum(int[], int, int)
     */
    public static long sumToLong(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Returns the sum of all elements in the specified long array or varargs.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long sum1 = N.sum(1000L, 2000L, 3000L);    // Returns 6000L
     *
     * long[] numbers = {500L, 1000L, 1500L};
     * long sum2 = N.sum(numbers);                // Returns 3000L
     * }</pre>
     *
     * @param a the array or varargs of long values
     * @return the sum of all elements, or 0 if the array is {@code null} or empty
     * @see #sum(long[], int, int)
     * @see #average(long...)
     */
    public static long sum(final long... a) {
        if (isEmpty(a)) {
            return 0L;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the long array.
     * Returns 0 if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {1000L, 2000L, 3000L, 4000L, 5000L};
     * long sum = N.sum(numbers, 1, 4);  // Returns 9000L (2000 + 3000 + 4000)
     * }</pre>
     *
     * @param a the array of long values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0 if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(long...)
     * @see #average(long[], int, int)
     */
    public static long sum(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return sum;
    }

    /**
     * Returns the sum of all elements in the specified float array or varargs.
     * Returns 0.0f if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float sum1 = N.sum(10.5f, 20.3f, 30.7f);    // Returns 61.5f
     *
     * float[] numbers = {5.5f, 10.5f, 15.5f};
     * float sum2 = N.sum(numbers);                // Returns 31.5f
     * }</pre>
     *
     * @param a the array or varargs of float values
     * @return the sum of all elements, or 0.0f if the array is {@code null} or empty
     * @see #sum(float[], int, int)
     * @see #sumToDouble(float...)
     * @see #average(float...)
     */
    public static float sum(final float... a) {
        if (isEmpty(a)) {
            return 0f;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the float array.
     * Returns 0.0f if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {10.5f, 20.3f, 30.7f, 40.2f, 50.8f};
     * float sum = N.sum(numbers, 1, 4);  // Returns 91.2f (20.3 + 30.7 + 40.2)
     * }</pre>
     *
     * @param a the array of float values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0.0f if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(float...)
     * @see #sumToDouble(float[], int, int)
     * @see #average(float[], int, int)
     */
    public static float sum(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0f;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return (float) summation.sum();
    }

    /**
     * Sums all elements in the given array of floats to a double value.
     *
     * @param a the array of floats to be summed.
     * @return the sum of all floats in the array. If the array is {@code null} or empty, {@code 0} is returned.
     */
    public static double sumToDouble(final float... a) {
        if (isEmpty(a)) {
            return 0f;
        }

        return sumToDouble(a, 0, a.length);
    }

    /**
     * Sums all elements within the specified range in the input array of floats to a double value.
     *
     * @param a the array of floats to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the input array. If the array is {@code null} or empty, {@code 0} is returned.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given array.
     */
    public static double sumToDouble(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0f;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.sum();
    }

    /**
     * Returns the sum of all elements in the specified double array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double sum1 = N.sum(10.5, 20.3, 30.7);    // Returns 61.5
     *
     * double[] numbers = {5.5, 10.5, 15.5};
     * double sum2 = N.sum(numbers);             // Returns 31.5
     * }</pre>
     *
     * @param a the array or varargs of double values
     * @return the sum of all elements, or 0.0d if the array is {@code null} or empty
     * @see #sum(double[], int, int)
     * @see #average(double...)
     */
    public static double sum(final double... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return sum(a, 0, a.length);
    }

    /**
     * Returns the sum of elements within the specified range of the double array.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {10.5, 20.3, 30.7, 40.2, 50.8};
     * double sum = N.sum(numbers, 1, 4);  // Returns 91.2 (20.3 + 30.7 + 40.2)
     * }</pre>
     *
     * @param a the array of double values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the sum of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #sum(double...)
     * @see #average(double[], int, int)
     */
    public static double sum(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.sum();
    }

    /**
     * Returns the average of all elements in the specified char array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     * The char values are converted to their numeric Unicode values for calculation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average('A', 'B', 'C');    // Returns 66.0 ((65 + 66 + 67) / 3)
     *
     * char[] chars = {'a', 'b', 'c'};
     * double avg2 = N.average(chars);            // Returns 98.0 ((97 + 98 + 99) / 3)
     * }</pre>
     *
     * @param a the array or varargs of char values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(char[], int, int)
     * @see #sum(char...)
     */
    public static double average(final char... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the char array.
     * Returns 0.0d if the array is {@code null} or empty.
     * The char values are converted to their numeric Unicode values for calculation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'A', 'B', 'C', 'D', 'E'};
     * double avg = N.average(chars, 1, 4);  // Returns 67.0 ((66 + 67 + 68) / 3)
     * }</pre>
     *
     * @param a the array of char values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(char...)
     * @see #sum(char[], int, int)
     */
    public static double average(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns the average of all elements in the specified byte array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average((byte) 10, (byte) 20, (byte) 30);    // Returns 20.0
     *
     * byte[] numbers = {5, 10, 15};
     * double avg2 = N.average(numbers);                            // Returns 10.0
     * }</pre>
     *
     * @param a the array or varargs of byte values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(byte[], int, int)
     * @see #sum(byte...)
     */
    public static double average(final byte... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the byte array.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {10, 20, 30, 40, 50};
     * double avg = N.average(numbers, 1, 4);  // Returns 30.0 ((20 + 30 + 40) / 3)
     * }</pre>
     *
     * @param a the array of byte values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(byte...)
     * @see #sum(byte[], int, int)
     */
    public static double average(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns the average of all elements in the specified short array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average((short) 100, (short) 200, (short) 300);    // Returns 200.0
     *
     * short[] numbers = {50, 100, 150};
     * double avg2 = N.average(numbers);                                  // Returns 100.0
     * }</pre>
     *
     * @param a the array or varargs of short values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(short[], int, int)
     * @see #sum(short...)
     */
    public static double average(final short... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the short array.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {100, 200, 300, 400, 500};
     * double avg = N.average(numbers, 1, 4);  // Returns 300.0 ((200 + 300 + 400) / 3)
     * }</pre>
     *
     * @param a the array of short values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(short...)
     * @see #sum(short[], int, int)
     */
    public static double average(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns the average of all elements in the specified int array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average(100, 200, 300);    // Returns 200.0
     *
     * int[] numbers = {50, 100, 150};
     * double avg2 = N.average(numbers);          // Returns 100.0
     * }</pre>
     *
     * @param a the array or varargs of int values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(int[], int, int)
     * @see #sum(int...)
     */
    public static double average(final int... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the int array.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {100, 200, 300, 400, 500};
     * double avg = N.average(numbers, 1, 4);  // Returns 300.0 ((200 + 300 + 400) / 3)
     * }</pre>
     *
     * @param a the array of int values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(int...)
     * @see #sum(int[], int, int)
     */
    public static double average(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += a[i];
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Returns the average of all elements in the specified long array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average(1000L, 2000L, 3000L);    // Returns 2000.0
     *
     * long[] numbers = {500L, 1000L, 1500L};
     * double avg2 = N.average(numbers);                // Returns 1000.0
     * }</pre>
     *
     * @param a the array or varargs of long values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(long[], int, int)
     * @see #sum(long...)
     */
    public static double average(final long... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the long array.
     * Returns 0.0d if the array is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {1000L, 2000L, 3000L, 4000L, 5000L};
     * double avg = N.average(numbers, 1, 4);  // Returns 3000.0 ((2000 + 3000 + 4000) / 3)
     * }</pre>
     *
     * @param a the array of long values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(long...)
     * @see #sum(long[], int, int)
     */
    public static double average(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sum(a, fromIndex, toIndex)) / (toIndex - fromIndex);
    }

    /**
     * Returns the average of all elements in the specified float array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average(10.5f, 20.3f, 30.7f);    // Returns approximately 20.5
     *
     * float[] numbers = {5.5f, 10.5f, 15.5f};
     * double avg2 = N.average(numbers);                // Returns approximately 10.5
     * }</pre>
     *
     * @param a the array or varargs of float values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(float[], int, int)
     * @see #sum(float...)
     */
    public static double average(final float... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the float array.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {10.5f, 20.3f, 30.7f, 40.2f, 50.8f};
     * double avg = N.average(numbers, 1, 4);  // Returns approximately 30.4 ((20.3 + 30.7 + 40.2) / 3)
     * }</pre>
     *
     * @param a the array of float values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(float...)
     * @see #sum(float[], int, int)
     */
    public static double average(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.average().orElseZero();
    }

    /**
     * Returns the average of all elements in the specified double array or varargs.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double avg1 = N.average(10.5, 20.3, 30.7);    // Returns approximately 20.5
     *
     * double[] numbers = {5.5, 10.5, 15.5};
     * double avg2 = N.average(numbers);             // Returns approximately 10.5
     * }</pre>
     *
     * @param a the array or varargs of double values
     * @return the average of all elements, or 0.0d if the array is {@code null} or empty
     * @see #average(double[], int, int)
     * @see #sum(double...)
     */
    public static double average(final double... a) {
        if (isEmpty(a)) {
            return 0d;
        }

        return average(a, 0, a.length);
    }

    /**
     * Returns the average of elements within the specified range of the double array.
     * Returns 0.0d if the array is {@code null} or empty.
     * Uses Kahan summation algorithm for improved numerical accuracy.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {10.5, 20.3, 30.7, 40.2, 50.8};
     * double avg = N.average(numbers, 1, 4);  // Returns approximately 30.4 ((20.3 + 30.7 + 40.2) / 3)
     * }</pre>
     *
     * @param a the array of double values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the average of elements within the specified range, or 0.0d if the array is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #average(double...)
     * @see #sum(double[], int, int)
     */
    public static double average(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0d;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(a[i]);
        }

        return summation.average().orElseZero();
    }

    /**
     * Sums all elements in the given array of numbers and returns the result as an integer.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @return the sum of all elements in the array as an integer.
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final T[] a) {
        return sumInt(a, Fn.numToInt());
    }

    /**
     * Sums all elements within the specified range in the input array of numbers and returns the result as an integer.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the array as an integer.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given array.
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final T[] a, final int fromIndex, final int toIndex) {
        return sumInt(a, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Sums all elements in the given array using the provided function to convert each element to an integer.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * int totalLength = N.sumInt(names, String::length);
     * // Returns: 15 (5 + 3 + 7)
     * }</pre>
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param func the function to convert each element to an integer.
     * @return the sum of all elements in the array as an integer.
     * @throws IndexOutOfBoundsException if an index is out of bounds
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final T[] a, final ToIntFunction<? super T> func) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return sumInt(a, 0, a.length, func);
    }

    /**
     * Sums all elements within the specified range in the input array using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to an integer.
     * @return the sum of all elements within the specified range of the array as an integer.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsInt(a[i]);
        }

        return Numbers.toIntExact(sum);
    }

    /**
     * Sums all elements within the specified range in the input collection of numbers and returns the result as an integer.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the collection as an integer.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given collection.
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumInt(c, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Sums all elements within the specified range in the input collection using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to an integer.
     * @return the sum of all elements within the specified range of the collection as an integer.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                sum += func.applyAsInt(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return Numbers.toIntExact(sum);
    }

    /**
     * Sums all elements in the given iterable of numbers and returns the result as a integer.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of elements to be summed.
     * @return the sum of all elements in the iterable as a integer.
     * @see Iterables#sumInt(Iterable)
     */
    public static <T extends Number> int sumInt(final Iterable<? extends T> c) {
        return sumInt(c, Fn.numToInt());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to an integer.
     * @return the sum of all elements in the iterable as an integer.
     * @see Iterables#sumInt(Iterable, ToIntFunction)
     */
    public static <T> int sumInt(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        return Numbers.toIntExact(sumIntToLong(c, func));
    }

    /**
     * Sums all elements in the given iterable of numbers and returns the result as a long.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to be summed.
     * @return the sum of all elements in the iterable as a long.
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumIntToLong(final Iterable<? extends T> c) {
        return sumIntToLong(c, Fn.numToInt());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to an integer and returns the result as a long.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to an integer.
     * @return the sum of all elements in the iterable as a long.
     * @see Iterables#sumIntToLong(Iterable, ToIntFunction)
     */
    public static <T> long sumIntToLong(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0;
        }

        long sum = 0;

        for (final T e : c) {
            sum += func.applyAsInt(e);
        }

        return sum;
    }

    /**
     * Sums all elements in the given array of numbers and returns the result as a long.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @return the sum of all elements in the array as a long.
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final T[] a) {
        return sumLong(a, Fn.numToLong());
    }

    /**
     * Sums all elements within the specified range in the input array of numbers and returns the result as a long.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the array as a long.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given array.
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final T[] a, final int fromIndex, final int toIndex) {
        return sumLong(a, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Sums all elements in the given array using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param func the function to convert each element to a long.
     * @return the sum of all elements in the array as a long.
     * @throws IndexOutOfBoundsException if an index is out of bounds
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final T[] a, final ToLongFunction<? super T> func) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0L;
        }

        return sumLong(a, 0, a.length, func);
    }

    /**
     * Sums all elements within the specified range in the input array using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to a long.
     * @return the sum of all elements within the specified range of the array as a long.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0L;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsLong(a[i]);
        }

        return sum;
    }

    /**
     * Sums all elements within the specified range in the input collection of numbers and returns the result as an long.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the collection as an long.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given collection.
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumLong(c, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Sums all elements within the specified range in the input collection using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to a long.
     * @return the sum of all elements within the specified range of the collection as a long.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0L;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsLong(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                sum += func.applyAsLong(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return sum;
    }

    /**
     * Sums all elements in the given iterable of numbers and returns the result as a long.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to be summed.
     * @return the sum of all elements in the iterable as a long.
     * @see Iterables#sumLong(Iterable)
     */
    public static <T extends Number> long sumLong(final Iterable<? extends T> c) {
        return sumLong(c, Fn.numToLong());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to a long.
     * @return the sum of all elements in the iterable as a long.
     * @see Iterables#sumLong(Iterable, ToLongFunction)
     */
    public static <T> long sumLong(final Iterable<? extends T> c, final ToLongFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0L;
        }

        long sum = 0;

        for (final T e : c) {
            sum += func.applyAsLong(e);
        }

        return sum;
    }

    /**
     * Sums all elements in the given array of numbers and returns the result as a double.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @return the sum of all elements in the array as a double.
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final T[] a) {
        return sumDouble(a, Fn.numToDouble());
    }

    /**
     * Sums all elements within the specified range in the input array of numbers and returns the result as a double.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the array as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given array.
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final T[] a, final int fromIndex, final int toIndex) {
        return sumDouble(a, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Sums all elements in the given array using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param func the function to convert each element to a double.
     * @return the sum of all elements in the array as a double.
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final T[] a, final ToDoubleFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0D;
        }

        return sumDouble(a, 0, a.length, func);
    }

    /**
     * Sums all elements within the specified range in the input array using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the array.
     * @param a the array of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to a double.
     * @return the sum of all elements within the specified range of the array as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0D;
        }

        final KahanSummation summation = new KahanSummation();

        for (int i = fromIndex; i < toIndex; i++) {
            summation.add(func.applyAsDouble(a[i]));
        }

        return summation.sum();
    }

    /**
     * Sums all elements within the specified range in the input collection of numbers and returns the result as an double.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @return the sum of all elements within the specified range in the collection as an double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds for the given collection.
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return sumDouble(c, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Sums all elements within the specified range in the input collection using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the collection.
     * @param c the collection of elements to be summed.
     * @param fromIndex the starting index (inclusive) of the range to be summed.
     * @param toIndex the ending index (exclusive) of the range to be summed.
     * @param func the function to convert each element to a double.
     * @return the sum of all elements within the specified range of the collection as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0D;
        }

        final KahanSummation summation = new KahanSummation();

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                summation.add(func.applyAsDouble(list.get(i)));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                summation.add(func.applyAsDouble(e));

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return summation.sum();
    }

    /**
     * Sums all elements in the given iterable of numbers and returns the result as a double.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to be summed.
     * @return the sum of all elements in the iterable as a double.
     * @see Iterables#sumDouble(Iterable)
     */
    public static <T extends Number> double sumDouble(final Iterable<? extends T> c) {
        return sumDouble(c, Fn.numToDouble());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to a double.
     * @return the sum of all elements in the iterable as a double.
     * @see Iterables#sumDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double sumDouble(final Iterable<? extends T> c, final ToDoubleFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0D;
        }

        final Iterator<? extends T> iter = c.iterator();
        final KahanSummation summation = new KahanSummation();

        while (iter.hasNext()) {
            summation.add(func.applyAsDouble(iter.next()));
        }

        return summation.sum();
    }

    /**
     * Sums all elements in the given iterable of BigInteger and returns the result as a BigInteger.
     *
     * @param c the iterable of BigInteger elements to be summed.
     * @return the sum of all elements in the iterable as a BigInteger.
     * @see Iterables#sumBigInteger(Iterable)
     */
    public static BigInteger sumBigInteger(final Iterable<? extends BigInteger> c) {
        return sumBigInteger(c, Fn.identity());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to a BigInteger.
     *
     * @param <T> the type of elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to a BigInteger.
     * @return the sum of all elements in the iterable as a BigInteger.
     * @see Iterables#sumBigInteger(Iterable, Function)
     */
    public static <T> BigInteger sumBigInteger(final Iterable<? extends T> c, final Function<? super T, BigInteger> func) {
        if (isEmptyCollection(c)) {
            return BigInteger.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigInteger result = BigInteger.ZERO;
        BigInteger next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                result = result.add(next);
            }
        }

        return result;
    }

    /**
     * Sums all elements in the given iterable of BigDecimal and returns the result as a BigDecimal.
     *
     * @param c the iterable of BigDecimal elements to be summed.
     * @return the sum of all elements in the iterable as a BigDecimal.
     * @see Iterables#sumBigDecimal(Iterable)
     */
    public static BigDecimal sumBigDecimal(final Iterable<? extends BigDecimal> c) {
        return sumBigDecimal(c, Fn.identity());
    }

    /**
     * Sums all elements in the given iterable using the provided function to convert each element to a BigDecimal.
     *
     * @param <T> the type of elements in the iterable.
     * @param c the iterable of elements to be summed.
     * @param func the function to convert each element to a BigDecimal.
     * @return the sum of all elements in the iterable as a BigDecimal.
     * @see Iterables#sumBigDecimal(Iterable, Function)
     */
    public static <T> BigDecimal sumBigDecimal(final Iterable<? extends T> c, final Function<? super T, BigDecimal> func) {
        if (isEmptyCollection(c)) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigDecimal result = BigDecimal.ZERO;
        BigDecimal next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                result = result.add(next);
            }
        }

        return result;
    }

    /**
     * Calculates the average of the elements in the given array of numbers.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageInt(Number[])
     */
    public static <T extends Number> double averageInt(final T[] a) {
        return averageInt(a, Fn.numToInt());
    }

    /**
     * Calculates the average of the elements in the given array of numbers within the specified range.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageInt(Number[], int, int)
     */
    public static <T extends Number> double averageInt(final T[] a, final int fromIndex, final int toIndex) {
        return averageInt(a, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Calculates the average of the elements in the given array using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the array
     * @param a the array of numbers to calculate the average.
     * @param func the function to convert each element to an integer.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageInt(Object[], ToIntFunction)
     */
    public static <T> double averageInt(final T[] a, final ToIntFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageInt(a, 0, a.length, func);
    }

    /**
     * Calculates the average of the elements within the specified range in the input array using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to an integer.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageInt(Object[], int, int, ToIntFunction)
     */
    public static <T> double averageInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        long sum = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            sum += func.applyAsInt(a[i]);
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of the elements within the specified range in the input collection of numbers.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageInt(Collection, int, int)
     */
    public static <T extends Number> double averageInt(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageInt(c, fromIndex, toIndex, Fn.numToInt());
    }

    /**
     * Calculates the average of the elements within the specified range in the input collection using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to an integer.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageInt(Collection, int, int, ToIntFunction)
     */
    public static <T> double averageInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0;
        }

        long sum = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                sum += func.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                sum += func.applyAsInt(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return ((double) sum) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of the elements in the given iterable of numbers.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to calculate the average.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageInt(Iterable)
     */
    public static <T extends Number> double averageInt(final Iterable<? extends T> c) {
        return averageInt(c, Fn.numToInt());
    }

    /**
     * Calculates the average of the elements in the given iterable using the provided function to convert each element to an integer.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to calculate the average.
     * @param func the function to convert each element to an integer.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageInt(Iterable, ToIntFunction)
     */
    public static <T> double averageInt(final Iterable<? extends T> c, final ToIntFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0D;
        }

        long sum = 0;
        long count = 0;

        for (final T e : c) {
            sum += func.applyAsInt(e);
            count++;
        }

        return count == 0 ? 0D : ((double) sum) / count;
    }

    /**
     * Calculates the average of the elements in the given array of numbers.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageLong(Number[])
     */
    public static <T extends Number> double averageLong(final T[] a) {
        return averageLong(a, Fn.numToLong());
    }

    /**
     * Calculates the average of the elements within the specified range in the input array of numbers.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageLong(Number[], int, int)
     */
    public static <T extends Number> double averageLong(final T[] a, final int fromIndex, final int toIndex) {
        return averageLong(a, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Calculates the average of the elements in the given array using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the array
     * @param a the array of numbers to calculate the average.
     * @param func the function to convert each element to a long.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageLong(Object[], ToLongFunction)
     */
    public static <T> double averageLong(final T[] a, final ToLongFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageLong(a, 0, a.length, func);
    }

    /**
     * Calculates the average of the elements within the specified range in the input array using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the array
     * @param a the array of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to a long.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageLong(Object[], int, int, ToLongFunction)
     */
    public static <T> double averageLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sumLong(a, fromIndex, toIndex, func)) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of the elements in the given collection of numbers.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements in the collection as a double.
     * @see Iterables#averageLong(Collection, int, int)
     */
    public static <T extends Number> double averageLong(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageLong(c, fromIndex, toIndex, Fn.numToLong());
    }

    /**
     * Calculates the average of the elements within the specified range in the input collection using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to a long.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageLong(Collection, int, int, ToLongFunction)
     */
    public static <T> double averageLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0d;
        }

        return ((double) sumLong(c, fromIndex, toIndex, func)) / (toIndex - fromIndex);
    }

    /**
     * Calculates the average of the elements in the given iterable of numbers.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to calculate the average.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageLong(Iterable)
     */
    public static <T extends Number> double averageLong(final Iterable<? extends T> c) {
        return averageLong(c, Fn.numToLong());
    }

    /**
     * Calculates the average of the elements in the given iterable using the provided function to convert each element to a long.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to calculate the average.
     * @param func the function to convert each element to a long.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageLong(Iterable, ToLongFunction)
     */
    public static <T> double averageLong(final Iterable<? extends T> c, final ToLongFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0D;
        }

        long sum = 0;
        long count = 0;

        for (final T e : c) {
            sum += func.applyAsLong(e);
            count++;
        }

        return count == 0 ? 0D : ((double) sum) / count;
    }

    /**
     * Calculates the average of the elements in the given array of numbers.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageDouble(Number[])
     */
    public static <T extends Number> double averageDouble(final T[] a) {
        return averageDouble(a, Fn.numToDouble());
    }

    /**
     * Calculates the average of the elements within the specified range in the input array of numbers.
     *
     * @param <T> the type of the elements in the array, which must extend Number.
     * @param a the array of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageDouble(Number[], int, int)
     */
    public static <T extends Number> double averageDouble(final T[] a, final int fromIndex, final int toIndex) {
        return averageDouble(a, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Calculates the average of the elements in the given array using the provided function to convert each element to a double.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * double avgLength = N.averageDouble(names, String::length);
     * // Returns: 5.0 ((5 + 3 + 7) / 3)
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array to calculate the average.
     * @param func the function to convert each element to a double.
     * @return the average of the elements in the array as a double.
     * @see Iterables#averageDouble(Object[], ToDoubleFunction)
     */
    public static <T> double averageDouble(final T[] a, final ToDoubleFunction<? super T> func) {
        if (isEmpty(a)) {
            return 0d;
        }

        return averageDouble(a, 0, a.length, func);
    }

    /**
     * Calculates the average of the elements within the specified range in the input array using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the array
     * @param a the array to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to a double.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageDouble(Object[], int, int, ToDoubleFunction)
     */
    public static <T> double averageDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (fromIndex == toIndex) {
            return 0d;
        }

        return Iterables.averageDouble(a, fromIndex, toIndex, func).orElseZero();
    }

    /**
     * Calculates the average of the elements in the given collection of numbers.
     *
     * @param <T> the type of the elements in the collection, which must extend Number.
     * @param c the collection of numbers to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @return the average of the elements in the collection as a double.
     * @see Iterables#averageDouble(Collection, int, int)
     */
    public static <T extends Number> double averageDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex) {
        return averageDouble(c, fromIndex, toIndex, Fn.numToDouble());
    }

    /**
     * Calculates the average of the elements within the specified range in the input collection using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection to calculate the average.
     * @param fromIndex the starting index (inclusive) of the range.
     * @param toIndex the ending index (exclusive) of the range.
     * @param func the function to convert each element to a double.
     * @return the average of the elements within the specified range as a double.
     * @throws IndexOutOfBoundsException if the specified range is out of bounds.
     * @see Iterables#averageDouble(Collection, int, int, ToDoubleFunction)
     */
    public static <T> double averageDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> func)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (fromIndex == toIndex) {
            return 0d;
        }

        return Iterables.averageDouble(c, fromIndex, toIndex, func).orElseZero();
    }

    /**
     * Calculates the average of the elements in the given iterable of numbers.
     *
     * @param <T> the type of the elements in the iterable, which must extend Number.
     * @param c the iterable of numbers to calculate the average.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageDouble(Iterable)
     */
    public static <T extends Number> double averageDouble(final Iterable<? extends T> c) {
        return averageDouble(c, Fn.numToDouble());
    }

    /**
     * Calculates the average of the elements in the given iterable using the provided function to convert each element to a double.
     *
     * @param <T> the type of the elements in the iterable.
     * @param c the iterable of elements to calculate the average.
     * @param func the function to convert each element to a double.
     * @return the average of the elements in the iterable as a double.
     * @see Iterables#averageDouble(Iterable, ToDoubleFunction)
     */
    public static <T> double averageDouble(final Iterable<? extends T> c, final ToDoubleFunction<? super T> func) {
        if (isEmptyCollection(c)) {
            return 0d;
        }

        return Iterables.averageDouble(c, func).orElseZero();
    }

    /**
     * Calculates the average of the elements in the given iterable of BigInteger.
     *
     * @param c the iterable of BigInteger elements to calculate the average.
     * @return the average of the elements in the iterable as a BigDecimal.
     * @see Iterables#averageBigInteger(Iterable)
     */
    public static BigDecimal averageBigInteger(final Iterable<? extends BigInteger> c) {
        return averageBigInteger(c, Fn.identity());
    }

    /**
     * Calculates the average of the elements in the given iterable using the provided function to convert each element to a BigInteger.
     *
     * @param <T> the type of elements in the iterable.
     * @param c the iterable of elements to calculate the average.
     * @param func the function to convert each element to a BigInteger.
     * @return the average of the elements in the iterable as a BigDecimal.
     * @see Iterables#averageBigInteger(Iterable, Function)
     */
    public static <T> BigDecimal averageBigInteger(final Iterable<? extends T> c, final Function<? super T, BigInteger> func) {
        if (isEmptyCollection(c)) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigInteger sum = BigInteger.ZERO;
        long cnt = 0;
        BigInteger next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                sum = sum.add(next);
                cnt++;
            }
        }

        return cnt == 0 ? BigDecimal.ZERO : new BigDecimal(sum).divide(BigDecimal.valueOf(cnt));
    }

    /**
     * Calculates the average of the elements in the given iterable of BigDecimal.
     *
     * @param c the iterable of BigDecimal elements to calculate the average.
     * @return the average of the elements in the iterable as a BigDecimal.
     * @see Iterables#averageBigDecimal(Iterable)
     */
    public static BigDecimal averageBigDecimal(final Iterable<? extends BigDecimal> c) {
        return averageBigDecimal(c, Fn.identity());
    }

    /**
     * Calculates the average of the elements in the given iterable using the provided function to convert each element to a BigDecimal.
     *
     * @param <T> the type of elements in the iterable.
     * @param c the iterable of elements to calculate the average.
     * @param func the function to convert each element to a BigDecimal.
     * @return the average of the elements in the iterable as a BigDecimal.
     * @see Iterables#averageBigDecimal(Iterable, Function)
     */
    public static <T> BigDecimal averageBigDecimal(final Iterable<? extends T> c, final Function<? super T, BigDecimal> func) {
        if (isEmptyCollection(c)) {
            return BigDecimal.ZERO;
        }

        final Iterator<? extends T> iter = c.iterator();
        BigDecimal sum = BigDecimal.ZERO;
        long cnt = 0;
        BigDecimal next = null;

        while (iter.hasNext()) {
            next = func.apply(iter.next());

            if (next != null) {
                sum = sum.add(next);
                cnt++;
            }
        }

        return cnt == 0 ? BigDecimal.ZERO : sum.divide(BigDecimal.valueOf(cnt));
    }

    /**
     * Returns the smaller of two char values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char smaller = N.min('a', 'z');      // Returns 'a'
     * char digit = N.min('5', '2');        // Returns '2'
     * char same = N.min('x', 'x');         // Returns 'x'
     * }</pre>
     *
     * @param a the first char value
     * @param b the second char value
     * @return the smaller of the two input values
     * @see #min(char, char, char)
     * @see #min(char...)
     * @see #max(char, char)
     */
    public static char min(final char a, final char b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two byte values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte smaller = N.min((byte) 10, (byte) 20);   // Returns 10
     * byte negative = N.min((byte) -5, (byte) 3);   // Returns -5
     * byte same = N.min((byte) 7, (byte) 7);        // Returns 7
     * }</pre>
     *
     * @param a the first byte value
     * @param b the second byte value
     * @return the smaller of the two input values
     * @see #min(byte, byte, byte)
     * @see #min(byte...)
     * @see #max(byte, byte)
     */
    public static byte min(final byte a, final byte b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two short values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short smaller = N.min((short) 100, (short) 200);   // Returns 100
     * short negative = N.min((short) -50, (short) 30);   // Returns -50
     * short same = N.min((short) 75, (short) 75);        // Returns 75
     * }</pre>
     *
     * @param a the first short value
     * @param b the second short value
     * @return the smaller of the two input values
     * @see #min(short, short, short)
     * @see #min(short...)
     * @see #max(short, short)
     */
    public static short min(final short a, final short b) {
        return (a <= b) ? a : b;
    }

    /**
     * Returns the smaller of two int values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int smaller = N.min(10, 20);        // Returns 10
     * int negative = N.min(-5, 3);        // Returns -5
     * int same = N.min(7, 7);             // Returns 7
     * }</pre>
     *
     * @param a the first int value
     * @param b the second int value
     * @return the smaller of the two input values
     * @see #min(int, int, int)
     * @see #min(int...)
     * @see #max(int, int)
     * @see Math#min(int, int)
     */
    public static int min(final int a, final int b) {
        return Math.min(a, b);
    }

    /**
     * Returns the smaller of two long values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long smaller = N.min(1000L, 2000L);       // Returns 1000L
     * long negative = N.min(-500L, 300L);       // Returns -500L
     * long same = N.min(999L, 999L);            // Returns 999L
     * }</pre>
     *
     * @param a the first long value
     * @param b the second long value
     * @return the smaller of the two input values
     * @see #min(long, long, long)
     * @see #min(long...)
     * @see #max(long, long)
     * @see Math#min(long, long)
     */
    public static long min(final long a, final long b) {
        return Math.min(a, b);
    }

    /**
     * Returns the smaller of two float values.
     * Uses {@link Math#min(float, float)} which handles NaN values according to IEEE 754:
     * if either value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float smaller = N.min(1.5f, 2.3f);           // Returns 1.5f
     * float nan = N.min(1.0f, Float.NaN);          // Returns NaN
     * float negZero = N.min(0.0f, -0.0f);          // Returns -0.0f
     * }</pre>
     *
     * @param a the first float value
     * @param b the second float value
     * @return the smaller of the two values; NaN if either value is NaN
     * @see #min(float, float, float)
     * @see #min(float...)
     * @see #max(float, float)
     * @see Math#min(float, float)
     */
    public static float min(final float a, final float b) {
        return Math.min(a, b);
    }

    /**
     * Returns the smaller of two double values.
     * Uses {@link Math#min(double, double)} which handles NaN values according to IEEE 754:
     * if either value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double smaller = N.min(1.5, 2.3);           // Returns 1.5
     * double nan = N.min(1.0, Double.NaN);        // Returns NaN
     * double negZero = N.min(0.0, -0.0);          // Returns -0.0
     * }</pre>
     *
     * @param a the first double value
     * @param b the second double value
     * @return the smaller of the two values; NaN if either value is NaN
     * @see #min(double, double, double)
     * @see #min(double...)
     * @see #max(double, double)
     * @see Math#min(double, double)
     */
    public static double min(final double a, final double b) {
        return Math.min(a, b);
    }

    /**
     * Returns the smaller of two comparable values based on their natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String smaller = N.min("apple", "banana");       // Returns "apple"
     * Integer min = N.min(10, 20);                     // Returns 10
     * Integer withNull = N.min(5, null);               // Returns 5 (null is treated as maximum)
     * }</pre>
     *
     * @param <T> the type of the comparable values
     * @param a the first comparable value
     * @param b the second comparable value
     * @return the smaller of the two values based on natural ordering; {@code null} if both are {@code null}
     * @see #min(Object, Object, Comparator)
     * @see #max(Comparable, Comparable)
     */
    public static <T extends Comparable<? super T>> T min(final T a, final T b) {
        return min(a, b, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smaller of two values based on the specified comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String min = N.min("apple", "banana", String.CASE_INSENSITIVE_ORDER);  // Returns "apple"
     *
     * // Custom comparator for length
     * String shorter = N.min("elephant", "cat", Comparator.comparing(String::length));  // Returns "cat"
     *
     * // Reverse order
     * Integer max = N.min(10, 20, Comparator.reverseOrder());  // Returns 20
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to compare
     * @param b the second value to compare
     * @param cmp the Comparator to compare the values; if {@code null}, natural ordering with nulls last is used
     * @return the smaller of the two values based on the comparator
     * @see #min(Comparable, Comparable)
     * @see #max(Object, Object, Comparator)
     */
    public static <T> T min(final T a, final T b, final Comparator<? super T> cmp) {
        if (cmp == null) {
            return ((Comparator<T>) NULL_MAX_COMPARATOR).compare(a, b) <= 0 ? a : b;
        } else {
            return cmp.compare(a, b) <= 0 ? a : b;
        }
    }

    /**
     * Returns the smallest of three char values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char smallest = N.min('z', 'a', 'm');        // Returns 'a'
     * char digits = N.min('5', '2', '9');          // Returns '2'
     * char same = N.min('x', 'x', 'x');            // Returns 'x'
     * }</pre>
     *
     * @param a the first char value
     * @param b the second char value
     * @param c the third char value
     * @return the smallest of the three input values.
     * @see #min(char, char)
     * @see #min(char...)
     * @see #max(char, char, char)
     */
    public static char min(final char a, final char b, final char c) {
        final char m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the smallest of three byte values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte smallest = N.min((byte) 15, (byte) 5, (byte) 10);      // Returns 5
     * byte negative = N.min((byte) -5, (byte) -20, (byte) -10);   // Returns -20
     * byte same = N.min((byte) 7, (byte) 7, (byte) 7);            // Returns 7
     * }</pre>
     *
     * @param a the first byte value
     * @param b the second byte value
     * @param c the third byte value
     * @return the smallest of the three input values.
     * @see #min(byte, byte)
     * @see #min(byte...)
     * @see #max(byte, byte, byte)
     */
    public static byte min(final byte a, final byte b, final byte c) {
        final byte m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the smallest of three short values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short smallest = N.min((short) 150, (short) 50, (short) 100);        // Returns 50
     * short negative = N.min((short) -50, (short) -200, (short) -100);     // Returns -200
     * short same = N.min((short) 75, (short) 75, (short) 75);              // Returns 75
     * }</pre>
     *
     * @param a the first short value
     * @param b the second short value
     * @param c the third short value
     * @return the smallest of the three input values.
     * @see #min(short, short)
     * @see #min(short...)
     * @see #max(short, short, short)
     */
    public static short min(final short a, final short b, final short c) {
        final short m = (a <= b) ? a : b;

        return (m <= c) ? m : c;
    }

    /**
     * Returns the smallest of three int values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int smallest = N.min(15, 5, 10);        // Returns 5
     * int negative = N.min(-5, -20, -10);     // Returns -20
     * int same = N.min(7, 7, 7);              // Returns 7
     * }</pre>
     *
     * @param a the first int value
     * @param b the second int value
     * @param c the third int value
     * @return the smallest of the three input values.
     * @see #min(int, int)
     * @see #min(int...)
     * @see #max(int, int, int)
     */
    public static int min(final int a, final int b, final int c) {
        final int m = Math.min(a, b);

        return Math.min(m, c);
    }

    /**
     * Returns the smallest of three long values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long smallest = N.min(1500L, 500L, 1000L);        // Returns 500L
     * long negative = N.min(-500L, -2000L, -1000L);     // Returns -2000L
     * long same = N.min(750L, 750L, 750L);              // Returns 750L
     * }</pre>
     *
     * @param a the first long value
     * @param b the second long value
     * @param c the third long value
     * @return the smallest of the three input values.
     * @see #min(long, long)
     * @see #min(long...)
     * @see #max(long, long, long)
     */
    public static long min(final long a, final long b, final long c) {
        final long m = Math.min(a, b);

        return Math.min(m, c);
    }

    /**
     * Returns the smallest of three float values.
     * Uses {@link Math#min(float, float)} which handles NaN values according to IEEE 754:
     * if any value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float smallest = N.min(2.5f, 1.0f, 2.0f);       // Returns 1.0f
     * float negative = N.min(-1.0f, -2.0f, -0.5f);    // Returns -2.0f
     * float nan = N.min(1.0f, Float.NaN, 2.0f);       // Returns NaN
     * float zero = N.min(0.0f, -0.0f, 1.0f);          // Returns -0.0f
     * }</pre>
     *
     * @param a the first float value
     * @param b the second float value
     * @param c the third float value
     * @return the smallest of the three values; NaN if any value is NaN.
     * @see #min(float, float)
     * @see #min(float...)
     * @see #max(float, float, float)
     * @see Math#min(float, float)
     */
    public static float min(final float a, final float b, final float c) {
        return Math.min(Math.min(a, b), c);
    }

    /**
     * Returns the smallest of three double values.
     * Uses {@link Math#min(double, double)} which handles NaN values according to IEEE 754:
     * if any value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double smallest = N.min(2.5, 1.0, 2.0);       // Returns 1.0
     * double negative = N.min(-1.0, -2.0, -0.5);    // Returns -2.0
     * double nan = N.min(1.0, Double.NaN, 2.0);     // Returns NaN
     * double zero = N.min(0.0, -0.0, 1.0);          // Returns -0.0
     * }</pre>
     *
     * @param a the first double value
     * @param b the second double value
     * @param c the third double value
     * @return the smallest of the three values; NaN if any value is NaN.
     * @see #min(double, double)
     * @see #min(double...)
     * @see #max(double, double, double)
     * @see Math#min(double, double)
     */
    public static double min(final double a, final double b, final double c) {
        return Math.min(Math.min(a, b), c);
    }

    /**
     * Returns the smallest of three comparable values based on their natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String smallest = N.min("mango", "apple", "zebra");     // Returns "apple"
     * Integer min = N.min(20, 10, 15);                        // Returns 10
     * Integer withNull = N.min(5, null, 10);                  // Returns 5 (null is treated as maximum)
     * }</pre>
     *
     * @param <T> the type of the comparable values
     * @param a the first comparable value
     * @param b the second comparable value
     * @param c the third comparable value
     * @return the smallest of the three values based on natural ordering.
     * @see #min(Comparable, Comparable)
     * @see #min(Object, Object, Object, Comparator)
     * @see #max(Comparable, Comparable, Comparable)
     */
    public static <T extends Comparable<? super T>> T min(final T a, final T b, final T c) {
        return min(a, b, c, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smallest of three values based on the specified comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String shortest = N.min("elephant", "cat", "dog", Comparator.comparing(String::length));  // Returns "cat"
     *
     * // Case-insensitive comparison
     * String min = N.min("APPLE", "banana", "Cherry", String.CASE_INSENSITIVE_ORDER);  // Returns "APPLE"
     *
     * // Reverse order (finds maximum with regular comparator)
     * Integer max = N.min(10, 20, 15, Comparator.reverseOrder());  // Returns 20
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value to compare
     * @param b the second value to compare
     * @param c the third value to compare
     * @param cmp the Comparator to compare the values; if {@code null}, natural ordering with nulls last is used
     * @return the smallest of the three values based on the comparator.
     * @see #min(Object, Object, Comparator)
     * @see #min(Comparable, Comparable, Comparable)
     * @see #max(Object, Object, Object, Comparator)
     */
    public static <T> T min(final T a, final T b, final T c, final Comparator<? super T> cmp) {
        return min(min(a, b, cmp), c, cmp);
    }

    /**
     * Returns the smallest value in the specified char array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char min1 = N.min('z', 'a', 'm', 'b');    // Returns 'a'
     *
     * char[] letters = {'x', 'y', 'a', 'z'};
     * char min2 = N.min(letters);               // Returns 'a'
     *
     * char single = N.min('q');                 // Returns 'q'
     * }</pre>
     *
     * @param a the array or varargs of char values, must not be {@code null} or empty
     * @return the smallest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(char[], int, int)
     * @see #max(char...)
     * @see #median(char...)
     */
    public static char min(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty"); //NOSONAR

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest char value within the specified range in the array.
     *
     * @param a the array of char values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest char value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(char...)
     * @see #max(char[], int, int)
     */
    public static char min(final char[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        char min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified byte array or varargs.
     *
     * @param a the array or varargs of byte values, must not be {@code null} or empty
     * @return the smallest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(byte[], int, int)
     * @see #max(byte...)
     */
    public static byte min(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest byte value within the specified range in the array.
     *
     * @param a the array of byte values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest byte value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(byte...)
     * @see #max(byte[], int, int)
     */
    public static byte min(final byte[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        byte min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified short array or varargs.
     *
     * @param a the array or varargs of short values, must not be {@code null} or empty
     * @return the smallest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(short[], int, int)
     * @see #max(short...)
     */
    public static short min(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest short value within the specified range in the array.
     *
     * @param a the array of short values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest short value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(short...)
     * @see #max(short[], int, int)
     */
    public static short min(final short[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        short min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified int array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int min1 = N.min(5, 2, 8, 1, 9);      // Returns 1
     *
     * int[] numbers = {10, 20, 5, 30};
     * int min2 = N.min(numbers);            // Returns 5
     *
     * int single = N.min(42);               // Returns 42
     * }</pre>
     *
     * @param a the array or varargs of int values, must not be {@code null} or empty
     * @return the smallest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(int[], int, int)
     * @see #max(int...)
     * @see #median(int...)
     */
    public static int min(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest int value within the specified range in the array.
     *
     * @param a the array of int values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest int value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(int...)
     * @see #max(int[], int, int)
     */
    public static int min(final int[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        int min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified long array or varargs.
     *
     * @param a the array or varargs of long values, must not be {@code null} or empty
     * @return the smallest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(long[], int, int)
     * @see #max(long...)
     */
    public static long min(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest long value within the specified range in the array.
     *
     * @param a the array of long values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest long value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(long...)
     * @see #max(long[], int, int)
     */
    public static long min(final long[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        long min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified float array or varargs.
     * NaN values are skipped; if all values are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float min1 = N.min(1.5f, 2.3f, 0.5f);     // Returns 0.5f
     *
     * float[] values = {10.5f, 20.3f, 5.1f};
     * float min2 = N.min(values);               // Returns 5.1f
     *
     * float withNaN = N.min(1.0f, Float.NaN, 2.0f);  // Returns 1.0f (NaN is skipped)
     * }</pre>
     *
     * @param a the array or varargs of float values, must not be {@code null} or empty
     * @return the smallest value in the array; NaN if all values are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(float[], int, int)
     * @see #max(float...)
     * @see IEEE754rUtil#min(float[]) that handles NaN differently
     */
    public static float min(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest float value within the specified range in the array.
     * NaN values are skipped; if all values in the range are NaN, returns NaN.
     *
     * @param a the array of float values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest float value within the specified range; NaN if all values in the range are NaN
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(float...)
     * @see #max(float[], int, int)
     * @see IEEE754rUtil#min(float[]) that handles NaN differently
     */
    public static float min(final float[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        float min = a[fromIndex];

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Float.isNaN(a[i])) {
                continue;
            } else if (Float.isNaN(min)) {
                min = a[i];
            } else {
                min = Math.min(min, a[i]);
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified double array or varargs.
     * NaN values are skipped; if all values are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double min1 = N.min(1.5, 2.3, 0.5);       // Returns 0.5
     *
     * double[] values = {10.5, 20.3, 5.1};
     * double min2 = N.min(values);              // Returns 5.1
     *
     * double withNaN = N.min(1.0, Double.NaN, 2.0);  // Returns 1.0 (NaN is skipped)
     * }</pre>
     *
     * @param a the array or varargs of double values, must not be {@code null} or empty
     * @return the smallest value in the array; NaN if all values are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(double[], int, int)
     * @see #max(double...)
     * @see IEEE754rUtil#min(double[]) that handles NaN differently
     */
    public static double min(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest double value within the specified range in the array.
     * NaN values are skipped; if all values in the range are NaN, returns NaN.
     *
     * @param a the array of double values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest double value within the specified range; NaN if all values in the range are NaN
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(double...)
     * @see #max(double[], int, int)
     * @see IEEE754rUtil#min(double[]) that handles NaN differently
     */
    public static double min(final double[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        double min = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Double.isNaN(a[i])) {
                continue;
            } else if (Double.isNaN(min)) {
                min = a[i];
            } else {
                min = Math.min(min, a[i]);
            }
        }

        return min;
    }

    /**
     * Returns the smallest value in the specified array based on their natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"zebra", "apple", "mango"};
     * String min = N.min(words);           // Returns "apple"
     *
     * Integer[] nums = {5, null, 2, 8};
     * Integer minNum = N.min(nums);        // Returns 2 (null is treated as maximum)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @return the smallest value in the array based on natural ordering
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(Comparable[], int, int)
     * @see #min(Object[], Comparator)
     * @see #max(Comparable[])
     * @see Iterables#min(Comparable[])
     */
    public static <T extends Comparable<? super T>> T min(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length);
    }

    /**
     * Returns the smallest value within the specified range in the array based on their natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null}
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest value within the specified range based on natural ordering
     * @throws IllegalArgumentException if the array is {@code null} or the range is empty
     * @see #min(Comparable[])
     * @see #min(Object[], int, int, Comparator)
     * @see #max(Comparable[], int, int)
     * @see Iterables#min(Object[], Comparator)
     */
    public static <T extends Comparable<? super T>> T min(final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        return min(a, fromIndex, toIndex, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smallest value in the specified array according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"zebra", "apple", "mango"};
     * String min = N.min(words, String.CASE_INSENSITIVE_ORDER);  // Returns "apple"
     *
     * // Custom comparator for length
     * String shortest = N.min(words, Comparator.comparing(String::length));  // Returns "apple" or "mango"
     *
     * // Reverse order
     * String max = N.min(words, Comparator.reverseOrder());  // Returns "zebra"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls last is used
     * @return the smallest value in the array according to the comparator
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(Object[], int, int, Comparator)
     * @see #max(Object[], Comparator)
     * @see Iterables#min(Object[], Comparator)
     */
    public static <T> T min(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return min(a, 0, a.length, cmp);
    }

    /**
     * Returns the smallest value within the specified range of the array according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "zebra", "mango", "banana", "cherry"};
     * String min = N.min(words, 1, 4, String.CASE_INSENSITIVE_ORDER);  // Returns "banana" (from index 1 to 3)
     *
     * // Custom comparator for length
     * String shortest = N.min(words, 0, 3, Comparator.comparing(String::length));  // Returns "zebra" or "mango"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls last is used
     * @return the smallest value within the specified range according to the comparator
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #min(Object[], Comparator)
     * @see #max(Object[], int, int, Comparator)
     * @see Iterables#min(Object[], Comparator)
     */
    @MayReturnNull
    public static <T> T min(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;
        final boolean isNullMinComparator = cmp == NULL_MIN_COMPARATOR;

        T candidate = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (cmp.compare(a[i], candidate) < 0) {
                candidate = a[i];
            }

            if (isNullMinComparator && candidate == null) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the smallest value within the specified range of the collection based on natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "zebra", "mango", "banana", "cherry");
     * String min = N.min(words, 1, 4);  // Returns "banana" (from index 1 to 3)
     *
     * List<Integer> numbers = Arrays.asList(10, 5, 8, 3, 15);
     * Integer smallest = N.min(numbers, 0, 3);  // Returns 5 (from index 0 to 2)
     * }</pre>
     *
     * @param <T> the type of comparable elements in the collection
     * @param c the collection of comparable values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the smallest value within the specified range based on natural ordering
     * @throws IllegalArgumentException if the collection is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #min(Collection, int, int, Comparator)
     * @see #max(Collection, int, int)
     * @see Iterables#min(Iterable)
     */
    public static <T extends Comparable<? super T>> T min(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return min(c, fromIndex, toIndex, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smallest value within the specified range of the collection according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "zebra", "mango", "banana", "cherry");
     * String min = N.min(words, 1, 4, String.CASE_INSENSITIVE_ORDER);  // Returns "banana" (from index 1 to 3)
     *
     * // Custom comparator for length
     * String shortest = N.min(words, 0, 3, Comparator.comparing(String::length));  // Returns "zebra" or "mango"
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection of values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls last is used
     * @return the smallest value within the specified range according to the comparator
     * @throws IllegalArgumentException if the collection is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #min(Collection, int, int)
     * @see #max(Collection, int, int, Comparator)
     * @see Iterables#min(Iterable, Comparator)
     */
    @MayReturnNull
    public static <T> T min(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c) || toIndex - fromIndex < 1 || fromIndex >= c.size()) {
            throw new IllegalArgumentException("The size of collection cannot be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;
        final boolean isNullMinComparator = cmp == NULL_MIN_COMPARATOR;

        T candidate = null;
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            candidate = list.get(fromIndex);

            for (int i = fromIndex + 1; i < toIndex; i++) {
                e = list.get(i);

                if (cmp.compare(e, candidate) < 0) {
                    candidate = e;
                }

                if (isNullMinComparator && candidate == null) { // NOSONAR
                    return null;
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex; i++) {
                if (i < fromIndex) {
                    it.next();
                } else if (i == fromIndex) {
                    candidate = it.next();
                } else {
                    e = it.next();

                    if (cmp.compare(e, candidate) < 0) {
                        candidate = e;
                    }

                    if (isNullMinComparator && candidate == null) { // NOSONAR
                        return null;
                    }
                }
            }
        }

        return candidate;
    }

    /**
     * Returns the smallest value in the iterable based on natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("zebra", "apple", "mango");
     * String min = N.min(words);  // Returns "apple"
     *
     * Iterable<Integer> numbers = Arrays.asList(10, 5, 20, 3);
     * Integer smallest = N.min(numbers);  // Returns 3
     * }</pre>
     *
     * @param <T> the type of comparable elements in the iterable
     * @param c the iterable of comparable values, must not be {@code null} or empty
     * @return the smallest value in the iterable based on natural ordering
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #min(Iterable, Comparator)
     * @see #max(Iterable)
     * @see Iterables#min(Iterable)
     */
    public static <T extends Comparable<? super T>> T min(final Iterable<? extends T> c) throws IllegalArgumentException {
        return min(c, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smallest value in the iterable according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("zebra", "apple", "mango");
     * String min = N.min(words, String.CASE_INSENSITIVE_ORDER);  // Returns "apple"
     *
     * // Custom comparator for length
     * String shortest = N.min(words, Comparator.comparing(String::length));  // Returns "apple" or "mango"
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls last is used
     * @return the smallest value in the iterable according to the comparator
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #min(Iterable)
     * @see #max(Iterable, Comparator)
     * @see Iterables#min(Iterable, Comparator)
     */
    public static <T> T min(final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return min(coll, 0, coll.size(), cmp);
        }

        final Iterator<? extends T> iter = Iterables.iterateNonEmpty(c, "The specified Collection/Iterable/Iterator cannot be null or empty"); //NOSONAR

        return min(iter, cmp);
    }

    /**
     * Returns the smallest value from the iterator based on natural ordering.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("zebra", "apple", "mango").iterator();
     * String min = N.min(words);  // Returns "apple"
     *
     * Iterator<Integer> numbers = Arrays.asList(10, 5, 20, 3).iterator();
     * Integer smallest = N.min(numbers);  // Returns 3
     * }</pre>
     *
     * @param <T> the type of comparable elements in the iterator
     * @param iter the iterator of comparable values, must not be {@code null} or empty
     * @return the smallest value from the iterator based on natural ordering
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #min(Iterator, Comparator)
     * @see #max(Iterator)
     * @see Iterables#min(Iterator)
     */
    public static <T extends Comparable<? super T>> T min(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return min(iter, (Comparator<T>) NULL_MAX_COMPARATOR);
    }

    /**
     * Returns the smallest value from the iterator according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered maximum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("zebra", "apple", "mango").iterator();
     * String min = N.min(words, String.CASE_INSENSITIVE_ORDER);  // Returns "apple"
     *
     * // Custom comparator for length
     * Iterator<String> words2 = Arrays.asList("zebra", "apple", "mango").iterator();
     * String shortest = N.min(words2, Comparator.comparing(String::length));  // Returns "apple" or "mango"
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls last is used
     * @return the smallest value from the iterator according to the comparator
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #min(Iterator)
     * @see #max(Iterator, Comparator)
     * @see Iterables#min(Iterator, Comparator)
     */
    @MayReturnNull
    public static <T> T min(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(!isEmpty(iter), "The specified Collection/Iterable/Iterator cannot be null or empty");
        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;
        final boolean isNullMinComparator = cmp == NULL_MIN_COMPARATOR;

        T candidate = iter.next();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (cmp.compare(e, candidate) < 0) {
                candidate = e;
            }

            if (isNullMinComparator && candidate == null) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum element from the array based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple smallest elements, the first one will be returned.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "pie", "zoo"};
     * String shortest = N.minBy(words, String::length);  // Returns "pie"
     *
     * Person[] people = {new Person("Alice", 30), new Person("Bob", 25)};
     * Person youngest = N.minBy(people, Person::getAge);  // Returns Bob
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the minimum element based on the extracted key
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #min(Object[], Comparator)
     * @see #maxBy(Object[], Function)
     * @see Comparators#nullsLastBy(Function)
     * @see Iterables#minBy(Object[], Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T minBy(final T[] a, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return min(a, Comparators.nullsLastBy(keyExtractor));
    }

    /**
     * Returns the minimum element from the iterable based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple smallest elements, the first one will be returned.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "pie", "zoo");
     * String shortest = N.minBy(words, String::length);  // Returns "pie"
     *
     * List<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25));
     * Person youngest = N.minBy(people, Person::getAge);  // Returns Bob
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the minimum element based on the extracted key
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #min(Iterable, Comparator)
     * @see #maxBy(Iterable, Function)
     * @see Comparators#nullsLastBy(Function)
     * @see Iterables#minBy(Iterable, Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T minBy(final Iterable<? extends T> c, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return min(c, Comparators.nullsLastBy(keyExtractor));
    }

    /**
     * Returns the minimum element from the iterator based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple smallest elements, the first one will be returned.
     * Null values are considered to be maximum (placed last when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("apple", "pie", "zoo").iterator();
     * String shortest = N.minBy(words, String::length);  // Returns "pie"
     *
     * Iterator<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25)).iterator();
     * Person youngest = N.minBy(people, Person::getAge);  // Returns Bob
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the minimum element based on the extracted key
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #min(Iterator, Comparator)
     * @see #maxBy(Iterator, Function)
     * @see Comparators#nullsLastBy(Function)
     * @see Iterables#minBy(Iterator, Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T minBy(final Iterator<? extends T> iter, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return min(iter, Comparators.nullsLastBy(keyExtractor));
    }

    /**
     * Returns a list containing the smallest elements in the specified array based on their natural ordering. Null values are considered to be maximum here.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to fetch the smallest elements.
     * @return a list containing the smallest elements in the array. If the array is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final T[] a) {
        return minAll(a, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list containing the smallest elements in the specified array according to the provided comparator.
     *
     * @param <T>the type of elements in the array.
     * @param a the array to fetch the smallest elements.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing the smallest elements in the array. If the array is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> minAll(final T[] a, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candidate = a[0];
        int cp = 0;

        result.add(candidate);

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], candidate);

            if (cp == 0) {
                result.add(a[i]);
            } else if (cp < 0) {
                result.clear();
                result.add(a[i]);
                candidate = a[i];
            }
        }

        return result;
    }

    /**
     * Returns a list containing the smallest elements in the specified iterable based on their natural ordering. Null values are considered to be maximum here.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to fetch the smallest elements.
     * @return a list containing the smallest elements in the iterable. If the iterable is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final Iterable<? extends T> c) {
        return minAll(c, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list containing the smallest elements in the specified iterable according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to fetch the smallest elements.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing the smallest elements in the iterable. If the iterable is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> minAll(final Iterable<? extends T> c, final Comparator<? super T> cmp) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>();
        }

        return minAll(c.iterator(), cmp);
    }

    /**
     * Returns a list containing the smallest elements in the specified iterator based on their natural ordering. Null values are considered to be maximum here.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to fetch the smallest elements.
     * @return a list containing the smallest elements in the iterator. If the iterator is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> minAll(final Iterator<? extends T> iter) {
        return minAll(iter, NULL_MAX_COMPARATOR);
    }

    /**
     * Returns a list containing the smallest elements in the specified iterator according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to fetch the smallest elements.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing the smallest elements in the iterator. If the iterator is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> minAll(final Iterator<? extends T> iter, Comparator<? super T> cmp) {
        cmp = cmp == null ? (Comparator<T>) NULL_MAX_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candidate = iter.next();
        T next = null;
        int cp = 0;

        result.add(candidate);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candidate);

            if (cp == 0) {
                result.add(next);
            } else if (cp < 0) {
                result.clear();
                result.add(next);
                candidate = next;
            }
        }

        return result;
    }

    /**
     * Returns the minimum value extracted from the specified array or a default value if the array is {@code null} or empty. Null values are considered to be maximum here.
     *
     * <p><b>Note:</b> This method is marked as {@code @Beta} and its API may change in future versions.</p>
     *
     * @param <T> the type of elements in the input array.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param a the array to extract the minimum value from.
     * @param valueExtractor the function to extract values from the array elements for comparison.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the minimum extracted value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final T[] a, final Function<? super T, ? extends R> valueExtractor,
            final R defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        R candidate = valueExtractor.apply(a[0]);
        R next = null;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.apply(a[i]);

            if (candidate == null || (next != null && (next.compareTo(candidate) < 0))) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum value extracted from the specified iterable or a default value if the iterable is {@code null} or empty. Null values are considered to be maximum here.
     *
     * @param <T> the type of elements in the input iterable.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param c the iterable to extract the minimum value from.
     * @param valueExtractor the function to extract values from the iterable elements for comparison.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the minimum extracted value or the default value if the iterable is {@code null} or empty.
     */
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final Iterable<? extends T> c,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return minOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum value extracted from the specified iterator or a default value if the iterator is {@code null} or empty. Null values are considered to be maximum here.
     *
     * @param <T> the type of elements in the input iterator.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param iter the iterator to extract the minimum value from.
     * @param valueExtractor the function to extract values from the iterator elements for comparison.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the minimum extracted value or the default value if the iterator is {@code null} or empty.
     */
    public static <T, R extends Comparable<? super R>> R minOrDefaultIfEmpty(final Iterator<? extends T> iter,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        R candidate = valueExtractor.apply(iter.next());
        R next = null;

        while (iter.hasNext()) {
            next = valueExtractor.apply(iter.next());

            if (candidate == null || (next != null && (next.compareTo(candidate) < 0))) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum integer value extracted from the array or a default value if the array is {@code null} or empty.
     *
     * <p><b>Note:</b> This method is marked as {@code @Beta} and its API may change in future versions.</p>
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the minimum integer from.
     * @param valueExtractor the function to extract integer values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the minimum extracted integer value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final T[] a, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        int candidate = valueExtractor.applyAsInt(a[0]);
        int next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsInt(a[i]);

            if (next < candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum integer value extracted from the specified iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the minimum integer from.
     * @param valueExtractor the function to extract integer values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the minimum extracted integer value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final Iterable<? extends T> c, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return minIntOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum integer value extracted from the specified iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the minimum integer from.
     * @param valueExtractor the function to extract integer values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the minimum extracted integer value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> int minIntOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        int candidate = valueExtractor.applyAsInt(iter.next());
        int next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsInt(iter.next());

            if (next < candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum long value extracted from the specified array or a default value if the array is {@code null} or empty.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the minimum long from.
     * @param valueExtractor the function to extract long values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the minimum extracted long value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final T[] a, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        long candidate = valueExtractor.applyAsLong(a[0]);
        long next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsLong(a[i]);

            if (next < candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum long value extracted from the specified iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the minimum long from.
     * @param valueExtractor the function to extract long values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the minimum extracted long value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final Iterable<? extends T> c, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return minLongOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum long value extracted from the specified iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the minimum long from.
     * @param valueExtractor the function to extract long values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the minimum extracted long value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> long minLongOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        long candidate = valueExtractor.applyAsLong(iter.next());
        long next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsLong(iter.next());

            if (next < candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum double value extracted from the specified array or a default value if the array is {@code null} or empty.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the minimum double from.
     * @param valueExtractor the function to extract double values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the minimum extracted double value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final T[] a, final ToDoubleFunction<? super T> valueExtractor, final double defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        double candidate = valueExtractor.applyAsDouble(a[0]);
        double next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsDouble(a[i]);

            if (compare(next, candidate) < 0) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the minimum double value extracted from the specified iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the minimum double from.
     * @param valueExtractor the function to extract double values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the minimum extracted double value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final Iterable<? extends T> c, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return minDoubleOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the minimum double value extracted from the specified iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the minimum double from.
     * @param valueExtractor the function to extract double values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the minimum extracted double value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> double minDoubleOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        double candidate = valueExtractor.applyAsDouble(iter.next());
        double next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsDouble(iter.next());

            if (compare(next, candidate) < 0) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified array based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input array, which must be comparable.
     * @param a the array to find the minimum and maximum values from.
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified array.
     * @throws IllegalArgumentException if the array is {@code null} or empty.
     * @see Iterables#minMax(Comparable[])
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final T[] a) throws IllegalArgumentException {
        return minMax(a, NATURAL_COMPARATOR);
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified array according to the provided comparator.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to find the minimum and maximum values from.
     * @param cmp the comparator to be used to compare the elements
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified array.
     * @throws IllegalArgumentException if the array is {@code null} or empty.
     * @see Iterables#minMax(Object[], Comparator)
     */
    public static <T> Pair<T, T> minMax(final T[] a, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        if (a.length == 1) {
            return Pair.of(a[0], a[0]);
        }

        cmp = checkComparator(cmp);

        T min = a[0];
        T max = a[0];
        int cp = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], min);

            if (cp < 0) {
                min = a[i];
            } else if ((cp > 0) && (cmp.compare(a[i], max) > 0)) {
                max = a[i];
            }
        }

        return Pair.of(min, max);
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified iterable based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterable, which must be comparable.
     * @param c the iterable to find the minimum and maximum values from.
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified iterable.
     * @throws IllegalArgumentException if the iterable is {@code null} or empty.
     * @see Iterables#minMax(Iterable)
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final Iterable<? extends T> c) throws IllegalArgumentException {
        return minMax(c, NATURAL_COMPARATOR);
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified iterable according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to find the minimum and maximum values from.
     * @param cmp the comparator to be used to compare the elements
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified iterable.
     * @throws IllegalArgumentException if the iterable is {@code null} or empty.
     * @see Iterables#minMax(Iterable, Comparator)
     */
    public static <T> Pair<T, T> minMax(@NotNull final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotNull(c, "The specified iterable cannot be null or empty");

        return minMax(c.iterator(), cmp);
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified iterator based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterator, which must be comparable.
     * @param iter the iterator to find the minimum and maximum values from.
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified iterator.
     * @throws IllegalArgumentException if the iterator is {@code null} or empty.
     * @see Iterables#minMax(Iterator)
     */
    public static <T extends Comparable<? super T>> Pair<T, T> minMax(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return minMax(iter, NATURAL_COMPARATOR);
    }

    /**
     * Returns a Pair object containing the minimum and maximum values in the specified iterator according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to find the minimum and maximum values from.
     * @param cmp the comparator to be used to compare the elements
     * @return a Pair object where the first element is the minimum value and the second element is the maximum value in the specified iterator.
     * @throws IllegalArgumentException if the iterator is {@code null} or empty.
     * @see Iterables#minMax(Iterator, Comparator)
     */
    public static <T> Pair<T, T> minMax(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(iter != null && iter.hasNext(), "The specified iterator cannot be null or empty");

        cmp = checkComparator(cmp);

        T next = iter.next();
        T min = next;
        T max = next;
        int cp = 0;

        while (iter.hasNext()) {
            next = iter.next();

            cp = cmp.compare(next, min);

            if (cp < 0) {
                min = next;
            } else if ((cp > 0) && (cmp.compare(next, max) > 0)) {
                max = next;
            }
        }

        return Pair.of(min, max);
    }

    /**
     * Returns the larger of two char values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char larger = N.max('a', 'z');        // Returns 'z'
     * char same = N.max('m', 'm');          // Returns 'm'
     * }</pre>
     *
     * @param a the first char value
     * @param b the second char value
     * @return the larger of the two input values
     * @see #max(char, char, char)
     * @see #max(char...)
     * @see #min(char, char)
     */
    public static char max(final char a, final char b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the larger of two byte values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte larger = N.max((byte) 10, (byte) 20);        // Returns 20
     * byte negative = N.max((byte) -5, (byte) 3);       // Returns 3
     * byte same = N.max((byte) 7, (byte) 7);            // Returns 7
     * }</pre>
     *
     * @param a the first byte value
     * @param b the second byte value
     * @return the larger of the two input values
     * @see #max(byte, byte, byte)
     * @see #max(byte...)
     * @see #min(byte, byte)
     */
    public static byte max(final byte a, final byte b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the larger of two short values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short larger = N.max((short) 100, (short) 200);        // Returns 200
     * short negative = N.max((short) -50, (short) 30);       // Returns 30
     * short same = N.max((short) 75, (short) 75);            // Returns 75
     * }</pre>
     *
     * @param a the first short value
     * @param b the second short value
     * @return the larger of the two input values
     * @see #max(short, short, short)
     * @see #max(short...)
     * @see #min(short, short)
     */
    public static short max(final short a, final short b) {
        return (a >= b) ? a : b;
    }

    /**
     * Returns the larger of two int values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int larger = N.max(10, 20);        // Returns 20
     * int negative = N.max(-5, 3);       // Returns 3
     * int same = N.max(7, 7);            // Returns 7
     * }</pre>
     *
     * @param a the first int value
     * @param b the second int value
     * @return the larger of the two input values
     * @see #max(int, int, int)
     * @see #max(int...)
     * @see #min(int, int)
     * @see Math#max(int, int)
     */
    public static int max(final int a, final int b) {
        return Math.max(a, b);
    }

    /**
     * Returns the larger of two long values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long larger = N.max(1000L, 2000L);        // Returns 2000L
     * long negative = N.max(-500L, 300L);       // Returns 300L
     * long same = N.max(750L, 750L);            // Returns 750L
     * }</pre>
     *
     * @param a the first long value
     * @param b the second long value
     * @return the larger of the two input values
     * @see #max(long, long, long)
     * @see #max(long...)
     * @see #min(long, long)
     * @see Math#max(long, long)
     */
    public static long max(final long a, final long b) {
        return Math.max(a, b);
    }

    /**
     * Returns the larger of two float values.
     * Uses {@link Math#max(float, float)} which handles NaN values according to IEEE 754:
     * if either value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float larger = N.max(1.5f, 2.3f);            // Returns 2.3f
     * float nan = N.max(1.0f, Float.NaN);          // Returns NaN
     * float posZero = N.max(0.0f, -0.0f);          // Returns 0.0f
     * }</pre>
     *
     * @param a the first float value
     * @param b the second float value
     * @return the larger of the two values; NaN if either value is NaN
     * @see #max(float, float, float)
     * @see #max(float...)
     * @see #min(float, float)
     * @see Math#max(float, float)
     */
    public static float max(final float a, final float b) {
        return Math.max(a, b);
    }

    /**
     * Returns the larger of two double values.
     * Uses {@link Math#max(double, double)} which handles NaN values according to IEEE 754:
     * if either value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double larger = N.max(1.5, 2.3);            // Returns 2.3
     * double nan = N.max(1.0, Double.NaN);        // Returns NaN
     * double posZero = N.max(0.0, -0.0);          // Returns 0.0
     * }</pre>
     *
     * @param a the first double value
     * @param b the second double value
     * @return the larger of the two values; NaN if either value is NaN
     * @see #max(double, double, double)
     * @see #max(double...)
     * @see #min(double, double)
     * @see Math#max(double, double)
     */
    public static double max(final double a, final double b) {
        return Math.max(a, b);
    }

    /**
     * Returns the larger of two comparable values based on their natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String larger = N.max("apple", "banana");        // Returns "banana"
     * Integer max = N.max(10, 20);                     // Returns 20
     * Integer withNull = N.max(5, null);               // Returns 5 (null is treated as minimum)
     * }</pre>
     *
     * @param <T> the type of the comparable values
     * @param a the first comparable value
     * @param b the second comparable value
     * @return the larger of the two values based on natural ordering; {@code null} if both are {@code null}
     * @see #max(Object, Object, Comparator)
     * @see #min(Comparable, Comparable)
     */
    public static <T extends Comparable<? super T>> T max(final T a, final T b) {
        return max(a, b, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the larger of two values according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String larger = N.max("apple", "BANANA", String.CASE_INSENSITIVE_ORDER);  // Returns "BANANA"
     *
     * // Custom comparator
     * String longer = N.max("hi", "hello", Comparator.comparing(String::length));  // Returns "hello"
     *
     * // Reverse order
     * String min = N.max("apple", "banana", Comparator.reverseOrder());  // Returns "apple"
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value
     * @param b the second value
     * @param cmp the Comparator to compare values; if {@code null}, natural ordering with nulls first is used
     * @return the larger of the two values according to the comparator; {@code null} if both are {@code null}
     * @see #max(Comparable, Comparable)
     * @see #min(Object, Object, Comparator)
     */
    public static <T> T max(final T a, final T b, final Comparator<? super T> cmp) {
        if (cmp == null) {
            return ((Comparator<T>) NULL_MIN_COMPARATOR).compare(a, b) >= 0 ? a : b;
        } else {
            return cmp.compare(a, b) >= 0 ? a : b;
        }
    }

    /**
     * Returns the largest of three char values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char largest = N.max('a', 'm', 'z');      // Returns 'z'
     * char same = N.max('b', 'b', 'b');         // Returns 'b'
     * }</pre>
     *
     * @param a the first char value
     * @param b the second char value
     * @param c the third char value
     * @return the largest of the three input values
     * @see #max(char, char)
     * @see #max(char...)
     * @see #min(char, char, char)
     */
    public static char max(final char a, final char b, final char c) {
        final char m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the largest of three byte values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte largest = N.max((byte) 5, (byte) 15, (byte) 10);      // Returns 15
     * byte negative = N.max((byte) -10, (byte) -5, (byte) -20);  // Returns -5
     * }</pre>
     *
     * @param a the first byte value
     * @param b the second byte value
     * @param c the third byte value
     * @return the largest of the three input values
     * @see #max(byte, byte)
     * @see #max(byte...)
     * @see #min(byte, byte, byte)
     */
    public static byte max(final byte a, final byte b, final byte c) {
        final byte m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the largest of three short values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short largest = N.max((short) 50, (short) 150, (short) 100);        // Returns 150
     * short negative = N.max((short) -100, (short) -50, (short) -200);    // Returns -50
     * }</pre>
     *
     * @param a the first short value
     * @param b the second short value
     * @param c the third short value
     * @return the largest of the three input values
     * @see #max(short, short)
     * @see #max(short...)
     * @see #min(short, short, short)
     */
    public static short max(final short a, final short b, final short c) {
        final short m = (a >= b) ? a : b;

        return (m >= c) ? m : c;
    }

    /**
     * Returns the largest of three int values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int largest = N.max(5, 15, 10);        // Returns 15
     * int negative = N.max(-10, -5, -20);    // Returns -5
     * int same = N.max(7, 7, 7);             // Returns 7
     * }</pre>
     *
     * @param a the first int value
     * @param b the second int value
     * @param c the third int value
     * @return the largest of the three input values
     * @see #max(int, int)
     * @see #max(int...)
     * @see #min(int, int, int)
     */
    public static int max(final int a, final int b, final int c) {
        final int m = Math.max(a, b);

        return Math.max(m, c);
    }

    /**
     * Returns the largest of three long values.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long largest = N.max(500L, 1500L, 1000L);        // Returns 1500L
     * long negative = N.max(-1000L, -500L, -2000L);    // Returns -500L
     * long same = N.max(750L, 750L, 750L);             // Returns 750L
     * }</pre>
     *
     * @param a the first long value
     * @param b the second long value
     * @param c the third long value
     * @return the largest of the three input values
     * @see #max(long, long)
     * @see #max(long...)
     * @see #min(long, long, long)
     */
    public static long max(final long a, final long b, final long c) {
        final long m = Math.max(a, b);

        return Math.max(m, c);
    }

    /**
     * Returns the largest of three float values.
     * Handles NaN values according to IEEE 754: if any value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float largest = N.max(1.5f, 2.5f, 2.0f);       // Returns 2.5f
     * float negative = N.max(-1.0f, -0.5f, -2.0f);   // Returns -0.5f
     * float nan = N.max(1.0f, Float.NaN, 2.0f);      // Returns NaN
     * }</pre>
     *
     * @param a the first float value
     * @param b the second float value
     * @param c the third float value
     * @return the largest of the three values; NaN if any value is NaN
     * @see #max(float, float)
     * @see #max(float...)
     * @see #min(float, float, float)
     */
    public static float max(final float a, final float b, final float c) {
        return Math.max(Math.max(a, b), c);
    }

    /**
     * Returns the largest of three double values.
     * Handles NaN values according to IEEE 754: if any value is NaN, then NaN is returned.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double largest = N.max(1.5, 2.5, 2.0);       // Returns 2.5
     * double negative = N.max(-1.0, -0.5, -2.0);   // Returns -0.5
     * double nan = N.max(1.0, Double.NaN, 2.0);    // Returns NaN
     * }</pre>
     *
     * @param a the first double value
     * @param b the second double value
     * @param c the third double value
     * @return the largest of the three values; NaN if any value is NaN
     * @see #max(double, double)
     * @see #max(double...)
     * @see #min(double, double, double)
     */
    public static double max(final double a, final double b, final double c) {
        return Math.max(Math.max(a, b), c);
    }

    /**
     * Returns the largest of three comparable values based on their natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String largest = N.max("apple", "zebra", "mango");        // Returns "zebra"
     * Integer max = N.max(10, 20, 15);                          // Returns 20
     * Integer withNull = N.max(5, null, 10);                    // Returns 10 (null is treated as minimum)
     * }</pre>
     *
     * @param <T> the type of the comparable values
     * @param a the first comparable value
     * @param b the second comparable value
     * @param c the third comparable value
     * @return the largest of the three values based on natural ordering
     * @see #max(Comparable, Comparable)
     * @see #max(Object, Object, Object, Comparator)
     * @see #min(Comparable, Comparable, Comparable)
     */
    public static <T extends Comparable<? super T>> T max(final T a, final T b, final T c) {
        return max(a, b, c, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the largest of three values according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String largest = N.max("apple", "ZEBRA", "mango", String.CASE_INSENSITIVE_ORDER);  // Returns "ZEBRA"
     *
     * // Custom comparator for length
     * String longest = N.max("hi", "hello", "hey", Comparator.comparing(String::length));  // Returns "hello"
     *
     * // Reverse order
     * String min = N.max("apple", "zebra", "mango", Comparator.reverseOrder());  // Returns "apple"
     * }</pre>
     *
     * @param <T> the type of the values
     * @param a the first value
     * @param b the second value
     * @param c the third value
     * @param cmp the Comparator to compare values; if {@code null}, natural ordering with nulls first is used
     * @return the largest of the three values according to the comparator
     * @see #max(Comparable, Comparable, Comparable)
     * @see #max(Object, Object, Comparator)
     * @see #min(Object, Object, Object, Comparator)
     */
    public static <T> T max(final T a, final T b, final T c, final Comparator<? super T> cmp) {
        return max(max(a, b, cmp), c, cmp);
    }

    /**
     * Returns the largest value in the specified char array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char max1 = N.max('a', 'm', 'z', 'b');    // Returns 'z'
     *
     * char[] chars = {'x', 'a', 'p', 'z'};
     * char max2 = N.max(chars);                 // Returns 'z'
     *
     * char single = N.max('q');                 // Returns 'q'
     * }</pre>
     *
     * @param a the array or varargs of char values, must not be {@code null} or empty
     * @return the largest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(char[], int, int)
     * @see #min(char...)
     * @see #median(char...)
     */
    public static char max(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the char array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'a', 'z', 'm', 'b', 'x'};
     * char max = N.max(chars, 1, 4);  // Returns 'z' (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of char values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(char...)
     * @see #min(char[], int, int)
     */
    public static char max(final char[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        char max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified byte array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte max1 = N.max((byte) 5, (byte) 2, (byte) 8, (byte) 1, (byte) 9);      // Returns 9
     *
     * byte[] numbers = {10, 20, 5, 30};
     * byte max2 = N.max(numbers);            // Returns 30
     *
     * byte single = N.max((byte) 42);        // Returns 42
     * }</pre>
     *
     * @param a the array or varargs of byte values, must not be {@code null} or empty
     * @return the largest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(byte[], int, int)
     * @see #min(byte...)
     * @see #median(byte...)
     */
    public static byte max(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the byte array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {5, 30, 15, 8, 20};
     * byte max = N.max(numbers, 1, 4);  // Returns 30 (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of byte values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(byte...)
     * @see #min(byte[], int, int)
     */
    public static byte max(final byte[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        byte max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified short array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short max1 = N.max((short) 50, (short) 20, (short) 80, (short) 10);      // Returns 80
     *
     * short[] numbers = {100, 200, 50, 300};
     * short max2 = N.max(numbers);            // Returns 300
     *
     * short single = N.max((short) 42);       // Returns 42
     * }</pre>
     *
     * @param a the array or varargs of short values, must not be {@code null} or empty
     * @return the largest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(short[], int, int)
     * @see #min(short...)
     * @see #median(short...)
     */
    public static short max(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the short array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 300, 150, 80, 200};
     * short max = N.max(numbers, 1, 4);  // Returns 300 (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of short values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(short...)
     * @see #min(short[], int, int)
     */
    public static short max(final short[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        short max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified int array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int max1 = N.max(5, 2, 8, 1, 9);      // Returns 9
     *
     * int[] numbers = {10, 20, 5, 30};
     * int max2 = N.max(numbers);            // Returns 30
     *
     * int single = N.max(42);               // Returns 42
     * }</pre>
     *
     * @param a the array or varargs of int values, must not be {@code null} or empty
     * @return the largest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(int[], int, int)
     * @see #min(int...)
     * @see #median(int...)
     */
    public static int max(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the int array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {5, 30, 15, 8, 20};
     * int max = N.max(numbers, 1, 4);  // Returns 30 (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of int values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(int...)
     * @see #min(int[], int, int)
     */
    public static int max(final int[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        int max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified long array or varargs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long max1 = N.max(500L, 200L, 800L, 100L);      // Returns 800L
     *
     * long[] numbers = {1000L, 2000L, 500L, 3000L};
     * long max2 = N.max(numbers);            // Returns 3000L
     *
     * long single = N.max(4200L);            // Returns 4200L
     * }</pre>
     *
     * @param a the array or varargs of long values, must not be {@code null} or empty
     * @return the largest value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(long[], int, int)
     * @see #min(long...)
     * @see #median(long...)
     */
    public static long max(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the long array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {500L, 3000L, 1500L, 800L, 2000L};
     * long max = N.max(numbers, 1, 4);  // Returns 3000L (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of long values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(long...)
     * @see #min(long[], int, int)
     */
    public static long max(final long[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        long max = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified float array or varargs.
     * NaN values are skipped; if all values are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float max1 = N.max(1.5f, 2.8f, 0.5f, 3.2f);      // Returns 3.2f
     *
     * float[] numbers = {1.0f, 2.0f, 0.5f, 3.0f};
     * float max2 = N.max(numbers);            // Returns 3.0f
     *
     * float single = N.max(4.2f);             // Returns 4.2f
     * }</pre>
     *
     * @param a the array or varargs of float values, must not be {@code null} or empty
     * @return the largest value in the array; NaN if all values are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(float[], int, int)
     * @see #min(float...)
     * @see #median(float...)
     * @see IEEE754rUtil#max(float[]) that handles NaN differently
     */
    public static float max(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the float array.
     * NaN values are skipped; if all values in the range are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {0.5f, 3.0f, 1.5f, 0.8f, 2.0f};
     * float max = N.max(numbers, 1, 4);  // Returns 3.0f (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of float values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range; NaN if all values in the range are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(float...)
     * @see #min(float[], int, int)
     * @see IEEE754rUtil#max(float[]) that handles NaN differently
     */
    public static float max(final float[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        float max = a[fromIndex];

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Float.isNaN(a[i])) {
                continue;
            } else if (Float.isNaN(max)) {
                max = a[i];
            } else {
                max = Math.max(max, a[i]);
            }
        }

        return max;
    }

    /**
     * Returns the largest value in the specified double array or varargs.
     * NaN values are skipped; if all values are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double max1 = N.max(1.5, 2.8, 0.5, 3.2);      // Returns 3.2
     *
     * double[] numbers = {1.0, 2.0, 0.5, 3.0};
     * double max2 = N.max(numbers);            // Returns 3.0
     *
     * double single = N.max(4.2);              // Returns 4.2
     * }</pre>
     *
     * @param a the array or varargs of double values, must not be {@code null} or empty
     * @return the largest value in the array; NaN if all values are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(double[], int, int)
     * @see #min(double...)
     * @see #median(double...)
     * @see IEEE754rUtil#max(double[]) that handles NaN differently
     */
    public static double max(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest value within the specified range of the double array.
     * NaN values are skipped; if all values in the range are NaN, returns NaN.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {0.5, 3.0, 1.5, 0.8, 2.0};
     * double max = N.max(numbers, 1, 4);  // Returns 3.0 (from index 1 to 3)
     * }</pre>
     *
     * @param a the array of double values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest value within the specified range; NaN if all values in the range are NaN
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(double...)
     * @see #min(double[], int, int)
     * @see IEEE754rUtil#max(double[]) that handles NaN differently
     */
    public static double max(final double[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        double max = a[fromIndex];

        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (Double.isNaN(a[i])) {
                continue;
            } else if (Double.isNaN(max)) {
                max = a[i];
            } else {
                max = Math.max(max, a[i]);
            }
        }

        return max;
    }

    /**
     * Returns the largest element in the array based on natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "zebra", "mango"};
     * String max = N.max(words);  // Returns "zebra"
     *
     * Integer[] numbers = {10, 30, 20};
     * Integer largest = N.max(numbers);  // Returns 30
     * }</pre>
     *
     * @param <T> the type of comparable elements in the array
     * @param a the array of comparable values, must not be {@code null} or empty
     * @return the largest element in the array based on natural ordering
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(Comparable[], int, int)
     * @see #max(Object[], Comparator)
     * @see #min(Comparable[])
     * @see Iterables#max(Comparable[])
     */
    public static <T extends Comparable<? super T>> T max(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length);
    }

    /**
     * Returns the largest element within the specified range of the array based on natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "zebra", "mango", "banana", "cherry"};
     * String max = N.max(words, 1, 4);  // Returns "zebra" (from index 1 to 3)
     *
     * Integer[] numbers = {10, 30, 15, 25, 20};
     * Integer largest = N.max(numbers, 0, 3);  // Returns 30 (from index 0 to 2)
     * }</pre>
     *
     * @param <T> the type of comparable elements in the array
     * @param a the array of comparable values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest element within the specified range based on natural ordering
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(Comparable[])
     * @see #max(Object[], int, int, Comparator)
     * @see #min(Comparable[], int, int)
     * @see Iterables#max(Comparable[])
     */
    public static <T extends Comparable<? super T>> T max(final T[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException {
        return max(a, fromIndex, toIndex, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the largest element in the array according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"zebra", "apple", "mango"};
     * String max = N.max(words, String.CASE_INSENSITIVE_ORDER);  // Returns "zebra"
     *
     * // Custom comparator for length
     * String longest = N.max(words, Comparator.comparing(String::length));  // Returns "zebra" or "apple"
     *
     * // Reverse order
     * String min = N.max(words, Comparator.reverseOrder());  // Returns "apple"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls first is used
     * @return the largest element in the array according to the comparator
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(Object[], int, int, Comparator)
     * @see #min(Object[], Comparator)
     * @see Iterables#max(Object[], Comparator)
     */
    public static <T> T max(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return max(a, 0, a.length, cmp);
    }

    /**
     * Returns the largest element within the specified range of the array according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "zebra", "mango", "banana", "cherry"};
     * String max = N.max(words, 1, 4, String.CASE_INSENSITIVE_ORDER);  // Returns "zebra" (from index 1 to 3)
     *
     * // Custom comparator for length
     * String longest = N.max(words, 0, 3, Comparator.comparing(String::length));  // Returns "zebra" or "apple"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls first is used
     * @return the largest element within the specified range according to the comparator
     * @throws IndexOutOfBoundsException if the specified range is out of bounds
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(Object[], Comparator)
     * @see #min(Object[], int, int, Comparator)
     * @see Iterables#max(Object[], Comparator)
     */
    @MayReturnNull
    public static <T> T max(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IndexOutOfBoundsException, IllegalArgumentException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;
        final boolean isNullMaxComparator = cmp == NULL_MAX_COMPARATOR;

        T candidate = a[fromIndex];
        for (int i = fromIndex + 1; i < toIndex; i++) {
            if (cmp.compare(a[i], candidate) > 0) {
                candidate = a[i];
            }

            if (isNullMaxComparator && candidate == null) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the largest element within the specified range of the collection based on natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "zebra", "mango", "banana", "cherry");
     * String max = N.max(words, 1, 4);  // Returns "zebra" (from index 1 to 3)
     *
     * List<Integer> numbers = Arrays.asList(10, 5, 8, 3, 15);
     * Integer largest = N.max(numbers, 0, 3);  // Returns 10 (from index 0 to 2)
     * }</pre>
     *
     * @param <T> the type of comparable elements in the collection
     * @param c the collection of comparable values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the largest element within the specified range based on natural ordering
     * @throws IllegalArgumentException if the collection is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(Collection, int, int, Comparator)
     * @see #min(Collection, int, int)
     * @see Iterables#max(Iterable)
     */
    public static <T extends Comparable<? super T>> T max(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return max(c, fromIndex, toIndex, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the largest element within the specified range of the collection according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "zebra", "mango", "banana", "cherry");
     * String max = N.max(words, 1, 4, String.CASE_INSENSITIVE_ORDER);  // Returns "zebra" (from index 1 to 3)
     *
     * // Custom comparator for length
     * String longest = N.max(words, 0, 3, Comparator.comparing(String::length));  // Returns "zebra" or "apple"
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection of values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls first is used
     * @return the largest element within the specified range according to the comparator
     * @throws IllegalArgumentException if the collection is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @see #max(Collection, int, int)
     * @see #min(Collection, int, int, Comparator)
     * @see Iterables#max(Iterable, Comparator)
     */
    @MayReturnNull
    public static <T> T max(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if (isEmpty(c) || toIndex - fromIndex < 1 || fromIndex >= c.size()) {
            throw new IllegalArgumentException("The size of collection cannot be null or empty");
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;
        final boolean isNullMaxComparator = cmp == NULL_MAX_COMPARATOR;

        T candidate = null;
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            candidate = list.get(fromIndex);

            for (int i = fromIndex + 1; i < toIndex; i++) {
                e = list.get(i);

                if (cmp.compare(e, candidate) > 0) {
                    candidate = e;
                }

                if (isNullMaxComparator && candidate == null) { // NOSONAR
                    return null;
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex; i++) {
                if (i < fromIndex) {
                    it.next();
                } else if (i == fromIndex) {
                    candidate = it.next();
                } else {
                    e = it.next();

                    if (cmp.compare(e, candidate) > 0) {
                        candidate = e;
                    }

                    if (isNullMaxComparator && candidate == null) { // NOSONAR
                        return null;
                    }
                }
            }
        }

        return candidate;
    }

    /**
     * Returns the largest element in the iterable based on natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("apple", "zebra", "mango");
     * String max = N.max(words);  // Returns "zebra"
     *
     * Iterable<Integer> numbers = Arrays.asList(10, 30, 20);
     * Integer largest = N.max(numbers);  // Returns 30
     * }</pre>
     *
     * @param <T> the type of comparable elements in the iterable
     * @param c the iterable of comparable values, must not be {@code null} or empty
     * @return the largest element in the iterable based on natural ordering
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #max(Iterable, Comparator)
     * @see #min(Iterable)
     * @see Iterables#max(Iterable)
     */
    public static <T extends Comparable<? super T>> T max(final Iterable<? extends T> c) throws IllegalArgumentException {
        return max(c, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the largest element in the iterable according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("apple", "zebra", "mango");
     * String max = N.max(words, String.CASE_INSENSITIVE_ORDER);  // Returns "zebra"
     *
     * // Custom comparator for length
     * String longest = N.max(words, Comparator.comparing(String::length));  // Returns "zebra" or "apple"
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls first is used
     * @return the largest element in the iterable according to the comparator
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #max(Iterable)
     * @see #min(Iterable, Comparator)
     * @see Iterables#max(Iterable, Comparator)
     */
    public static <T> T max(final Iterable<? extends T> c, final Comparator<? super T> cmp) throws IllegalArgumentException {
        if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return max(coll, 0, coll.size(), cmp);
        }

        final Iterator<? extends T> iter = Iterables.iterateNonEmpty(c, "The specified Collection/Iterable/Iterator cannot be null or empty"); //NOSONAR

        return max(iter, cmp);
    }

    /**
     * Returns the largest element from the iterator based on natural ordering.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("apple", "zebra", "mango").iterator();
     * String max = N.max(words);  // Returns "zebra"
     *
     * Iterator<Integer> numbers = Arrays.asList(10, 30, 20).iterator();
     * Integer largest = N.max(numbers);  // Returns 30
     * }</pre>
     *
     * @param <T> the type of comparable elements in the iterator
     * @param iter the iterator of comparable values, must not be {@code null} or empty
     * @return the largest element from the iterator based on natural ordering
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #max(Iterator, Comparator)
     * @see #min(Iterator)
     * @see Iterables#max(Iterator)
     */
    public static <T extends Comparable<? super T>> T max(final Iterator<? extends T> iter) throws IllegalArgumentException {
        return max(iter, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the largest element from the iterator according to the provided comparator.
     * If the comparator is {@code null}, {@code null} values are considered minimum.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("apple", "zebra", "mango").iterator();
     * String max = N.max(words, String.CASE_INSENSITIVE_ORDER);  // Returns "zebra"
     *
     * // Custom comparator for length
     * Iterator<String> words2 = Arrays.asList("apple", "zebra", "mango").iterator();
     * String longest = N.max(words2, Comparator.comparing(String::length));  // Returns "zebra" or "apple"
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values, must not be {@code null} or empty
     * @param cmp the Comparator to compare elements; if {@code null}, natural ordering with nulls first is used
     * @return the largest element from the iterator according to the comparator
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #max(Iterator)
     * @see #min(Iterator, Comparator)
     * @see Iterables#max(Iterator, Comparator)
     */
    @MayReturnNull
    public static <T> T max(final Iterator<? extends T> iter, Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgument(!isEmpty(iter), "The specified Collection/Iterable/Iterator cannot be null or empty");
        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;
        final boolean isNullMaxComparator = cmp == NULL_MAX_COMPARATOR;

        T candidate = iter.next();
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (cmp.compare(e, candidate) > 0) {
                candidate = e;
            }

            if (isNullMaxComparator && candidate == null) { // NOSONAR
                return null;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum element from the array based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple largest elements, the first one will be returned.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "pie", "zoo"};
     * String longest = N.maxBy(words, String::length);  // Returns "apple" (or "pie")
     *
     * Person[] people = {new Person("Alice", 30), new Person("Bob", 25)};
     * Person oldest = N.maxBy(people, Person::getAge);  // Returns Alice
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the maximum element based on the extracted key
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #max(Object[], Comparator)
     * @see #minBy(Object[], Function)
     * @see Comparators#nullsFirstBy(Function)
     * @see Iterables#maxBy(Object[], Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T maxBy(final T[] a, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return max(a, Comparators.nullsFirstBy(keyExtractor));
    }

    /**
     * Returns the maximum element from the iterable based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple largest elements, the first one will be returned.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "pie", "zoo");
     * String longest = N.maxBy(words, String::length);  // Returns "apple" (or "pie")
     *
     * List<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25));
     * Person oldest = N.maxBy(people, Person::getAge);  // Returns Alice
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the maximum element based on the extracted key
     * @throws IllegalArgumentException if the iterable is {@code null} or empty
     * @see #max(Iterable, Comparator)
     * @see #minBy(Iterable, Function)
     * @see Comparators#nullsFirstBy(Function)
     * @see Iterables#maxBy(Iterable, Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T maxBy(final Iterable<? extends T> c, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return max(c, Comparators.nullsFirstBy(keyExtractor));
    }

    /**
     * Returns the maximum element from the iterator based on the key extracted by the {@code keyExtractor} function.
     * If there are multiple largest elements, the first one will be returned.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> words = Arrays.asList("apple", "pie", "zoo").iterator();
     * String longest = N.maxBy(words, String::length);  // Returns "apple" (or "pie")
     *
     * Iterator<Person> people = Arrays.asList(new Person("Alice", 30), new Person("Bob", 25)).iterator();
     * Person oldest = N.maxBy(people, Person::getAge);  // Returns Alice
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values, must not be {@code null} or empty
     * @param keyExtractor the function to extract the comparable key from each element, must not be {@code null}
     * @return the maximum element based on the extracted key
     * @throws IllegalArgumentException if the iterator is {@code null} or empty
     * @see #max(Iterator, Comparator)
     * @see #minBy(Iterator, Function)
     * @see Comparators#nullsFirstBy(Function)
     * @see Iterables#maxBy(Iterator, Function)
     */
    @SuppressWarnings("rawtypes")
    public static <T> T maxBy(final Iterator<? extends T> iter, final Function<? super T, ? extends Comparable> keyExtractor) throws IllegalArgumentException {
        return max(iter, Comparators.nullsFirstBy(keyExtractor));
    }

    /**
     * Returns a list containing the biggest elements in the specified array based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input array, which must be comparable.
     * @param a the array to fetch the biggest elements.
     * @return a list containing the biggest elements in the array. If the array is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final T[] a) {
        return maxAll(a, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list containing all biggest elements in the specified array according to the provided comparator.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to fetch the biggest elements from.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing all biggest elements in the array. If the array is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> maxAll(final T[] a, Comparator<? super T> cmp) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candidate = a[0];
        int cp = 0;

        result.add(candidate);

        for (int i = 1, len = a.length; i < len; i++) {
            cp = cmp.compare(a[i], candidate);

            if (cp == 0) {
                result.add(a[i]);
            } else if (cp > 0) {
                result.clear();
                result.add(a[i]);
                candidate = a[i];
            }
        }

        return result;
    }

    /**
     * Returns a list containing the biggest elements in the specified iterable based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterable, which must be comparable.
     * @param c the iterable to fetch the biggest elements.
     * @return a list containing the biggest elements in the iterable. If the iterable is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final Iterable<? extends T> c) {
        return maxAll(c, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list containing all biggest elements in the specified iterable according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to fetch the biggest elements from.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing all biggest elements in the iterable. If the iterable is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> maxAll(final Iterable<? extends T> c, final Comparator<? super T> cmp) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>();
        }

        return maxAll(c.iterator(), cmp);
    }

    /**
     * Returns a list containing the biggest elements in the specified iterator based on their natural ordering. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterator, which must be comparable.
     * @param iter the iterator to fetch the biggest elements.
     * @return a list containing the biggest elements in the iterator. If the iterator is {@code null} or empty, an empty list is returned.
     */
    public static <T extends Comparable<? super T>> List<T> maxAll(final Iterator<? extends T> iter) {
        return maxAll(iter, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns a list containing all biggest elements in the specified iterator according to the provided comparator.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to fetch the biggest elements from.
     * @param cmp the comparator to be used to compare the elements
     * @return a list containing all biggest elements in the iterator. If the iterator is {@code null} or empty, an empty list is returned.
     */
    public static <T> List<T> maxAll(final Iterator<? extends T> iter, Comparator<? super T> cmp) {
        cmp = cmp == null ? (Comparator<T>) NULL_MIN_COMPARATOR : cmp;

        final List<T> result = new ArrayList<>();
        T candidate = iter.next();
        T next = null;
        int cp = 0;

        result.add(candidate);

        while (iter.hasNext()) {
            next = iter.next();
            cp = cmp.compare(next, candidate);

            if (cp == 0) {
                result.add(next);
            } else if (cp > 0) {
                result.clear();
                result.add(next);
                candidate = next;
            }
        }

        return result;
    }

    /**
     * Returns the maximum value extracted from the specified array or a default value if the array is {@code null} or empty. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input array.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param a the array to extract the maximum value from.
     * @param valueExtractor the function to extract values from the array elements for comparison.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the maximum extracted value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final T[] a, final Function<? super T, ? extends R> valueExtractor,
            final R defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        R candidate = valueExtractor.apply(a[0]);
        R next = null;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.apply(a[i]);

            if (candidate == null || (next != null && (next.compareTo(candidate) > 0))) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum value extracted from the specified iterable or a default value if the iterable is {@code null} or empty. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterable.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param c the iterable to extract the maximum value from.
     * @param valueExtractor the function to extract values from the iterable elements for comparison.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the maximum extracted value or the default value if the iterable is {@code null} or empty.
     */
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final Iterable<? extends T> c,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return maxOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum value extracted from the specified iterator or a default value if the iterator is {@code null} or empty. Null values are considered to be minimum here.
     *
     * @param <T> the type of elements in the input iterator.
     * @param <R> the type of the extracted value, which must be comparable.
     * @param iter the iterator to extract the maximum value from.
     * @param valueExtractor the function to extract values from the iterator elements for comparison.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the maximum extracted value or the default value if the iterator is {@code null} or empty.
     */
    public static <T, R extends Comparable<? super R>> R maxOrDefaultIfEmpty(final Iterator<? extends T> iter,
            final Function<? super T, ? extends R> valueExtractor, final R defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        R candidate = valueExtractor.apply(iter.next());
        R next = null;

        while (iter.hasNext()) {
            next = valueExtractor.apply(iter.next());

            if (candidate == null || (next != null && (next.compareTo(candidate) > 0))) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum integer value extracted from the array or a default value if the array is {@code null} or empty.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the maximum integer from.
     * @param valueExtractor the function to extract integer values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the maximum extracted integer value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final T[] a, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        int candidate = valueExtractor.applyAsInt(a[0]);
        int next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsInt(a[i]);

            if (next > candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum integer value extracted from the iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the maximum integer from.
     * @param valueExtractor the function to extract integer values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the maximum extracted integer value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final Iterable<? extends T> c, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return maxIntOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum integer value extracted from the iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the maximum integer from.
     * @param valueExtractor the function to extract integer values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the maximum extracted integer value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> int maxIntOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToIntFunction<? super T> valueExtractor, final int defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        int candidate = valueExtractor.applyAsInt(iter.next());
        int next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsInt(iter.next());

            if (next > candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum long value extracted from the array or a default value if the array is {@code null} or empty.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the maximum long from.
     * @param valueExtractor the function to extract long values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the maximum extracted long value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final T[] a, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        long candidate = valueExtractor.applyAsLong(a[0]);
        long next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsLong(a[i]);

            if (next > candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum long value extracted from the iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the maximum long from.
     * @param valueExtractor the function to extract long values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the maximum extracted long value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final Iterable<? extends T> c, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return maxLongOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum long value extracted from the iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the maximum long from.
     * @param valueExtractor the function to extract long values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the maximum extracted long value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> long maxLongOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToLongFunction<? super T> valueExtractor, final long defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        long candidate = valueExtractor.applyAsLong(iter.next());
        long next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsLong(iter.next());

            if (next > candidate) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum double value extracted from the array or a default value if the array is {@code null} or empty.
     *
     * @param <T> the type of elements in the input array.
     * @param a the array to extract the maximum double from.
     * @param valueExtractor the function to extract double values from the array elements.
     * @param defaultValue the default value to return if the array is {@code null} or empty.
     * @return the maximum extracted double value or the default value if the array is {@code null} or empty.
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final T[] a, final ToDoubleFunction<? super T> valueExtractor, final double defaultValue) {
        if (isEmpty(a)) {
            return defaultValue;
        }

        double candidate = valueExtractor.applyAsDouble(a[0]);
        double next = 0;

        for (int i = 1, len = a.length; i < len; i++) {
            next = valueExtractor.applyAsDouble(a[i]);

            if (compare(next, candidate) > 0) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the maximum double value extracted from the iterable or a default value if the iterable is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterable.
     * @param c the iterable to extract the maximum double from.
     * @param valueExtractor the function to extract double values from the iterable elements.
     * @param defaultValue the default value to return if the iterable is {@code null} or empty.
     * @return the maximum extracted double value or the default value if the iterable is {@code null} or empty.
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final Iterable<? extends T> c, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (isEmptyCollection(c)) {
            return defaultValue;
        }

        return maxDoubleOrDefaultIfEmpty(c.iterator(), valueExtractor, defaultValue);
    }

    /**
     * Returns the maximum double value extracted from the iterator or a default value if the iterator is {@code null} or empty.
     *
     * @param <T> the type of elements in the input iterator.
     * @param iter the iterator to extract the maximum double from.
     * @param valueExtractor the function to extract double values from the iterator elements.
     * @param defaultValue the default value to return if the iterator is {@code null} or empty.
     * @return the maximum extracted double value or the default value if the iterator is {@code null} or empty.
     */
    @Beta
    public static <T> double maxDoubleOrDefaultIfEmpty(final Iterator<? extends T> iter, final ToDoubleFunction<? super T> valueExtractor,
            final double defaultValue) {
        if (iter == null || !iter.hasNext()) {
            return defaultValue;
        }

        double candidate = valueExtractor.applyAsDouble(iter.next());
        double next = 0;

        while (iter.hasNext()) {
            next = valueExtractor.applyAsDouble(iter.next());

            if (compare(next, candidate) > 0) {
                candidate = next;
            }
        }

        return candidate;
    }

    /**
     * Returns the median of three char values.
     * The median is the middle value when sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char median1 = N.median('a', 'c', 'b');  // Returns 'b'
     * char median2 = N.median('x', 'y', 'z');  // Returns 'y'
     * }</pre>
     *
     * @param a the first char value
     * @param b the second char value
     * @param c the third char value
     * @return the median of the three values
     * @see #median(char...)
     * @see #min(char, char, char)
     * @see #max(char, char, char)
     */
    public static char median(final char a, final char b, final char c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three byte values.
     * The median is the middle value when sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte median1 = N.median((byte) 10, (byte) 30, (byte) 20);      // Returns 20
     * byte median2 = N.median((byte) 5, (byte) 1, (byte) 3);         // Returns 3
     * }</pre>
     *
     * @param a the first byte value
     * @param b the second byte value
     * @param c the third byte value
     * @return the median of the three values
     * @see #median(byte...)
     * @see #min(byte, byte, byte)
     * @see #max(byte, byte, byte)
     */
    public static byte median(final byte a, final byte b, final byte c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three short values.
     * The median is the middle value when sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short median1 = N.median((short) 100, (short) 300, (short) 200);      // Returns 200
     * short median2 = N.median((short) 50, (short) 10, (short) 30);         // Returns 30
     * }</pre>
     *
     * @param a the first short value
     * @param b the second short value
     * @param c the third short value
     * @return the median of the three values
     * @see #median(short...)
     * @see #min(short, short, short)
     * @see #max(short, short, short)
     */
    public static short median(final short a, final short b, final short c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three int values.
     * The median is the middle value when sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int median1 = N.median(10, 30, 20);      // Returns 20
     * int median2 = N.median(5, 1, 3);         // Returns 3
     * int median3 = N.median(15, 15, 15);      // Returns 15
     * }</pre>
     *
     * @param a the first int value
     * @param b the second int value
     * @param c the third int value
     * @return the median of the three values
     * @see #median(int...)
     * @see #min(int, int, int)
     * @see #max(int, int, int)
     */
    public static int median(final int a, final int b, final int c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three long values.
     * The median is the middle value when sorted in ascending order.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long median1 = N.median(1000L, 3000L, 2000L);      // Returns 2000L
     * long median2 = N.median(500L, 100L, 300L);         // Returns 300L
     * }</pre>
     *
     * @param a the first long value
     * @param b the second long value
     * @param c the third long value
     * @return the median of the three values
     * @see #median(long...)
     * @see #min(long, long, long)
     * @see #max(long, long, long)
     */
    public static long median(final long a, final long b, final long c) {
        if ((a >= b && a <= c) || (a >= c && a <= b)) {
            return a;
        } else if ((b >= a && b <= c) || (b >= c && b <= a)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three float values.
     * The median is the middle value when sorted in ascending order.
     * Handles NaN values according to IEEE 754 comparison rules.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float median1 = N.median(1.5f, 3.5f, 2.5f);      // Returns 2.5f
     * float median2 = N.median(0.5f, 0.1f, 0.3f);      // Returns 0.3f
     * }</pre>
     *
     * @param a the first float value
     * @param b the second float value
     * @param c the third float value
     * @return the median of the three values
     * @see #median(float...)
     * @see #min(float, float, float)
     * @see #max(float, float, float)
     */
    public static float median(final float a, final float b, final float c) {
        final int ab = Float.compare(a, b);
        final int ac = Float.compare(a, c);
        int bc = 0;

        if ((ab >= 0 && ac <= 0) || (ac >= 0 && ab <= 0)) {
            return a;
        } else if ((((bc = Float.compare(b, c)) <= 0) && ab <= 0) || (bc >= 0 && ab >= 0)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three double values.
     * The median is the middle value when sorted in ascending order.
     * Handles NaN values according to IEEE 754 comparison rules.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double median1 = N.median(1.5, 3.5, 2.5);      // Returns 2.5
     * double median2 = N.median(0.5, 0.1, 0.3);      // Returns 0.3
     * }</pre>
     *
     * @param a the first double value
     * @param b the second double value
     * @param c the third double value
     * @return the median of the three values
     * @see #median(double...)
     * @see #min(double, double, double)
     * @see #max(double, double, double)
     */
    public static double median(final double a, final double b, final double c) {
        final int ab = Double.compare(a, b);
        final int ac = Double.compare(a, c);
        int bc = 0;

        if ((ab >= 0 && ac <= 0) || (ac >= 0 && ab <= 0)) {
            return a;
        } else if ((((bc = Double.compare(b, c)) <= 0) && ab <= 0) || (bc >= 0 && ab >= 0)) {
            return b;
        } else {
            return c;
        }
    }

    /**
     * Returns the median of three comparable values based on their natural ordering.
     * The median is the middle value when sorted in ascending order.
     * Null values are considered to be minimum (placed first when comparing).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String median1 = N.median("apple", "zebra", "mango");      // Returns "mango"
     * Integer median2 = N.median(10, 30, 20);                    // Returns 20
     * }</pre>
     *
     * @param <T> the type of comparable values
     * @param a the first value
     * @param b the second value
     * @param c the third value
     * @return the median of the three values
     * @see #median(Comparable[])
     * @see #median(Object, Object, Object, Comparator)
     * @see #min(Comparable, Comparable, Comparable)
     * @see #max(Comparable, Comparable, Comparable)
     */
    public static <T extends Comparable<? super T>> T median(final T a, final T b, final T c) {
        return (T) median(a, b, c, NATURAL_COMPARATOR);
    }

    /**
     * Returns the median of three values according to the provided comparator.
     * The median is the middle value when sorted by the comparator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String median = N.median("hi", "hello", "hey", Comparator.comparing(String::length));  // Returns "hey" or "hi"
     * }</pre>
     *
     * @param <T> the type of values
     * @param a the first value
     * @param b the second value
     * @param c the third value
     * @param cmp the Comparator to compare values; if {@code null}, natural ordering is used
     * @return the median of the three values
     * @see #median(Comparable, Comparable, Comparable)
     * @see #median(Object[], Comparator)
     */
    public static <T> T median(final T a, final T b, final T c, Comparator<? super T> cmp) {
        cmp = checkComparator(cmp);

        final int ab = cmp.compare(a, b);
        final int bc = cmp.compare(b, c);

        if (ab <= 0) {
            if (bc <= 0) {
                return b;
            } else if (cmp.compare(a, c) <= 0) {
                return c;
            } else {
                return a;
            }
        } else {
            if (bc >= 0) {
                return b;
            } else if (cmp.compare(a, c) <= 0) {
                return a;
            } else {
                return c;
            }
        }
    }

    /**
     * Returns the median value in the specified char array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char median1 = N.median('a', 'm', 'z', 'b');     // Returns 'b' or 'm'
     *
     * char[] chars = {'x', 'a', 'p', 'z', 'm'};
     * char median2 = N.median(chars);                  // Returns 'p'
     * }</pre>
     *
     * @param a the array or varargs of char values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(char[], int, int)
     * @see #median(char, char, char)
     * @see Median#of(char[])
     */
    public static char median(final char... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the char array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'a', 'z', 'm', 'b', 'x'};
     * char median = N.median(chars, 1, 4);  // Returns 'm' (from 'z', 'm', 'b')
     * }</pre>
     *
     * @param a the array of char values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(char...)
     * @see Median#of(char[], int, int)
     */
    public static char median(final char[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified byte array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte median1 = N.median((byte) 10, (byte) 30, (byte) 20);     // Returns 20
     *
     * byte[] numbers = {5, 30, 15, 8, 20};
     * byte median2 = N.median(numbers);                             // Returns 15
     * }</pre>
     *
     * @param a the array or varargs of byte values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(byte[], int, int)
     * @see #median(byte, byte, byte)
     * @see Median#of(byte[])
     */
    public static byte median(final byte... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the byte array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {5, 30, 15, 8, 20};
     * byte median = N.median(numbers, 1, 4);  // Returns 15 (from 30, 15, 8)
     * }</pre>
     *
     * @param a the array of byte values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(byte...)
     * @see Median#of(byte[], int, int)
     */
    public static byte median(final byte[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified short array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short median1 = N.median((short) 100, (short) 300, (short) 200);     // Returns 200
     *
     * short[] numbers = {50, 300, 150, 80, 200};
     * short median2 = N.median(numbers);                                   // Returns 150
     * }</pre>
     *
     * @param a the array or varargs of short values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(short[], int, int)
     * @see #median(short, short, short)
     * @see Median#of(short[])
     */
    public static short median(final short... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the short array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 300, 150, 80, 200};
     * short median = N.median(numbers, 1, 4);  // Returns 150 (from 300, 150, 80)
     * }</pre>
     *
     * @param a the array of short values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(short...)
     * @see Median#of(short[], int, int)
     */
    public static short median(final short[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified int array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int median1 = N.median(10, 30, 20);     // Returns 20
     * int median2 = N.median(1, 2);           // Returns 1
     *
     * int[] numbers = {5, 30, 15, 8, 20};
     * int median3 = N.median(numbers);        // Returns 15
     * }</pre>
     *
     * @param a the array or varargs of int values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(int[], int, int)
     * @see #median(int, int, int)
     * @see Median#of(int[])
     */
    public static int median(final int... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the int array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {5, 30, 15, 8, 20};
     * int median = N.median(numbers, 1, 4);  // Returns 15 (from 30, 15, 8)
     * }</pre>
     *
     * @param a the array of int values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(int...)
     * @see Median#of(int[], int, int)
     */
    public static int median(final int[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified long array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long median1 = N.median(1000L, 3000L, 2000L);     // Returns 2000L
     *
     * long[] numbers = {500L, 3000L, 1500L, 800L, 2000L};
     * long median2 = N.median(numbers);                 // Returns 1500L
     * }</pre>
     *
     * @param a the array or varargs of long values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(long[], int, int)
     * @see #median(long, long, long)
     * @see Median#of(long[])
     */
    public static long median(final long... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the long array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {500L, 3000L, 1500L, 800L, 2000L};
     * long median = N.median(numbers, 1, 4);  // Returns 1500L (from 3000, 1500, 800)
     * }</pre>
     *
     * @param a the array of long values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(int[])
     * @see Median#of(long[], int, int)
     */
    public static long median(final long[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified float array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float median1 = N.median(1.5f, 3.5f, 2.5f);     // Returns 2.5f
     *
     * float[] numbers = {0.5f, 3.0f, 1.5f, 0.8f, 2.0f};
     * float median2 = N.median(numbers);              // Returns 1.5f
     * }</pre>
     *
     * @param a the array or varargs of float values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(float[], int, int)
     * @see #median(float, float, float)
     * @see Median#of(float[])
     */
    public static float median(final float... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the float array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {0.5f, 3.0f, 1.5f, 0.8f, 2.0f};
     * float median = N.median(numbers, 1, 4);  // Returns 1.5f (from 3.0, 1.5, 0.8)
     * }</pre>
     *
     * @param a the array of float values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(float...)
     * @see Median#of(float[], int, int)
     */
    public static float median(final float[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value in the specified double array or varargs.
     * The median is the middle value when sorted in ascending order.
     * For arrays with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double median1 = N.median(1.5, 3.5, 2.5);     // Returns 2.5
     *
     * double[] numbers = {0.5, 3.0, 1.5, 0.8, 2.0};
     * double median2 = N.median(numbers);           // Returns 1.5
     * }</pre>
     *
     * @param a the array or varargs of double values, must not be {@code null} or empty
     * @return the median value in the array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(double[], int, int)
     * @see #median(double, double, double)
     * @see Median#of(double[])
     */
    public static double median(final double... a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value within the specified range of the double array.
     * The median is the middle value when sorted in ascending order.
     * For ranges with an even number of elements, returns the lower of the two middle elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {0.5, 3.0, 1.5, 0.8, 2.0};
     * double median = N.median(numbers, 1, 4);  // Returns 1.5 (from 3.0, 1.5, 0.8)
     * }</pre>
     *
     * @param a the array of double values, must not be {@code null} or empty
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @return the median value within the specified range
     * @throws IllegalArgumentException if the array is {@code null} or empty, or if {@code toIndex - fromIndex < 1}
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #median(double...)
     * @see Median#of(double[], int, int)
     */
    public static double median(final double[] a, final int fromIndex, final int toIndex) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        final int len = toIndex - fromIndex;

        if (len == 1) {
            return a[fromIndex];
        } else if (len == 2) {
            return min(a[fromIndex], a[fromIndex + 1]);
        } else if (len == 3) {
            return median(a[fromIndex], a[fromIndex + 1], a[fromIndex + 2]);
        } else {
            return kthLargest(a, fromIndex, toIndex, len / 2 + 1);
        }
    }

    /**
     * Returns the median value of all elements in the specified array.
     * 
     * <p>The median is the middle value when the elements are sorted in ascending order. For array with
     * an odd number of elements, this is the exact middle element. For array with an even number of
     * elements, this method returns the lower of the two middle elements (not the average).</p>
     *
     * @param <T> the type of elements in the input array
     * @param a the array of values to find the median of
     * @return the median in the specified array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(int[])
     * @see Median#of(Comparable[])
     */
    public static <T extends Comparable<? super T>> T median(final T[] a) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length);
    }

    /**
     * Returns the median value of elements within the specified range of the specified array.
     *
     * <p>The median is computed for elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
     * For ranges with an odd number of elements, this returns the exact middle element when sorted.
     * For ranges with an even number of elements, this returns the lower of the two middle elements.</p>
     *
     * @param <T> the type of elements in the input array
     * @param a the array of values to find the median of
     * @param fromIndex the starting index (inclusive) of the range to calculate median for
     * @param toIndex the ending index (exclusive) of the range to calculate median for
     * @return the median within the specified range in the input array
     * @throws IllegalArgumentException if the specified array or range is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     * @see #median(int[])
     * @see Median#of(Comparable[], int, int)
     */
    public static <T extends Comparable<? super T>> T median(final T[] a, final int fromIndex, final int toIndex)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        return (T) median(a, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Returns the median value of all elements in the specified array.
     * 
     * <p>The median is the middle value when the elements are sorted in ascending order. For array with
     * an odd number of elements, this is the exact middle element. For array with an even number of
     * elements, this method returns the lower of the two middle elements (not the average).</p>
     *
     * @param <T> the type of elements in the input array
     * @param a the array of values to find the median of
     * @param cmp the comparator to determine the order of the values
     * @return the median in the specified array
     * @throws IllegalArgumentException if the array is {@code null} or empty
     * @see #median(int[])
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Comparable[])
     * @see Median#of(Comparable[], int, int)
     * @see Median#of(Object[], Comparator)
     * @see Median#of(Object[], int, int, Comparator)
     */
    public static <T> T median(final T[] a, final Comparator<? super T> cmp) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return median(a, 0, a.length, cmp);
    }

    /**
     * Returns the median value of elements within the specified range of the specified array.
     *
     * <p>The median is computed for elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
     * For ranges with an odd number of elements, this returns the exact middle element when sorted.
     * For ranges with an even number of elements, this returns the lower of the two middle elements.</p>
     *
     * @param <T> the type of elements in the input array
     * @param a the array of values to find the median of
     * @param fromIndex the starting index (inclusive) of the range to calculate median for
     * @param toIndex the ending index (exclusive) of the range to calculate median for
     * @param cmp the comparator to determine the order of the values
     * @return the median within the specified range in the input array
     * @throws IllegalArgumentException if the specified array or range is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of the array bounds
     * @see #median(int[])
     * @see Median#of(Comparable[])
     * @see Median#of(Comparable[], int, int)
     * @see Median#of(Object[], Comparator)
     * @see Median#of(Object[], int, int, Comparator)
     */
    public static <T> T median(final T[] a, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, a.length);

        cmp = checkComparator(cmp);

        final int len = toIndex - fromIndex;

        final T ret = kthLargest(a, fromIndex, toIndex, len / 2 + 1, cmp);
        final T element = a[toIndex - (len / 2 + 1)];

        // fix for N.median(["ant", "bee", "tiger"], Comparator.comparing(String::length)));
        if (element != ret && cmp.compare(element, ret) == 0) {
            return element;
        } else {
            return ret;
        }
    }

    /**
     * Returns the median value of all elements in the specified collection.
     * 
     * <p>The median is the middle value when the elements are sorted in ascending order. For collection with
     * an odd number of elements, this is the exact middle element. For collection with an even number of
     * elements, this method returns the lower of the two middle elements (not the average).</p>
     *
     * @param <T> the type of elements in the input collection
     * @param c the collection of values to find the median of
     * @return the median in the specified collection
     * @throws IllegalArgumentException if the collection is {@code null} or empty
     * @see #median(int[])
     * @see Median#of(Collection)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, Comparator)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final Collection<? extends T> c) throws IllegalArgumentException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return median(c, 0, c.size());
    }

    /**
     * Returns the median value of elements within the specified range of the specified collection.
     *
     * <p>The median is computed for elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
     * For ranges with an odd number of elements, this returns the exact middle element when sorted.
     * For ranges with an even number of elements, this returns the lower of the two middle elements.</p>
     *
     * @param <T> the type of elements in the input collection
     * @param c the collection of values to find the median of
     * @param fromIndex the starting index (inclusive) of the range to calculate median for
     * @param toIndex the ending index (exclusive) of the range to calculate median for
     * @return the median within the specified range in the input array
     * @throws IllegalArgumentException if the specified collection or range is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     * @see #median(int[])
     * @see Median#of(Collection)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, Comparator)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T extends Comparable<? super T>> T median(final Collection<? extends T> c, final int fromIndex, final int toIndex)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        return (T) median(c, fromIndex, toIndex, NATURAL_COMPARATOR);
    }

    /**
     * Returns the median value of all elements in the specified collection.
     * 
     * <p>The median is the middle value when the elements are sorted in ascending order. For collection with
     * an odd number of elements, this is the exact middle element. For collection with an even number of
     * elements, this method returns the lower of the two middle elements (not the average).</p>
     *
     * @param <T> the type of elements in the input collection
     * @param c the collection of values to find the median of
     * @param cmp the comparator to determine the order of the values
     * @return the median in the specified collection
     * @throws IllegalArgumentException if the collection is {@code null} or empty
     * @throws IndexOutOfBoundsException if an index is out of bounds
     * @see #median(int[])
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Collection)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, Comparator)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T> T median(final Collection<? extends T> c, final Comparator<? super T> cmp) throws IndexOutOfBoundsException, IllegalArgumentException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return median(c, 0, c.size(), cmp);
    }

    /**
     * Returns the median value of elements within the specified range of the specified collection.
     *
     * <p>The median is computed for elements from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
     * For ranges with an odd number of elements, this returns the exact middle element when sorted.
     * For ranges with an even number of elements, this returns the lower of the two middle elements.</p>
     *
     * @param <T> the type of elements in the input collection
     * @param c the collection of values to find the median of
     * @param fromIndex the starting index (inclusive) of the range to calculate median for
     * @param toIndex the ending index (exclusive) of the range to calculate median for
     * @param cmp the comparator to determine the order of the values
     * @return the median within the specified range in the input array
     * @throws IllegalArgumentException if the specified collection or range is {@code null} or empty
     * @throws IndexOutOfBoundsException if the range is out of the collection bounds
     * @see #median(int[])
     * @see Iterables#median(Collection, Comparator)
     * @see Median#of(Collection)
     * @see Median#of(Collection, int, int)
     * @see Median#of(Collection, Comparator)
     * @see Median#of(Collection, int, int, Comparator)
     */
    public static <T> T median(final Collection<? extends T> c, final int fromIndex, final int toIndex, Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection cannot be null or empty"); //NOSONAR
        }

        checkFromToIndex(fromIndex, toIndex, c.size());

        cmp = checkComparator(cmp);

        final int len = toIndex - fromIndex;

        final T ret = kthLargest(c, fromIndex, toIndex, len / 2 + 1, cmp);
        final T element = N.getElement(c, toIndex - (len / 2 + 1));
        // fix for N.median(("ant", "bee", "tiger"), Comparator.comparing(String::length)));
        if (element != ret && cmp.compare(element, ret) == 0) {
            return element;
        } else {
            return ret;
        }
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'E', 'A', 'C', 'B', 'D'};
     * char result = N.kthLargest(chars, 2);
     * // Returns 'D' (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(char[], int, int, int)
     */
    public static char kthLargest(final char[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] chars = {'E', 'A', 'C', 'B', 'D'};
     * char result = N.kthLargest(chars, 1, 4, 2);
     * // Returns 'B' (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(char[], int)
     */
    public static char kthLargest(final char[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex); //NOSONAR

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Character> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (a[i] < queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {50, 10, 30, 20, 40};
     * byte result = N.kthLargest(numbers, 2);
     * // Returns 40 (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(byte[], int, int, int)
     */
    public static byte kthLargest(final byte[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {50, 10, 30, 20, 40};
     * byte result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 20 (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(byte[], int)
     */
    public static byte kthLargest(final byte[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Byte> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (a[i] < queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {500, 100, 300, 200, 400};
     * short result = N.kthLargest(numbers, 2);
     * // Returns 400 (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(short[], int, int, int)
     */
    public static short kthLargest(final short[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {500, 100, 300, 200, 400};
     * short result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 200 (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(short[], int)
     */
    public static short kthLargest(final short[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Short> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (a[i] < queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int result = N.kthLargest(numbers, 2);
     * // Returns 400 (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(int[], int, int, int)
     */
    public static int kthLargest(final int[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 200 (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(int[], int)
     */
    public static int kthLargest(final int[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Integer> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (a[i] < queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long result = N.kthLargest(numbers, 2);
     * // Returns 4000L (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(long[], int, int, int)
     */
    public static long kthLargest(final long[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 2000L (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(long[], int)
     */
    public static long kthLargest(final long[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Long> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (a[i] > queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (a[i] < queue.peek()) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float result = N.kthLargest(numbers, 2);
     * // Returns 40.5f (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(float[], int, int, int)
     */
    public static float kthLargest(final float[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 20.5f (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(float[], int)
     */
    public static float kthLargest(final float[] a, final int fromIndex, final int toIndex, int k) throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Float> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Float.compare(a[i], queue.peek()) > 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (Float.compare(a[i], queue.peek()) < 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double result = N.kthLargest(numbers, 2);
     * // Returns 40.5 (second largest)
     * }</pre>
     *
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(double[], int, int, int)
     */
    public static double kthLargest(final double[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double result = N.kthLargest(numbers, 1, 4, 2);
     * // Returns 20.5 (second largest in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(double[], int)
     */
    public static double kthLargest(final double[] a, final int fromIndex, final int toIndex, int k)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(a, fromIndex, toIndex);
        } else if (k == len) {
            return min(a, fromIndex, toIndex);
        }

        Queue<Double> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k);

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    if (Double.compare(a[i], queue.peek()) > 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        } else {
            k = len - k + 1;

            queue = new PriorityQueue<>(k, Comparator.reverseOrder());

            for (int i = fromIndex; i < toIndex; i++) {
                if (queue.size() < k) {
                    queue.add(a[i]);
                } else {
                    //noinspection DataFlowIssue
                    if (Double.compare(a[i], queue.peek()) < 0) {
                        queue.remove();
                        queue.add(a[i]);
                    }
                }
            }
        }

        //noinspection DataFlowIssue
        return queue.peek();
    }

    /**
     * Returns the k-th largest element in the array (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * String result = N.kthLargest(words, 2);
     * // Returns "date" (second largest alphabetically)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(Comparable[], int, int, int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final T[] a, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * String result = N.kthLargest(words, 1, 4, 2);
     * // Returns "banana" (second largest in range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(Comparable[], int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final T[] a, final int fromIndex, final int toIndex, final int k)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        return kthLargest(a, fromIndex, toIndex, k, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the k-th largest element in the array using the provided comparator (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * String result = N.kthLargest(words, 2, Comparator.comparingInt(String::length));
     * // Returns "cherry" (second longest)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param k the position (1-based) of the largest element to find
     * @param cmp the comparator to determine ordering
     * @return the k-th largest element
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, array.length]
     * @see #kthLargest(Object[], int, int, int, Comparator)
     */
    public static <T> T kthLargest(final T[] a, final int k, final Comparator<? super T> cmp) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotEmpty(a, "The specified array cannot be null or empty");

        return kthLargest(a, 0, a.length, k, cmp);
    }

    /**
     * Returns the k-th largest element within the specified range using the provided comparator (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * String result = N.kthLargest(words, 1, 4, 2, Comparator.comparingInt(String::length));
     * // Returns "banana" (second longest in range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @param cmp the comparator to determine ordering
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the array is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(Object[], int, Comparator)
     */
    public static <T> T kthLargest(final T[] a, final int fromIndex, final int toIndex, int k, final Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(a) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The specified array cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, len(a));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        return kthLargest(Arrays.asList(a), fromIndex, toIndex, k, cmp);
    }

    /**
     * Returns the k-th largest element in the collection (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * String result = N.kthLargest(words, 2);
     * // Returns "date" (second largest alphabetically)
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element
     * @throws IllegalArgumentException if the collection is {@code null}/empty or k is out of range [1, collection.size()]
     * @see #kthLargest(Collection, int, int, int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final Collection<? extends T> c, final int k) throws IllegalArgumentException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return kthLargest(c, 0, c.size(), k);
    }

    /**
     * Returns the k-th largest element within the specified range (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * String result = N.kthLargest(words, 1, 4, 2);
     * // Returns "banana" (second largest in range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the collection is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(Collection, int)
     */
    public static <T extends Comparable<? super T>> T kthLargest(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int k)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection cannot be null or empty");
        }

        return kthLargest(c, fromIndex, toIndex, k, (Comparator<T>) NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the k-th largest element in the collection using the provided comparator (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * String result = N.kthLargest(words, 2, Comparator.comparingInt(String::length));
     * // Returns "cherry" (second longest)
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param k the position (1-based) of the largest element to find
     * @param cmp the comparator to determine ordering
     * @return the k-th largest element
     * @throws IllegalArgumentException if the collection is {@code null}/empty or k is out of range [1, collection.size()]
     * @see #kthLargest(Collection, int, int, int, Comparator)
     */
    public static <T> T kthLargest(final Collection<? extends T> c, final int k, final Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotEmpty(c, "The specified collection cannot be null or empty");

        return kthLargest(c, 0, c.size(), k, cmp);
    }

    /**
     * Returns the k-th largest element within the specified range using the provided comparator (k=1 returns the largest, k=2 the second largest, etc).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * String result = N.kthLargest(words, 1, 4, 2, Comparator.comparingInt(String::length));
     * // Returns "banana" (second longest in range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param k the position (1-based) of the largest element to find
     * @param cmp the comparator to determine ordering
     * @return the k-th largest element within the range
     * @throws IllegalArgumentException if the collection is {@code null}/empty or k is out of range [1, range length]
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #kthLargest(Collection, int, Comparator)
     */
    public static <T> T kthLargest(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int k, final Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (isEmpty(c) || toIndex - fromIndex < 1) {
            throw new IllegalArgumentException("The length of collection cannot be null or empty");
        }

        checkFromToIndex(fromIndex, toIndex, size(c));
        checkArgument(k > 0 && k <= toIndex - fromIndex, "'k' (%s) is out of range %s", k, toIndex - fromIndex);

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final int len = toIndex - fromIndex;

        if (k == 1) {
            return max(c, fromIndex, toIndex, comparator);
        } else if (k == len) {
            return min(c, fromIndex, toIndex, comparator);
        }

        final Iterator<? extends T> iter = c.iterator();
        Queue<T> queue = null;

        if (k <= len / 2) {
            queue = new PriorityQueue<>(k, cmp);
            int cursor = 0;

            while (cursor < fromIndex && iter.hasNext()) {
                cursor++;
                iter.next();
            }

            T e = null;
            while (cursor < toIndex && iter.hasNext()) {
                e = iter.next();

                if (e == null) {
                    final Object[] tmp = N.toArray(c, fromIndex, toIndex);
                    N.sort((T[]) tmp, comparator);
                    return (T) tmp[tmp.length - k];
                }

                if (queue.size() < k) {
                    queue.add(e);
                } else {
                    if (comparator.compare(e, queue.peek()) > 0) {
                        queue.remove();
                        queue.add(e);
                    }
                }

                cursor++;
            }
        } else {
            final int n = len - k + 1;

            queue = new PriorityQueue<>(n, Comparators.reverseOrder(comparator));

            int cursor = 0;

            while (cursor < fromIndex && iter.hasNext()) {
                cursor++;
                iter.next();
            }

            T e = null;
            while (cursor < toIndex && iter.hasNext()) {
                e = iter.next();

                if (e == null) {
                    final Object[] tmp = N.toArray(c, fromIndex, toIndex);
                    N.sort((T[]) tmp, comparator);
                    return (T) tmp[tmp.length - k];
                }

                if (queue.size() < n) {
                    queue.add(e);
                } else {
                    if (comparator.compare(e, queue.peek()) < 0) {
                        queue.remove();
                        queue.add(e);
                    }
                }

                cursor++;
            }
        }

        return queue.peek();
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 10, 30, 20, 40};
     * short[] result = N.top(numbers, 3);
     * // Returns [50, 40, 30] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(short[], int, Comparator)
     */
    public static short[] top(final short[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 10, 30, 20, 40};
     * short[] result = N.top(numbers, 3, Comparator.reverseOrder());
     * // Returns [10, 20, 30] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(short[], int, int, int, Comparator)
     */
    public static short[] top(final short[] a, final int n, final Comparator<? super Short> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 10, 30, 20, 40};
     * short[] result = N.top(numbers, 1, 4, 2);
     * // Returns [30, 20] from range [1,4) in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(short[], int, int, int, Comparator)
     */
    public static short[] top(final short[] a, final int fromIndex, final int toIndex, final int n) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {50, 10, 30, 20, 40};
     * short[] result = N.top(numbers, 1, 4, 2, Comparator.reverseOrder());
     * // Returns [10, 20] in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(short[], int, Comparator)
     */
    public static short[] top(final short[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Short> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return EMPTY_SHORT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Short> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Short> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Short> iter = heap.iterator();
        final short[] res = new short[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int[] result = N.top(numbers, 3);
     * // Returns [500, 400, 300] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(int[], int, Comparator)
     */
    public static int[] top(final int[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int[] result = N.top(numbers, 3, Comparator.reverseOrder());
     * // Returns [100, 200, 300] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(int[], int, int, int, Comparator)
     */
    public static int[] top(final int[] a, final int n, final Comparator<? super Integer> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int[] result = N.top(numbers, 1, 4, 2);
     * // Returns [300, 200] from range [1,4) in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(int[], int, int, int, Comparator)
     */
    public static int[] top(final int[] a, final int fromIndex, final int toIndex, final int n) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {500, 100, 300, 200, 400};
     * int[] result = N.top(numbers, 1, 4, 2, Comparator.reverseOrder());
     * // Returns [100, 200] in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(int[], int, Comparator)
     */
    public static int[] top(final int[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Integer> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return EMPTY_INT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Integer> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Integer> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Integer> iter = heap.iterator();
        final int[] res = new int[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long[] result = N.top(numbers, 3);
     * // Returns [5000L, 4000L, 3000L] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(long[], int, Comparator)
     */
    public static long[] top(final long[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long[] result = N.top(numbers, 3, Comparator.reverseOrder());
     * // Returns [1000L, 2000L, 3000L] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(long[], int, int, int, Comparator)
     */
    public static long[] top(final long[] a, final int n, final Comparator<? super Long> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long[] result = N.top(numbers, 1, 4, 2);
     * // Returns [3000L, 2000L] from range [1,4) in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(long[], int, int, int, Comparator)
     */
    public static long[] top(final long[] a, final int fromIndex, final int toIndex, final int n) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {5000L, 1000L, 3000L, 2000L, 4000L};
     * long[] result = N.top(numbers, 1, 4, 2, Comparator.reverseOrder());
     * // Returns [1000L, 2000L] in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(long[], int, Comparator)
     */
    public static long[] top(final long[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Long> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return EMPTY_LONG_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Long> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Long> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Long> iter = heap.iterator();
        final long[] res = new long[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float[] result = N.top(numbers, 3);
     * // Returns [50.5f, 40.5f, 30.5f] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(float[], int, Comparator)
     */
    public static float[] top(final float[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float[] result = N.top(numbers, 3, Comparator.reverseOrder());
     * // Returns [10.5f, 20.5f, 30.5f] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(float[], int, int, int, Comparator)
     */
    public static float[] top(final float[] a, final int n, final Comparator<? super Float> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float[] result = N.top(numbers, 1, 4, 2);
     * // Returns [30.5f, 20.5f] from range [1,4) in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(float[], int, int, int, Comparator)
     */
    public static float[] top(final float[] a, final int fromIndex, final int toIndex, final int n) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {50.5f, 10.5f, 30.5f, 20.5f, 40.5f};
     * float[] result = N.top(numbers, 1, 4, 2, Comparator.reverseOrder());
     * // Returns [10.5f, 20.5f] in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(float[], int, Comparator)
     */
    public static float[] top(final float[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Float> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return EMPTY_FLOAT_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Float> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Float> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Float> iter = heap.iterator();
        final float[] res = new float[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double[] result = N.top(numbers, 3);
     * // Returns [50.5, 40.5, 30.5] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(double[], int, Comparator)
     */
    public static double[] top(final double[] a, final int n) {
        return top(a, n, null);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double[] result = N.top(numbers, 3, Comparator.reverseOrder());
     * // Returns [10.5, 20.5, 30.5] in any order
     * }</pre>
     *
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(double[], int, int, int, Comparator)
     */
    public static double[] top(final double[] a, final int n, final Comparator<? super Double> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double[] result = N.top(numbers, 1, 4, 2);
     * // Returns [30.5, 20.5] from range [1,4) in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return an array containing the top n largest elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(double[], int, int, int, Comparator)
     */
    public static double[] top(final double[] a, final int fromIndex, final int toIndex, final int n)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {50.5, 10.5, 30.5, 20.5, 40.5};
     * double[] result = N.top(numbers, 1, 4, 2, Comparator.reverseOrder());
     * // Returns [10.5, 20.5] in any order
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering ({@code null} for natural order)
     * @return an array containing the top n elements from the range (empty if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(double[], int, Comparator)
     */
    public static double[] top(final double[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super Double> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return EMPTY_DOUBLE_ARRAY;
        } else if (n >= toIndex - fromIndex) {
            return copyOfRange(a, fromIndex, toIndex);
        }

        final Comparator<? super Double> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<Double> heap = new PriorityQueue<>(n, comparator);

        for (int i = fromIndex; i < toIndex; i++) {
            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), a[i]) < 0) {
                    heap.poll();
                    heap.add(a[i]);
                }
            } else {
                heap.offer(a[i]);
            }
        }

        final Iterator<Double> iter = heap.iterator();
        final double[] res = new double[n];
        int idx = 0;

        while (iter.hasNext()) {
            res[idx++] = iter.next();
        }

        return res;
    }

    /**
     * Returns the top n largest elements from the array (order not guaranteed, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 3);
     * // Returns list with 3 largest elements in any order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param n the number of top elements to return
     * @return a list containing the top n largest elements (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Object[], int, Comparator)
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int n) {
        return top(a, n, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 3, Comparator.comparingInt(String::length));
     * // Returns list with 3 longest elements in any order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @return a list containing the top n elements (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Object[], int, int, int, Comparator)
     */
    public static <T> List<T> top(final T[] a, final int n, final Comparator<? super T> cmp) {
        return top(a, 0, len(a), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 1, 4, 2);
     * // Returns list with 2 largest elements from range [1,4) in any order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return a list containing the top n elements from the range (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Comparable[], int)
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, NULL_MIN_COMPARATOR);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 1, 4, 2, Comparator.comparingInt(String::length));
     * // Returns list with 2 longest elements from range [1,4) in any order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @return a list containing the top n elements from the range (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Object[], int, Comparator)
     */
    public static <T> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (isEmpty(a) || n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            return toList(a, fromIndex, toIndex);
        }

        return top(Arrays.asList(a), fromIndex, toIndex, n, cmp);
    }

    /**
     * Returns the top n largest elements from the collection (order not guaranteed, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 3);
     * // Returns list with 3 largest elements in any order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param n the number of top elements to return
     * @return a list containing the top n largest elements (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Collection, int, Comparator)
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int n) {
        return top(c, n, null);
    }

    /**
     * Returns the top n largest elements from the collection using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 3, Comparator.comparingInt(String::length));
     * // Returns list with 3 longest elements in any order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @return a list containing the top n elements (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Collection, int, int, int, Comparator)
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int n, final Comparator<? super T> cmp) {
        return top(c, 0, size(c), n, cmp);
    }

    /**
     * Returns the top n largest elements from the specified range (order not guaranteed, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 1, 4, 2);
     * // Returns list with 2 largest elements from range [1,4) in any order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @return a list containing the top n elements from the range (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Collection, int)
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(c, fromIndex, toIndex, n, null);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (order not guaranteed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 1, 4, 2, Comparator.comparingInt(String::length));
     * // Returns list with 2 longest elements from range [1,4) in any order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @return a list containing the top n elements from the range (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Collection, int, Comparator)
     */
    @SuppressWarnings("deprecation")
    public static <T> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, c == null ? 0 : c.size());

        if (isEmpty(c) || n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            if (fromIndex == 0 && toIndex == c.size()) {
                return new ArrayList<>(c);
            } else {
                final List<T> res = new ArrayList<>(toIndex - fromIndex);
                final Iterator<? extends T> iter = c.iterator();
                T e = null;

                for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                    e = iter.next();

                    if (i < fromIndex) {
                        continue;
                    }

                    res.add(e);
                }

                return res;
            }
        }

        final Comparator<? super T> comparator = cmp == null ? NULL_MIN_COMPARATOR : cmp;
        final Queue<T> heap = new PriorityQueue<>(n, comparator);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (e == null) {
                    final Object[] tmp = N.toArray(c, fromIndex, toIndex);
                    N.sort((T[]) tmp, comparator);
                    return N.toList((T[]) tmp, tmp.length - n, tmp.length);
                }

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), e) < 0) {
                        heap.poll();
                        heap.add(e);
                    }
                } else {
                    heap.offer(e);
                }
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();
            T e = null;

            for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                e = iter.next();

                if (i < fromIndex) {
                    continue;
                }

                if (e == null) {
                    final Object[] tmp = N.toArray(c, fromIndex, toIndex);
                    N.sort((T[]) tmp, comparator);
                    return N.toList((T[]) tmp, tmp.length - n, tmp.length);
                }

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), e) < 0) {
                        heap.poll();
                        heap.add(e);
                    }
                } else {
                    heap.offer(e);
                }
            }
        }

        return InternalUtil.createList((T[]) heap.toArray(EMPTY_OBJECT_ARRAY));
    }

    /**
     * Returns the top n largest elements from the array (encounter order optionally preserved, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 3, true);
     * // Returns list with 3 largest elements in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param n the number of top elements to return
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n largest elements (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Object[], int, Comparator, boolean)
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int n, final boolean keepEncounterOrder) {
        return top(a, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the array using the provided comparator (encounter order optionally preserved).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 3, Comparator.comparingInt(String::length), true);
     * // Returns list with 3 longest elements in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Object[], int, int, int, Comparator, boolean)
     */
    public static <T> List<T> top(final T[] a, final int n, final Comparator<? super T> cmp, final boolean keepEncounterOrder) {
        return top(a, 0, len(a), n, cmp, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the specified range (encounter order optionally preserved, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 1, 4, 2, true);
     * // Returns list with 2 largest elements from range [1,4) in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements from the range (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Comparable[], int, boolean)
     */
    public static <T extends Comparable<? super T>> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n,
            final boolean keepEncounterOrder) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(a, fromIndex, toIndex, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (encounter order optionally preserved).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"elephant", "apple", "cherry", "banana", "date"};
     * List<String> result = N.top(words, 1, 4, 2, Comparator.comparingInt(String::length), true);
     * // Returns list with 2 longest elements from range [1,4) in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements from the range (empty list if array is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Object[], int, Comparator, boolean)
     */
    public static <T> List<T> top(final T[] a, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp,
            final boolean keepEncounterOrder) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, a == null ? 0 : a.length);

        if (!keepEncounterOrder) {
            return top(a, fromIndex, toIndex, n, cmp);
        }

        if (isEmpty(a) || n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            return toList(a, fromIndex, toIndex);
        }

        final Comparator<Indexed<T>> comparator = createComparatorForIndexedObject(cmp);

        final Queue<Indexed<T>> heap = new PriorityQueue<>(n, comparator);
        Indexed<T> indexed = null;

        for (int i = fromIndex; i < toIndex; i++) {
            indexed = Indexed.of(a[i], i);

            if (heap.size() >= n) {
                if (comparator.compare(heap.peek(), indexed) < 0) {
                    heap.poll();
                    heap.add(indexed);
                }
            } else {
                heap.offer(indexed);
            }
        }

        final Indexed<T>[] arrayOfIndexed = heap.toArray(new Indexed[0]);

        sort(arrayOfIndexed, Comparator.comparingInt(Indexed::index));

        final List<T> res = new ArrayList<>(arrayOfIndexed.length);

        for (final Indexed<T> element : arrayOfIndexed) {
            res.add(element.value());
        }

        return res;
    }

    @SuppressWarnings("rawtypes")
    private static <T> Comparator<Indexed<T>> createComparatorForIndexedObject(final Comparator<? super T> cmp) {
        Comparator<Indexed<T>> pairCmp = null;

        if (cmp != null) {
            pairCmp = (a, b) -> cmp.compare(a.value(), b.value());
        } else {
            final Comparator<Indexed<Comparable>> tmp = (a, b) -> compare(a.value(), b.value());
            pairCmp = (Comparator) tmp;
        }

        return pairCmp;
    }

    /**
     * Returns the top n largest elements from the collection (encounter order optionally preserved, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 3, true);
     * // Returns list with 3 largest elements in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param n the number of top elements to return
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n largest elements (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Collection, int, Comparator, boolean)
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int n, final boolean keepEncounterOrder) {
        return top(c, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the collection using the provided comparator (encounter order optionally preserved).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 3, Comparator.comparingInt(String::length), true);
     * // Returns list with 3 longest elements in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @see #top(Collection, int, int, int, Comparator, boolean)
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int n, final Comparator<? super T> cmp, final boolean keepEncounterOrder) {
        return top(c, 0, size(c), n, cmp, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the specified range (encounter order optionally preserved, {@code null} values treated as smallest).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 1, 4, 2, true);
     * // Returns list with 2 largest elements from range [1,4) in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements from the range (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Collection, int, boolean)
     */
    public static <T extends Comparable<? super T>> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n,
            final boolean keepEncounterOrder) throws IllegalArgumentException, IndexOutOfBoundsException {
        return top(c, fromIndex, toIndex, n, NULL_MIN_COMPARATOR, keepEncounterOrder);
    }

    /**
     * Returns the top n largest elements from the specified range using the provided comparator (encounter order optionally preserved).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("elephant", "apple", "cherry", "banana", "date");
     * List<String> result = N.top(words, 1, 4, 2, Comparator.comparingInt(String::length), true);
     * // Returns list with 2 longest elements from range [1,4) in encounter order
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param n the number of top elements to return
     * @param cmp the comparator to determine ordering
     * @param keepEncounterOrder if {@code true}, preserves encounter order; otherwise order not guaranteed
     * @return a list containing the top n elements from the range (empty list if collection is {@code null}/empty or n is 0)
     * @throws IllegalArgumentException if n is negative
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #top(Collection, int, Comparator, boolean)
     */
    public static <T> List<T> top(final Collection<? extends T> c, final int fromIndex, final int toIndex, final int n, final Comparator<? super T> cmp,
            final boolean keepEncounterOrder) throws IllegalArgumentException, IndexOutOfBoundsException {
        checkArgNotNegative(n, cs.n);
        checkFromToIndex(fromIndex, toIndex, c == null ? 0 : c.size());

        if (!keepEncounterOrder) {
            return top(c, fromIndex, toIndex, n, cmp);
        }

        if (isEmpty(c) || n == 0) {
            return new ArrayList<>();
        } else if (n >= toIndex - fromIndex) {
            if (fromIndex == 0 && toIndex == c.size()) {
                return new ArrayList<>(c);
            } else {
                final List<T> res = new ArrayList<>(toIndex - fromIndex);
                final Iterator<? extends T> iter = c.iterator();
                T e = null;

                for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                    e = iter.next();

                    if (i < fromIndex) {
                        continue;
                    }

                    res.add(e);
                }

                return res;
            }
        }

        final Comparator<Indexed<T>> comparator = createComparatorForIndexedObject(cmp);

        final Queue<Indexed<T>> heap = new PriorityQueue<>(n, comparator);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            Indexed<T> indexed = null;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                indexed = Indexed.of(e, i);

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), indexed) < 0) {
                        heap.poll();
                        heap.add(indexed);
                    }
                } else {
                    heap.offer(indexed);
                }
            }
        } else {
            final Iterator<? extends T> iter = c.iterator();
            Indexed<T> indexed = null;
            T e = null;

            for (int i = 0; i < toIndex && iter.hasNext(); i++) {
                e = iter.next();

                if (i < fromIndex) {
                    continue;
                }

                indexed = Indexed.of(e, i);

                if (heap.size() >= n) {
                    if (comparator.compare(heap.peek(), indexed) < 0) {
                        heap.poll();
                        heap.add(indexed);
                    }
                } else {
                    heap.offer(indexed);
                }
            }
        }

        final Indexed<T>[] arrayOfIndexed = heap.toArray(new Indexed[0]);

        sort(arrayOfIndexed, Comparator.comparingInt(Indexed::index));

        final List<T> res = new ArrayList<>(arrayOfIndexed.length);

        for (final Indexed<T> element : arrayOfIndexed) {
            res.add(element.value());
        }

        return res;
    }

    /**
     * Calculates the percentiles of the provided sorted array of characters.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(char[])} if needed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] grades = {'A', 'A', 'B', 'B', 'C', 'C', 'D', 'F'};
     * Arrays.sort(grades); // Ensure sorted
     * Map<Percentage, Character> percentiles = N.percentiles(grades);
     *
     * // Access specific percentiles
     * char median = percentiles.get(Percentage.P50);  // 'B' or 'C'
     * char p90 = percentiles.get(Percentage.P90);     // High grade threshold
     * }</pre>
     *
     * @param sortedArray the sorted array of characters for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding characters from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see Percentage
     */
    public static Map<Percentage, Character> percentiles(final char[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty"); //NOSONAR

        final int len = sortedArray.length;
        final Map<Percentage, Character> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of bytes.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(byte[])} if needed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] scores = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
     * Arrays.sort(scores); // Ensure sorted
     * Map<Percentage, Byte> percentiles = N.percentiles(scores);
     *
     * // Find percentile thresholds
     * byte median = percentiles.get(Percentage.P50);   // Returns 50
     * byte p95 = percentiles.get(Percentage.P95);      // Returns 95
     * byte p99 = percentiles.get(Percentage.P99);      // Returns 99
     * }</pre>
     *
     * @param sortedArray the sorted array of bytes for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding bytes from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see Percentage
     */
    public static Map<Percentage, Byte> percentiles(final byte[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Byte> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of shorts.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(short[])} if needed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] responseTimes = {100, 150, 200, 250, 300, 350, 400, 450, 500};
     * Arrays.sort(responseTimes);
     * Map<Percentage, Short> percentiles = N.percentiles(responseTimes);
     *
     * // Analyze response time distribution
     * short p50 = percentiles.get(Percentage.P50);   // Median: 300ms
     * short p95 = percentiles.get(Percentage.P95);   // 95th percentile
     * short p99 = percentiles.get(Percentage.P99);   // 99th percentile for SLA
     * }</pre>
     *
     * @param sortedArray the sorted array of shorts for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding shorts from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see Percentage
     */
    public static Map<Percentage, Short> percentiles(final short[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Short> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of integers.
     * 
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * final int[] sortedArray = Array.range(1, 101);
     * final Map<Percentage, Integer> percentiles = N.percentiles(sortedArray);
     * percentiles.forEach(Fn.println("="));
     *                     0.0001%=1
     *                     0.001%=1
     *                     0.01%=1
     *                     0.1%=1
     *                     1%=2
     *                     2%=3
     *                     3%=4
     *                     4%=5
     *                     5%=6
     *                     6%=7
     *                     7%=8
     *                     8%=9
     *                     9%=10
     *                     10%=11
     *                     20%=21
     *                     30%=31
     *                     40%=41
     *                     50%=51
     *                     60%=61
     *                     70%=71
     *                     80%=81
     *                     90%=91
     *                     91%=92
     *                     92%=93
     *                     93%=94
     *                     94%=95
     *                     95%=96
     *                     96%=97
     *                     97%=98
     *                     98%=99
     *                     99%=100
     *                     99.9%=100
     *                     99.99%=100
     *                     99.999%=100
     *                     99.9999%=100
     * }</pre>
     *
     * @param sortedArray the sorted array of integers for which to calculate the percentiles.
     * @return a map where the keys are the percentiles and the values are the corresponding integers from the array.
     * @throws IllegalArgumentException if the provided array is empty.
     */
    public static Map<Percentage, Integer> percentiles(final int[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Integer> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of longs.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(long[])} if needed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] timestamps = {1000000L, 2000000L, 3000000L, 4000000L, 5000000L};
     * Arrays.sort(timestamps);
     * Map<Percentage, Long> percentiles = N.percentiles(timestamps);
     *
     * // Analyze timestamp distribution
     * long median = percentiles.get(Percentage.P50);   // Middle timestamp
     * long p99 = percentiles.get(Percentage.P99);      // 99th percentile latency
     * }</pre>
     *
     * @param sortedArray the sorted array of longs for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding longs from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see Percentage
     */
    public static Map<Percentage, Long> percentiles(final long[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Long> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of floats.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(float[])} if needed.</p>
     *
     * <p><b>Note:</b> For NaN and special float values, ensure proper sorting beforehand.
     * NaN values will affect percentile calculations as they follow IEEE 754 comparison rules.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] prices = {19.99f, 29.99f, 39.99f, 49.99f, 59.99f, 69.99f};
     * Arrays.sort(prices);
     * Map<Percentage, Float> percentiles = N.percentiles(prices);
     *
     * // Analyze price distribution
     * float medianPrice = percentiles.get(Percentage.P50);    // Middle price point
     * float p75 = percentiles.get(Percentage.P75);            // Upper quartile
     * float p25 = percentiles.get(Percentage.P25);            // Lower quartile
     * }</pre>
     *
     * @param sortedArray the sorted array of floats for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding floats from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see #percentiles(double[])
     * @see Percentage
     */
    public static Map<Percentage, Float> percentiles(final float[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Float> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array of doubles.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order for accurate results.
     * Use {@link java.util.Arrays#sort(double[])} if needed.</p>
     *
     * <p><b>Note:</b> For NaN and special double values, ensure proper sorting beforehand.
     * NaN values will affect percentile calculations as they follow IEEE 754 comparison rules.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] measurements = {10.5, 20.3, 30.7, 40.2, 50.9, 60.1, 70.4, 80.8, 90.6};
     * Arrays.sort(measurements);
     * Map<Percentage, Double> percentiles = N.percentiles(measurements);
     *
     * // Statistical analysis
     * double median = percentiles.get(Percentage.P50);       // 50th percentile (median)
     * double p95 = percentiles.get(Percentage.P95);          // 95th percentile
     * double p99_9 = percentiles.get(Percentage.P99_9);      // 99.9th percentile
     *
     * System.out.printf("Median: %.2f, P95: %.2f%n", median, p95);
     * }</pre>
     *
     * @param sortedArray the sorted array of doubles for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding doubles from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see #percentiles(float[])
     * @see Percentage
     */
    public static Map<Percentage, Double> percentiles(final double[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, Double> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted array.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input array must be sorted in ascending order according to the natural
     * ordering of its elements (or custom comparator used during sorting). Use
     * {@link java.util.Arrays#sort(Object[])} if elements implement {@link Comparable}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David", "Eve", "Frank"};
     * Arrays.sort(names);
     * Map<Percentage, String> percentiles = N.percentiles(names);
     *
     * // Find percentile values in sorted data
     * String median = percentiles.get(Percentage.P50);    // Middle name alphabetically
     * String p75 = percentiles.get(Percentage.P75);       // Upper quartile
     *
     * // With custom objects
     * Person[] people = {new Person("Alice", 25), new Person("Bob", 30)};
     * Arrays.sort(people, Comparator.comparing(Person::getAge));
     * Map<Percentage, Person> agePercentiles = N.percentiles(people);
     * Person medianAge = agePercentiles.get(Percentage.P50);
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param sortedArray the sorted array for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding elements from the array.
     * @throws IllegalArgumentException if the provided array is {@code null} or empty
     * @see #percentiles(int[])
     * @see #percentiles(List)
     * @see Percentage
     */
    public static <T> Map<Percentage, T> percentiles(final T[] sortedArray) throws IllegalArgumentException {
        checkArgNotEmpty(sortedArray, "The specified 'sortedArray' cannot be null or empty");

        final int len = sortedArray.length;
        final Map<Percentage, T> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedArray[(int) (len * p.doubleValue())]);
        }

        return m;
    }

    /**
     * Calculates the percentiles of the provided sorted list.
     * Returns a map containing percentile values from the predefined {@link Percentage} enum
     * (0.0001%, 0.001%, 0.01%, 0.1%, 1%-99%, 99.9%, 99.99%, 99.999%, 99.9999%).
     *
     * <p><b>Important:</b> The input list must be sorted in ascending order according to the natural
     * ordering of its elements (or custom comparator used during sorting). Use
     * {@link java.util.Collections#sort(List)} if elements implement {@link Comparable}.</p>
     *
     * <p><b>Performance note:</b> This method uses indexed access via {@link List#get(int)}.
     * For optimal performance, use list implementations with O(1) random access like {@link java.util.ArrayList}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> scores = Arrays.asList(65, 70, 75, 80, 85, 90, 95, 100);
     * Collections.sort(scores);
     * Map<Percentage, Integer> percentiles = N.percentiles(scores);
     *
     * // Analyze test score distribution
     * int median = percentiles.get(Percentage.P50);      // 80 (median score)
     * int p90 = percentiles.get(Percentage.P90);         // 95 (90th percentile)
     * int p10 = percentiles.get(Percentage.P10);         // 70 (10th percentile)
     *
     * // Useful for SLA calculations
     * List<Double> latencies = getResponseLatencies(); // Pre-sorted
     * Map<Percentage, Double> latencyPercentiles = N.percentiles(latencies);
     * double sla = latencyPercentiles.get(Percentage.P99);  // 99th percentile for SLA
     * }</pre>
     *
     * @param <T> the type of elements in the list
     * @param sortedList the sorted list for which to calculate the percentiles
     * @return a map where the keys are the percentiles and the values are the corresponding elements from the list.
     * @throws IllegalArgumentException if the provided list is {@code null} or empty
     * @see #percentiles(int[])
     * @see #percentiles(Object[])
     * @see Percentage
     */
    public static <T> Map<Percentage, T> percentiles(final List<T> sortedList) throws IllegalArgumentException {
        checkArgNotEmpty(sortedList, "The specified 'sortedList' cannot be null or empty");

        final int size = sortedList.size();
        final Map<Percentage, T> m = newLinkedHashMap(Percentage.values().length);

        for (final Percentage p : Percentage.values()) {
            m.put(p, sortedList.get((int) (size * p.doubleValue())));
        }

        return m;
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, true, false};
     * boolean[] result = N.filter(flags, b -> b);
     * // Returns [true, true, true]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(boolean[], int, int, BooleanPredicate)
     */
    public static boolean[] filter(final boolean[] a, final BooleanPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, true, false};
     * boolean[] result = N.filter(flags, 1, 4, b -> b);
     * // Returns [true, true] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #filter(boolean[], BooleanPredicate)
     */
    public static boolean[] filter(final boolean[] a, final int fromIndex, final int toIndex, final BooleanPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] result = new boolean[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'B', 'c', 'D', 'e'};
     * char[] result = N.filter(letters, Character::isLowerCase);
     * // Returns ['a', 'c', 'e']
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(char[], int, int, CharPredicate)
     */
    public static char[] filter(final char[] a, final CharPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'B', 'c', 'D', 'e'};
     * char[] result = N.filter(letters, 1, 4, Character::isUpperCase);
     * // Returns ['B', 'D'] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #filter(char[], CharPredicate)
     */
    public static char[] filter(final char[] a, final int fromIndex, final int toIndex, final CharPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] result = new char[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 3, 4, 5};
     * byte[] result = N.filter(numbers, n -> n % 2 == 0);
     * // Returns [2, 4]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(byte[], int, int, BytePredicate)
     */
    public static byte[] filter(final byte[] a, final BytePredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 3, 4, 5};
     * byte[] result = N.filter(numbers, 1, 4, n -> n % 2 == 0);
     * // Returns [2, 4] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #filter(byte[], BytePredicate)
     */
    public static byte[] filter(final byte[] a, final int fromIndex, final int toIndex, final BytePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] result = new byte[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30, 40, 50};
     * short[] result = N.filter(numbers, n -> n > 25);
     * // Returns [30, 40, 50]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(short[], int, int, ShortPredicate)
     */
    public static short[] filter(final short[] a, final ShortPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30, 40, 50};
     * short[] result = N.filter(numbers, 1, 4, n -> n > 25);
     * // Returns [30, 40] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #filter(short[], ShortPredicate)
     */
    public static short[] filter(final short[] a, final int fromIndex, final int toIndex, final ShortPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] result = new short[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * int[] result = N.filter(numbers, n -> n % 2 == 0);
     * // Returns [2, 4]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(int[], int, int, IntPredicate)
     */
    public static int[] filter(final int[] a, final IntPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5};
     * int[] result = N.filter(numbers, 1, 4, n -> n % 2 == 0);
     * // Returns [2, 4] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #filter(int[], IntPredicate)
     */
    public static int[] filter(final int[] a, final int fromIndex, final int toIndex, final IntPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        int[] result = new int[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * long[] result = N.filter(numbers, n -> n > 250L);
     * // Returns [300L, 400L, 500L]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(long[], int, int, LongPredicate)
     */
    public static long[] filter(final long[] a, final LongPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * long[] result = N.filter(numbers, 1, 4, n -> n > 250L);
     * // Returns [300L, 400L] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(long[], LongPredicate)
     */
    public static long[] filter(final long[] a, final int fromIndex, final int toIndex, final LongPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        long[] result = new long[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.5f, 3.5f, 4.5f, 5.5f};
     * float[] result = N.filter(numbers, n -> n > 3.0f);
     * // Returns [3.5f, 4.5f, 5.5f]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(float[], int, int, FloatPredicate)
     */
    public static float[] filter(final float[] a, final FloatPredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.5f, 3.5f, 4.5f, 5.5f};
     * float[] result = N.filter(numbers, 1, 4, n -> n > 3.0f);
     * // Returns [3.5f, 4.5f] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(float[], FloatPredicate)
     */
    public static float[] filter(final float[] a, final int fromIndex, final int toIndex, final FloatPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] result = new float[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new array containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.5, 3.5, 4.5, 5.5};
     * double[] result = N.filter(numbers, n -> n > 3.0);
     * // Returns [3.5, 4.5, 5.5]
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new array containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(double[], int, int, DoublePredicate)
     */
    public static double[] filter(final double[] a, final DoublePredicate filter) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return filter(a, 0, a.length, filter);
    }

    /**
     * Returns a new array containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.5, 3.5, 4.5, 5.5};
     * double[] result = N.filter(numbers, 1, 4, n -> n > 3.0);
     * // Returns [3.5, 4.5] from range [1,4)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return a new array containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(double[], DoublePredicate)
     */
    public static double[] filter(final double[] a, final int fromIndex, final int toIndex, final DoublePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] result = new double[(toIndex - fromIndex) / 2];
        int len = result.length;
        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                if (count == len) {
                    result = copyOf(result, toIndex - fromIndex);
                    len = result.length;
                }

                result[count++] = a[i];
            }
        }

        return result.length == count ? result : copyOfRange(result, 0, count);
    }

    /**
     * Returns a new list containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * List<String> result = N.filter(names, s -> s.length() > 4);
     * // Returns ["Alice", "Charlie", "David"]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array
     * @param filter the predicate to test each element
     * @return a new list containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(Object[], int, int, Predicate)
     */
    public static <T> List<T> filter(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return filter(a, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing only elements that match the given predicate (collection created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * Set<String> result = N.filter(names, s -> s.length() > 4, n -> new HashSet<>());
     * // Returns a Set containing ["Alice", "Charlie", "David"]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param <C> the type of the collection to return
     * @param a the array
     * @param filter the predicate to test each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing matching elements (empty if array is {@code null}/empty)
     * @see #filter(Object[], int, int, Predicate, IntFunction)
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final Predicate<? super T> filter, final IntFunction<C> supplier)
            throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return filter(a, 0, a.length, filter, supplier);
    }

    /**
     * Returns a new list containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David", "Eve"};
     * List<String> result = N.filter(names, 1, 4, s -> s.length() > 4);
     * // Returns ["Charlie", "David"] from range [1,4)
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return a new list containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(Object[], Predicate)
     */
    public static <T> List<T> filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter) throws IndexOutOfBoundsException {
        return filter(a, fromIndex, toIndex, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing only elements within the specified range that match the given predicate (collection created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David", "Eve"};
     * Set<String> result = N.filter(names, 1, 4, s -> s.length() > 4, n -> new HashSet<>());
     * // Returns a Set containing ["Charlie", "David"] from range [1,4)
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param <C> the type of the collection to return
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(Object[], Predicate, IntFunction)
     */
    public static <T, C extends Collection<T>> C filter(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter,
            final IntFunction<C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(min(9, (toIndex - fromIndex)));

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                result.add(a[i]);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
     * List<String> result = N.filter(names, 1, 4, s -> s.length() > 4);
     * // Returns ["Charlie", "David"] from range [1,4)
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return a new list containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(Collection, int, int, Predicate, IntFunction)
     */
    public static <T> List<T> filter(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Predicate<? super T> filter)
            throws IndexOutOfBoundsException {
        return filter(c, fromIndex, toIndex, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing only elements within the specified range that match the given predicate (collection created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
     * Set<String> result = N.filter(names, 1, 4, s -> s.length() > 4, n -> new HashSet<>());
     * // Returns a Set containing ["Charlie", "David"] from range [1,4)
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param <C> the type of the collection to return
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing matching elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #filter(Collection, int, int, Predicate)
     */
    public static <T, C extends Collection<T>> C filter(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Predicate<? super T> filter, final IntFunction<C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c)); // NOSONAR

        if (isEmpty(c) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(min(9, (toIndex - fromIndex)));

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (filter.test(e)) {
                    result.add(e);
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                if (filter.test(e)) {
                    result.add(e);

                }

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
     * List<Integer> result = N.filter(numbers, n -> n % 2 == 0);
     * // Returns [2, 4]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param c the iterable
     * @param filter the predicate to test each element
     * @return a new list containing matching elements (empty if iterable is {@code null}/empty)
     * @see #filter(Iterable, Predicate, IntFunction)
     */
    public static <T> List<T> filter(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        return filter(c, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing only elements that match the given predicate (collection created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
     * Set<Integer> result = N.filter(numbers, n -> n % 2 == 0, n -> new HashSet<>());
     * // Returns a Set containing [2, 4]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <C> the type of the collection to return
     * @param c the iterable
     * @param filter the predicate to test each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing matching elements (empty if iterable is {@code null}/empty)
     * @see #filter(Iterable, Predicate)
     */
    public static <T, C extends Collection<T>> C filter(final Iterable<? extends T> c, final Predicate<? super T> filter, final IntFunction<C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getMinSize(c));

        for (final T e : c) {
            if (filter.test(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements that match the given predicate (the iterator will be consumed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Integer> iter = Arrays.asList(1, 2, 3, 4, 5).iterator();
     * List<Integer> result = N.filter(iter, n -> n % 2 == 0);
     * // Returns [2, 4]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param iter the iterator
     * @param filter the predicate to test each element
     * @return a new list containing matching elements (empty if iterator is {@code null} or has no elements)
     * @see #filter(Iterator, Predicate, IntFunction)
     */
    public static <T> List<T> filter(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        return filter(iter, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing only elements that match the given predicate (collection created by the provided supplier, iterator will be consumed).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Integer> iter = Arrays.asList(1, 2, 3, 4, 5).iterator();
     * Set<Integer> result = N.filter(iter, n -> n % 2 == 0, n -> new HashSet<>());
     * // Returns a Set containing [2, 4]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <C> the type of the collection to return
     * @param iter the iterator
     * @param filter the predicate to test each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing matching elements (empty if iterator is {@code null} or has no elements)
     * @see #filter(Iterator, Predicate)
     */
    public static <T, C extends Collection<T>> C filter(final Iterator<? extends T> iter, final Predicate<? super T> filter, final IntFunction<C> supplier) {
        if (iter == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(9);
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (filter.test(e)) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new boolean array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * boolean[] isLongName = N.mapToBoolean(names, s -> s.length() > 4);  // [true, false, true]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a boolean value
     * @return a new boolean array containing the transformed values
     * @see #mapToBoolean(Object[], int, int, ToBooleanFunction)
     */
    public static <T> boolean[] mapToBoolean(final T[] a, final ToBooleanFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return mapToBoolean(a, 0, a.length, mapper);
    }

    /**
     * Returns a new boolean array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * boolean[] isLongName = N.mapToBoolean(names, 1, 3, s -> s.length() > 4);  // [false, true]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a boolean value
     * @return a new boolean array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToBoolean(Object[], ToBooleanFunction)
     */
    public static <T> boolean[] mapToBoolean(final T[] a, final int fromIndex, final int toIndex, final ToBooleanFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] result = new boolean[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsBoolean(a[i]);
        }

        return result;
    }

    /**
     * Returns a new boolean array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * boolean[] isLongName = N.mapToBoolean(names, s -> s.length() > 4);  // [true, false, true]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a boolean value
     * @return a new boolean array containing the transformed values
     * @see #mapToBoolean(Collection, int, int, ToBooleanFunction)
     */
    public static <T> boolean[] mapToBoolean(final Collection<? extends T> c, final ToBooleanFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        return mapToBoolean(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new boolean array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
     * boolean[] isLongName = N.mapToBoolean(names, 1, 3, s -> s.length() > 4);  // [false, true]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a boolean value
     * @return a new boolean array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToBoolean(Collection, ToBooleanFunction)
     */
    public static <T> boolean[] mapToBoolean(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToBooleanFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        final boolean[] result = new boolean[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsBoolean(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsBoolean(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new char array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey"};
     * char[] firstChars = N.mapToChar(words, s -> s.charAt(0));  // ['H', 'H', 'H']
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a char value
     * @return a new char array containing the transformed values
     * @see #mapToChar(Object[], int, int, ToCharFunction)
     */
    public static <T> char[] mapToChar(final T[] a, final ToCharFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_CHAR_ARRAY;
        }

        return mapToChar(a, 0, a.length, mapper);
    }

    /**
     * Returns a new char array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey", "Howdy"};
     * char[] firstChars = N.mapToChar(words, 1, 3, s -> s.charAt(0));  // ['H', 'H']
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a char value
     * @return a new char array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToChar(Object[], ToCharFunction)
     */
    public static <T> char[] mapToChar(final T[] a, final int fromIndex, final int toIndex, final ToCharFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] result = new char[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsChar(a[i]);
        }

        return result;
    }

    /**
     * Returns a new char array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey");
     * char[] firstChars = N.mapToChar(words, s -> s.charAt(0));  // ['H', 'H', 'H']
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a char value
     * @return a new char array containing the transformed values
     * @see #mapToChar(Collection, int, int, ToCharFunction)
     */
    public static <T> char[] mapToChar(final Collection<? extends T> c, final ToCharFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_CHAR_ARRAY;
        }

        return mapToChar(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new char array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey", "Howdy");
     * char[] firstChars = N.mapToChar(words, 1, 3, s -> s.charAt(0));  // ['H', 'H']
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a char value
     * @return a new char array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToChar(Collection, ToCharFunction)
     */
    public static <T> char[] mapToChar(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToCharFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_CHAR_ARRAY;
        }

        final char[] result = new char[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsChar(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsChar(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new byte array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {10, 20, 30};
     * byte[] bytes = N.mapToByte(numbers, n -> (byte)(n / 10));  // [1, 2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a byte value
     * @return a new byte array containing the transformed values
     * @see #mapToByte(Object[], int, int, ToByteFunction)
     */
    public static <T> byte[] mapToByte(final T[] a, final ToByteFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_BYTE_ARRAY;
        }

        return mapToByte(a, 0, a.length, mapper);
    }

    /**
     * Returns a new byte array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {10, 20, 30, 40};
     * byte[] bytes = N.mapToByte(numbers, 1, 3, n -> (byte)(n / 10));  // [2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a byte value
     * @return a new byte array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToByte(Object[], ToByteFunction)
     */
    public static <T> byte[] mapToByte(final T[] a, final int fromIndex, final int toIndex, final ToByteFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] result = new byte[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsByte(a[i]);
        }

        return result;
    }

    /**
     * Returns a new byte array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(10, 20, 30);
     * byte[] bytes = N.mapToByte(numbers, n -> (byte)(n / 10));  // [1, 2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a byte value
     * @return a new byte array containing the transformed values
     * @see #mapToByte(Collection, int, int, ToByteFunction)
     */
    public static <T> byte[] mapToByte(final Collection<? extends T> c, final ToByteFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_BYTE_ARRAY;
        }

        return mapToByte(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new byte array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(10, 20, 30, 40);
     * byte[] bytes = N.mapToByte(numbers, 1, 3, n -> (byte)(n / 10));  // [2, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a byte value
     * @return a new byte array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToByte(Collection, ToByteFunction)
     */
    public static <T> byte[] mapToByte(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToByteFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_BYTE_ARRAY;
        }

        final byte[] result = new byte[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsByte(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsByte(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new short array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {100, 200, 300};
     * short[] shorts = N.mapToShort(numbers, n -> (short)(n / 10));  // [10, 20, 30]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a short value
     * @return a new short array containing the transformed values
     * @see #mapToShort(Object[], int, int, ToShortFunction)
     */
    public static <T> short[] mapToShort(final T[] a, final ToShortFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_SHORT_ARRAY;
        }

        return mapToShort(a, 0, a.length, mapper);
    }

    /**
     * Returns a new short array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {100, 200, 300, 400};
     * short[] shorts = N.mapToShort(numbers, 1, 3, n -> (short)(n / 10));  // [20, 30]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a short value
     * @return a new short array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToShort(Object[], ToShortFunction)
     */
    public static <T> short[] mapToShort(final T[] a, final int fromIndex, final int toIndex, final ToShortFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] result = new short[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsShort(a[i]);
        }

        return result;
    }

    /**
     * Returns a new short array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(100, 200, 300);
     * short[] shorts = N.mapToShort(numbers, n -> (short)(n / 10));  // [10, 20, 30]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a short value
     * @return a new short array containing the transformed values
     * @see #mapToShort(Collection, int, int, ToShortFunction)
     */
    public static <T> short[] mapToShort(final Collection<? extends T> c, final ToShortFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_SHORT_ARRAY;
        }

        return mapToShort(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new short array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(100, 200, 300, 400);
     * short[] shorts = N.mapToShort(numbers, 1, 3, n -> (short)(n / 10));  // [20, 30]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a short value
     * @return a new short array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToShort(Collection, ToShortFunction)
     */
    public static <T> short[] mapToShort(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToShortFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_SHORT_ARRAY;
        }

        final short[] result = new short[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsShort(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsShort(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new int array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey"};
     * int[] lengths = N.mapToInt(words, String::length);  // [2, 5, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to an int value
     * @return a new int array containing the transformed values
     * @see #mapToInt(Object[], int, int, ToIntFunction)
     */
    public static <T> int[] mapToInt(final T[] a, final ToIntFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_INT_ARRAY;
        }

        return mapToInt(a, 0, a.length, mapper);
    }

    /**
     * Returns a new int array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey", "Howdy"};
     * int[] lengths = N.mapToInt(words, 1, 3, String::length);  // [5, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to an int value
     * @return a new int array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToInt(Object[], ToIntFunction)
     */
    public static <T> int[] mapToInt(final T[] a, final int fromIndex, final int toIndex, final ToIntFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        final int[] result = new int[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Returns a new int array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey");
     * int[] lengths = N.mapToInt(words, String::length);  // [2, 5, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to an int value
     * @return a new int array containing the transformed values
     * @see #mapToInt(Collection, int, int, ToIntFunction)
     */
    public static <T> int[] mapToInt(final Collection<? extends T> c, final ToIntFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_INT_ARRAY;
        }

        return mapToInt(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new int array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey", "Howdy");
     * int[] lengths = N.mapToInt(words, 1, 3, String::length);  // [5, 3]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to an int value
     * @return a new int array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToInt(Collection, ToIntFunction)
     */
    public static <T> int[] mapToInt(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToIntFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_INT_ARRAY;
        }

        final int[] result = new int[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsInt(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsInt(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new int array by transforming each long value using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] longs = {100L, 200L, 300L};
     * int[] ints = N.mapToInt(longs, l -> (int)(l / 10));  // [10, 20, 30]
     * }</pre>
     *
     * @param a the array of long values
     * @param mapper the function to transform each long value to an int value
     * @return a new int array containing the transformed values
     */
    @Beta
    public static int[] mapToInt(final long[] a, final LongToIntFunction mapper) {
        if (a == null) {
            return EMPTY_INT_ARRAY;
        }

        final int len = len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Returns a new int array by transforming each double value using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] doubles = {10.5, 20.8, 30.2};
     * int[] ints = N.mapToInt(doubles, d -> (int)Math.round(d));  // [11, 21, 30]
     * }</pre>
     *
     * @param a the array of double values
     * @param mapper the function to transform each double value to an int value
     * @return a new int array containing the transformed values
     */
    @Beta
    public static int[] mapToInt(final double[] a, final DoubleToIntFunction mapper) {
        if (a == null) {
            return EMPTY_INT_ARRAY;
        }

        final int len = len(a);
        final int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsInt(a[i]);
        }

        return result;
    }

    /**
     * Returns a new long array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] timestamps = {"1000", "2000", "3000"};
     * long[] millis = N.mapToLong(timestamps, Long::parseLong);  // [1000L, 2000L, 3000L]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a long value
     * @return a new long array containing the transformed values
     * @see #mapToLong(Object[], int, int, ToLongFunction)
     */
    public static <T> long[] mapToLong(final T[] a, final ToLongFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_LONG_ARRAY;
        }

        return mapToLong(a, 0, a.length, mapper);
    }

    /**
     * Returns a new long array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] timestamps = {"1000", "2000", "3000", "4000"};
     * long[] millis = N.mapToLong(timestamps, 1, 3, Long::parseLong);  // [2000L, 3000L]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a long value
     * @return a new long array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToLong(Object[], ToLongFunction)
     */
    public static <T> long[] mapToLong(final T[] a, final int fromIndex, final int toIndex, final ToLongFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] result = new long[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Returns a new long array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> timestamps = Arrays.asList("1000", "2000", "3000");
     * long[] millis = N.mapToLong(timestamps, Long::parseLong);  // [1000L, 2000L, 3000L]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a long value
     * @return a new long array containing the transformed values
     * @see #mapToLong(Collection, int, int, ToLongFunction)
     */
    public static <T> long[] mapToLong(final Collection<? extends T> c, final ToLongFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_LONG_ARRAY;
        }

        return mapToLong(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new long array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> timestamps = Arrays.asList("1000", "2000", "3000", "4000");
     * long[] millis = N.mapToLong(timestamps, 1, 3, Long::parseLong);  // [2000L, 3000L]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a long value
     * @return a new long array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToLong(Collection, ToLongFunction)
     */
    public static <T> long[] mapToLong(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToLongFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_LONG_ARRAY;
        }

        final long[] result = new long[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsLong(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsLong(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Transforms the int values in the specified array to long values using the specified {@code IntToLongFunction}.
     * <p>
     * Mostly it's designed for one-step operation.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     * </p>
     *
     * @param a the array of int values to be mapped
     * @param mapper the function used to map the int values to long values
     * @return a new long array containing the mapped values, or an empty long array if the input array is {@code null} or empty
     */
    @Beta
    public static long[] mapToLong(final int[] a, final IntToLongFunction mapper) {
        if (a == null) {
            return EMPTY_LONG_ARRAY;
        }

        final int len = len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Transforms the double values in the specified array to long values using the specified {@code DoubleToLongFunction}.
     * <p>
     * Mostly it's designed for one-step operation.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     * </p>
     *
     * @param a the array of double values to be mapped
     * @param mapper the function used to map the double values to long values
     * @return a new long array containing the mapped values, or an empty long array if the input array is {@code null} or empty
     */
    @Beta
    public static long[] mapToLong(final double[] a, final DoubleToLongFunction mapper) {
        if (a == null) {
            return EMPTY_LONG_ARRAY;
        }

        final int len = len(a);
        final long[] result = new long[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsLong(a[i]);
        }

        return result;
    }

    /**
     * Returns a new float array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {1, 2, 3};
     * float[] floats = N.mapToFloat(numbers, n -> n * 1.5f);  // [1.5f, 3.0f, 4.5f]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a float value
     * @return a new float array containing the transformed values
     * @see #mapToFloat(Object[], int, int, ToFloatFunction)
     */
    public static <T> float[] mapToFloat(final T[] a, final ToFloatFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return mapToFloat(a, 0, a.length, mapper);
    }

    /**
     * Returns a new float array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {1, 2, 3, 4};
     * float[] floats = N.mapToFloat(numbers, 1, 3, n -> n * 1.5f);  // [3.0f, 4.5f]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a float value
     * @return a new float array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToFloat(Object[], ToFloatFunction)
     */
    public static <T> float[] mapToFloat(final T[] a, final int fromIndex, final int toIndex, final ToFloatFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] result = new float[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsFloat(a[i]);
        }

        return result;
    }

    /**
     * Returns a new float array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3);
     * float[] floats = N.mapToFloat(numbers, n -> n * 1.5f);  // [1.5f, 3.0f, 4.5f]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a float value
     * @return a new float array containing the transformed values
     * @see #mapToFloat(Collection, int, int, ToFloatFunction)
     */
    public static <T> float[] mapToFloat(final Collection<? extends T> c, final ToFloatFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_FLOAT_ARRAY;
        }

        return mapToFloat(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new float array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
     * float[] floats = N.mapToFloat(numbers, 1, 3, n -> n * 1.5f);  // [3.0f, 4.5f]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a float value
     * @return a new float array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToFloat(Collection, ToFloatFunction)
     */
    public static <T> float[] mapToFloat(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToFloatFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_FLOAT_ARRAY;
        }

        final float[] result = new float[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsFloat(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsFloat(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new double array by transforming each element using the given mapper function.
     * Returns an empty array if the input array is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] numbers = {"1.5", "2.5", "3.5"};
     * double[] doubles = N.mapToDouble(numbers, Double::parseDouble);  // [1.5, 2.5, 3.5]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param mapper the function to transform each element to a double value
     * @return a new double array containing the transformed values
     * @see #mapToDouble(Object[], int, int, ToDoubleFunction)
     */
    public static <T> double[] mapToDouble(final T[] a, final ToDoubleFunction<? super T> mapper) {
        if (isEmpty(a)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return mapToDouble(a, 0, a.length, mapper);
    }

    /**
     * Returns a new double array by transforming elements within the specified range using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] numbers = {"1.5", "2.5", "3.5", "4.5"};
     * double[] doubles = N.mapToDouble(numbers, 1, 3, Double::parseDouble);  // [2.5, 3.5]
     * }</pre>
     *
     * @param <T> the type of the elements in the array
     * @param a the array of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a double value
     * @return a new double array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToDouble(Object[], ToDoubleFunction)
     */
    public static <T> double[] mapToDouble(final T[] a, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] result = new double[toIndex - fromIndex];

        for (int i = fromIndex; i < toIndex; i++) {
            result[i - fromIndex] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Returns a new double array by transforming each element of the collection using the given mapper function.
     * Returns an empty array if the collection is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> numbers = Arrays.asList("1.5", "2.5", "3.5");
     * double[] doubles = N.mapToDouble(numbers, Double::parseDouble);  // [1.5, 2.5, 3.5]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param mapper the function to transform each element to a double value
     * @return a new double array containing the transformed values
     * @see #mapToDouble(Collection, int, int, ToDoubleFunction)
     */
    public static <T> double[] mapToDouble(final Collection<? extends T> c, final ToDoubleFunction<? super T> mapper) {
        if (isEmpty(c)) {
            return EMPTY_DOUBLE_ARRAY;
        }

        return mapToDouble(c, 0, c.size(), mapper);
    }

    /**
     * Returns a new double array by transforming elements within the specified range of the collection using the given mapper function.
     * Returns an empty array if the range is empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> numbers = Arrays.asList("1.5", "2.5", "3.5", "4.5");
     * double[] doubles = N.mapToDouble(numbers, 1, 3, Double::parseDouble);  // [2.5, 3.5]
     * }</pre>
     *
     * @param <T> the type of the elements in the collection
     * @param c the collection of values
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range
     * @param mapper the function to transform each element to a double value
     * @return a new double array containing the transformed values from the range
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #mapToDouble(Collection, ToDoubleFunction)
     */
    public static <T> double[] mapToDouble(final Collection<? extends T> c, final int fromIndex, final int toIndex, final ToDoubleFunction<? super T> mapper)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final double[] result = new double[toIndex - fromIndex];

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result[i - fromIndex] = mapper.applyAsDouble(list.get(i));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result[idx - fromIndex] = mapper.applyAsDouble(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Transforms the int values in the specified array to double values using the specified {@code IntToDoubleFunction}.
     * <p>
     * Mostly it's designed for one-step operation.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     * </p>
     *
     * @param a the array of int values to be mapped
     * @param mapper the function used to map the int values to double values
     * @return a new double array containing the mapped values, or an empty double array if the input array is {@code null} or empty
     */
    @Beta
    public static double[] mapToDouble(final int[] a, final IntToDoubleFunction mapper) {
        if (a == null) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int len = len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Transforms the long values in the specified array to double values using the specified {@code IntToDoubleFunction}.
     * <p>
     * Mostly it's designed for one-step operation.
     * {@code java.util.stream.Stream} is preferred for multiple phases operation.
     * </p>
     *
     * @param a the array of long values to be mapped
     * @param mapper the function used to map the long values to double values
     * @return a new double array containing the mapped values, or an empty double array if the input array is {@code null} or empty
     */
    @Beta
    public static double[] mapToDouble(final long[] a, final LongToDoubleFunction mapper) {
        if (a == null) {
            return EMPTY_DOUBLE_ARRAY;
        }

        final int len = len(a);
        final double[] result = new double[len];

        for (int i = 0; i < len; i++) {
            result[i] = mapper.applyAsDouble(a[i]);
        }

        return result;
    }

    /**
     * Returns a new list containing the result of applying the given mapper function to each element.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * List<Integer> result = N.map(names, String::length);
     * // Returns [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned list
     * @param a the array
     * @param mapper the function to transform each element
     * @return a new list containing the transformed elements (empty if array is {@code null}/empty)
     * @see #map(Object[], int, int, Function)
     */
    public static <T, R> List<R> map(final T[] a, final Function<? super T, ? extends R> mapper) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return map(a, 0, a.length, mapper);
    }

    /**
     * Returns a new collection containing the result of applying the given mapper function to each element (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * Set<Integer> result = N.map(names, String::length, n -> new HashSet<>());
     * // Returns a Set containing [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param a the array
     * @param mapper the function to transform each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing the transformed elements (empty if array is {@code null}/empty)
     * @see #map(Object[], int, int, Function, IntFunction)
     */
    public static <T, R, C extends Collection<R>> C map(final T[] a, final Function<? super T, ? extends R> mapper, final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return map(a, 0, a.length, mapper, supplier);
    }

    /**
     * Returns a new list containing the result of applying the given mapper function to each element within the specified range.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * List<Integer> result = N.map(names, 1, 3, String::length);
     * // Returns [3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned list
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element
     * @return a new list containing the transformed elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #map(Object[], Function)
     */
    public static <T, R> List<R> map(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper)
            throws IndexOutOfBoundsException {
        return map(a, fromIndex, toIndex, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing the result of applying the given mapper function to each element within the specified range (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * Set<Integer> result = N.map(names, 1, 3, String::length, n -> new HashSet<>());
     * // Returns a Set containing [3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing the transformed elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #map(Object[], Function, IntFunction)
     */
    public static <T, R, C extends Collection<R>> C map(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(mapper.apply(a[i]));
        }

        return result;
    }

    /**
     * Returns a new list containing the result of applying the given mapper function to each element within the specified range of the collection.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
     * List<Integer> result = N.map(names, 1, 3, String::length);
     * // Returns [3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input collection
     * @param <R> the type of the elements in the returned list
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element
     * @return a new list containing the transformed elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #map(Collection, int, int, Function, IntFunction)
     */
    public static <T, R> List<R> map(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Function<? super T, ? extends R> mapper)
            throws IndexOutOfBoundsException {
        return map(c, fromIndex, toIndex, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing the result of applying the given mapper function to each element within the specified range of the collection (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
     * Set<Integer> result = N.map(names, 1, 3, String::length, n -> new HashSet<>());
     * // Returns a Set containing [3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the input collection
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing the transformed elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #map(Collection, int, int, Function)
     */
    public static <T, R, C extends Collection<R>> C map(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends R> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(toIndex - fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                result.add(mapper.apply(list.get(i)));
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                result.add(mapper.apply(e));

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing the result of applying the given mapper function to each element of the iterable.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * List<Integer> result = N.map(names, String::length);
     * // Returns [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <R> the type of the elements in the returned list
     * @param c the iterable
     * @param mapper the function to transform each element
     * @return a new list containing the transformed elements (empty if iterable is {@code null}/empty)
     * @see #map(Iterable, Function, IntFunction)
     */
    public static <T, R> List<R> map(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper) {
        return map(c, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing the result of applying the given mapper function to each element of the iterable (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * Set<Integer> result = N.map(names, String::length, n -> new HashSet<>());
     * // Returns a Set containing [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable
     * @param mapper the function to transform each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing the transformed elements (empty if iterable is {@code null}/empty)
     * @see #map(Iterable, Function)
     */
    public static <T, R, C extends Collection<R>> C map(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper,
            final IntFunction<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0));

        for (final T e : c) {
            result.add(mapper.apply(e));
        }

        return result;
    }

    /**
     * Returns a new list containing the result of applying the given mapper function to each element of the iterator (the iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", "Bob", "Charlie").iterator();
     * List<Integer> result = N.map(iter, String::length);
     * // Returns [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <R> the type of the elements in the returned list
     * @param iter the iterator
     * @param mapper the function to transform each element
     * @return a new list containing the transformed elements (empty if iterator is {@code null} or has no elements)
     * @see #map(Iterator, Function, IntFunction)
     * @see Iterators#map(Iterator, Function)
     */
    public static <T, R> List<R> map(final Iterator<? extends T> iter, final Function<? super T, ? extends R> mapper) {
        return map(iter, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing the result of applying the given mapper function to each element of the iterator (collection created by the provided supplier, iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", "Bob", "Charlie").iterator();
     * Set<Integer> result = N.map(iter, String::length, n -> new HashSet<>());
     * // Returns a Set containing [5, 3, 7]
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param iter the iterator
     * @param mapper the function to transform each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing the transformed elements (empty if iterator is {@code null} or has no elements)
     * @see #map(Iterator, Function)
     * @see Iterators#map(Iterator, Function)
     */
    public static <T, R, C extends Collection<R>> C map(final Iterator<? extends T> iter, final Function<? super T, ? extends R> mapper,
            final IntFunction<? extends C> supplier) {
        if (iter == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(9);

        while (iter.hasNext()) {
            result.add(mapper.apply(iter.next()));
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from the collections produced by applying the mapper function to each element.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello"};
     * List<Character> result = N.flatMap(words, s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned list
     * @param a the array
     * @param mapper the function to transform each element to a collection
     * @return a new list containing all elements from all mapped collections (empty if array is {@code null}/empty)
     * @see #flatMap(Object[], int, int, Function)
     */
    public static <T, R> List<R> flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends R>> mapper) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return flatMap(a, 0, a.length, mapper);
    }

    /**
     * Returns a new collection containing all elements from the collections produced by applying the mapper function to each element (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello"};
     * Set<Character> result = N.flatMap(words,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param a the array
     * @param mapper the function to transform each element to a collection
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all mapped collections (empty if array is {@code null}/empty)
     * @see #flatMap(Object[], int, int, Function, IntFunction)
     */
    public static <T, R, C extends Collection<R>> C flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends R>> mapper,
            final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        return flatMap(a, 0, a.length, mapper, supplier);
    }

    /**
     * Returns a new list containing all elements from the collections produced by applying the mapper function to each element within the specified range.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey"};
     * List<Character> result = N.flatMap(words, 0, 2,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from the first 2 words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned list
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element to a collection
     * @return a new list containing all elements from all mapped collections (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #flatMap(Object[], Function)
     */
    public static <T, R> List<R> flatMap(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(a, fromIndex, toIndex, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from the collections produced by applying the mapper function to each element within the specified range (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"Hi", "Hello", "Hey"};
     * Set<Character> result = N.flatMap(words, 0, 2,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from the first 2 words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element to a collection
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all mapped collections (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #flatMap(Object[], Function, IntFunction)
     */
    public static <T, R, C extends Collection<R>> C flatMap(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        Collection<? extends R> mr = null;

        for (int i = fromIndex; i < toIndex; i++) {
            if (notEmpty(mr = mapper.apply(a[i]))) {
                result.addAll(mr);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from the collections produced by applying the mapper function to each element within the specified range of the collection.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey");
     * List<Character> result = N.flatMap(words, 0, 2,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from the first 2 words
     * }</pre>
     *
     * @param <T> the type of the elements in the input collection
     * @param <R> the type of the elements in the returned list
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element to a collection
     * @return a new list containing all elements from all mapped collections (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #flatMap(Collection, int, int, Function, IntFunction)
     */
    public static <T, R> List<R> flatMap(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper) throws IndexOutOfBoundsException {
        return flatMap(c, fromIndex, toIndex, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from the collections produced by applying the mapper function to each element within the specified range of the collection (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hello", "Hey");
     * Set<Character> result = N.flatMap(words, 0, 2,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from the first 2 words
     * }</pre>
     *
     * @param <T> the type of the elements in the input collection
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param mapper the function to transform each element to a collection
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all mapped collections (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @see #flatMap(Collection, int, int, Function)
     */
    public static <T, R, C extends Collection<R>> C flatMap(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return supplier.apply(0);
        }

        final int len = initSizeForFlatMap(toIndex - fromIndex);
        final C result = supplier.apply(len);
        Collection<? extends R> mr = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                if (notEmpty(mr = mapper.apply(list.get(i)))) {
                    result.addAll(mr);
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                if (notEmpty(mr = mapper.apply(e))) {
                    result.addAll(mr);
                }

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from the collections produced by applying the mapper function to each element of the iterable.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("Hi", "Hello");
     * List<Character> result = N.flatMap(words,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <R> the type of the elements in the returned list
     * @param c the iterable
     * @param mapper the function to transform each element to a collection
     * @return a new list containing all elements from all mapped collections (empty if iterable is {@code null}/empty)
     * @see #flatMap(Iterable, Function, IntFunction)
     */
    public static <T, R> List<R> flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(c, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from the collections produced by applying the mapper function to each element of the iterable (collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> words = Arrays.asList("Hi", "Hello");
     * Set<Character> result = N.flatMap(words,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable
     * @param mapper the function to transform each element to a collection
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all mapped collections (empty if iterable is {@code null}/empty)
     * @see #flatMap(Iterable, Function)
     */
    public static <T, R, C extends Collection<R>> C flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends R>> mapper,
            final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(initSizeForFlatMap(c));
        Collection<? extends R> mr = null;

        for (final T e : c) {
            if (notEmpty(mr = mapper.apply(e))) {
                result.addAll(mr);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from the collections produced by applying the mapper function to each element of the iterator (the iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hello").iterator();
     * List<Character> result = N.flatMap(iter,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <R> the type of the elements in the returned list
     * @param iter the iterator
     * @param mapper the function to transform each element to a collection
     * @return a new list containing all elements from all mapped collections (empty if iterator is {@code null} or has no elements)
     * @see #flatMap(Iterator, Function, IntFunction)
     * @see Iterators#flatMap(Iterator, Function)
     */
    public static <T, R> List<R> flatMap(final Iterator<? extends T> iter, final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return flatMap(iter, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from the collections produced by applying the mapper function to each element of the iterator (collection created by the provided supplier, iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hello").iterator();
     * Set<Character> result = N.flatMap(iter,
     *     s -> s.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param iter the iterator
     * @param mapper the function to transform each element to a collection
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all mapped collections (empty if iterator is {@code null} or has no elements)
     * @see #flatMap(Iterator, Function)
     * @see Iterators#flatMap(Iterator, Function)
     */
    public static <T, R, C extends Collection<R>> C flatMap(final Iterator<? extends T> iter,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<? extends C> supplier) throws IndexOutOfBoundsException {
        if (iter == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(9);
        Collection<? extends R> mr = null;

        while (iter.hasNext()) {
            if (notEmpty(mr = mapper.apply(iter.next()))) {
                result.addAll(mr);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from applying two levels of flat-mapping (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] sentences = {"Hi there", "Hello world"};
     * List<Character> result = N.flatMap(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned list
     * @param a the array
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @return a new list containing all elements from all nested mapped collections (empty if array is {@code null}/empty)
     * @see #flatMap(Object[], Function, Function, IntFunction)
     */
    public static <T, U, R> List<R> flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2) {

        return flatMap(a, mapper, mapper2, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from applying two levels of flat-mapping (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element, collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] sentences = {"Hi there", "Hello world"};
     * Set<Character> result = N.flatMap(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the input array
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param a the array
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all nested mapped collections (empty if array is {@code null}/empty)
     * @see #flatMap(Object[], Function, Function)
     */
    public static <T, U, R, C extends Collection<R>> C flatMap(final T[] a, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2, final IntFunction<? extends C> supplier) {
        if (isEmpty(a)) {
            return supplier.apply(0);
        }

        final int len = a.length > MAX_ARRAY_SIZE / LOAD_FACTOR_FOR_TWO_FLAT_MAP ? MAX_ARRAY_SIZE : a.length * LOAD_FACTOR_FOR_TWO_FLAT_MAP;
        final C result = supplier.apply(len);

        for (final T e : a) {
            final Collection<? extends U> c1 = mapper.apply(e);

            if (notEmpty(c1)) {
                for (final U e2 : c1) {
                    final Collection<? extends R> c2 = mapper2.apply(e2);

                    if (notEmpty(c2)) {
                        result.addAll(c2);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from applying two levels of flat-mapping to the iterable (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> sentences = Arrays.asList("Hi there", "Hello world");
     * List<Character> result = N.flatMap(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned list
     * @param c the iterable
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @return a new list containing all elements from all nested mapped collections (empty if iterable is {@code null}/empty)
     * @see #flatMap(Iterable, Function, Function, IntFunction)
     */
    public static <T, U, R> List<R> flatMap(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2) {

        return flatMap(c, mapper, mapper2, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from applying two levels of flat-mapping to the iterable (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element, collection created by the provided supplier).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterable<String> sentences = Arrays.asList("Hi there", "Hello world");
     * Set<Character> result = N.flatMap(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterable
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all nested mapped collections (empty if iterable is {@code null}/empty)
     * @see #flatMap(Iterable, Function, Function)
     */
    public static <T, U, R, C extends Collection<R>> C flatMap(final Iterable<? extends T> c,
            final Function<? super T, ? extends Collection<? extends U>> mapper, final Function<? super U, ? extends Collection<? extends R>> mapper2,
            final IntFunction<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(initSizeForFlatMap(c));

        for (final T e : c) {
            final Collection<? extends U> c1 = mapper.apply(e);

            if (notEmpty(c1)) {
                for (final U e2 : c1) {
                    final Collection<? extends R> c2 = mapper2.apply(e2);

                    if (notEmpty(c2)) {
                        result.addAll(c2);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing all elements from applying two levels of flat-mapping to the iterator (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element, the iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi there", "Hello world").iterator();
     * List<Character> result = N.flatMap(iter,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()));
     * // Returns all characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned list
     * @param iter the iterator
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @return a new list containing all elements from all nested mapped collections (empty if iterator is {@code null} or has no elements)
     * @see #flatMap(Iterator, Function, Function, IntFunction)
     */
    public static <T, U, R> List<R> flatMap(final Iterator<? extends T> iter, final Function<? super T, ? extends Collection<? extends U>> mapper,
            final Function<? super U, ? extends Collection<? extends R>> mapper2) {

        return flatMap(iter, mapper, mapper2, IntFunctions.ofList());
    }

    /**
     * Returns a new collection containing all elements from applying two levels of flat-mapping to the iterator (first mapper transforms each element to intermediate collections, second mapper flattens each intermediate element, collection created by the provided supplier, iterator will be consumed).
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi there", "Hello world").iterator();
     * Set<Character> result = N.flatMap(iter,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.chars().mapToObj(c -> (char)c).collect(Collectors.toList()),
     *     n -> new HashSet<>());
     * // Returns all unique characters from all words
     * }</pre>
     *
     * @param <T> the type of the elements in the iterator
     * @param <U> the intermediate type after the first mapping
     * @param <R> the type of the elements in the returned collection
     * @param <C> the type of the collection to return
     * @param iter the iterator
     * @param mapper the function to transform each element to a collection of intermediate type
     * @param mapper2 the function to transform each intermediate element to a collection of final type
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing all elements from all nested mapped collections (empty if iterator is {@code null} or has no elements)
     * @see #flatMap(Iterator, Function, Function)
     */
    public static <T, U, R, C extends Collection<R>> C flatMap(final Iterator<? extends T> iter,
            final Function<? super T, ? extends Collection<? extends U>> mapper, final Function<? super U, ? extends Collection<? extends R>> mapper2,
            final IntFunction<? extends C> supplier) {
        if (iter == null) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(9);

        while (iter.hasNext()) {
            final Collection<? extends U> c1 = mapper.apply(iter.next());

            if (notEmpty(c1)) {
                for (final U e2 : c1) {
                    final Collection<? extends R> c2 = mapper2.apply(e2);

                    if (notEmpty(c2)) {
                        result.addAll(c2);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the array while the predicate returns {@code true}.
     * Returns an empty list if the array is {@code null} or empty.
     * Stops at the first element where the predicate returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry"};
     * List<String> result = N.takeWhile(words, s -> s.startsWith("a"));
     * // Returns ["apple", "apricot"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}
     * @see #takeWhileInclusive(Object[], Predicate)
     * @see #dropWhile(Object[], Predicate)
     */
    public static <T> List<T> takeWhile(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, len(a)));

        for (final T e : a) {
            if (filter.test(e)) {
                result.add(e);
            } else {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the iterable while the predicate returns {@code true}.
     * Returns an empty list if the iterable is {@code null} or empty.
     * Stops at the first element where the predicate returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(2, 4, 6, 7, 8, 10);
     * List<Integer> evens = N.takeWhile(numbers, n -> n % 2 == 0);
     * // Returns [2, 4, 6]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}
     * @see #takeWhileInclusive(Iterable, Predicate)
     * @see #dropWhile(Iterable, Predicate)
     */
    public static <T> List<T> takeWhile(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, getSizeOrDefault(c, 0)));

        for (final T e : c) {
            if (filter.test(e)) {
                result.add(e);
            } else {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the iterator while the predicate returns {@code true}.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * Stops at the first element where the predicate returns {@code false}.
     * The iterator will be partially consumed up to and including the first failing element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("short", "tiny", "brief", "extremely long").iterator();
     * List<String> result = N.takeWhile(iter, s -> s.length() < 10);
     * // Returns ["short", "tiny", "brief"]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}
     * @see #takeWhileInclusive(Iterator, Predicate)
     * @see #dropWhile(Iterator, Predicate)
     */
    public static <T> List<T> takeWhile(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(9);
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (filter.test(e)) {
                result.add(e);
            } else {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the array while the predicate returns {@code true}, including the first element that fails.
     * Returns an empty list if the array is {@code null} or empty.
     * Unlike {@link #takeWhile}, this includes the element where the predicate first returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Integer[] numbers = {1, 3, 5, 6, 7, 9};
     * List<Integer> result = N.takeWhileInclusive(numbers, n -> n % 2 != 0);
     * // Returns [1, 3, 5, 6] (includes the even number 6)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}, plus the first failing element
     * @see #takeWhile(Object[], Predicate)
     * @see #dropWhile(Object[], Predicate)
     */
    public static <T> List<T> takeWhileInclusive(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, len(a)));

        for (final T e : a) {
            result.add(e);

            if (!filter.test(e)) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the iterable while the predicate returns {@code true}, including the first element that fails.
     * Returns an empty list if the iterable is {@code null} or empty.
     * Unlike {@link #takeWhile}, this includes the element where the predicate first returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("Hi", "Hey", "Hello", "Welcome");
     * List<String> result = N.takeWhileInclusive(words, s -> s.length() <= 3);
     * // Returns ["Hi", "Hey", "Hello"] (includes "Hello" which is > 3 chars)
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}, plus the first failing element
     * @see #takeWhile(Iterable, Predicate)
     * @see #dropWhile(Iterable, Predicate)
     */
    public static <T> List<T> takeWhileInclusive(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, getSizeOrDefault(c, 0)));

        for (final T e : c) {
            result.add(e);

            if (!filter.test(e)) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements from the beginning of the iterator while the predicate returns {@code true}, including the first element that fails.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * Unlike {@link #takeWhile}, this includes the element where the predicate first returns {@code false}.
     * The iterator will be partially consumed up to and including the first failing element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Double> iter = Arrays.asList(0.5, 1.5, 2.5, 3.5, 4.5).iterator();
     * List<Double> result = N.takeWhileInclusive(iter, d -> d < 3.0);
     * // Returns [0.5, 1.5, 2.5, 3.5] (includes 3.5 which is >= 3.0)
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values
     * @param filter the predicate to test each element
     * @return a new list containing elements while the predicate returns {@code true}, plus the first failing element
     * @see #takeWhile(Iterator, Predicate)
     * @see #dropWhile(Iterator, Predicate)
     */
    public static <T> List<T> takeWhileInclusive(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(9);
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();
            result.add(e);

            if (!filter.test(e)) {
                break;
            }
        }

        return result;
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code false}.
     * Returns an empty list if the array is {@code null} or empty.
     * Skips all leading elements while the predicate returns {@code true}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry", "cherry"};
     * List<String> result = N.dropWhile(words, s -> s.startsWith("a"));
     * // Returns ["banana", "blueberry", "cherry"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values
     * @param filter the predicate to test each element
     * @return a new list containing elements after dropping leading elements that match the predicate
     * @see #takeWhile(Object[], Predicate)
     * @see #skipUntil(Object[], Predicate)
     */
    public static <T> List<T> dropWhile(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, len(a)));
        final int len = a.length;
        int idx = 0;

        while (idx < len && filter.test(a[idx])) {
            idx++;
        }

        while (idx < len) {
            result.add(a[idx++]);
        }

        return result;
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code false}.
     * Returns an empty list if the iterable is {@code null} or empty.
     * Skips all leading elements while the predicate returns {@code true}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(2, 4, 6, 7, 8, 10);
     * List<Integer> result = N.dropWhile(numbers, n -> n % 2 == 0);
     * // Returns [7, 8, 10]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @return a new list containing elements after dropping leading elements that match the predicate
     * @see #takeWhile(Iterable, Predicate)
     * @see #skipUntil(Iterable, Predicate)
     */
    public static <T> List<T> dropWhile(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>(0);
        }

        return dropWhile(c.iterator(), filter, new ArrayList<>(min(9, getSizeOrDefault(c, 0))));
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code false}.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * Skips all leading elements while the predicate returns {@code true}.
     * The iterator will be fully consumed by this operation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Integer> iter = Arrays.asList(1, 3, 5, 6, 7, 9).iterator();
     * List<Integer> result = N.dropWhile(iter, n -> n % 2 != 0);
     * // Returns [6, 7, 9]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values
     * @param filter the predicate to test each element
     * @return a new list containing elements after dropping leading elements that match the predicate
     * @see #takeWhile(Iterator, Predicate)
     * @see #skipUntil(Iterator, Predicate)
     */
    public static <T> List<T> dropWhile(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return new ArrayList<>(0);
        }

        return dropWhile(iter, filter, new ArrayList<>(9));
    }

    private static <T> List<T> dropWhile(final Iterator<? extends T> iter, final Predicate<? super T> filter, final List<T> result) {
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (!filter.test(e)) {
                result.add(e);
                break;
            }
        }

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code true}.
     * Returns an empty list if the array is {@code null} or empty.
     * Skips all leading elements while the predicate returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apricot", "cherry"};
     * List<String> result = N.skipUntil(words, s -> s.startsWith("a") && s.length() > 5);
     * // Returns ["apricot", "cherry"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array of values
     * @param filter the predicate to test each element
     * @return a new list containing elements starting from the first element that matches the predicate
     * @see #dropWhile(Object[], Predicate)
     */
    @Beta
    public static <T> List<T> skipUntil(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return new ArrayList<>(0);
        }

        final List<T> result = new ArrayList<>(min(9, len(a)));
        final int len = a.length;
        int idx = 0;

        while (idx < len && !filter.test(a[idx])) {
            idx++;
        }

        while (idx < len) {
            result.add(a[idx++]);
        }

        return result;
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code true}.
     * Returns an empty list if the iterable is {@code null} or empty.
     * Skips all leading elements while the predicate returns {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 3, 5, 8, 10, 12);
     * List<Integer> result = N.skipUntil(numbers, n -> n % 2 == 0);
     * // Returns [8, 10, 12]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @return a new list containing elements starting from the first element that matches the predicate
     * @see #dropWhile(Iterable, Predicate)
     */
    @Beta
    public static <T> List<T> skipUntil(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>(0);
        }

        return skipUtil(c.iterator(), filter, new ArrayList<>(min(9, getSizeOrDefault(c, 0))));
    }

    /**
     * Returns a new list containing elements starting from the first element where the predicate returns {@code true}.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * Skips all leading elements while the predicate returns {@code false}.
     * The iterator will be fully consumed by this operation.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hello", "Welcome").iterator();
     * List<String> result = N.skipUntil(iter, s -> s.length() > 4);
     * // Returns ["Hello", "Welcome"]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator of values
     * @param filter the predicate to test each element
     * @return a new list containing elements starting from the first element that matches the predicate
     * @see #dropWhile(Iterator, Predicate)
     */
    @Beta
    public static <T> List<T> skipUntil(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return new ArrayList<>(0);
        }

        return skipUtil(iter, filter, new ArrayList<>(9));
    }

    private static <T> List<T> skipUtil(final Iterator<? extends T> iter, final Predicate<? super T> filter, final List<T> result) {
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            if (filter.test(e)) {
                result.add(e);
                break;
            }
        }

        while (iter.hasNext()) {
            result.add(iter.next());
        }

        return result;
    }

    /**
     * Returns a new list by first transforming each element using the mapper function, then filtering the transformed values using the predicate.
     * Returns an empty list if the iterable is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "hi", "banana", "go");
     * List<Integer> lengths = N.mapAndFilter(words, String::length, len -> len > 2);
     * // Returns [5, 6] (maps to lengths, then keeps only those > 2)
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned list
     * @param c the iterable of values
     * @param mapper the function to transform each element
     * @param filter the predicate to test each transformed element
     * @return a new list containing transformed elements that match the filter
     * @see #filterAndMap(Iterable, Predicate, Function)
     * @see #mapAndFilter(Iterable, Function, Predicate, IntFunction)
     */
    @Beta
    public static <T, R> List<R> mapAndFilter(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper, final Predicate<? super R> filter) {
        return mapAndFilter(c, mapper, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection by first transforming each element using the mapper function, then filtering the transformed values using the predicate.
     * Returns an empty collection if the iterable is {@code null} or empty.
     * The collection is created by the provided supplier function.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dan");
     * Set<Integer> lengths = N.mapAndFilter(names, String::length, len -> len > 3, n -> new HashSet<>());
     * // Returns unique lengths > 3: [5, 7]
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable of values
     * @param mapper the function to transform each element
     * @param filter the predicate to test each transformed element
     * @param supplier the supplier function that provides a new collection
     * @return a new collection containing transformed elements that match the filter
     * @see #filterAndMap(Iterable, Predicate, Function, IntFunction)
     * @see #mapAndFilter(Iterable, Function, Predicate)
     */
    @Beta
    public static <T, R, C extends Collection<R>> C mapAndFilter(final Iterable<? extends T> c, final Function<? super T, ? extends R> mapper,
            final Predicate<? super R> filter, final IntFunction<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0) / 2);
        R val = null;

        for (final T e : c) {
            val = mapper.apply(e);

            if (filter.test(val)) {
                result.add(val);
            }
        }

        return result;
    }

    /**
     * Returns a new list by first filtering elements using the predicate, then transforming the filtered values using the mapper function.
     * Returns an empty list if the iterable is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "hi", "banana", "go");
     * List<Integer> lengths = N.filterAndMap(words, s -> s.length() > 2, String::length);
     * // Returns [5, 6] (keeps words > 2 chars, then maps to lengths)
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned list
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @param mapper the function to transform each filtered element
     * @return a new list containing transformed values from filtered elements
     * @see #mapAndFilter(Iterable, Function, Predicate)
     * @see #filterAndMap(Iterable, Predicate, Function, IntFunction)
     */
    @Beta
    public static <T, R> List<R> filterAndMap(final Iterable<? extends T> c, final Predicate<? super T> filter, final Function<? super T, ? extends R> mapper) {
        return filterAndMap(c, filter, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection by first filtering elements using the predicate, then transforming the filtered values using the mapper function.
     * Returns an empty collection if the iterable is {@code null} or empty.
     * The collection is created by the provided supplier function.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
     * Set<String> evens = N.filterAndMap(numbers, n -> n % 2 == 0, n -> "num" + n, n -> new LinkedHashSet<>());
     * // Returns ["num2", "num4", "num6"]
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @param mapper the function to transform each filtered element
     * @param supplier the supplier function that provides a new collection
     * @return a new collection containing transformed values from filtered elements
     * @see #mapAndFilter(Iterable, Function, Predicate, IntFunction)
     * @see #filterAndMap(Iterable, Predicate, Function)
     */
    @Beta
    public static <T, R, C extends Collection<R>> C filterAndMap(final Iterable<? extends T> c, final Predicate<? super T> filter,
            final Function<? super T, ? extends R> mapper, final IntFunction<C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0) / 2);

        for (final T e : c) {
            if (filter.test(e)) {
                result.add(mapper.apply(e));
            }
        }

        return result;
    }

    /**
     * Returns a new list by first flat-mapping each element to a collection, then filtering the flattened values using the predicate.
     * Returns an empty list if the iterable is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> sentences = Arrays.asList("Hi there", "Go now", "Hello world");
     * List<String> longWords = N.flatMapAndFilter(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.length() > 3);
     * // Returns ["there", "Hello", "world"]
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned list
     * @param c the iterable of values
     * @param mapper the function to transform each element to a collection
     * @param filter the predicate to test each flattened element
     * @return a new list containing flattened elements that match the filter
     * @see #filterAndFlatMap(Iterable, Predicate, Function)
     * @see #flatMapAndFilter(Iterable, Function, Predicate, IntFunction)
     */
    @Beta
    public static <T, R> List<R> flatMapAndFilter(final Iterable<? extends T> c, final Function<? super T, ? extends Collection<? extends R>> mapper,
            final Predicate<? super R> filter) {
        return flatMapAndFilter(c, mapper, filter, IntFunctions.ofList());
    }

    /**
     * Returns a new collection by first flat-mapping each element to a collection, then filtering the flattened values using the predicate.
     * Returns an empty collection if the iterable is {@code null} or empty.
     * The collection is created by the provided supplier function.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> sentences = Arrays.asList("Hi X", "Go Y", "Hello world");
     * Set<String> longWords = N.flatMapAndFilter(sentences,
     *     s -> Arrays.asList(s.split(" ")),
     *     word -> word.length() > 3,
     *     n -> new HashSet<>());
     * // Returns unique long words: ["Hello", "world"]
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable of values
     * @param mapper the function to transform each element to a collection
     * @param filter the predicate to test each flattened element
     * @param supplier the supplier function that provides a new collection
     * @return a new collection containing flattened elements that match the filter
     * @see #filterAndFlatMap(Iterable, Predicate, Function, IntFunction)
     * @see #flatMapAndFilter(Iterable, Function, Predicate)
     */
    @Beta
    public static <T, R, C extends Collection<R>> C flatMapAndFilter(final Iterable<? extends T> c,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final Predicate<? super R> filter, final IntFunction<? extends C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0) / 2);
        Collection<? extends R> vals = null;

        for (final T e : c) {
            vals = mapper.apply(e);

            if (notEmpty(vals)) {
                for (final R val : vals) {
                    if (filter.test(val)) {
                        result.add(val);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list by first filtering elements using the predicate, then flat-mapping the filtered values to collections.
     * Returns an empty list if the iterable is {@code null} or empty.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> sentences = Arrays.asList("Hi there", "Go", "Hello world");
     * List<String> words = N.filterAndFlatMap(sentences,
     *     s -> s.length() > 5,
     *     s -> Arrays.asList(s.split(" ")));
     * // Returns ["Hi", "there", "Hello", "world"] (only from sentences > 5 chars)
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned list
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @param mapper the function to transform each filtered element to a collection
     * @return a new list containing flattened values from filtered elements
     * @see #flatMapAndFilter(Iterable, Function, Predicate)
     * @see #filterAndFlatMap(Iterable, Predicate, Function, IntFunction)
     */
    @Beta
    public static <T, R> List<R> filterAndFlatMap(final Iterable<? extends T> c, final Predicate<? super T> filter,
            final Function<? super T, ? extends Collection<? extends R>> mapper) {
        return filterAndFlatMap(c, filter, mapper, IntFunctions.ofList());
    }

    /**
     * Returns a new collection by first filtering elements using the predicate, then flat-mapping the filtered values to collections.
     * Returns an empty collection if the iterable is {@code null} or empty.
     * The collection is created by the provided supplier function.
     *
     * <p>Note: This is designed for one-step operations. For multiple transformation phases, consider using {@link java.util.stream.Stream}.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> sentences = Arrays.asList("Hi", "Go there", "Hello world");
     * Set<String> words = N.filterAndFlatMap(sentences,
     *     s -> s.length() > 5,
     *     s -> Arrays.asList(s.split(" ")),
     *     n -> new LinkedHashSet<>());
     * // Returns ["Go", "there", "Hello", "world"] (from sentences > 5 chars)
     * }</pre>
     *
     * @param <T> the type of elements in the input iterable
     * @param <R> the type of elements in the returned collection
     * @param <C> the type of the collection to return
     * @param c the iterable of values
     * @param filter the predicate to test each element
     * @param mapper the function to transform each filtered element to a collection
     * @param supplier the supplier function that provides a new collection
     * @return a new collection containing flattened values from filtered elements
     * @see #flatMapAndFilter(Iterable, Function, Predicate, IntFunction)
     * @see #filterAndFlatMap(Iterable, Predicate, Function)
     */
    @Beta
    public static <T, R, C extends Collection<R>> C filterAndFlatMap(final Iterable<? extends T> c, final Predicate<? super T> filter,
            final Function<? super T, ? extends Collection<? extends R>> mapper, final IntFunction<C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.apply(0);
        }

        final C result = supplier.apply(getSizeOrDefault(c, 0) / 2);
        Collection<? extends R> vals = null;

        for (final T e : c) {
            if (filter.test(e)) {
                vals = mapper.apply(e);

                if (notEmpty(vals)) {
                    result.addAll(vals);
                }
            }
        }

        return result;
    }

    private static int getSizeOrDefault(final Iterable<?> c, final int defaultSize) {
        return c instanceof Collection ? ((Collection<?>) c).size() : defaultSize;
    }

    private static int getMinSize(final Iterable<?> c) {
        return min(9, getSizeOrDefault(c, 0));
    }

    private static int initSizeForFlatMap(final Iterable<?> c) {
        return c instanceof Collection ? initSizeForFlatMap(((Collection<?>) c).size()) : 0;
    }

    private static int initSizeForFlatMap(final int size) {
        return size > MAX_ARRAY_SIZE / LOAD_FACTOR_FOR_FLAT_MAP ? MAX_ARRAY_SIZE : (int) (size * LOAD_FACTOR_FOR_FLAT_MAP); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] values = {true, false, true, false, true};
     * boolean[] result = N.distinct(values);
     * // Returns [true, false]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(boolean[], int, int)
     */
    public static boolean[] distinct(final boolean[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] values = {true, false, true, false, true};
     * boolean[] result = N.distinct(values, 1, 4);
     * // Returns [false, true] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(boolean[])
     */
    public static boolean[] distinct(final boolean[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'a', 'c', 'b'};
     * char[] result = N.distinct(letters);
     * // Returns ['a', 'b', 'c']
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(char[], int, int)
     */
    public static char[] distinct(final char[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'b', 'a', 'c', 'b'};
     * char[] result = N.distinct(letters, 1, 4);
     * // Returns ['b', 'a', 'c'] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(char[])
     */
    public static char[] distinct(final char[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 1, 3, 2};
     * byte[] result = N.distinct(numbers);
     * // Returns [1, 2, 3]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(byte[], int, int)
     */
    public static byte[] distinct(final byte[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 1, 3, 2};
     * byte[] result = N.distinct(numbers, 1, 4);
     * // Returns [2, 1, 3] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(byte[])
     */
    public static byte[] distinct(final byte[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 10, 30, 20};
     * short[] result = N.distinct(numbers);
     * // Returns [10, 20, 30]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(short[], int, int)
     */
    public static short[] distinct(final short[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 10, 30, 20};
     * short[] result = N.distinct(numbers, 1, 4);
     * // Returns [20, 10, 30] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(short[])
     */
    public static short[] distinct(final short[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 1, 3, 2};
     * int[] result = N.distinct(numbers);
     * // Returns [1, 2, 3]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(int[], int, int)
     */
    public static int[] distinct(final int[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 1, 3, 2};
     * int[] result = N.distinct(numbers, 1, 4);
     * // Returns [2, 1, 3] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(int[])
     */
    public static int[] distinct(final int[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 100L, 300L, 200L};
     * long[] result = N.distinct(numbers);
     * // Returns [100, 200, 300]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(long[], int, int)
     */
    public static long[] distinct(final long[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 100L, 300L, 200L};
     * long[] result = N.distinct(numbers, 1, 4);
     * // Returns [200, 100, 300] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if range is empty)
     * @throws IndexOutOfBoundsException if the range is invalid
     * @see #distinct(long[])
     */
    public static long[] distinct(final long[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.5f, 1.5f, 3.5f, 2.5f};
     * float[] result = N.distinct(numbers);
     * // Returns [1.5, 2.5, 3.5]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(float[], int, int)
     */
    public static float[] distinct(final float[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.5f, 1.5f, 3.5f, 2.5f};
     * float[] result = N.distinct(numbers, 1, 4);
     * // Returns [2.5, 1.5, 3.5] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #distinct(float[])
     */
    public static float[] distinct(final float[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new array containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.5, 1.5, 3.5, 2.5};
     * double[] result = N.distinct(numbers);
     * // Returns [1.5, 2.5, 3.5]
     * }</pre>
     *
     * @param a the array
     * @return a new array containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(double[], int, int)
     */
    public static double[] distinct(final double[] a) {
        return distinct(a, 0, len(a)); // NOSONAR
    }

    /**
     * Returns a new array containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.5, 1.5, 3.5, 2.5};
     * double[] result = N.distinct(numbers, 1, 4);
     * // Returns [2.5, 1.5, 3.5] (from range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new array containing only the unique elements from the range (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #distinct(double[])
     */
    public static double[] distinct(final double[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return removeDuplicates(a, fromIndex, toIndex, false);
    }

    /**
     * Returns a new list containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry", "banana"};
     * List<String> result = N.distinct(words);
     * // Returns ["apple", "banana", "cherry"]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @return a new list containing only the unique elements (empty if array is {@code null}/empty)
     * @see #distinct(Object[], int, int)
     * @see #distinctBy(Object[], Function)
     */
    public static <T> List<T> distinct(final T[] a) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return distinct(a, 0, a.length);
    }

    /**
     * Returns a new list containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "apple", "cherry", "banana"};
     * List<String> result = N.distinct(words, 1, 4);
     * // Returns ["banana", "apple", "cherry"] (from range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new list containing only the unique elements from the range (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #distinct(Object[])
     * @see #distinctBy(Object[], int, int, Function)
     */
    public static <T> List<T> distinct(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);

        for (int i = fromIndex; i < toIndex; i++) {
            if (set.add(hashKey(a[i]))) {
                result.add(a[i]);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only unique elements from the specified range, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "banana");
     * List<String> result = N.distinct(words, 1, 4);
     * // Returns ["banana", "apple", "cherry"] (from range [1,4))
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return a new list containing only the unique elements from the range (empty if collection is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > c.size() || fromIndex > toIndex}
     * @see #distinct(Iterable)
     */
    public static <T> List<T> distinct(final Collection<? extends T> c, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex && it.hasNext(); i++) {
                e = it.next();

                if (i < fromIndex) {
                    continue;
                }

                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 4);
     * List<Integer> result = N.distinct(numbers);
     * // Returns [1, 2, 3, 4]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @return a new list containing only the unique elements (empty if iterable is {@code null}/empty)
     * @see #distinct(Iterator)
     * @see #distinctBy(Iterable, Function)
     */
    public static <T> List<T> distinct(final Iterable<? extends T> c) {
        if (isEmptyCollection(c)) {
            return new ArrayList<>();
        } else if (c instanceof Collection) {
            final Collection<T> coll = (Collection<T>) c;
            return distinct(coll, 0, coll.size());
        } else {
            final List<T> result = new ArrayList<>();
            final Set<Object> set = new HashSet<>();

            for (final T e : c) {
                if (set.add(hashKey(e))) {
                    result.add(e);
                }
            }

            return result;
        }
    }

    /**
     * Returns a new list containing only unique elements, removing all duplicates (preserves order of first occurrence).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hi", "Hello", "Hey").iterator();
     * List<String> result = N.distinct(iter);
     * // Returns ["Hi", "Hey", "Hello"]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @return a new list containing only the unique elements (empty if iterator is {@code null} or has no elements)
     * @see #distinct(Iterable)
     * @see #distinctBy(Iterator, Function)
     */
    public static <T> List<T> distinct(final Iterator<? extends T> iter) {
        return distinctBy(iter, Fn.identity());
    }

    /**
     * Returns a new list containing only elements with unique keys extracted by the given function (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry"};
     * List<String> result = N.distinctBy(words, s -> s.charAt(0));
     * // Returns ["apple", "banana"] (distinct by first character)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param keyExtractor the function to extract the comparison key from each element
     * @return a new list containing elements with unique keys (empty if array is {@code null}/empty)
     * @see #distinct(Object[])
     * @see #distinctBy(Object[], int, int, Function)
     */
    public static <T> List<T> distinctBy(final T[] a, final Function<? super T, ?> keyExtractor) {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return distinctBy(a, 0, a.length, keyExtractor);
    }

    /**
     * Returns a new list containing only elements from the specified range with unique keys extracted by the given function (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry", "cherry"};
     * List<String> result = N.distinctBy(words, 1, 4, String::length);
     * // Returns ["apricot", "banana"] (from range [1,4), distinct by length)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param keyExtractor the function to extract the comparison key from each element
     * @return a new list containing elements with unique keys from the range (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #distinctBy(Object[], Function)
     */
    public static <T> List<T> distinctBy(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ?> keyExtractor)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);

        for (int i = fromIndex; i < toIndex; i++) {
            if (set.add(hashKey(keyExtractor.apply(a[i])))) {
                result.add(a[i]);
            }
        }

        return result;
    }

    /**
     * Returns a new collection containing only elements with unique keys extracted by the given function (collection created by the provided supplier, preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry"};
     * Set<String> result = N.distinctBy(words, String::length, HashSet::new);
     * // Returns unique words by length (one per length)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <C> the type of the collection to return
     * @param a the array
     * @param keyExtractor the function to extract the comparison key from each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing elements with unique keys (empty if array is {@code null}/empty)
     * @see #distinctBy(Object[], Function)
     */
    public static <T, C extends Collection<T>> C distinctBy(final T[] a, final Function<? super T, ?> keyExtractor, final Supplier<C> supplier) {
        if (isEmpty(a)) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = newHashSet(len(a) / 2 + 1);

        for (final T e : a) {
            if (set.add(hashKey(keyExtractor.apply(e)))) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements from the specified range with unique keys extracted by the given function (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry");
     * List<String> result = N.distinctBy(words, 0, 3, s -> s.charAt(0));
     * // Returns ["apple", "banana"] (from range [0,3), distinct by first character)
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param keyExtractor the function to extract the comparison key from each element
     * @return a new list containing elements with unique keys from the range (empty if collection is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > c.size() || fromIndex > toIndex}
     * @see #distinctBy(Iterable, Function)
     */
    public static <T> List<T> distinctBy(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Function<? super T, ?> keyExtractor)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return new ArrayList<>();
        }

        final int initCapacity = (toIndex - fromIndex) / 2 + 1;
        final List<T> result = new ArrayList<>(initCapacity);
        final Set<Object> set = newHashSet(initCapacity);
        T e = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                if (set.add(hashKey(keyExtractor.apply(e)))) {
                    result.add(e);
                }
            }
        } else {
            final Iterator<? extends T> it = c.iterator();

            for (int i = 0; i < toIndex && it.hasNext(); i++) {
                e = it.next();

                if (i < fromIndex) {
                    continue;
                }

                if (set.add(hashKey(keyExtractor.apply(e)))) {
                    result.add(e);
                }
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements with unique keys extracted by the given function (preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Amy", "Charlie");
     * List<String> result = N.distinctBy(names, s -> s.charAt(0));
     * // Returns ["Alice", "Bob", "Charlie"] (distinct by first character)
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param keyExtractor the function to extract the comparison key from each element
     * @return a new list containing elements with unique keys (empty if iterable is {@code null}/empty)
     * @see #distinct(Iterable)
     * @see #distinctBy(Iterable, Function, Supplier)
     */
    public static <T> List<T> distinctBy(final Iterable<? extends T> c, final Function<? super T, ?> keyExtractor) {
        return distinctBy(c, keyExtractor, Suppliers.ofList());
    }

    /**
     * Returns a new collection containing only elements with unique keys extracted by the given function (collection created by the provided supplier, preserves order of first occurrence).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry");
     * Set<String> result = N.distinctBy(words, String::length, LinkedHashSet::new);
     * // Returns one word per unique length
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <C> the type of the collection to return
     * @param c the iterable
     * @param keyExtractor the function to extract the comparison key from each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing elements with unique keys (empty if iterable is {@code null}/empty)
     * @see #distinctBy(Iterable, Function)
     */
    public static <T, C extends Collection<T>> C distinctBy(final Iterable<? extends T> c, final Function<? super T, ?> keyExtractor,
            final Supplier<C> supplier) {
        if (isEmptyCollection(c)) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = newHashSet(c instanceof Collection ? ((Collection<T>) c).size() / 2 + 1 : 0);

        for (final T e : c) {
            if (set.add(hashKey(keyExtractor.apply(e)))) {
                result.add(e);
            }
        }

        return result;
    }

    /**
     * Returns a new list containing only elements with unique keys extracted by the given function (preserves order of first occurrence).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * List<String> result = N.distinctBy(iter, s -> s.charAt(0));
     * // Returns ["apple", "banana"] (distinct by first character)
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @param keyExtractor the function to extract the comparison key from each element
     * @return a new list containing elements with unique keys (empty if iterator is {@code null} or has no elements)
     * @see #distinct(Iterator)
     * @see #distinctBy(Iterator, Function, Supplier)
     */
    public static <T> List<T> distinctBy(final Iterator<? extends T> iter, final Function<? super T, ?> keyExtractor) {
        return distinctBy(iter, keyExtractor, Suppliers.ofList());
    }

    /**
     * Returns a new collection containing only elements with unique keys extracted by the given function (collection created by the provided supplier, preserves order of first occurrence).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana", "blueberry").iterator();
     * Set<String> result = N.distinctBy(iter, String::length, HashSet::new);
     * // Returns one word per unique length
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <C> the type of the collection to return
     * @param iter the iterator
     * @param keyExtractor the function to extract the comparison key from each element
     * @param supplier the supplier function to create the result collection
     * @return a new collection containing elements with unique keys (empty if iterator is {@code null} or has no elements)
     * @see #distinctBy(Iterator, Function)
     */
    public static <T, C extends Collection<T>> C distinctBy(final Iterator<? extends T> iter, final Function<? super T, ?> keyExtractor,
            final Supplier<C> supplier) {
        if (iter == null) {
            return supplier.get();
        }

        final C result = supplier.get();
        final Set<Object> set = new HashSet<>();

        T next = null;

        while (iter.hasNext()) {
            next = iter.next();

            if (set.add(hashKey(keyExtractor.apply(next)))) {
                result.add(next);
            }
        }

        return result;
    }

    /**
     * Returns {@code true} if all elements match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "avocado"};
     * boolean result = N.allMatch(words, s -> s.startsWith("a"));
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param filter the predicate to test each element
     * @return {@code true} if all elements match the predicate ({@code true} if array is {@code null}/empty)
     * @see #anyMatch(Object[], Predicate)
     * @see #noneMatch(Object[], Predicate)
     */
    public static <T> boolean allMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return true;
        }

        for (final T e : a) {
            if (!filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if all elements match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(2, 4, 6, 8);
     * boolean result = N.allMatch(numbers, n -> n % 2 == 0);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param filter the predicate to test each element
     * @return {@code true} if all elements match the predicate ({@code true} if iterable is {@code null}/empty)
     * @see #anyMatch(Iterable, Predicate)
     * @see #noneMatch(Iterable, Predicate)
     */
    public static <T> boolean allMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return true;
        }

        for (final T e : c) {
            if (!filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if all elements match the given predicate.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hello").iterator();
     * boolean result = N.allMatch(iter, s -> s.length() < 10);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @param filter the predicate to test each element
     * @return {@code true} if all elements match the predicate ({@code true} if iterator is {@code null} or has no elements)
     * @see #anyMatch(Iterator, Predicate)
     * @see #noneMatch(Iterator, Predicate)
     */
    public static <T> boolean allMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return true;
        }

        while (iter.hasNext()) {
            if (!filter.test(iter.next())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if at least one element matches the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry"};
     * boolean result = N.anyMatch(words, s -> s.length() > 6);
     * // Returns true (banana, cherry)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param filter the predicate to test each element
     * @return {@code true} if at least one element matches the predicate ({@code false} if array is {@code null}/empty)
     * @see #allMatch(Object[], Predicate)
     * @see #noneMatch(Object[], Predicate)
     */
    public static <T> boolean anyMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return false;
        }

        for (final T e : a) {
            if (filter.test(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if at least one element matches the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 8);
     * boolean result = N.anyMatch(numbers, n -> n % 2 == 0);
     * // Returns true (8 is even)
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param filter the predicate to test each element
     * @return {@code true} if at least one element matches the predicate ({@code false} if iterable is {@code null}/empty)
     * @see #allMatch(Iterable, Predicate)
     * @see #noneMatch(Iterable, Predicate)
     */
    public static <T> boolean anyMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return false;
        }

        for (final T e : c) {
            if (filter.test(e)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if at least one element matches the given predicate.
     *
     * <p>Note: The iterator will be consumed until a match is found or fully exhausted.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hello World").iterator();
     * boolean result = N.anyMatch(iter, s -> s.length() > 10);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @param filter the predicate to test each element
     * @return {@code true} if at least one element matches the predicate ({@code false} if iterator is {@code null} or has no elements)
     * @see #allMatch(Iterator, Predicate)
     * @see #noneMatch(Iterator, Predicate)
     */
    public static <T> boolean anyMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return false;
        }

        while (iter.hasNext()) {
            if (filter.test(iter.next())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if no elements match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry"};
     * boolean result = N.noneMatch(words, String::isEmpty);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param filter the predicate to test each element
     * @return {@code true} if no elements match the predicate ({@code true} if array is {@code null}/empty)
     * @see #allMatch(Object[], Predicate)
     * @see #anyMatch(Object[], Predicate)
     */
    public static <T> boolean noneMatch(final T[] a, final Predicate<? super T> filter) {
        if (isEmpty(a)) {
            return true;
        }

        for (final T e : a) {
            if (filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if no elements match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);
     * boolean result = N.noneMatch(numbers, n -> n % 2 == 0);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param filter the predicate to test each element
     * @return {@code true} if no elements match the predicate ({@code true} if iterable is {@code null}/empty)
     * @see #allMatch(Iterable, Predicate)
     * @see #anyMatch(Iterable, Predicate)
     */
    public static <T> boolean noneMatch(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return true;
        }

        for (final T e : c) {
            if (filter.test(e)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if no elements match the given predicate.
     *
     * <p>Note: The iterator will be consumed until a match is found or fully exhausted.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hello").iterator();
     * boolean result = N.noneMatch(iter, s -> s.length() > 10);
     * // Returns true
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @param filter the predicate to test each element
     * @return {@code true} if no elements match the predicate ({@code true} if iterator is {@code null} or has no elements)
     * @see #allMatch(Iterator, Predicate)
     * @see #anyMatch(Iterator, Predicate)
     */
    public static <T> boolean noneMatch(final Iterator<? extends T> iter, final Predicate<? super T> filter) {
        if (iter == null) {
            return true;
        }

        while (iter.hasNext()) {
            if (filter.test(iter.next())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if the number of matching elements is between the specified minimum and maximum (inclusive).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry", "date"};
     * boolean result = N.nMatch(words, 2, 3, s -> s.length() > 5);
     * // Returns true (2 words: "banana" and "cherry" are > 5 chars)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param atLeast the minimum number of matches required (inclusive)
     * @param atMost the maximum number of matches allowed (inclusive)
     * @param filter the predicate to test each element
     * @return {@code true} if match count is within the range ({@code true} if array is empty and {@code atLeast} is 0)
     * @throws IllegalArgumentException if {@code atLeast} &lt; 0 || {@code atMost} &lt; 0 || {@code atLeast} &gt; {@code atMost}
     * @see #allMatch(Object[], Predicate)
     * @see #count(Object[], Predicate)
     */
    public static <T> boolean nMatch(final T[] a, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, "atLeast"); //NOSONAR
        checkArgNotNegative(atMost, "atMost"); //NOSONAR
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'"); //NOSONAR

        if (isEmpty(a)) {
            return atLeast == 0;
        }

        final int len = len(a);

        if (len < atLeast) {
            return false;
        }

        long cnt = 0;

        for (int i = 0; i < len; i++) {
            if (filter.test(a[i]) && (++cnt > atMost)) {
                return false;
            }
        }

        return cnt >= atLeast && cnt <= atMost;
    }

    /**
     * Returns {@code true} if the number of matching elements is between the specified minimum and maximum (inclusive).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(2, 4, 5, 6, 8);
     * boolean result = N.nMatch(numbers, 2, 4, n -> n % 2 == 0);
     * // Returns true (4 even numbers: 2, 4, 6, 8)
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param atLeast the minimum number of matches required (inclusive)
     * @param atMost the maximum number of matches allowed (inclusive)
     * @param filter the predicate to test each element
     * @return {@code true} if match count is within the range ({@code true} if iterable is empty and {@code atLeast} is 0)
     * @throws IllegalArgumentException if {@code atLeast} &lt; 0 || {@code atMost} &lt; 0 || {@code atLeast} &gt; {@code atMost}
     * @see #allMatch(Iterable, Predicate)
     * @see #count(Iterable, Predicate)
     */
    public static <T> boolean nMatch(final Iterable<? extends T> c, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, cs.atLeast);
        checkArgNotNegative(atMost, cs.atMost);
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'");

        if (isEmptyCollection(c)) {
            return atLeast == 0;
        }

        if (c instanceof final Collection<? extends T> coll) { // NOSONAR
            final int size = coll.size();

            if (size < atLeast) {
                return false;
            }
        }

        return nMatch(c.iterator(), atLeast, atMost, filter);
    }

    /**
     * Returns {@code true} if the number of matching elements is between the specified minimum and maximum (inclusive).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Hi", "Hey", "Hello", "World").iterator();
     * boolean result = N.nMatch(iter, 1, 2, s -> s.length() <= 3);
     * // Returns true (2 short words: "Hi" and "Hey")
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator
     * @param atLeast the minimum number of matches required (inclusive)
     * @param atMost the maximum number of matches allowed (inclusive)
     * @param filter the predicate to test each element
     * @return {@code true} if match count is within the range ({@code true} if iterator is empty and {@code atLeast} is 0)
     * @throws IllegalArgumentException if {@code atLeast} &lt; 0 || {@code atMost} &lt; 0 || {@code atLeast} &gt; {@code atMost}
     * @see #allMatch(Iterator, Predicate)
     * @see #count(Iterator, Predicate)
     */
    public static <T> boolean nMatch(final Iterator<? extends T> iter, final int atLeast, final int atMost, final Predicate<? super T> filter) {
        checkArgNotNegative(atLeast, cs.atLeast);
        checkArgNotNegative(atMost, cs.atMost);
        checkArgument(atLeast <= atMost, "'atLeast' must be <= 'atMost'");

        if (iter == null) {
            return atLeast == 0;
        }

        long cnt = 0;

        while (iter.hasNext()) {
            if (filter.test(iter.next()) && (++cnt > atMost)) {
                return false;
            }
        }

        return cnt >= atLeast && cnt <= atMost;
    }

    /**
     * Returns {@code true} if all elements are {@code true}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, true, true};
     * boolean result = N.allTrue(flags);
     * // Returns true
     * }</pre>
     *
     * @param a the array
     * @return {@code true} if all elements are {@code true} ({@code true} if array is {@code null}/empty)
     * @see #allFalse(boolean[])
     * @see #anyTrue(boolean[])
     */
    public static boolean allTrue(final boolean[] a) {
        if (isEmpty(a)) {
            return true;
        }

        for (final boolean b : a) {
            if (!b) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if all elements are {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {false, false, false};
     * boolean result = N.allFalse(flags);
     * // Returns true
     * }</pre>
     *
     * @param a the array
     * @return {@code true} if all elements are {@code false} ({@code true} if array is {@code null}/empty)
     * @see #allTrue(boolean[])
     * @see #anyFalse(boolean[])
     */
    public static boolean allFalse(final boolean[] a) {
        if (isEmpty(a)) {
            return true;
        }

        for (final boolean b : a) {
            if (b) {
                return false;
            }
        }

        return true;
    }

    /**
     * Returns {@code true} if at least one element is {@code true}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {false, true, false};
     * boolean result = N.anyTrue(flags);
     * // Returns true
     * }</pre>
     *
     * @param a the array
     * @return {@code true} if at least one element is {@code true} ({@code false} if array is {@code null}/empty)
     * @see #anyFalse(boolean[])
     * @see #allTrue(boolean[])
     */
    public static boolean anyTrue(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        for (final boolean b : a) {
            if (b) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns {@code true} if at least one element is {@code false}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true};
     * boolean result = N.anyFalse(flags);
     * // Returns true
     * }</pre>
     *
     * @param a the array
     * @return {@code true} if at least one element is {@code false} ({@code false} if array is {@code null}/empty)
     * @see #anyTrue(boolean[])
     * @see #allFalse(boolean[])
     */
    public static boolean anyFalse(final boolean[] a) {
        if (isEmpty(a)) {
            return false;
        }

        for (final boolean b : a) {
            if (!b) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, true, false};
     * int result = N.count(flags, b -> b);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(boolean[], int, int, BooleanPredicate)
     */
    public static int count(final boolean[] a, final BooleanPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean[] flags = {true, false, true, true, false};
     * int result = N.count(flags, 1, 4, b -> b);
     * // Returns 2 (range [1,4) has 2 true values)
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(boolean[], BooleanPredicate)
     */
    public static int count(final boolean[] a, final int fromIndex, final int toIndex, final BooleanPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'B', 'c', 'D', 'e'};
     * int result = N.count(letters, Character::isLowerCase);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(char[], int, int, CharPredicate)
     */
    public static int count(final char[] a, final CharPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * char[] letters = {'a', 'B', 'c', 'D', 'e'};
     * int result = N.count(letters, 1, 4, Character::isUpperCase);
     * // Returns 2 (range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(char[], CharPredicate)
     */
    public static int count(final char[] a, final int fromIndex, final int toIndex, final CharPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 3, 4, 5, 6, 7, 8};
     * int result = N.count(numbers, b -> b % 2 == 0);
     * // Returns 4
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(byte[], int, int, BytePredicate)
     */
    public static int count(final byte[] a, final BytePredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * byte[] numbers = {1, 2, 3, 4, 5, 6, 7, 8};
     * int result = N.count(numbers, 2, 6, b -> b % 2 == 0);
     * // Returns 2 (4 and 6 in range [2,6))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(byte[], BytePredicate)
     */
    public static int count(final byte[] a, final int fromIndex, final int toIndex, final BytePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30, 40, 50};
     * int result = N.count(numbers, s -> s > 20);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(short[], int, int, ShortPredicate)
     */
    public static int count(final short[] a, final ShortPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * short[] numbers = {10, 20, 30, 40, 50};
     * int result = N.count(numbers, 1, 4, s -> s > 20);
     * // Returns 2 (30 and 40 in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(short[], ShortPredicate)
     */
    public static int count(final short[] a, final int fromIndex, final int toIndex, final ShortPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
     * int result = N.count(numbers, n -> n % 2 == 0);
     * // Returns 5
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(int[], int, int, IntPredicate)
     */
    public static int count(final int[] a, final IntPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
     * int result = N.count(numbers, 3, 8, n -> n % 2 == 0);
     * // Returns 2 (4 and 6 in range [3,8))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(int[], IntPredicate)
     */
    public static int count(final int[] a, final int fromIndex, final int toIndex, final IntPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * int result = N.count(numbers, n -> n > 200L);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(long[], int, int, LongPredicate)
     */
    public static int count(final long[] a, final LongPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * long[] numbers = {100L, 200L, 300L, 400L, 500L};
     * int result = N.count(numbers, 1, 4, n -> n > 200L);
     * // Returns 2 (300L and 400L in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(long[], LongPredicate)
     */
    public static int count(final long[] a, final int fromIndex, final int toIndex, final LongPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.3f, 3.7f, 4.1f, 5.9f};
     * int result = N.count(numbers, n -> n > 3.0f);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(float[], int, int, FloatPredicate)
     */
    public static int count(final float[] a, final FloatPredicate filter) {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * float[] numbers = {1.5f, 2.3f, 3.7f, 4.1f, 5.9f};
     * int result = N.count(numbers, 1, 4, n -> n > 3.0f);
     * // Returns 1 (only 3.7f in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(float[], FloatPredicate)
     */
    public static int count(final float[] a, final int fromIndex, final int toIndex, final FloatPredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.3, 3.7, 4.1, 5.9};
     * int result = N.count(numbers, n -> n > 3.0);
     * // Returns 3
     * }</pre>
     *
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     * @see #count(double[], int, int, DoublePredicate)
     */
    public static int count(final double[] a, final DoublePredicate filter) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * double[] numbers = {1.5, 2.3, 3.7, 4.1, 5.9};
     * int result = N.count(numbers, 1, 4, n -> n > 3.0);
     * // Returns 1 (only 3.7 in range [1,4))
     * }</pre>
     *
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements in the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #count(double[], DoublePredicate)
     */
    public static int count(final double[] a, final int fromIndex, final int toIndex, final DoublePredicate filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry"};
     * int result = N.count(words, s -> s.length() > 5);
     * // Returns 2
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if array is {@code null}/empty)
     */
    public static <T> int count(final T[] a, final Predicate<? super T> filter) throws IndexOutOfBoundsException {
        if (isEmpty(a)) {
            return 0;
        }

        return count(a, 0, a.length, filter);
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "banana", "cherry", "date"};
     * int result = N.count(words, 1, 3, s -> s.length() > 5);
     * // Returns 2 (banana and cherry in range [1,3))
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements within the range that match the predicate (0 if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     */
    public static <T> int count(final T[] a, final int fromIndex, final int toIndex, final Predicate<? super T> filter) throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return 0;
        }

        int count = 0;

        for (int i = fromIndex; i < toIndex; i++) {
            if (filter.test(a[i])) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the number of elements within the specified range that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
     * int result = N.count(words, 1, 3, s -> s.length() > 5);
     * // Returns 2 (banana and cherry in range [1,3))
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param c the collection
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param filter the predicate to test each element
     * @return the number of elements within the range that match the predicate (0 if collection is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > c.size() || fromIndex > toIndex}
     */
    public static <T> int count(final Collection<? extends T> c, final int fromIndex, final int toIndex, final Predicate<? super T> filter)
            throws IndexOutOfBoundsException {
        checkFromToIndex(fromIndex, toIndex, size(c));

        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || (fromIndex == toIndex && fromIndex < c.size())) {
            return 0;
        }

        int count = 0;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            for (int i = fromIndex; i < toIndex; i++) {
                if (filter.test(list.get(i))) {
                    count++;
                }
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }
                if (filter.test(e)) {
                    count++;
                }

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return count;
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
     * int result = N.count(numbers, n -> n % 2 == 0);
     * // Returns 3
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param c the iterable
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if iterable is {@code null}/empty)
     */
    public static <T> int count(final Iterable<? extends T> c, final Predicate<? super T> filter) {
        if (isEmptyCollection(c)) {
            return 0;
        }

        int count = 0;

        for (final T e : c) {
            if (filter.test(e)) {
                count++;
            }
        }

        return count;
    }

    /**
     * Returns the total number of elements.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("a", "b", "c", "d").iterator();
     * int result = N.count(iter);
     * // Returns 4 (iterator is now consumed)
     * }</pre>
     *
     * @param iter the iterator (will be consumed)
     * @return the total number of elements (0 if iterator is {@code null} or has no elements)
     * @throws ArithmeticException if the count overflows an {@code int}
     * @see #count(Iterator, Predicate)
     */
    public static int count(final Iterator<?> iter) throws ArithmeticException {
        if (iter == null) {
            return 0;
        }

        return Numbers.toIntExact(Iterators.count(iter));
    }

    /**
     * Returns the number of elements that match the given predicate.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<Integer> iter = Arrays.asList(1, 2, 3, 4, 5, 6).iterator();
     * int result = N.count(iter, n -> n % 2 == 0);
     * // Returns 3 (iterator is now consumed)
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param iter the iterator (will be consumed)
     * @param filter the predicate to test each element
     * @return the number of elements that match the predicate (0 if iterator is {@code null} or has no elements)
     * @throws ArithmeticException if the count overflows an {@code int}
     * @see #count(Iterator)
     */
    public static <T> int count(final Iterator<? extends T> iter, final Predicate<? super T> filter) throws ArithmeticException {
        if (iter == null) {
            return 0;
        }

        return Numbers.toIntExact(Iterators.count(iter, filter));
    }

    /**
     * Merges two the input arrays into a list based where the order of the elements is determined by the given selector function.
     *
     * @param <T> the type of elements in the arrays
     * @param a the first array to merge
     * @param b the second array to merge
     * @param nextSelector a function that determines the next element to add to the result list
     * @return a list containing the merged elements from both arrays. An empty list is returned if both arrays are {@code null} or empty.
     * @see #concat(Object[], Object[])
     */
    public static <T> List<T> merge(final T[] a, final T[] b, final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        if (isEmpty(a)) {
            return isEmpty(b) ? new ArrayList<>() : asList(b);
        } else if (isEmpty(b)) {
            return asList(a);
        }

        final List<T> result = new ArrayList<>(a.length + b.length);
        final int lenA = a.length;
        final int lenB = b.length;
        int cursorA = 0;
        int cursorB = 0;

        while (cursorA < lenA || cursorB < lenB) {
            if ((cursorA < lenA) && ((cursorB >= lenB) || (nextSelector.apply(a[cursorA], b[cursorB]) == MergeResult.TAKE_FIRST))) {
                result.add(a[cursorA++]);
            } else {
                result.add(b[cursorB++]);
            }
        }

        return result;
    }

    /**
     * Merges two the input iterables into a list based where the order of the elements is determined by the given selector function.
     *
     * @param <T> the type of elements in the iterables
     * @param a the first iterable to merge
     * @param b the second iterable to merge
     * @param nextSelector a function that determines the next element to add to the result list
     * @return a list containing the merged elements from both iterables. An empty list is returned if both iterables are {@code null} or empty.
     * @see #concat(Iterable, Iterable)
     */
    public static <T> List<T> merge(final Iterable<? extends T> a, final Iterable<? extends T> b,
            final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        return merge(N.asList(a, b), nextSelector, IntFunctions.ofList());
    }

    /**
     * Merges multiple iterables into a list based where the order of the elements is determined by the given selector function.
     *
     * @param <T> the type of elements in the iterables
     * @param c the collection of iterable to merge
     * @param nextSelector a function that determines the next element to add to the result list
     * @return a list containing the merged elements from all iterables. An empty list is returned if all iterables are {@code null} or empty.
     * @see #concat(Collection)
     * @see #concat(Collection, IntFunction)
     */
    public static <T> List<T> merge(final Collection<? extends Iterable<? extends T>> c, final BiFunction<? super T, ? super T, MergeResult> nextSelector) {
        return merge(c, nextSelector, IntFunctions.ofList());
    }

    /**
     * Merges multiple iterables into a list based where the order of the elements is determined by the given selector function.
     * The returned collection is created by the specified {@code supplier}.
     *
     * @param <T> the type of elements in the iterables
     * @param <C> the type of the resulting collection
     * @param c the collection of iterable to merge
     * @param nextSelector a function that determines the next element to add to the result collection
     * @param supplier the supplier used to create the returned collection
     * @return a collection containing the merged elements from all iterables. An empty collection created by the specified {@code supplier} is returned if all iterables are {@code null} or empty.
     * @see #concat(Collection)
     * @see #concat(Collection, IntFunction)
     */
    public static <T, C extends Collection<T>> C merge(final Collection<? extends Iterable<? extends T>> c,
            final BiFunction<? super T, ? super T, MergeResult> nextSelector, final IntFunction<? extends C> supplier) {
        if (isEmpty(c)) {
            return supplier.apply(0);
        } else if (c.size() == 1) {
            final Iterable<? extends T> a = N.firstOrNullIfEmpty(c);
            return a == null ? supplier.apply(0) : N.toCollection(a, supplier);
        } else if (c.size() == 2) {
            final Iterator<? extends Iterable<? extends T>> iter = c.iterator();
            final Iterable<? extends T> a = iter.next();
            final Iterable<? extends T> b = iter.next();

            if (a == null) {
                return b == null ? supplier.apply(0) : N.toCollection(b, supplier);
            } else if (b == null) {
                return N.toCollection(a, supplier);
            }

            final C ret = supplier.apply(getSizeOrDefault(a, 0) + getSizeOrDefault(b, 0));
            final Iterator<? extends T> iterA = a.iterator();
            final Iterator<? extends T> iterB = b.iterator();

            T nextA = null;
            T nextB = null;
            boolean hasNextA = false;
            boolean hasNextB = false;

            while (hasNextA || hasNextB || iterA.hasNext() || iterB.hasNext()) {
                if (hasNextA) {
                    if (iterB.hasNext()) {
                        if (nextSelector.apply(nextA, (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                            hasNextA = false;
                            hasNextB = true;
                            ret.add(nextA);
                        } else {
                            ret.add(nextB);
                        }
                    } else {
                        hasNextA = false;
                        ret.add(nextA);
                    }
                } else if (hasNextB) {
                    if (iterA.hasNext()) {
                        if (nextSelector.apply((nextA = iterA.next()), nextB) == MergeResult.TAKE_FIRST) {
                            ret.add(nextA);
                        } else {
                            hasNextA = true;
                            hasNextB = false;
                            ret.add(nextB);
                        }
                    } else {
                        hasNextB = false;
                        ret.add(nextB);
                    }
                } else if (iterA.hasNext()) {
                    if (iterB.hasNext()) {
                        if (nextSelector.apply((nextA = iterA.next()), (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                            hasNextB = true;
                            ret.add(nextA);
                        } else {
                            hasNextA = true;
                            ret.add(nextB);
                        }
                    } else {
                        ret.add(iterA.next());
                    }
                } else {
                    ret.add(iterB.next());
                }
            }

            return ret;
        } else {
            int totalSize = 0;
            Iterator<T> mergedIter = ObjIterator.empty();
            Iterator<? extends T> iter = null;

            for (final Iterable<? extends T> e : c) {
                iter = e == null ? null : e.iterator();

                if (iter == null || !iter.hasNext()) {
                    continue;
                }

                totalSize += getSizeOrDefault(e, 0);

                final Iterator<T> iterA = mergedIter;
                final Iterator<? extends T> iterB = iter;

                mergedIter = new Iterator<>() {
                    private T nextA = null;
                    private T nextB = null;
                    private boolean hasNextA = false;
                    private boolean hasNextB = false;

                    @Override
                    public boolean hasNext() {
                        return hasNextA || hasNextB || iterA.hasNext() || iterB.hasNext();
                    }

                    @Override
                    public T next() {
                        if (hasNextA) {
                            if (iterB.hasNext()) {
                                if (nextSelector.apply(nextA, (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                                    hasNextA = false;
                                    hasNextB = true;
                                    return nextA;
                                } else {
                                    return nextB;
                                }
                            } else {
                                hasNextA = false;
                                return nextA;
                            }
                        } else if (hasNextB) {
                            if (iterA.hasNext()) {
                                if (nextSelector.apply((nextA = iterA.next()), nextB) == MergeResult.TAKE_FIRST) {
                                    return nextA;
                                } else {
                                    hasNextA = true;
                                    hasNextB = false;
                                    return nextB;
                                }
                            } else {
                                hasNextB = false;
                                return nextB;
                            }
                        } else if (iterA.hasNext()) {
                            if (iterB.hasNext()) {
                                if (nextSelector.apply((nextA = iterA.next()), (nextB = iterB.next())) == MergeResult.TAKE_FIRST) {
                                    hasNextB = true;
                                    return nextA;
                                } else {
                                    hasNextA = true;
                                    return nextB;
                                }
                            } else {
                                return iterA.next();
                            }
                        } else {
                            return iterB.next();
                        }
                    }
                };
            }

            final C ret = supplier.apply(totalSize);

            while (mergedIter.hasNext()) {
                ret.add(mergedIter.next());
            }

            return ret;
        }
    }

    //    /**

    /**
     * Zips two arrays into a single list using the provided zip function.
     * The size of the resulting list is equal to the size of the shorter input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <R> the type of elements in the resulting list
     * @param a the first array to zip
     * @param b the second array to zip
     * @param zipFunction a function that combines elements from the two arrays. An empty list is returned if the one of input arrays is {@code null} or empty.
     * @return a list containing the zipped elements
     * @see Fn#pair()
     * @see Fn#tuple2()
     */
    public static <A, B, R> List<R> zip(final A[] a, final B[] b, final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        if (isEmpty(a) || isEmpty(b)) {
            return new ArrayList<>();
        }

        final int minLen = min(a.length, b.length);
        final List<R> result = new ArrayList<>(minLen);

        for (int i = 0; i < minLen; i++) {
            result.add(zipFunction.apply(a[i], b[i]));
        }

        return result;
    }

    /**
     * Zips two iterables into a single list using the provided zip function.
     * The size of the resulting list is equal to the size of the shorter input iterable.
     *
     * @param <A> the type of elements in the first iterable
     * @param <B> the type of elements in the second iterable
     * @param <R> the type of elements in the resulting list
     * @param a the first iterable to zip
     * @param b the second iterable to zip
     * @param zipFunction a function that combines elements from the two iterables. An empty list is returned if the one of input iterables is {@code null} or empty.
     * @return a list containing the zipped elements
     * @see Fn#pair()
     * @see Fn#tuple2()
     */
    public static <A, B, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        if (isEmptyCollection(a) || isEmptyCollection(b)) {
            return new ArrayList<>();
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final int minLen = min(getSizeOrDefault(a, 0), getSizeOrDefault(b, 0));
        final List<R> result = new ArrayList<>(minLen);

        while (iterA.hasNext() && iterB.hasNext()) {
            result.add(zipFunction.apply(iterA.next(), iterB.next()));
        }

        return result;
    }

    /**
     * Zips three arrays into a single list using the provided zip function.
     * The size of the resulting list is equal to the size of the shortest input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <C> the type of elements in the third array
     * @param <R> the type of elements in the resulting list
     * @param a the first array to zip
     * @param b the second array to zip
     * @param c the third array to zip
     * @param zipFunction a function that combines elements from the three arrays. An empty list is returned if the one of input arrays is {@code null} or empty.
     * @return a list containing the zipped elements
     * @see Fn#triple()
     * @see Fn#tuple3()
     */
    public static <A, B, C, R> List<R> zip(final A[] a, final B[] b, final C[] c, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        if (isEmpty(a) || isEmpty(b) || isEmpty(c)) {
            return new ArrayList<>();
        }

        final int minLen = min(a.length, b.length, c.length);
        final List<R> result = new ArrayList<>(minLen);

        for (int i = 0; i < minLen; i++) {
            result.add(zipFunction.apply(a[i], b[i], c[i]));
        }

        return result;
    }

    /**
     * Zips three iterables into a single list using the provided zip function.
     * The size of the resulting list is equal to the size of the shortest input iterables.
     *
     * @param <A> the type of elements in the first iterable
     * @param <B> the type of elements in the second iterable
     * @param <C> the type of elements in the third iterable
     * @param <R> the type of elements in the resulting list
     * @param a the first iterable to zip
     * @param b the second iterable to zip
     * @param c the third iterable to zip
     * @param zipFunction a function that combines elements from the three iterables. An empty list is returned if the one of input iterables is {@code null} or empty.
     * @return a list containing the zipped elements
     * @see Fn#triple()
     * @see Fn#tuple3()
     */
    public static <A, B, C, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        if (isEmptyCollection(a) || isEmptyCollection(b) || isEmptyCollection(c)) {
            return new ArrayList<>();
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final Iterator<C> iterC = c.iterator();
        final int minLen = min(getSizeOrDefault(a, 0), getSizeOrDefault(b, 0), getSizeOrDefault(c, 0));
        final List<R> result = new ArrayList<>(minLen);

        while (iterA.hasNext() && iterB.hasNext() && iterC.hasNext()) {
            result.add(zipFunction.apply(iterA.next(), iterB.next(), iterC.next()));
        }

        return result;
    }

    /**
     * Zips two arrays into a single list using the provided zip function.
     * If one array is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting list is equal to the size of the longer input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <R> the type of elements in the resulting list
     * @param a the first array to zip
     * @param b the second array to zip
     * @param valueForNoneA the default value to use if the first array is shorter
     * @param valueForNoneB the default value to use if the second array is shorter
     * @param zipFunction a function that combines elements from the two arrays
     * @return a list containing the zipped elements
     * @see Fn#pair()
     * @see Fn#tuple2()
     */
    public static <A, B, R> List<R> zip(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int maxLen = max(lenA, lenB);
        final List<R> result = new ArrayList<>(maxLen);

        for (int i = 0; i < maxLen; i++) {
            result.add(zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB));
        }

        return result;
    }

    /**
     * Zips two iterables into a single list using the provided zip function.
     * If one iterable is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting list is equal to the size of the longer input iterable.
     *
     * @param <A> the type of elements in the first iterable
     * @param <B> the type of elements in the second iterable
     * @param <R> the type of elements in the resulting list
     * @param a the first iterable to zip
     * @param b the second iterable to zip
     * @param valueForNoneA the default value to use if the first iterable is shorter
     * @param valueForNoneB the default value to use if the second iterable is shorter
     * @param zipFunction a function that combines elements from the two iterables
     * @return a list containing the zipped elements
     * @see Fn#pair()
     * @see Fn#tuple2()
     */
    public static <A, B, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction) {
        final Iterator<A> iterA = a == null ? ObjIterator.empty() : a.iterator();
        final Iterator<B> iterB = b == null ? ObjIterator.empty() : b.iterator();
        final int lenA = getSizeOrDefault(a, 0);
        final int lenB = getSizeOrDefault(b, 0);
        final int maxLen = max(lenA, lenB);
        final List<R> result = new ArrayList<>(maxLen);

        if (a == null || a instanceof Collection) {
            if (b == null || b instanceof Collection) {
                for (int i = 0; i < maxLen; i++) {
                    result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB));
                }
            } else {
                for (int i = 0; i < lenA || iterB.hasNext(); i++) {
                    result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB));
                }
            }
        } else if (b == null || b instanceof Collection) {
            for (int i = 0; i < lenB || iterA.hasNext(); i++) {
                result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB));
            }
        } else {
            while (iterA.hasNext() || iterB.hasNext()) {
                result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB));
            }
        }

        return result;
    }

    /**
     * Zips three arrays into a single list using the provided zip function.
     * If one array is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting list is equal to the size of the longest input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <C> the type of elements in the third array
     * @param <R> the type of elements in the resulting list
     * @param a the first array to zip
     * @param b the second array to zip
     * @param c the third array to zip
     * @param valueForNoneA the default value to use if the first array is shorter
     * @param valueForNoneB the default value to use if the second array is shorter
     * @param valueForNoneC the default value to use if the third array is shorter
     * @param zipFunction a function that combines elements from the three arrays
     * @return a list containing the zipped elements
     * @see Fn#triple()
     * @see Fn#tuple3()
     */
    public static <A, B, C, R> List<R> zip(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB, final C valueForNoneC,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int maxLen = max(lenA, lenB, lenC);
        final List<R> result = new ArrayList<>(maxLen);

        for (int i = 0; i < maxLen; i++) {
            result.add(zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC));
        }

        return result;
    }

    /**
     * Zips three iterables into a single list using the provided zip function.
     * If one iterable is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting list is equal to the size of the longest input iterable.
     *
     * @param <A> the type of elements in the first iterable
     * @param <B> the type of elements in the second iterable
     * @param <C> the type of elements in the third iterable
     * @param <R> the type of elements in the resulting list
     * @param a the first iterable to zip
     * @param b the second iterable to zip
     * @param c the third iterable to zip
     * @param valueForNoneA the default value to use if the first iterable is shorter
     * @param valueForNoneB the default value to use if the second iterable is shorter
     * @param valueForNoneC the default value to use if the third iterable is shorter
     * @param zipFunction a function that combines elements from the three iterables
     * @return a list containing the zipped elements
     * @see Fn#triple()
     * @see Fn#tuple3()
     */
    public static <A, B, C, R> List<R> zip(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c, final A valueForNoneA, final B valueForNoneB,
            final C valueForNoneC, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction) {
        final Iterator<A> iterA = isEmptyCollection(a) ? ObjIterator.empty() : a.iterator();
        final Iterator<B> iterB = isEmptyCollection(b) ? ObjIterator.empty() : b.iterator();
        final Iterator<C> iterC = isEmptyCollection(c) ? ObjIterator.empty() : c.iterator();
        final int lenA = getSizeOrDefault(a, 0);
        final int lenB = getSizeOrDefault(b, 0);
        final int lenC = getSizeOrDefault(c, 0);
        final int maxLen = max(lenA, lenB, lenC);
        final List<R> result = new ArrayList<>(maxLen);

        if (a == null || a instanceof Collection) {
            if (b == null || b instanceof Collection) {
                if (c == null || c instanceof Collection) {
                    for (int i = 0; i < maxLen; i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                                i < lenC ? iterC.next() : valueForNoneC));
                    }
                } else {
                    for (int i = 0; i < lenA || i < lenB || iterC.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                                iterC.hasNext() ? iterC.next() : valueForNoneC));
                    }
                }
            } else {
                if (c == null || c instanceof Collection) {
                    for (int i = 0; i < lenA || i < lenC || iterB.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                                i < lenC ? iterC.next() : valueForNoneC));
                    }
                } else {
                    for (int i = 0; i < lenA || iterB.hasNext() || iterC.hasNext(); i++) {
                        result.add(zipFunction.apply(i < lenA ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                                iterC.hasNext() ? iterC.next() : valueForNoneC));
                    }
                }
            }
        } else if (b == null || b instanceof Collection) {
            if (c == null || c instanceof Collection) {
                for (int i = 0; i < lenB || i < lenC || iterA.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                            i < lenC ? iterC.next() : valueForNoneC));
                }
            } else {
                for (int i = 0; i < lenB || iterA.hasNext() || iterC.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, i < lenB ? iterB.next() : valueForNoneB,
                            iterC.hasNext() ? iterC.next() : valueForNoneC));
                }
            }
        } else {
            if (c == null || c instanceof Collection) {
                for (int i = 0; i < lenC || iterA.hasNext() || iterB.hasNext(); i++) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                            i < lenC ? iterC.next() : valueForNoneC));
                }
            } else {
                while (iterA.hasNext() || iterB.hasNext() || iterC.hasNext()) {
                    result.add(zipFunction.apply(iterA.hasNext() ? iterA.next() : valueForNoneA, iterB.hasNext() ? iterB.next() : valueForNoneB,
                            iterC.hasNext() ? iterC.next() : valueForNoneC));
                }
            }
        }

        return result;
    }

    /**
     * Zips two arrays into a single array using the provided zip function.
     * The size of the resulting array is equal to the size of the shorter input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <R> the type of elements in the resulting array
     * @param a the first array to zip
     * @param b the second array to zip
     * @param targetElementType the class of the resulting array's element type
     * @param zipFunction a function that combines elements from the two arrays. An empty list is returned if the one of input arrays is {@code null} or empty.
     * @return an array containing the zipped elements
     * @throws IllegalArgumentException if the targetElementType is null
     */
    public static <A, B, R> R[] zip(final A[] a, final B[] b, final BiFunction<? super A, ? super B, ? extends R> zipFunction, final Class<R> targetElementType)
            throws IllegalArgumentException {
        final int lenA = len(a);
        final int lenB = len(b);
        final int minLen = min(lenA, lenB);

        final R[] result = newArray(targetElementType, minLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        return result;
    }

    /**
     * Zips two arrays into a single array using the provided zip function.
     * If one array is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting array is equal to the size of the longer input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <R> the type of elements in the resulting array
     * @param a the first array to zip
     * @param b the second array to zip
     * @param valueForNoneA the default value to use if the first array is shorter
     * @param valueForNoneB the default value to use if the second array is shorter
     * @param targetElementType the class of the resulting array's element type
     * @param zipFunction a function that combines elements from the two arrays
     * @return an array containing the zipped elements
     * @throws IllegalArgumentException if the targetElementType is null
     */
    public static <A, B, R> R[] zip(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final BiFunction<? super A, ? super B, ? extends R> zipFunction, final Class<R> targetElementType) throws IllegalArgumentException {
        final int lenA = len(a);
        final int lenB = len(b);
        final int minLen = min(lenA, lenB);
        final int maxLen = max(lenA, lenB);

        final R[] result = newArray(targetElementType, maxLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i]);
        }

        if (lenA < maxLen) {
            for (int i = lenA; i < maxLen; i++) {
                result[i] = zipFunction.apply(valueForNoneA, b[i]);
            }
        } else if (lenB < maxLen) {
            for (int i = lenB; i < maxLen; i++) {
                result[i] = zipFunction.apply(a[i], valueForNoneB);
            }
        }

        return result;
    }

    /**
     * Zips three arrays into a single array using the provided zip function.
     * The size of the resulting array is equal to the size of the shortest input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <C> the type of elements in the third array
     * @param <R> the type of elements in the resulting array
     * @param a the first array to zip
     * @param b the second array to zip
     * @param c the third array to zip
     * @param targetElementType the class of the resulting array's element type
     * @param zipFunction a function that combines elements from the three arrays. An empty list is returned if the one of input arrays is {@code null} or empty.
     * @return an array containing the zipped elements
     * @throws IllegalArgumentException if the targetElementType is null
     */
    public static <A, B, C, R> R[] zip(final A[] a, final B[] b, final C[] c, final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction,
            final Class<R> targetElementType) throws IllegalArgumentException {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int minLen = min(lenA, lenB, lenC);

        final R[] result = newArray(targetElementType, minLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        return result;
    }

    /**
     * Zips three arrays into a single array using the provided zip function.
     * If one array is shorter, the provided default values are used for the remaining elements.
     * The size of the resulting array is equal to the size of the longest input array.
     *
     * @param <A> the type of elements in the first array
     * @param <B> the type of elements in the second array
     * @param <C> the type of elements in the third array
     * @param <R> the type of elements in the resulting array
     * @param a the first array to zip
     * @param b the second array to zip
     * @param c the third array to zip
     * @param valueForNoneA the default value to use if the first array is shorter
     * @param valueForNoneB the default value to use if the second array is shorter
     * @param valueForNoneC the default value to use if the third array is shorter
     * @param targetElementType the class of the resulting array's element type
     * @param zipFunction a function that combines elements from the three arrays
     * @return an array containing the zipped elements
     * @throws IllegalArgumentException if the targetElementType is null
     */
    public static <A, B, C, R> R[] zip(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB, final C valueForNoneC,
            final TriFunction<? super A, ? super B, ? super C, ? extends R> zipFunction, final Class<R> targetElementType) throws IllegalArgumentException {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);
        final int minLen = min(lenA, lenB, lenC);
        final int maxLen = max(lenA, lenB, lenC);

        final R[] result = newArray(targetElementType, maxLen);

        for (int i = 0; i < minLen; i++) {
            result[i] = zipFunction.apply(a[i], b[i], c[i]);
        }

        if (minLen < maxLen) {
            for (int i = minLen; i < maxLen; i++) {
                result[i] = zipFunction.apply(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
            }
        }

        return result;
    }

    /**
     * Unzips an iterable into two separate lists using the provided unzip function.
     *
     * @param <T> the type of elements in the input iterable
     * @param <A> the type of elements in the first output list
     * @param <B> the type of elements in the second output list
     * @param c the input iterable to unzip
     * @param unzip a function that takes an element from the input iterable and a pair, and populates the pair with the unzipped values
     * @return a pair of lists, where the first list contains the first elements and the second list contains the second elements
     */
    public static <T, A, B> Pair<List<A>, List<B>> unzip(final Iterable<? extends T> c, final BiConsumer<? super T, Pair<A, B>> unzip) {
        return unzip(c, unzip, IntFunctions.ofList());
    }

    /**
     * Unzips an iterable into two separate collections using the provided unzip function.
     *
     * @param <T> the type of elements in the input iterable
     * @param <A> the type of elements in the first output collection
     * @param <B> the type of elements in the second output collection
     * @param <LC> the type of the first output collection
     * @param <RC> the type of the second output collection
     * @param c the input iterable to unzip
     * @param unzip a function that takes an element from the input iterable and a pair, and populates the pair with the unzipped values
     * @param supplier a function that provides new instances of the output collections
     * @return a pair of lists, where the first collection contains the first elements and the second collection contains the second elements
     */
    public static <T, A, B, LC extends Collection<A>, RC extends Collection<B>> Pair<LC, RC> unzip(final Iterable<? extends T> c,
            final BiConsumer<? super T, Pair<A, B>> unzip, final IntFunction<? extends Collection<?>> supplier) {
        final int len = getSizeOrDefault(c, 0);

        final LC l = (LC) supplier.apply(len);
        final RC r = (RC) supplier.apply(len);
        final Pair<A, B> p = new Pair<>();

        if (c != null) {
            for (final T e : c) {
                unzip.accept(e, p);

                l.add(p.left());
                r.add(p.right());
            }
        }

        return Pair.of(l, r);
    }

    /**
     * Unzips an iterable into three separate lists using the provided unzip function.
     *
     * @param <T> the type of elements in the input iterable
     * @param <A> the type of elements in the first output list
     * @param <B> the type of elements in the second output list
     * @param <C> the type of elements in the third output list
     * @param c the input iterable to unzip
     * @param unzip a function that takes an element from the input iterable and a triple, and populates the triple with the unzipped values
     * @return a triple of lists, where the first list contains the first elements, the second list contains the second elements and the third list contains the third elements
     * @see TriIterator#unzip(Iterable, BiConsumer)
     * @see TriIterator#toMultiList(Supplier)
     * @see TriIterator#toMultiSet(Supplier)
     * @deprecated replaced by {@link TriIterator#unzip(Iterable, BiConsumer)}
     */
    @Deprecated
    public static <T, A, B, C> Triple<List<A>, List<B>, List<C>> unzipp(final Iterable<? extends T> c, final BiConsumer<? super T, Triple<A, B, C>> unzip) {
        return unzipp(c, unzip, IntFunctions.ofList());
    }

    /**
     * Unzips an iterable into three separate collections using the provided unzip function.
     *
     * @param <T> the type of elements in the input iterable
     * @param <A> the type of elements in the first output collection
     * @param <B> the type of elements in the second output collection
     * @param <C> the type of elements in the third output collection
     * @param <LC> the type of the first output collection
     * @param <MC> the type of the second output collection
     * @param <RC> the type of the third output collection
     * @param c the input iterable to unzip
     * @param unzip a function that takes an element from the input iterable and a triple, and populates the triple with the unzipped values
     * @param supplier a function that provides new instances of the output collections
     * @return a triple of collections, where the first collection contains the first elements, the second collection contains the second elements and the third collection contains the third elements
     * @see TriIterator#unzip(Iterable, BiConsumer)
     * @see TriIterator#toMultiList(Supplier)
     * @see TriIterator#toMultiSet(Supplier)
     * @deprecated replaced by {@link TriIterator#unzip(Iterable, BiConsumer)}
     */
    @Deprecated
    public static <T, A, B, C, LC extends Collection<A>, MC extends Collection<B>, RC extends Collection<C>> Triple<LC, MC, RC> unzipp(
            final Iterable<? extends T> c, final BiConsumer<? super T, Triple<A, B, C>> unzip, final IntFunction<? extends Collection<?>> supplier) {
        final int len = getSizeOrDefault(c, 0);

        final LC l = (LC) supplier.apply(len);
        final MC m = (MC) supplier.apply(len);
        final RC r = (RC) supplier.apply(len);
        final Triple<A, B, C> t = new Triple<>();

        if (c != null) {
            for (final T e : c) {
                unzip.accept(e, t);

                l.add(t.left());
                m.add(t.middle());
                r.add(t.right());
            }
        }

        return Triple.of(l, m, r);
    }

    /**
     * Returns a map grouping elements by keys extracted from each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry"};
     * Map<Character, List<String>> result = N.groupBy(words, s -> s.charAt(0));
     * // Returns {'a': ["apple", "apricot"], 'b': ["banana", "blueberry"]}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <K> the type of keys
     * @param a the array
     * @param keyExtractor the function to extract grouping keys
     * @return a map with keys and lists of elements sharing each key (empty if array is {@code null}/empty)
     * @see #groupBy(Object[], Function, Supplier)
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final T[] a, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(a, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys extracted from each element (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana"};
     * LinkedHashMap<Character, List<String>> result = N.groupBy(words, s -> s.charAt(0), LinkedHashMap::new);
     * // Returns a LinkedHashMap with insertion order preserved
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param a the array
     * @param keyExtractor the function to extract grouping keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of elements sharing each key (empty if array is {@code null}/empty)
     * @see #groupBy(Object[], Function)
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final T[] a, final Function<? super T, ? extends K> keyExtractor, final Supplier<M> mapSupplier) {
        return groupBy(a, 0, len(a), keyExtractor, mapSupplier);
    }

    /**
     * Returns a map grouping elements in the specified range by keys extracted from each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry", "cherry"};
     * Map<Character, List<String>> result = N.groupBy(words, 0, 3, s -> s.charAt(0));
     * // Returns {'a': ["apple", "apricot"], 'b': ["banana"]}
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <K> the type of keys
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param keyExtractor the function to extract grouping keys
     * @return a map with keys and lists of elements sharing each key (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #groupBy(Object[], int, int, Function, Supplier)
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final T[] a, final int fromIndex, final int toIndex, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(a, fromIndex, toIndex, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements in the specified range by keys extracted from each element (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] words = {"apple", "apricot", "banana", "blueberry"};
     * TreeMap<Character, List<String>> result = N.groupBy(words, 0, 3, s -> s.charAt(0), TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param a the array
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param keyExtractor the function to extract grouping keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of elements sharing each key (empty if array is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #groupBy(Object[], int, int, Function)
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final T[] a, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends K> keyExtractor, final Supplier<M> mapSupplier) throws IndexOutOfBoundsException {
        final int length = len(a);

        checkFromToIndex(fromIndex, toIndex, length);

        final M ret = mapSupplier.get();
        K key = null;
        List<T> val = null;

        for (int i = fromIndex; i < toIndex; i++) {
            key = keyExtractor.apply(a[i]);
            val = ret.computeIfAbsent(key, k -> new ArrayList<>());

            val.add(a[i]);
        }

        return ret;
    }

    /**
     * Returns a map grouping elements in the specified range by keys extracted from each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry");
     * Map<Character, List<String>> result = N.groupBy(words, 0, 3, s -> s.charAt(0));
     * // Returns {'a': ["apple", "apricot"], 'b': ["banana"]}
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param keyExtractor the function to extract grouping keys
     * @return a map with keys and lists of elements sharing each key (empty if collection is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > c.size() || fromIndex > toIndex}
     * @see #groupBy(Collection, int, int, Function, Supplier)
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(c, fromIndex, toIndex, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements in the specified range by keys extracted from each element (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * TreeMap<Character, List<String>> result = N.groupBy(words, 0, 2, s -> s.charAt(0), TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param c the collection
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param keyExtractor the function to extract grouping keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of elements sharing each key (empty if collection is {@code null}/empty or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > c.size() || fromIndex > toIndex}
     * @see #groupBy(Collection, int, int, Function)
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final Collection<? extends T> c, final int fromIndex, final int toIndex,
            final Function<? super T, ? extends K> keyExtractor, final Supplier<M> mapSupplier) throws IndexOutOfBoundsException {
        final int length = size(c);

        checkFromToIndex(fromIndex, toIndex, length);

        final M ret = mapSupplier.get();
        K key = null;
        List<T> val = null;

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;
            T e = null;

            for (int i = fromIndex; i < toIndex; i++) {
                e = list.get(i);

                key = keyExtractor.apply(e);
                val = ret.computeIfAbsent(key, k -> new ArrayList<>());

                val.add(e);
            }
        } else {
            int idx = 0;

            for (final T e : c) {
                if (idx < fromIndex) {
                    idx++;
                    continue;
                }

                key = keyExtractor.apply(e);
                val = ret.computeIfAbsent(key, k -> new ArrayList<>());

                val.add(e);

                if (++idx >= toIndex) {
                    break;
                }
            }
        }

        return ret;
    }

    /**
     * Returns a map grouping elements by keys extracted from each element.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * Map<Character, List<String>> result = N.groupBy(words, s -> s.charAt(0));
     * // Returns {'a': ["apple", "apricot"], 'b': ["banana"]}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @return a map with keys and lists of elements sharing each key (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function, Supplier)
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(c, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys extracted from each element (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * LinkedHashMap<Character, List<String>> result = N.groupBy(words, s -> s.charAt(0), LinkedHashMap::new);
     * // Returns a LinkedHashMap with insertion order
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of elements sharing each key (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function)
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        K key = null;
        List<T> val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = ret.computeIfAbsent(key, k -> new ArrayList<>());

            val.add(e);
        }

        return ret;
    }

    /**
     * Returns a map grouping elements by keys extracted from each element.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * Map<Character, List<String>> result = N.groupBy(iter, s -> s.charAt(0));
     * // Returns {'a': ["apple", "apricot"], 'b': ["banana"]}
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @return a map with keys and lists of elements sharing each key (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function, Supplier)
     */
    @Beta
    public static <T, K> Map<K, List<T>> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor) {
        return groupBy(iter, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys extracted from each element (map created by the provided supplier).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot").iterator();
     * LinkedHashMap<Character, List<String>> result = N.groupBy(iter, s -> s.charAt(0), LinkedHashMap::new);
     * // Returns a LinkedHashMap with insertion order
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of elements sharing each key (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function)
     */
    @Beta
    public static <T, K, M extends Map<K, List<T>>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        K key = null;
        List<T> val = null;
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);
            val = ret.computeIfAbsent(key, k -> new ArrayList<>());

            val.add(e);
        }

        return ret;
    }

    /**
     * Returns a map grouping elements by keys, with values transformed by a function.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * Map<Character, List<Integer>> result = N.groupBy(words, s -> s.charAt(0), String::length);
     * // Returns {'a': [5, 7], 'b': [6]}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <V> the type of transformed values
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @param valueExtractor the function to transform values
     * @return a map with keys and lists of transformed values (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function, Function, Supplier)
     */
    @Beta
    public static <T, K, V> Map<K, List<V>> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        return groupBy(c, keyExtractor, valueExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys, with values transformed by a function (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot");
     * TreeMap<Character, List<Integer>> result = N.groupBy(words, s -> s.charAt(0), String::length, TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <V> the type of transformed values
     * @param <M> the type of map to return
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @param valueExtractor the function to transform values
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of transformed values (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function, Function)
     */
    @Beta
    public static <T, K, V, M extends Map<K, List<V>>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        K key = null;
        List<V> val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = ret.computeIfAbsent(key, k -> new ArrayList<>());

            val.add(valueExtractor.apply(e));
        }

        return ret;
    }

    /**
     * Returns a map grouping elements by keys, with values transformed by a function.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * Map<Character, List<Integer>> result = N.groupBy(iter, s -> s.charAt(0), String::length);
     * // Returns {'a': [5, 7], 'b': [6]}
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param <V> the type of transformed values
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @param valueExtractor the function to transform values
     * @return a map with keys and lists of transformed values (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function, Function, Supplier)
     */
    @Beta
    public static <T, K, V> Map<K, List<V>> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor) {
        return groupBy(iter, keyExtractor, valueExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys, with values transformed by a function (map created by the provided supplier).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot").iterator();
     * TreeMap<Character, List<Integer>> result = N.groupBy(iter, s -> s.charAt(0), String::length, TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param <V> the type of transformed values
     * @param <M> the type of map to return
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @param valueExtractor the function to transform values
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and lists of transformed values (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function, Function)
     */
    @Beta
    public static <T, K, V, M extends Map<K, List<V>>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Function<? super T, ? extends V> valueExtractor, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        K key = null;
        List<V> val = null;
        T e = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);
            val = ret.computeIfAbsent(key, k -> new ArrayList<>());

            val.add(valueExtractor.apply(e));
        }

        return ret;
    }

    /**
     * Returns a map grouping elements by keys, with values aggregated using a collector.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry");
     * Map<Character, Long> result = N.groupBy(words, s -> s.charAt(0), Collectors.counting());
     * // Returns {'a': 2, 'b': 2}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <R> the type of aggregated values
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @param collector the collector to aggregate grouped values
     * @return a map with keys and aggregated values (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function, Collector, Supplier)
     * @see java.util.stream.Collectors
     */
    @Beta
    public static <T, K, R> Map<K, R> groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector) {
        return groupBy(c, keyExtractor, collector, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys, with values aggregated using a collector (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * TreeMap<Character, String> result = N.groupBy(words, s -> s.charAt(0), Collectors.joining(", "), TreeMap::new);
     * // Returns a TreeMap with sorted keys: {'a': "apple, apricot", 'b': "banana"}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <R> the type of aggregated values
     * @param <M> the type of map to return
     * @param c the iterable
     * @param keyExtractor the function to extract grouping keys
     * @param collector the collector to aggregate grouped values
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and aggregated values (empty if iterable is {@code null}/empty)
     * @see #groupBy(Iterable, Function, Collector)
     * @see java.util.stream.Collectors
     */
    @Beta
    public static <T, K, R, M extends Map<K, R>> M groupBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        final Supplier<Object> downstreamSupplier = (Supplier<Object>) collector.supplier();
        final BiConsumer<Object, ? super T> downstreamAccumulator = (BiConsumer<Object, ? super T>) collector.accumulator();
        final Function<Object, R> downstreamFinisher = (Function<Object, R>) collector.finisher();

        final Map<K, Object> intermediate = (Map<K, Object>) ret;

        if (c == null) {
            return ret;
        }

        K key = null;
        Object val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);

            if (((val = intermediate.get(key)) == null) && ((val = downstreamSupplier.get()) != null)) {
                intermediate.put(key, val);
            }

            downstreamAccumulator.accept(val, e);
        }

        updateIntermediateValue(intermediate, downstreamFinisher);

        return ret;
    }

    /**
     * Returns a map grouping elements by keys, with values aggregated using a collector.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * Map<Character, Long> result = N.groupBy(iter, s -> s.charAt(0), Collectors.counting());
     * // Returns {'a': 2, 'b': 1}
     * }</pre>
     *
     * @param <K> the type of keys
     * @param <T> the type of elements in the iterator
     * @param <R> the type of aggregated values
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @param collector the collector to aggregate grouped values
     * @return a map with keys and aggregated values (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function, Collector, Supplier)
     * @see java.util.stream.Collectors
     */
    @Beta
    public static <K, T, R> Map<K, R> groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector) {
        return groupBy(iter, keyExtractor, collector, Suppliers.ofMap());
    }

    /**
     * Returns a map grouping elements by keys, with values aggregated using a collector (map created by the provided supplier).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * TreeMap<Character, String> result = N.groupBy(iter, s -> s.charAt(0), Collectors.joining(", "), TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <K> the type of keys
     * @param <T> the type of elements in the iterator
     * @param <R> the type of aggregated values
     * @param <M> the type of map to return
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract grouping keys
     * @param collector the collector to aggregate grouped values
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and aggregated values (empty if iterator is {@code null} or has no elements)
     * @see #groupBy(Iterator, Function, Collector)
     * @see java.util.stream.Collectors
     */
    @Beta
    public static <K, T, R, M extends Map<K, R>> M groupBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Collector<? super T, ?, R> collector, final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        final Supplier<Object> downstreamSupplier = (Supplier<Object>) collector.supplier();
        final BiConsumer<Object, ? super T> downstreamAccumulator = (BiConsumer<Object, ? super T>) collector.accumulator();
        final Function<Object, R> downstreamFinisher = (Function<Object, R>) collector.finisher();

        final Map<K, Object> intermediate = (Map<K, Object>) ret;

        if (iter == null) {
            return ret;
        }

        T e = null;
        K key = null;
        Object val = null;

        while (iter.hasNext()) {
            e = iter.next();

            key = keyExtractor.apply(e);

            if (((val = intermediate.get(key)) == null) && ((val = downstreamSupplier.get()) != null)) {
                intermediate.put(key, val);
            }

            downstreamAccumulator.accept(val, e);
        }

        updateIntermediateValue(intermediate, downstreamFinisher);

        return ret;
    }

    /**
     * Returns a map counting occurrences of each key extracted from elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry");
     * Map<Character, Integer> result = N.countBy(words, s -> s.charAt(0));
     * // Returns {'a': 2, 'b': 2}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param c the iterable
     * @param keyExtractor the function to extract counting keys
     * @return a map with keys and their occurrence counts (empty if iterable is {@code null}/empty)
     * @see #countBy(Iterable, Function, Supplier)
     * @see #groupBy(Iterable, Function)
     */
    @Beta
    public static <T, K> Map<K, Integer> countBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor) {
        return countBy(c, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map counting occurrences of each key extracted from elements (map created by the provided supplier).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> words = Arrays.asList("apple", "apricot", "banana");
     * TreeMap<Character, Integer> result = N.countBy(words, s -> s.charAt(0), TreeMap::new);
     * // Returns a TreeMap with sorted keys: {'a': 2, 'b': 1}
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param c the iterable
     * @param keyExtractor the function to extract counting keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and their occurrence counts (empty if iterable is {@code null}/empty)
     * @see #countBy(Iterable, Function)
     * @see #groupBy(Iterable, Function, Supplier)
     */
    @Beta
    public static <T, K, M extends Map<K, Integer>> M countBy(final Iterable<? extends T> c, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (c == null) {
            return ret;
        }

        @SuppressWarnings("rawtypes")
        final Map<K, MutableInt> intermediateMap = (Map) ret;

        K key = null;
        MutableInt val = null;

        for (final T e : c) {
            key = keyExtractor.apply(e);
            val = intermediateMap.get(key);

            if (val == null) {
                intermediateMap.put(key, MutableInt.of(1));
            } else {
                val.increment();
            }
        }

        updateIntermediateValue(intermediateMap, MutableInt::value);

        return ret;
    }

    /**
     * Returns a map counting occurrences of each key extracted from elements.
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * Map<Character, Integer> result = N.countBy(iter, s -> s.charAt(0));
     * // Returns {'a': 2, 'b': 1}
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract counting keys
     * @return a map with keys and their occurrence counts (empty if iterator is {@code null} or has no elements)
     * @see #countBy(Iterator, Function, Supplier)
     * @see #groupBy(Iterator, Function)
     */
    @Beta
    public static <T, K> Map<K, Integer> countBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor) {
        return countBy(iter, keyExtractor, Suppliers.ofMap());
    }

    /**
     * Returns a map counting occurrences of each key extracted from elements (map created by the provided supplier).
     *
     * <p>Note: The iterator will be fully consumed by this operation.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("apple", "apricot", "banana").iterator();
     * TreeMap<Character, Integer> result = N.countBy(iter, s -> s.charAt(0), TreeMap::new);
     * // Returns a TreeMap with sorted keys
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <K> the type of keys
     * @param <M> the type of map to return
     * @param iter the iterator (will be consumed)
     * @param keyExtractor the function to extract counting keys
     * @param mapSupplier the supplier to create the result map
     * @return a map with keys and their occurrence counts (empty if iterator is {@code null} or has no elements)
     * @see #countBy(Iterator, Function)
     * @see #groupBy(Iterator, Function, Supplier)
     */
    @Beta
    public static <T, K, M extends Map<K, Integer>> M countBy(final Iterator<? extends T> iter, final Function<? super T, ? extends K> keyExtractor,
            final Supplier<M> mapSupplier) {
        final M ret = mapSupplier.get();

        if (iter == null) {
            return ret;
        }

        @SuppressWarnings("rawtypes")
        final Map<K, MutableInt> intermediateMap = (Map) ret;

        K key = null;
        MutableInt val = null;

        while (iter.hasNext()) {
            key = keyExtractor.apply(iter.next());
            val = intermediateMap.get(key);

            if (val == null) {
                intermediateMap.put(key, MutableInt.of(1));
            } else {
                val.increment();
            }
        }

        updateIntermediateValue(intermediateMap, MutableInt::value);

        return ret;
    }

    static <V> void updateIntermediateValue(final Map<?, V> intermediate, final Function<? super V, ?> downstreamFinisher) {
        for (final Map.Entry<?, V> entry : intermediate.entrySet()) {
            entry.setValue((V) downstreamFinisher.apply(entry.getValue()));
        }
    }

    /**
     * Returns an iterator over array elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * Iterator<String> result = N.iterate(names);
     * // Iterates over "Alice", "Bob", "Charlie"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @return an iterator over the array elements (empty if array is {@code null}/empty)
     * @see #iterate(Object[], int, int)
     * @see ObjIterator#of(Object[])
     */
    @Beta
    public static <T> ObjIterator<T> iterate(final T[] a) {
        return ObjIterator.of(a);
    }

    /**
     * Returns an iterator over elements in the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * Iterator<String> result = N.iterate(names, 1, 3);
     * // Iterates over "Bob", "Charlie"
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param a the array
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @return an iterator over the specified range (empty if array is {@code null} or range is empty)
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > a.length || fromIndex > toIndex}
     * @see #iterate(Object[])
     * @see ObjIterator#of(Object[], int, int)
     */
    @Beta
    public static <T> Iterator<T> iterate(final T[] a, final int fromIndex, final int toIndex) throws IndexOutOfBoundsException {
        return ObjIterator.of(a, fromIndex, toIndex);
    }

    /**
     * Returns an iterator over map entries.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
     * Iterator<Map.Entry<String, Integer>> result = N.iterate(ages);
     * // Iterates over map entries
     * }</pre>
     *
     * @param <K> the type of keys
     * @param <V> the type of values
     * @param map the map
     * @return an iterator over the map entries (empty if map is {@code null}/empty)
     * @see Map#entrySet()
     */
    @Beta
    public static <K, V> Iterator<Map.Entry<K, V>> iterate(final Map<K, V> map) {
        return map == null ? ObjIterator.empty() : map.entrySet().iterator();
    }

    /**
     * Returns an iterator over iterable elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * Iterator<String> result = N.iterate(names);
     * // Iterates over the list elements
     * }</pre>
     *
     * @param <T> the type of elements
     * @param c the iterable
     * @return an iterator over the iterable elements (empty if iterable is {@code null})
     * @see Iterable#iterator()
     * @see ObjIterator#of(Iterable)
     */
    @Beta
    public static <T> Iterator<T> iterate(final Iterable<? extends T> c) {
        return c == null ? ObjIterator.empty() : (Iterator<T>) c.iterator();
    }

    /**
     * Returns a list of iterators, one for each iterable in the collection.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<List<String>> groups = Arrays.asList(Arrays.asList("A", "B"), Arrays.asList("C", "D"));
     * List<Iterator<String>> result = N.iterateEach(groups);
     * // Returns list of 2 separate iterators
     * }</pre>
     *
     * @param <T> the type of elements
     * @param iterables the collection of iterables
     * @return a list containing one iterator for each iterable (empty if collection is {@code null}/empty)
     * @see #iterateAll(Collection)
     * @see #iterate(Iterable)
     */
    @Beta
    public static <T> List<Iterator<T>> iterateEach(final Collection<? extends Iterable<? extends T>> iterables) {
        final List<Iterator<T>> iterators = new ArrayList<>(size(iterables));

        if (iterables != null) {
            for (final Iterable<? extends T> iterable : iterables) {
                iterators.add(iterate(iterable));
            }
        }

        return iterators;
    }

    /**
     * Returns a single iterator that sequentially iterates over all elements from all iterables.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<List<String>> groups = Arrays.asList(Arrays.asList("A", "B"), Arrays.asList("C", "D"));
     * Iterator<String> result = N.iterateAll(groups);
     * // Iterates over "A", "B", "C", "D" in sequence
     * }</pre>
     *
     * @param <T> the type of elements
     * @param iterables the collection of iterables to concatenate
     * @return a single iterator over all elements (empty if collection is {@code null}/empty)
     * @see #iterateEach(Collection)
     * @see #concat(Iterable...)
     * @see Iterators#concatIterables(Collection)
     */
    @Beta
    public static <T> ObjIterator<T> iterateAll(final Collection<? extends Iterable<? extends T>> iterables) {
        return Iterators.concatIterables(iterables);
    }

    /**
     * Returns {@code true} if the two arrays have no elements in common.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] a = {"apple", "banana"};
     * String[] b = {"cherry", "date"};
     * boolean result = N.disjoint(a, b);
     * // Returns true (no common elements)
     * }</pre>
     *
     * @param a the first array
     * @param b the second array
     * @return {@code true} if the arrays have no common elements ({@code true} if either array is {@code null}/empty)
     * @see #disjoint(Collection, Collection)
     * @see Collections#disjoint(Collection, Collection)
     */
    public static boolean disjoint(final Object[] a, final Object[] b) {
        if (isEmpty(a) || isEmpty(b)) {
            return true;
        }

        return a.length >= b.length ? disjoint(Arrays.asList(a), asSet(b)) : disjoint(asSet(a), Arrays.asList(b));
    }

    /**
     * Returns {@code true} if the two collections have no elements in common.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> c1 = Arrays.asList("apple", "banana");
     * List<String> c2 = Arrays.asList("cherry", "date");
     * boolean result = N.disjoint(c1, c2);
     * // Returns true (no common elements)
     * }</pre>
     *
     * @param c1 the first collection
     * @param c2 the second collection
     * @return {@code true} if the collections have no common elements ({@code true} if either collection is {@code null}/empty)
     * @see #disjoint(Object[], Object[])
     * @see Collections#disjoint(Collection, Collection)
     */
    public static boolean disjoint(final Collection<?> c1, final Collection<?> c2) {
        if (isEmpty(c1) || isEmpty(c2)) {
            return true;
        }

        if (c1 instanceof Set || (!(c2 instanceof Set) && c1.size() > c2.size())) {
            for (final Object e : c2) {
                if (c1.contains(e)) {
                    return false;
                }
            }
        } else {
            for (final Object e : c1) {
                if (c2.contains(e)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Returns the JSON string representation of the object.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> data = Map.of("age", 25, "score", 90);
     * String result = N.toJson(data);
     * // Returns {"age":25,"score":90}
     * }</pre>
     *
     * @param obj the object to serialize
     * @return a JSON string representation ({@code "null"} if object is {@code null})
     * @see #toJson(Object, boolean)
     * @see #toJson(Object, JSONSerializationConfig)
     * @see #fromJson(String, Class)
     */
    public static String toJson(final Object obj) {
        return Utils.jsonParser.serialize(obj, Utils.jsc);
    }

    /**
     * Returns the JSON string representation of the object with optional pretty formatting.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> data = Map.of("age", 25, "score", 90);
     * String result = N.toJson(data, true);
     * // Returns formatted: {"age": 25, "score": 90}
     * }</pre>
     *
     * @param obj the object to serialize
     * @param prettyFormat {@code true} for formatted output with indentation
     * @return a JSON string representation ({@code "null"} if object is {@code null})
     * @see #toJson(Object)
     * @see #toJson(Object, JSONSerializationConfig)
     */
    public static String toJson(final Object obj, final boolean prettyFormat) {
        return Utils.jsonParser.serialize(obj, prettyFormat ? Utils.jscPrettyFormat : Utils.jsc);
    }

    /**
     * Returns the JSON string representation of the object using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setDateFormat("yyyy-MM-dd");
     * String result = N.toJson(person, config);
     * // Returns JSON with custom date formatting
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the serialization configuration
     * @return a JSON string representation ({@code "null"} if object is {@code null})
     * @see #toJson(Object)
     * @see #toJson(Object, boolean)
     */
    public static String toJson(final Object obj, final JSONSerializationConfig config) {
        return Utils.jsonParser.serialize(obj, config);
    }

    /**
     * Writes the JSON representation of the object to the specified file.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> data = Map.of("age", 25, "score", 90);
     * File outputFile = new File("data.json");
     * N.toJson(data, outputFile);
     * // Writes {"age":25,"score":90} to data.json
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the file to write to (created if nonexistent, overwritten if exists)
     * @see #toJson(Object, JSONSerializationConfig, File)
     * @see #fromJson(File, Class)
     */
    public static void toJson(final Object obj, final File output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     * Writes the JSON representation of the object to the specified file using the given configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setPrettyFormat(true);
     * File outputFile = new File("data.json");
     * N.toJson(person, config, outputFile);
     * // Writes formatted JSON to data.json
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the serialization configuration
     * @param output the file to write to (created if nonexistent, overwritten if exists)
     * @see #toJson(Object, File)
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final File output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     * Writes the JSON representation of the object to the specified output stream.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> data = Map.of("age", 25, "score", 90);
     * try (OutputStream out = new FileOutputStream("data.json")) {
     *     N.toJson(data, out);
     * }
     * // Writes {"age":25,"score":90} to the stream
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the output stream to write to
     * @see #toJson(Object, JSONSerializationConfig, OutputStream)
     */
    public static void toJson(final Object obj, final OutputStream output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     * Writes the JSON representation of the object to the specified output stream using the given configuration.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setPrettyFormat(true);
     * try (OutputStream out = new FileOutputStream("data.json")) {
     *     N.toJson(person, config, out);
     * }
     * // Writes formatted JSON to the stream
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the serialization configuration
     * @param output the output stream to write to
     * @see #toJson(Object, OutputStream)
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final OutputStream output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     * Writes the JSON representation of the object to the specified writer.
     *
     * <p>Note: The writer is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> data = Map.of("age", 25, "score", 90);
     * try (Writer writer = new FileWriter("data.json")) {
     *     N.toJson(data, writer);
     * }
     * // Writes {"age":25,"score":90} to the writer
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the writer to write to
     * @see #toJson(Object, JSONSerializationConfig, Writer)
     */
    public static void toJson(final Object obj, final Writer output) {
        Utils.jsonParser.serialize(obj, output);
    }

    /**
     * Writes the JSON representation of the object to the specified writer using the given configuration.
     *
     * <p>Note: The writer is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setPrettyFormat(true);
     * try (Writer writer = new FileWriter("data.json")) {
     *     N.toJson(person, config, writer);
     * }
     * // Writes formatted JSON to the writer
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the serialization configuration
     * @param output the writer to write to
     * @see #toJson(Object, Writer)
     */
    public static void toJson(final Object obj, final JSONSerializationConfig config, final Writer output) {
        Utils.jsonParser.serialize(obj, config, output);
    }

    /**
     * Returns an object deserialized from the JSON string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "{\"age\":25,\"score\":90}";
     * Map<String, Integer> result = N.fromJson(json, Map.class);
     * // Returns a Map with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if JSON string is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, Type)
     * @see #toJson(Object)
     */
    public static <T> T fromJson(final String json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     * Returns an object deserialized from the JSON string using the specified Type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]";
     * List<Person> result = N.fromJson(json, new TypeReference<List<Person>>(){}.type());
     * // Returns a List of Person objects
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if JSON string is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, Class)
     * @see TypeReference
     */
    public static <T> T fromJson(final String json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     * Returns an object deserialized from the JSON string, or a default value if the result is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "null";
     * Map<String, Integer> result = N.fromJson(json, new HashMap<>(), Map.class);
     * // Returns the empty HashMap (default value)
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param defaultIfNull the value to return if deserialization produces {@code null}
     * @param targetType the target class type
     * @return the deserialized object or the default value
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, Object, Type)
     * @see #fromJson(String, Class)
     */
    public static <T> T fromJson(final String json, final T defaultIfNull, final Class<? extends T> targetType) {
        final T ret = fromJson(json, targetType);

        return ret == null ? defaultIfNull : ret;
    }

    /**
     * Returns an object deserialized from the JSON string using the specified Type, or a default value if the result is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "null";
     * List<String> result = N.fromJson(json, Collections.emptyList(), new TypeReference<List<String>>(){}.type());
     * // Returns the empty list (default value)
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param defaultIfNull the value to return if deserialization produces {@code null}
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object or the default value
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, Object, Class)
     * @see #fromJson(String, Type)
     */
    public static <T> T fromJson(final String json, final T defaultIfNull, final Type<? extends T> targetType) {
        final T ret = fromJson(json, targetType);

        return ret == null ? defaultIfNull : ret;
    }

    /**
     * Returns an object deserialized from the JSON string using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * Person result = N.fromJson(jsonString, config, Person.class);
     * // Returns Person with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param config the deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if JSON string is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, JSONDeserializationConfig, Type)
     * @see #fromJson(String, Class)
     */
    public static <T> T fromJson(final String json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     * Returns an object deserialized from the JSON string using the specified Type and configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * List<Person> result = N.fromJson(jsonString, config, new TypeReference<List<Person>>(){}.type());
     * // Returns List with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string to deserialize
     * @param config the deserialization configuration
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if JSON string is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(String, JSONDeserializationConfig, Class)
     * @see #fromJson(String, Type)
     */
    public static <T> T fromJson(final String json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     * Returns an object deserialized from JSON content in the file.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * File file = new File("data.json");
     * Map<String, Integer> result = N.fromJson(file, Map.class);
     * // Returns a Map with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the file to read JSON from
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if file contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(File, Type)
     * @see #toJson(Object, File)
     */
    public static <T> T fromJson(final File json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the file using the specified Type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * File file = new File("people.json");
     * List<Person> result = N.fromJson(file, new TypeReference<List<Person>>(){}.type());
     * // Returns a List of Person objects
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the file to read JSON from
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if file contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(File, Class)
     * @see TypeReference
     */
    public static <T> T fromJson(final File json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the file using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * File file = new File("person.json");
     * Person result = N.fromJson(file, config, Person.class);
     * // Returns Person with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the file to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if file contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(File, JSONDeserializationConfig, Type)
     * @see #fromJson(File, Class)
     */
    public static <T> T fromJson(final File json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the file using the specified Type and configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * File file = new File("people.json");
     * List<Person> result = N.fromJson(file, config, new TypeReference<List<Person>>(){}.type());
     * // Returns List with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the file to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if file contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(File, JSONDeserializationConfig, Class)
     * @see #fromJson(File, Type)
     */
    public static <T> T fromJson(final File json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     * Returns an object deserialized from JSON content in the input stream.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (InputStream in = new FileInputStream("data.json")) {
     *     Map<String, Integer> result = N.fromJson(in, Map.class);
     * }
     * // Returns a Map with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the input stream to read JSON from
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if stream contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(InputStream, Type)
     * @see #toJson(Object, OutputStream)
     */
    public static <T> T fromJson(final InputStream json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the input stream using the specified Type.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (InputStream in = new FileInputStream("people.json")) {
     *     List<Person> result = N.fromJson(in, new TypeReference<List<Person>>(){}.type());
     * }
     * // Returns a List of Person objects
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the input stream to read JSON from
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if stream contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(InputStream, Class)
     * @see TypeReference
     */
    public static <T> T fromJson(final InputStream json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the input stream using the specified configuration.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * try (InputStream in = new FileInputStream("person.json")) {
     *     Person result = N.fromJson(in, config, Person.class);
     * }
     * // Returns Person with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the input stream to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if stream contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(InputStream, JSONDeserializationConfig, Type)
     * @see #fromJson(InputStream, Class)
     */
    public static <T> T fromJson(final InputStream json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the input stream using the specified Type and configuration.
     *
     * <p>Note: The stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * try (InputStream in = new FileInputStream("people.json")) {
     *     List<Person> result = N.fromJson(in, config, new TypeReference<List<Person>>(){}.type());
     * }
     * // Returns List with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the input stream to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if stream contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(InputStream, JSONDeserializationConfig, Class)
     * @see #fromJson(InputStream, Type)
     */
    public static <T> T fromJson(final InputStream json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     * Returns an object deserialized from JSON content in the reader.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (Reader reader = new FileReader("data.json")) {
     *     Map<String, Integer> result = N.fromJson(reader, Map.class);
     * }
     * // Returns a Map with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the reader to read JSON from
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if reader contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(Reader, Type)
     * @see #toJson(Object, Writer)
     */
    public static <T> T fromJson(final Reader json, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the reader using the specified Type.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (Reader reader = new FileReader("people.json")) {
     *     List<Person> result = N.fromJson(reader, new TypeReference<List<Person>>(){}.type());
     * }
     * // Returns a List of Person objects
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the reader to read JSON from
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if reader contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(Reader, Class)
     * @see TypeReference
     */
    public static <T> T fromJson(final Reader json, final Type<? extends T> targetType) {
        return fromJson(json, null, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the reader using the specified configuration.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * try (Reader reader = new FileReader("person.json")) {
     *     Person result = N.fromJson(reader, config, Person.class);
     * }
     * // Returns Person with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the reader to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if reader contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(Reader, JSONDeserializationConfig, Type)
     * @see #fromJson(Reader, Class)
     */
    public static <T> T fromJson(final Reader json, final JSONDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, config, targetType);
    }

    /**
     * Returns an object deserialized from JSON content in the reader using the specified Type and configuration.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * try (Reader reader = new FileReader("people.json")) {
     *     List<Person> result = N.fromJson(reader, config, new TypeReference<List<Person>>(){}.type());
     * }
     * // Returns List with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the reader to read JSON from
     * @param config the deserialization configuration
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if reader contains {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromJson(Reader, JSONDeserializationConfig, Class)
     * @see #fromJson(Reader, Type)
     */
    public static <T> T fromJson(final Reader json, final JSONDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     * Returns an object deserialized from a substring of the JSON string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "prefix{\"age\":25,\"score\":90}suffix";
     * Map<String, Integer> result = N.fromJson(json, 6, 29, Map.class);
     * // Returns a Map with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string containing the data
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if substring is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > json.length() || fromIndex > toIndex}
     * @see #fromJson(String, int, int, Type)
     * @see #fromJson(String, Class)
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final Class<? extends T> targetType)
            throws IndexOutOfBoundsException {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, targetType);
    }

    /**
     * Returns an object deserialized from a substring of the JSON string using the specified Type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "prefix[{\"name\":\"Alice\"}]suffix";
     * List<Person> result = N.fromJson(json, 6, 22, new TypeReference<List<Person>>(){}.type());
     * // Returns a List of Person objects
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string containing the data
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if substring is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > json.length() || fromIndex > toIndex}
     * @see #fromJson(String, int, int, Class)
     * @see #fromJson(String, Type)
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final Type<? extends T> targetType)
            throws IndexOutOfBoundsException {
        return fromJson(json, fromIndex, toIndex, null, targetType);
    }

    /**
     * Returns an object deserialized from a substring of the JSON string using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * String json = "prefix{\"name\":\"Alice\",\"birth\":\"2000-01-01\"}suffix";
     * Person result = N.fromJson(json, 6, 45, config, Person.class);
     * // Returns Person with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string containing the data
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param config the deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if substring is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > json.length() || fromIndex > toIndex}
     * @see #fromJson(String, int, int, JSONDeserializationConfig, Type)
     * @see #fromJson(String, int, int, Class)
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final JSONDeserializationConfig config,
            final Class<? extends T> targetType) {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, config, targetType);
    }

    /**
     * Returns an object deserialized from a substring of the JSON string using the specified Type and configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * String json = "prefix[{\"name\":\"Alice\",\"birth\":\"2000-01-01\"}]suffix";
     * List<Person> result = N.fromJson(json, 6, 49, config, new TypeReference<List<Person>>(){}.type());
     * // Returns List with custom date parsing
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param json the JSON string containing the data
     * @param fromIndex the starting index (inclusive)
     * @param toIndex the ending index (exclusive)
     * @param config the deserialization configuration
     * @param targetType the target Type (supports generics like {@code List<String>})
     * @return the deserialized object ({@code null} if substring is {@code "null"})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @throws IndexOutOfBoundsException if {@code fromIndex < 0 || toIndex > json.length() || fromIndex > toIndex}
     * @see #fromJson(String, int, int, JSONDeserializationConfig, Class)
     * @see #fromJson(String, int, int, Type)
     */
    public static <T> T fromJson(final String json, final int fromIndex, final int toIndex, final JSONDeserializationConfig config,
            final Type<? extends T> targetType) throws IndexOutOfBoundsException {
        return Utils.jsonParser.deserialize(json, fromIndex, toIndex, setConfig(targetType, config, true), targetType.clazz());
    }

    /**
     * Returns a stream of elements deserialized from the JSON array string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]";
     * Stream<Person> result = N.streamJson(json, new TypeReference<Person>(){}.type());
     * // Streams Person objects from the JSON array
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array string
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if string is {@code null} or represents empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(String, JSONDeserializationConfig, Type)
     * @see #fromJson(String, Type)
     */
    public static <T> Stream<T> streamJson(final String jsonArray, final Type<? extends T> elementType) {
        return streamJson(jsonArray, null, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array string using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * String json = "[{\"name\":\"Alice\",\"birth\":\"2000-01-01\"}]";
     * Stream<Person> result = N.streamJson(json, config, new TypeReference<Person>(){}.type());
     * // Streams Person objects with custom date parsing
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array string
     * @param config the deserialization configuration
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if string is {@code null} or represents empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(String, Type)
     */
    public static <T> Stream<T> streamJson(final String jsonArray, final JSONDeserializationConfig config, final Type<? extends T> elementType) {
        return Utils.jsonParser.stream(jsonArray, setElementType(config, elementType), elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the file.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * File file = new File("people.json");
     * Stream<Person> result = N.streamJson(file, new TypeReference<Person>(){}.type());
     * // Streams Person objects from the file
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array file
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if file is {@code null}/nonexistent or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(File, JSONDeserializationConfig, Type)
     * @see #fromJson(File, Type)
     */
    public static <T> Stream<T> streamJson(final File jsonArray, final Type<? extends T> elementType) {
        return streamJson(jsonArray, null, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the file using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * File file = new File("people.json");
     * Stream<Person> result = N.streamJson(file, config, new TypeReference<Person>(){}.type());
     * // Streams Person objects with custom date parsing
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array file
     * @param config the deserialization configuration
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if file is {@code null}/nonexistent or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(File, Type)
     */
    public static <T> Stream<T> streamJson(final File jsonArray, final JSONDeserializationConfig config, final Type<? extends T> elementType) {
        return Utils.jsonParser.stream(jsonArray, setElementType(config, elementType), elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the input stream.
     *
     * <p>Note: The input stream is not closed when the returned stream is closed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (InputStream in = new FileInputStream("people.json")) {
     *     Stream<Person> result = N.streamJson(in, new TypeReference<Person>(){}.type());
     *     // Streams Person objects from the input stream
     * }
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array input stream
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if stream is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(InputStream, boolean, Type)
     * @see #fromJson(InputStream, Type)
     */
    public static <T> Stream<T> streamJson(final InputStream jsonArray, final Type<? extends T> elementType) {
        return streamJson(jsonArray, false, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the input stream.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * InputStream in = new FileInputStream("people.json");
     * Stream<Person> result = N.streamJson(in, true, new TypeReference<Person>(){}.type());
     * // Input stream will be closed when stream is closed
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array input stream
     * @param closeInputStreamWhenStreamIsClosed {@code true} to close input stream with the stream
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if stream is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(InputStream, JSONDeserializationConfig, boolean, Type)
     */
    public static <T> Stream<T> streamJson(final InputStream jsonArray, final boolean closeInputStreamWhenStreamIsClosed, final Type<? extends T> elementType) {
        return streamJson(jsonArray, null, closeInputStreamWhenStreamIsClosed, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the input stream using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * InputStream in = new FileInputStream("people.json");
     * Stream<Person> result = N.streamJson(in, config, true, new TypeReference<Person>(){}.type());
     * // Streams Person objects with custom date parsing
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array input stream
     * @param config the deserialization configuration
     * @param closeInputStreamWhenStreamIsClosed {@code true} to close input stream with the stream
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if stream is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(InputStream, boolean, Type)
     */
    public static <T> Stream<T> streamJson(final InputStream jsonArray, final JSONDeserializationConfig config,
            final boolean closeInputStreamWhenStreamIsClosed, final Type<? extends T> elementType) {
        return Utils.jsonParser.stream(jsonArray, setElementType(config, elementType), closeInputStreamWhenStreamIsClosed, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the reader.
     *
     * <p>Note: The reader is not closed when the returned stream is closed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (Reader reader = new FileReader("people.json")) {
     *     Stream<Person> result = N.streamJson(reader, new TypeReference<Person>(){}.type());
     *     // Streams Person objects from the reader
     * }
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array reader
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if reader is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(Reader, boolean, Type)
     * @see #fromJson(Reader, Type)
     */
    public static <T> Stream<T> streamJson(final Reader jsonArray, final Type<? extends T> elementType) {
        return streamJson(jsonArray, false, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the reader.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Reader reader = new FileReader("people.json");
     * Stream<Person> result = N.streamJson(reader, true, new TypeReference<Person>(){}.type());
     * // Reader will be closed when stream is closed
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array reader
     * @param closeReaderWhenStreamIsClosed {@code true} to close reader with the stream
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if reader is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(Reader, JSONDeserializationConfig, boolean, Type)
     */
    public static <T> Stream<T> streamJson(final Reader jsonArray, final boolean closeReaderWhenStreamIsClosed, final Type<? extends T> elementType) {
        return streamJson(jsonArray, null, closeReaderWhenStreamIsClosed, elementType);
    }

    /**
     * Returns a stream of elements deserialized from the JSON array in the reader using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONDeserializationConfig config = new JSONDeserializationConfig().setDateFormat("yyyy-MM-dd");
     * Reader reader = new FileReader("people.json");
     * Stream<Person> result = N.streamJson(reader, config, true, new TypeReference<Person>(){}.type());
     * // Streams Person objects with custom date parsing
     * }</pre>
     *
     * @param <T> the type of stream elements
     * @param jsonArray the JSON array reader
     * @param config the deserialization configuration
     * @param closeReaderWhenStreamIsClosed {@code true} to close reader with the stream
     * @param elementType the target element Type
     * @return a stream of deserialized elements (empty if reader is {@code null} or contains empty array)
     * @throws IllegalArgumentException if elementType is {@code null}
     * @see #streamJson(Reader, boolean, Type)
     */
    public static <T> Stream<T> streamJson(final Reader jsonArray, final JSONDeserializationConfig config, final boolean closeReaderWhenStreamIsClosed,
            final Type<? extends T> elementType) {
        return Utils.jsonParser.stream(jsonArray, setElementType(config, elementType), closeReaderWhenStreamIsClosed, elementType);
    }

    private static JSONDeserializationConfig setElementType(final JSONDeserializationConfig config, final Type<?> elementType) {
        final JSONDeserializationConfig configToReturn = config == null ? JDC.create() : config.copy();

        configToReturn.setElementType(elementType);

        return configToReturn;
    }

    private static <C extends DeserializationConfig<C>> C setConfig(final Type<?> targetType, final C config, final boolean isJSON) {
        C configToReturn = config;

        if (targetType.isCollection() || targetType.isArray()) {
            if (config == null || config.getElementType() == null) {
                configToReturn = config == null ? (C) (isJSON ? JDC.create() : XDC.create()) : config.copy();

                configToReturn.setElementType(targetType.getElementType());
            }
        } else if (targetType.isMap() && (config == null || config.getMapKeyType() == null || config.getMapValueType() == null)) {
            configToReturn = config == null ? (C) (isJSON ? JDC.create() : XDC.create()) : config.copy();

            if (configToReturn.getMapKeyType() == null) {
                configToReturn.setMapKeyType(targetType.getParameterTypes()[0]);
            }

            if (configToReturn.getMapValueType() == null) {
                configToReturn.setMapValueType(targetType.getParameterTypes()[1]);
            }
        }

        return configToReturn;
    }

    /**
     * Returns the JSON string formatted with indentation and line breaks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "{\"name\":\"Alice\",\"age\":25}";
     * String result = N.formatJson(json);
     * // Returns formatted: {"name": "Alice", "age": 25}
     * }</pre>
     *
     * @param json the JSON string to format
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, JSONSerializationConfig)
     * @see #toJson(Object, boolean)
     */
    public static String formatJson(final String json) {
        return formatJson(json, Utils.jscPrettyFormat, Object.class);
    }

    /**
     * Returns the JSON string formatted with indentation and line breaks, using type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "{\"name\":\"Alice\",\"age\":25}";
     * String result = N.formatJson(json, Map.class);
     * // Returns formatted JSON with proper indentation
     * }</pre>
     *
     * @param json the JSON string to format
     * @param transferType the type for deserialization
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, Type)
     * @see #formatJson(String)
     */
    public static String formatJson(final String json, final Class<?> transferType) {
        return toJson(fromJson(json, transferType), Utils.jscPrettyFormat);
    }

    /**
     * Returns the JSON string formatted with indentation and line breaks, using Type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]";
     * String result = N.formatJson(json, new TypeReference<List<Map<String, String>>>(){}.type());
     * // Returns formatted JSON with proper indentation
     * }</pre>
     *
     * @param json the JSON string to format
     * @param transferType the Type for deserialization (supports generics like {@code List<String>})
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, Class)
     * @see TypeReference
     */
    public static String formatJson(final String json, final Type<?> transferType) {
        return toJson(fromJson(json, transferType), Utils.jscPrettyFormat);
    }

    /**
     * Returns the JSON string formatted using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setIndentation("  ");
     * String json = "{\"name\":\"Alice\"}";
     * String result = N.formatJson(json, config);
     * // Returns formatted JSON with custom indentation
     * }</pre>
     *
     * @param json the JSON string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, JSONSerializationConfig, Class)
     * @see #formatJson(String)
     */
    public static String formatJson(final String json, final JSONSerializationConfig config) {
        return formatJson(json, config, Object.class);
    }

    /**
     * Returns the JSON string formatted using the specified configuration, with Type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setIndentation("  ");
     * String json = "[{\"name\":\"Alice\"}]";
     * String result = N.formatJson(json, config, new TypeReference<List<Map<String, String>>>(){}.type());
     * // Returns formatted JSON with custom indentation
     * }</pre>
     *
     * @param json the JSON string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @param transferType the Type for deserialization (supports generics like {@code List<String>})
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, JSONSerializationConfig, Class)
     * @see TypeReference
     */
    public static String formatJson(final String json, final JSONSerializationConfig config, final Type<?> transferType) {
        final JSONSerializationConfig configToUse = config == null ? Utils.jscPrettyFormat
                : (!config.prettyFormat() ? config.copy().prettyFormat(true) : config);

        return toJson(fromJson(json, transferType), configToUse);
    }

    /**
     * Returns the JSON string formatted using the specified configuration, with type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * JSONSerializationConfig config = new JSONSerializationConfig().setIndentation("  ");
     * String json = "{\"name\":\"Alice\"}";
     * String result = N.formatJson(json, config, Map.class);
     * // Returns formatted JSON with custom indentation
     * }</pre>
     *
     * @param json the JSON string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @param transferType the type for deserialization
     * @return the formatted JSON string ({@code null} if input is {@code null})
     * @see #formatJson(String, JSONSerializationConfig, Type)
     * @see #formatJson(String, Class)
     */
    public static String formatJson(final String json, final JSONSerializationConfig config, final Class<?> transferType) {
        final JSONSerializationConfig configToUse = config == null ? Utils.jscPrettyFormat
                : (!config.prettyFormat() ? config.copy().prettyFormat(true) : config);

        return toJson(fromJson(json, transferType), configToUse);
    }

    /**
     * Returns the XML string representation of the object.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person person = new Person("Alice", 25);
     * String result = N.toXml(person);
     * // Returns <Person><name>Alice</name><age>25</age></Person>
     * }</pre>
     *
     * @param obj the object to serialize
     * @return the XML string representation ({@code "null"} if object is {@code null})
     * @see #toXml(Object, boolean)
     * @see #toXml(Object, XMLSerializationConfig)
     * @see #fromXml(String, Class)
     */
    public static String toXml(final Object obj) {
        return Utils.xmlParser.serialize(obj);
    }

    /**
     * Returns the XML string representation of the object with optional pretty formatting.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person person = new Person("Alice", 25);
     * String result = N.toXml(person, true);
     * // Returns formatted XML with indentation
     * }</pre>
     *
     * @param obj the object to serialize
     * @param prettyFormat {@code true} to format with indentation and line breaks
     * @return the XML string representation ({@code "null"} if object is {@code null})
     * @see #toXml(Object)
     * @see #toXml(Object, XMLSerializationConfig)
     */
    public static String toXml(final Object obj, final boolean prettyFormat) {
        return Utils.xmlParser.serialize(obj, prettyFormat ? Utils.xscPrettyFormat : Utils.xsc);
    }

    /**
     * Returns the XML string representation of the object using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setPrettyFormat(true);
     * Person person = new Person("Alice", 25);
     * String result = N.toXml(person, config);
     * // Returns XML formatted according to config
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the XML serialization configuration
     * @return the XML string representation ({@code "null"} if object is {@code null})
     * @see #toXml(Object, boolean)
     * @see #fromXml(String, XMLDeserializationConfig, Class)
     */
    public static String toXml(final Object obj, final XMLSerializationConfig config) {
        return Utils.xmlParser.serialize(obj, config);
    }

    /**
     * Writes the XML representation of the object to the specified file.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person person = new Person("Alice", 25);
     * File outputFile = new File("person.xml");
     * N.toXml(person, outputFile);
     * // Writes <Person><name>Alice</name><age>25</age></Person> to file
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the file to write to (created if nonexistent, overwritten if exists)
     * @see #toXml(Object, XMLSerializationConfig, File)
     * @see #fromXml(File, Class)
     */
    public static void toXml(final Object obj, final File output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     * Writes the XML representation of the object to the specified file using the configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setPrettyFormat(true);
     * Person person = new Person("Alice", 25);
     * File outputFile = new File("person.xml");
     * N.toXml(person, config, outputFile);
     * // Writes formatted XML to file
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the XML serialization configuration
     * @param output the file to write to (created if nonexistent, overwritten if exists)
     * @see #toXml(Object, File)
     * @see #fromXml(File, XMLDeserializationConfig, Class)
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final File output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     * Writes the XML representation of the object to the specified output stream.
     *
     * <p>Note: The output stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person person = new Person("Alice", 25);
     * try (OutputStream out = new FileOutputStream("person.xml")) {
     *     N.toXml(person, out);
     *     // Writes <Person><name>Alice</name><age>25</age></Person> to stream
     * }
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the output stream to write to
     * @see #toXml(Object, XMLSerializationConfig, OutputStream)
     * @see #fromXml(InputStream, Class)
     */
    public static void toXml(final Object obj, final OutputStream output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     * Writes the XML representation of the object to the specified output stream using the configuration.
     *
     * <p>Note: The output stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setPrettyFormat(true);
     * Person person = new Person("Alice", 25);
     * try (OutputStream out = new FileOutputStream("person.xml")) {
     *     N.toXml(person, config, out);
     *     // Writes formatted XML to stream
     * }
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the XML serialization configuration
     * @param output the output stream to write to
     * @see #toXml(Object, OutputStream)
     * @see #fromXml(InputStream, XMLDeserializationConfig, Class)
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final OutputStream output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     * Writes the XML representation of the object to the specified writer.
     *
     * <p>Note: The writer is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Person person = new Person("Alice", 25);
     * try (Writer writer = new FileWriter("person.xml")) {
     *     N.toXml(person, writer);
     *     // Writes <Person><name>Alice</name><age>25</age></Person> to writer
     * }
     * }</pre>
     *
     * @param obj the object to serialize
     * @param output the writer to write to
     * @see #toXml(Object, XMLSerializationConfig, Writer)
     * @see #fromXml(Reader, Class)
     */
    public static void toXml(final Object obj, final Writer output) {
        Utils.xmlParser.serialize(obj, output);
    }

    /**
     * Writes the XML representation of the object to the specified writer using the configuration.
     *
     * <p>Note: The writer is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setPrettyFormat(true);
     * Person person = new Person("Alice", 25);
     * try (Writer writer = new FileWriter("person.xml")) {
     *     N.toXml(person, config, writer);
     *     // Writes formatted XML to writer
     * }
     * }</pre>
     *
     * @param obj the object to serialize
     * @param config the XML serialization configuration
     * @param output the writer to write to
     * @see #toXml(Object, Writer)
     * @see #fromXml(Reader, XMLDeserializationConfig, Class)
     */
    public static void toXml(final Object obj, final XMLSerializationConfig config, final Writer output) {
        Utils.xmlParser.serialize(obj, config, output);
    }

    /**
     * Returns an object deserialized from the XML string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<Person><name>Alice</name><age>25</age></Person>";
     * Person result = N.fromXml(xml, Person.class);
     * // Returns a Person object with name="Alice", age=25
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the XML string to deserialize
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(String, Type)
     * @see #toXml(Object)
     */
    public static <T> T fromXml(final String xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     * Returns an object deserialized from the XML string with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<list><item>Alice</item><item>Bob</item></list>";
     * List<String> result = N.fromXml(xml, new TypeReference<List<String>>(){}.type());
     * // Returns a List<String> with the deserialized data
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the XML string to deserialize
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(String, Class)
     * @see TypeReference
     */
    public static <T> T fromXml(final String xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     * Returns an object deserialized from the XML string using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * String xml = "<Person><name>Alice</name><age>25</age></Person>";
     * Person result = N.fromXml(xml, config, Person.class);
     * // Returns a Person object with deserialization according to config
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the XML string to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(String, Class)
     * @see #toXml(Object, XMLSerializationConfig)
     */
    public static <T> T fromXml(final String xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     * Returns an object deserialized from the XML string using the configuration with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * String xml = "<list><item>Alice</item><item>Bob</item></list>";
     * List<String> result = N.fromXml(xml, config, new TypeReference<List<String>>(){}.type());
     * // Returns a List<String> with deserialization according to config
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the XML string to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(String, Type)
     * @see TypeReference
     */
    public static <T> T fromXml(final String xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     * Returns an object deserialized from the XML file.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * File xmlFile = new File("person.xml");
     * Person result = N.fromXml(xmlFile, Person.class);
     * // Returns a Person object deserialized from the file
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the file containing XML to deserialize
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(File, Type)
     * @see #toXml(Object, File)
     */
    public static <T> T fromXml(final File xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     * Returns an object deserialized from the XML file with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * File xmlFile = new File("names.xml");
     * List<String> result = N.fromXml(xmlFile, new TypeReference<List<String>>(){}.type());
     * // Returns a List<String> deserialized from the file
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the file containing XML to deserialize
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(File, Class)
     * @see TypeReference
     */
    public static <T> T fromXml(final File xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     * Returns an object deserialized from the XML file using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * File xmlFile = new File("person.xml");
     * Person result = N.fromXml(xmlFile, config, Person.class);
     * // Returns a Person object with deserialization according to config
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the file containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(File, Class)
     * @see #toXml(Object, XMLSerializationConfig, File)
     */
    public static <T> T fromXml(final File xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     * Returns an object deserialized from the XML file using the configuration with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * File xmlFile = new File("names.xml");
     * List<String> result = N.fromXml(xmlFile, config, new TypeReference<List<String>>(){}.type());
     * // Returns a List<String> with deserialization according to config
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the file containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(File, Type)
     * @see TypeReference
     */
    public static <T> T fromXml(final File xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     * Returns an object deserialized from the XML input stream.
     *
     * <p>Note: The input stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (InputStream in = new FileInputStream("person.xml")) {
     *     Person result = N.fromXml(in, Person.class);
     *     // Returns a Person object deserialized from the stream
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the input stream containing XML to deserialize
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(InputStream, Type)
     * @see #toXml(Object, OutputStream)
     */
    public static <T> T fromXml(final InputStream xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     * Returns an object deserialized from the XML input stream with generic type support.
     *
     * <p>Note: The input stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (InputStream in = new FileInputStream("names.xml")) {
     *     List<String> result = N.fromXml(in, new TypeReference<List<String>>(){}.type());
     *     // Returns a List<String> deserialized from the stream
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the input stream containing XML to deserialize
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(InputStream, Class)
     * @see TypeReference
     */
    public static <T> T fromXml(final InputStream xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     * Returns an object deserialized from the XML input stream using the specified configuration.
     *
     * <p>Note: The input stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * try (InputStream in = new FileInputStream("person.xml")) {
     *     Person result = N.fromXml(in, config, Person.class);
     *     // Returns a Person object with deserialization according to config
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the input stream containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(InputStream, Class)
     * @see #toXml(Object, XMLSerializationConfig, OutputStream)
     */
    public static <T> T fromXml(final InputStream xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     * Returns an object deserialized from the XML input stream using the configuration with generic type support.
     *
     * <p>Note: The input stream is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * try (InputStream in = new FileInputStream("names.xml")) {
     *     List<String> result = N.fromXml(in, config, new TypeReference<List<String>>(){}.type());
     *     // Returns a List<String> with deserialization according to config
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the input stream containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(InputStream, Type)
     * @see TypeReference
     */
    public static <T> T fromXml(final InputStream xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     * Returns an object deserialized from the XML reader.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (Reader reader = new FileReader("person.xml")) {
     *     Person result = N.fromXml(reader, Person.class);
     *     // Returns a Person object deserialized from the reader
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the reader containing XML to deserialize
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(Reader, Type)
     * @see #toXml(Object, Writer)
     */
    public static <T> T fromXml(final Reader xml, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, targetType);
    }

    /**
     * Returns an object deserialized from the XML reader with generic type support.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * try (Reader reader = new FileReader("names.xml")) {
     *     List<String> result = N.fromXml(reader, new TypeReference<List<String>>(){}.type());
     *     // Returns a List<String> deserialized from the reader
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the reader containing XML to deserialize
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(Reader, Class)
     * @see TypeReference
     */
    public static <T> T fromXml(final Reader xml, final Type<? extends T> targetType) {
        return fromJson(xml, null, targetType);
    }

    /**
     * Returns an object deserialized from the XML reader using the specified configuration.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * try (Reader reader = new FileReader("person.xml")) {
     *     Person result = N.fromXml(reader, config, Person.class);
     *     // Returns a Person object with deserialization according to config
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the reader containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target class type
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(Reader, Class)
     * @see #toXml(Object, XMLSerializationConfig, Writer)
     */
    public static <T> T fromXml(final Reader xml, final XMLDeserializationConfig config, final Class<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, config, targetType);
    }

    /**
     * Returns an object deserialized from the XML reader using the configuration with generic type support.
     *
     * <p>Note: The reader is not closed by this method.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLDeserializationConfig config = new XMLDeserializationConfig().setIgnoreUnknownProperty(true);
     * try (Reader reader = new FileReader("names.xml")) {
     *     List<String> result = N.fromXml(reader, config, new TypeReference<List<String>>(){}.type());
     *     // Returns a List<String> with deserialization according to config
     * }
     * }</pre>
     *
     * @param <T> the type of the returned object
     * @param xml the reader containing XML to deserialize
     * @param config the XML deserialization configuration
     * @param targetType the target Type with generic information
     * @return the deserialized object ({@code null} if XML represents {@code null})
     * @throws IllegalArgumentException if targetType is {@code null}
     * @see #fromXml(Reader, Type)
     * @see TypeReference
     */
    public static <T> T fromXml(final Reader xml, final XMLDeserializationConfig config, final Type<? extends T> targetType) {
        return Utils.xmlParser.deserialize(xml, setConfig(targetType, config, false), targetType.clazz());
    }

    /**
     * Returns the XML string formatted with indentation and line breaks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<Person><name>Alice</name><age>25</age></Person>";
     * String result = N.formatXml(xml);
     * // Returns formatted XML with indentation
     * }</pre>
     *
     * @param xml the XML string to format
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, Class)
     * @see #toXml(Object, boolean)
     */
    public static String formatXml(final String xml) {
        return formatXml(xml, MapEntity.class);
    }

    /**
     * Returns the XML string formatted with indentation and line breaks, using type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<Person><name>Alice</name></Person>";
     * String result = N.formatXml(xml, Person.class);
     * // Returns formatted XML with proper structure for Person type
     * }</pre>
     *
     * @param xml the XML string to format
     * @param transferType the type for deserialization during formatting
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, Type)
     * @see #formatXml(String)
     */
    public static String formatXml(final String xml, final Class<?> transferType) {
        return toXml(fromXml(xml, transferType), Utils.xscPrettyFormat);
    }

    /**
     * Returns the XML string formatted with indentation and line breaks, with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<list><item>Alice</item><item>Bob</item></list>";
     * String result = N.formatXml(xml, new TypeReference<List<String>>(){}.type());
     * // Returns formatted XML with proper structure for List<String> type
     * }</pre>
     *
     * @param xml the XML string to format
     * @param transferType the Type for deserialization during formatting with generic information
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, Class)
     * @see TypeReference
     */
    public static String formatXml(final String xml, final Type<?> transferType) {
        return toXml(fromXml(xml, transferType), Utils.xscPrettyFormat);
    }

    /**
     * Returns the XML string formatted using the specified configuration.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setIndentation("  ");
     * String xml = "<Person><name>Alice</name></Person>";
     * String result = N.formatXml(xml, config);
     * // Returns formatted XML with custom indentation
     * }</pre>
     *
     * @param xml the XML string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, XMLSerializationConfig, Class)
     * @see #formatXml(String)
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config) {
        return formatXml(xml, config, MapEntity.class);
    }

    /**
     * Returns the XML string formatted using the specified configuration, with type information for proper parsing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setIndentation("  ");
     * String xml = "<Person><name>Alice</name></Person>";
     * String result = N.formatXml(xml, config, Person.class);
     * // Returns formatted XML with custom indentation
     * }</pre>
     *
     * @param xml the XML string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @param transferType the type for deserialization during formatting
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, XMLSerializationConfig, Type)
     * @see #formatXml(String, Class)
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config, final Class<?> transferType) {
        final XMLSerializationConfig configToUse = config == null ? Utils.xscPrettyFormat
                : (!config.prettyFormat() ? config.copy().prettyFormat(true) : config);

        return toXml(fromXml(xml, transferType), configToUse);
    }

    /**
     * Returns the XML string formatted using the specified configuration with generic type support.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * XMLSerializationConfig config = new XMLSerializationConfig().setIndentation("  ");
     * String xml = "<list><item>Alice</item><item>Bob</item></list>";
     * String result = N.formatXml(xml, config, new TypeReference<List<String>>(){}.type());
     * // Returns formatted XML with custom indentation
     * }</pre>
     *
     * @param xml the XML string to format
     * @param config the serialization configuration (pretty formatting enabled automatically if not set)
     * @param transferType the Type for deserialization during formatting with generic information
     * @return the formatted XML string ({@code null} if input is {@code null})
     * @see #formatXml(String, XMLSerializationConfig, Class)
     * @see TypeReference
     */
    public static String formatXml(final String xml, final XMLSerializationConfig config, final Type<?> transferType) {
        final XMLSerializationConfig configToUse = config == null ? Utils.xscPrettyFormat
                : (!config.prettyFormat() ? config.copy().prettyFormat(true) : config);

        return toXml(fromXml(xml, transferType), configToUse);
    }

    /**
     * Returns the JSON string representation converted from the XML string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<person><name>Alice</name><age>25</age></person>";
     * String result = N.xml2Json(xml);
     * // Returns {"name":"Alice","age":25}
     * }</pre>
     *
     * @param xml the XML string to convert
     * @return the JSON string representation ({@code null} if XML is {@code null})
     * @see #xml2Json(String, Class)
     * @see #json2Xml(String)
     */
    public static String xml2Json(final String xml) {
        return xml2Json(xml, Map.class);
    }

    /**
     * Returns the JSON string representation converted from the XML string using an intermediate type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String xml = "<person><name>Alice</name><age>25</age></person>";
     * String result = N.xml2Json(xml, Person.class);
     * // Returns JSON representation of Person object
     * }</pre>
     *
     * @param xml the XML string to convert
     * @param transferType the intermediate type for parsing during conversion (must be Bean or Map type)
     * @return the JSON string representation ({@code null} if XML is {@code null})
     * @see #xml2Json(String)
     * @see #json2Xml(String, Class)
     */
    public static String xml2Json(final String xml, final Class<?> transferType) {
        return Utils.jsonParser.serialize(Utils.xmlParser.deserialize(xml, transferType), Utils.jsc);
    }

    /**
     * Returns the XML string representation converted from the JSON string.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "{\"name\":\"Alice\",\"age\":25}";
     * String result = N.json2Xml(json);
     * // Returns <name>Alice</name><age>25</age>
     * }</pre>
     *
     * @param json the JSON string to convert
     * @return the XML string representation ({@code null} if JSON is {@code null})
     * @see #json2Xml(String, Class)
     * @see #xml2Json(String)
     */
    public static String json2Xml(final String json) {
        return json2Xml(json, Map.class);
    }

    /**
     * Returns the XML string representation converted from the JSON string using an intermediate type.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String json = "{\"name\":\"Alice\",\"age\":25}";
     * String result = N.json2Xml(json, Person.class);
     * // Returns XML representation of Person object
     * }</pre>
     *
     * @param json the JSON string to convert
     * @param transferType the intermediate type for parsing during conversion (must be Bean or Map type)
     * @return the XML string representation ({@code null} if JSON is {@code null})
     * @see #json2Xml(String)
     * @see #xml2Json(String, Class)
     */
    public static String json2Xml(final String json, final Class<?> transferType) {
        return Utils.xmlParser.serialize(Utils.jsonParser.deserialize(json, transferType));
    }

    /**
     * Executes the action for each value in the integer range [startInclusive, endExclusive).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.forEach(0, 3, () -> System.out.println("Hello"));
     * // Prints "Hello" three times
     * }</pre>
     *
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param action the action to execute for each iteration
     * @throws E if the action throws an exception
     * @see #forEach(int, int, int, Throwables.Runnable)
     * @see #forEach(int, int, Throwables.IntConsumer)
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final Throwables.Runnable<E> action) throws E {
        forEach(startInclusive, endExclusive, 1, action);
    }

    /**
     * Executes the action for each value in the integer range with the specified step.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.forEach(0, 6, 2, () -> System.out.println("Hello"));
     * // Prints "Hello" three times (for 0, 2, 4)
     * }</pre>
     *
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param step the step increment (positive or negative, but not zero)
     * @param action the action to execute for each iteration
     * @throws IllegalArgumentException if step is zero
     * @throws E if the action throws an exception
     * @see #forEach(int, int, Throwables.Runnable)
     * @see #forEach(int, int, int, Throwables.IntConsumer)
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final Throwables.Runnable<E> action)
            throws IllegalArgumentException, E {
        checkArgument(step != 0, "The input parameter 'step' cannot be zero"); //NOSONAR

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = ((long) endExclusive - startInclusive) / step + (((long) endExclusive - startInclusive) % step == 0 ? 0 : 1);

        while (len-- > 0) {
            action.run();
        }
    }

    /**
     * Executes the action for each value in the integer range [startInclusive, endExclusive).
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.forEach(0, 3, i -> System.out.println("Index: " + i));
     * // Prints: Index: 0, Index: 1, Index: 2
     * }</pre>
     *
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param action the action to execute, receiving each index value
     * @throws E if the action throws an exception
     * @see #forEach(int, int, int, Throwables.IntConsumer)
     * @see #forEach(int, int, Throwables.Runnable)
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final Throwables.IntConsumer<E> action) throws E {
        forEach(startInclusive, endExclusive, 1, action);
    }

    /**
     * Executes the action for each value in the integer range with the specified step.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.forEach(0, 6, 2, i -> System.out.println("Index: " + i));
     * // Prints: Index: 0, Index: 2, Index: 4
     * }</pre>
     *
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param step the step increment (positive or negative, but not zero)
     * @param action the action to execute, receiving each index value
     * @throws IllegalArgumentException if step is zero
     * @throws E if the action throws an exception
     * @see #forEach(int, int, Throwables.IntConsumer)
     * @see #forEach(int, int, int, Throwables.Runnable)
     */
    public static <E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final Throwables.IntConsumer<E> action)
            throws E {
        checkArgument(step != 0, "The input parameter 'step' cannot be zero");

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = ((long) endExclusive - startInclusive) / step + (((long) endExclusive - startInclusive) % step == 0 ? 0 : 1);
        int start = startInclusive;

        while (len-- > 0) {
            action.accept(start);
            start += step;
        }
    }

    /**
     * Executes the action for each value in the integer range, passing the index and an object.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * StringBuilder sb = new StringBuilder();
     * N.forEach(0, 3, sb, (i, builder) -> builder.append(i).append(" "));
     * // sb contains "0 1 2 "
     * }</pre>
     *
     * @param <T> the type of the object passed to the action
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param a the object to pass to the action
     * @param action the action to execute, receiving index and object
     * @throws E if the action throws an exception
     * @see #forEach(int, int, int, Object, Throwables.IntObjConsumer)
     */
    public static <T, E extends Exception> void forEach(final int startInclusive, final int endExclusive, final T a,
            final Throwables.IntObjConsumer<? super T, E> action) throws E {
        forEach(startInclusive, endExclusive, 1, a, action);
    }

    /**
     * Executes the action for each value in the integer range with the specified step, passing the index and an object.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * StringBuilder sb = new StringBuilder();
     * N.forEach(0, 6, 2, sb, (i, builder) -> builder.append(i).append(" "));
     * // sb contains "0 2 4 "
     * }</pre>
     *
     * @param <T> the type of the object passed to the action
     * @param <E> the type of exception that the action may throw
     * @param startInclusive the start of the range (inclusive)
     * @param endExclusive the end of the range (exclusive)
     * @param step the step increment (positive or negative, but not zero)
     * @param a the object to pass to the action
     * @param action the action to execute, receiving index and object
     * @throws IllegalArgumentException if step is zero
     * @throws E if the action throws an exception
     * @see #forEach(int, int, Object, Throwables.IntObjConsumer)
     */
    public static <T, E extends Exception> void forEach(final int startInclusive, final int endExclusive, final int step, final T a,
            final Throwables.IntObjConsumer<? super T, E> action) throws E {
        checkArgument(step != 0, "The input parameter 'step' cannot be zero");

        if (endExclusive == startInclusive || endExclusive > startInclusive != step > 0) {
            return;
        }

        long len = ((long) endExclusive - startInclusive) / step + (((long) endExclusive - startInclusive) % step == 0 ? 0 : 1);
        int start = startInclusive;

        while (len-- > 0) {
            action.accept(start, a);
            start += step;
        }
    }

    /**
     * Executes the action for each element in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * N.forEach(names, name -> System.out.println(name));
     * // Prints each name
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param action the action to execute for each element
     * @throws E if the action throws an exception
     * @see #forEach(Object[], int, int, Throwables.Consumer)
     * @see #forEach(Iterable, Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEach(final T[] a, final Throwables.Consumer<? super T, E> action) throws E {
        if (isEmpty(a)) {
            return;
        }

        for (final T e : a) {
            action.accept(e);
        }
    }

    /**
     * Executes the action for each element in the array within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "Diana"};
     * N.forEach(names, 1, 3, name -> System.out.println(name));
     * // Prints: Bob, Charlie
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param action the action to execute for each element
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @throws E if the action throws an exception
     * @see #forEach(Object[], Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEach(final T[] a, final int fromIndex, final int toIndex, final Throwables.Consumer<? super T, E> action)
            throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), len(a)); // NOSONAR
        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (fromIndex <= toIndex) {
            for (int i = fromIndex; i < toIndex; i++) {
                action.accept(a[i]);
            }
        } else {
            for (int i = min(a.length - 1, fromIndex); i > toIndex; i--) {
                action.accept(a[i]);
            }
        }
    }

    /**
     * Executes the action for each element in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * N.forEach(names, name -> System.out.println(name));
     * // Prints each name
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute for each element
     * @throws E if the action throws an exception
     * @see #forEach(Iterator, Throwables.Consumer)
     * @see #forEach(Object[], Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> action) throws E {
        if (c == null) {
            return;
        }

        for (final T e : c) {
            action.accept(e);
        }
    }

    /**
     * Executes the action for each element in the iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", "Bob").iterator();
     * N.forEach(iter, name -> System.out.println(name));
     * // Prints each name
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param action the action to execute for each element
     * @throws E if the action throws an exception
     * @see #forEach(Iterable, Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> action) throws E {
        if (iter == null) {
            return;
        }

        while (iter.hasNext()) {
            action.accept(iter.next());
        }
    }

    /**
     * Executes the action for each element in the collection within the specified range.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana");
     * N.forEach(names, 1, 3, name -> System.out.println(name));
     * // Prints: Bob, Charlie
     * }</pre>
     *
     * @param <T> the type of elements in the collection
     * @param <E> the type of exception that the action may throw
     * @param c the collection to iterate
     * @param fromIndex the start index (inclusive)
     * @param toIndex the end index (exclusive)
     * @param action the action to execute for each element
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @throws E if the action throws an exception
     * @see #forEach(Iterable, Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEach(final Collection<? extends T> c, int fromIndex, final int toIndex,
            final Throwables.Consumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), size(c));
        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        fromIndex = min(c.size() - 1, fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            if (fromIndex <= toIndex) {
                for (int i = fromIndex; i < toIndex; i++) {
                    action.accept(list.get(i));
                }
            } else {
                for (int i = fromIndex; i > toIndex; i--) {
                    action.accept(list.get(i));
                }
            }
        } else {
            if (fromIndex <= toIndex) {
                final Iterator<? extends T> iter = c.iterator();
                int idx = 0;

                while (idx < fromIndex && iter.hasNext()) {
                    iter.next();
                    idx++;
                }

                while (iter.hasNext()) {
                    action.accept(iter.next());

                    if (++idx >= toIndex) {
                        break;
                    }
                }
            } else {
                final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

                if (descendingIterator != null) {
                    int idx = c.size() - 1;

                    while (idx > fromIndex && descendingIterator.hasNext()) {
                        descendingIterator.next();
                        idx--;
                    }

                    while (descendingIterator.hasNext()) {
                        action.accept(descendingIterator.next());

                        if (--idx <= toIndex) {
                            break;
                        }
                    }
                } else {
                    final Iterator<? extends T> iter = c.iterator();
                    int idx = 0;

                    while (idx <= toIndex && iter.hasNext()) {
                        iter.next();
                        idx++;
                    }

                    final T[] a = (T[]) new Object[fromIndex - toIndex];

                    while (iter.hasNext()) {
                        a[idx - 1 - toIndex] = iter.next();

                        if (idx++ >= fromIndex) {
                            break;
                        }
                    }

                    for (int i = a.length - 1; i >= 0; i--) {
                        action.accept(a[i]);
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each entry in the map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
     * N.forEach(ages, entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
     * // Prints: Alice: 25, Bob: 30
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param <E> the type of exception that the action may throw
     * @param map the map to iterate
     * @param action the action to execute for each entry
     * @throws E if the action throws an exception
     * @see #forEach(Map, Throwables.BiConsumer)
     */
    public static <K, V, E extends Exception> void forEach(final Map<K, V> map, final Throwables.Consumer<? super Map.Entry<K, V>, E> action) throws E {
        if (isEmpty(map)) {
            return;
        }

        forEach(map.entrySet(), action);
    }

    /**
     * Executes the action for each key-value pair in the map.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
     * N.forEach(ages, (name, age) -> System.out.println(name + " is " + age));
     * // Prints: Alice is 25, Bob is 30
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param <E> the type of exception that the action may throw
     * @param map the map to iterate
     * @param action the action to execute, receiving key and value
     * @throws E if the action throws an exception
     * @see #forEach(Map, Throwables.Consumer)
     */
    public static <K, V, E extends Exception> void forEach(final Map<K, V> map, final Throwables.BiConsumer<? super K, ? super V, E> action) throws E {
        if (isEmpty(map)) {
            return;
        }

        for (final Map.Entry<K, V> entry : map.entrySet()) {
            action.accept(entry.getKey(), entry.getValue());
        }
    }

    /**
     * Executes the action for each element in the iterable using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> urls = Arrays.asList("http://a.com", "http://b.com");
     * N.forEach(urls, url -> fetchData(url), 2);
     * // Processes URLs in parallel using 2 threads
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the consumer may throw
     * @param c the iterable to iterate
     * @param elementConsumer the action to execute for each element
     * @param processThreadNum the number of threads for parallel processing
     * @see #forEach(Iterable, Throwables.Consumer, int, Executor)
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEach(c, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the action for each element in the iterable using parallel processing with a custom executor.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> urls = Arrays.asList("http://a.com", "http://b.com");
     * Executor executor = Executors.newFixedThreadPool(2);
     * N.forEach(urls, url -> fetchData(url), 2, executor);
     * // Processes URLs in parallel using custom executor
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the consumer may throw
     * @param c the iterable to iterate
     * @param elementConsumer the action to execute for each element
     * @param processThreadNum the number of threads for parallel processing
     * @param executor the executor for thread management
     * @see #forEach(Iterable, Throwables.Consumer, int)
     */
    public static <T, E extends Exception> void forEach(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) {
        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;

        forEach(isEmptyCollection(c) ? ObjIterator.<T> empty() : c.iterator(), elementConsumer, N.min(size, processThreadNum), executor);
    }

    /**
     * Executes the action for each element in the iterator using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = urls.iterator();
     * N.forEach(iter, url -> fetchData(url), 2);
     * // Processes iterator elements in parallel using 2 threads
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the consumer may throw
     * @param iter the iterator to iterate
     * @param elementConsumer the action to execute for each element
     * @param processThreadNum the number of threads for parallel processing
     * @see #forEach(Iterator, Throwables.Consumer, int, Executor)
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEach(iter, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the action for each element in the iterator using parallel processing with a custom executor.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = urls.iterator();
     * Executor executor = Executors.newFixedThreadPool(2);
     * N.forEach(iter, url -> fetchData(url), 2, executor);
     * // Processes iterator elements in parallel using custom executor
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the consumer may throw
     * @param iter the iterator to iterate
     * @param elementConsumer the action to execute for each element
     * @param processThreadNum the number of threads for parallel processing
     * @param executor the executor for thread management
     * @see #forEach(Iterator, Throwables.Consumer, int)
     */
    public static <T, E extends Exception> void forEach(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) {
        final Iterator<? extends T> iteratorII = iter == null ? ObjIterator.empty() : iter;
        final CountDownLatch countDownLatch = new CountDownLatch(processThreadNum);
        final Holder<Exception> errorHolder = new Holder<>();

        for (int i = 0; i < processThreadNum; i++) {
            executor.execute(() -> {
                T element = null;

                try {
                    while (errorHolder.value() == null) {
                        synchronized (iteratorII) {
                            if (iteratorII.hasNext()) {
                                element = iteratorII.next();
                            } else {
                                break;
                            }
                        }

                        elementConsumer.accept(element);
                    }
                } catch (final Exception e) {
                    synchronized (errorHolder) {
                        if (errorHolder.value() == null) {
                            errorHolder.setValue(e);
                        } else {
                            errorHolder.value().addSuppressed(e);
                        }
                    }
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (final InterruptedException e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }

        if (errorHolder.value() != null) {
            throw ExceptionUtil.toRuntimeException(errorHolder.value(), true);
        }
    }

    /**
     * Executes the action for each element in the array paired with elements from a mapped iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] users = {"Alice", "Bob"};
     * N.forEach(users,
     *     user -> getOrders(user),  // returns List<Order>
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each user with each of their orders
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param a the array to iterate
     * @param flatMapper the function producing an iterable for each element (skips {@code null} results)
     * @param action the action to execute for each (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Iterable, Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     * Executes the action for each element in the iterable paired with elements from a mapped iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> users = Arrays.asList("Alice", "Bob");
     * N.forEach(users,
     *     user -> getOrders(user),  // returns List<Order>
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each user with each of their orders
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param c the iterable to iterate
     * @param flatMapper the function producing an iterable for each element (skips {@code null} results)
     * @param action the action to execute for each (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Object[], Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmptyCollection(c)) {
            return;
        }

        for (final T t : c) {
            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     * Executes the action for each element in the iterator paired with elements from a mapped iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> users = userList.iterator();
     * N.forEach(users,
     *     user -> getOrders(user),  // returns List<Order>
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each user with each of their orders
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param iter the iterator to iterate
     * @param flatMapper the function producing an iterable for each element (skips {@code null} results)
     * @param action the action to execute for each (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Iterable, Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEach(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            final Iterable<U> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final U u : c2) {
                    action.accept(t, u);
                }
            }
        }
    }

    /**
     * Executes the provided {@code action} for each element in the given array after applying the {@code flatMapper} and {@code flatMapper2} functions.
     * The {@code flatMapper} function maps each element of type {@code T} to an {@code Iterable} of elements of type {@code T2}.
     * The {@code flatMapper2} function maps each element of type {@code T2} to an {@code Iterable} of elements of type {@code T3}.
     * The {@code action} is then performed for each triple of elements from the original array and the resulting iterables.
     *
     * @param <T> the type of the elements in the array
     * @param <T2> the type of the elements in the iterable returned by the flatMapper
     * @param <T3> the type of the elements in the iterable returned by the flatMapper2
     * @param <E> the type of the exception that the flatMapper may throw
     * @param <E2> the type of the exception that the flatMapper2 may throw
     * @param <E3> the type of the exception that the action may throw
     * @param a the array whose elements are to be processed
     * @param flatMapper the function to apply to each element in given the array to produce an iterable of elements of type T2
     * @param flatMapper2 the function to apply to each element in the iterable of type T2 to produce an iterable of elements of type T3
     * @param action the action to be performed for each triple of elements from the given array and the resulting iterables
     * @throws E if the flatMapper throws an exception
     * @throws E2 if the flatMapper2 throws an exception
     * @throws E3 if the action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the provided {@code action} for each element in the given iterable after applying the {@code flatMapper} and {@code flatMapper2} functions.
     * The {@code flatMapper} function maps each element of type {@code T} to an {@code Iterable} of elements of type {@code T2}.
     * The {@code flatMapper2} function maps each element of type {@code T2} to an {@code Iterable} of elements of type {@code T3}.
     * The {@code action} is then performed for each triple of elements from the original iterable and the resulting iterables.
     *
     * @param <T> the type of the elements in the collection
     * @param <T2> the type of the elements in the iterable returned by the flatMapper
     * @param <T3> the type of the elements in the iterable returned by the flatMapper2
     * @param <E> the type of the exception that the flatMapper may throw
     * @param <E2> the type of the exception that the flatMapper2 may throw
     * @param <E3> the type of the exception that the action may throw
     * @param c the collection whose elements are to be processed
     * @param flatMapper the function to apply to each element in the given iterable to produce an iterable of elements of type T2
     * @param flatMapper2 the function to apply to each element in the iterable of type T2 to produce an iterable of elements of type T3
     * @param action the action to be performed for each triple of elements from the given iterable and the resulting iterables
     * @throws E if the flatMapper throws an exception
     * @throws E2 if the flatMapper2 throws an exception
     * @throws E3 if the action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmptyCollection(c)) {
            return;
        }

        for (final T t : c) {
            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the provided {@code action} for each element in the given iterator after applying the {@code flatMapper} and {@code flatMapper2} functions.
     * The {@code flatMapper} function maps each element of type {@code T} to an {@code Iterable} of elements of type {@code T2}.
     * The {@code flatMapper2} function maps each element of type {@code T2} to an {@code Iterable} of elements of type {@code T3}.
     * The {@code action} is then performed for each triple of elements from the original iterator and the resulting iterables.
     *
     * @param <T> the type of the elements in the iterator
     * @param <T2> the type of the elements in the iterable returned by the flatMapper
     * @param <T3> the type of the elements in the iterable returned by the flatMapper2
     * @param <E> the type of the exception that the flatMapper may throw
     * @param <E2> the type of the exception that the flatMapper2 may throw
     * @param <E3> the type of the exception that the action may throw
     * @param iter the iterator whose elements are to be processed
     * @param flatMapper the function to apply to each element in the given iterator to produce an iterable of elements of type T2
     * @param flatMapper2 the function to apply to each element in the iterable of type T2 to produce an iterable of elements of type T3
     * @param action the action to be performed for each triple of elements from the given iterator and the resulting iterables
     * @throws E if the flatMapper throws an exception
     * @throws E2 if the flatMapper2 throws an exception
     * @throws E3 if the action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEach(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            final Iterable<T2> c2 = flatMapper.apply(t);

            if (c2 != null) {
                for (final T2 t2 : c2) {
                    final Iterable<T3> c3 = flatMapper2.apply(t2);

                    if (c3 != null) {
                        for (final T3 t3 : c3) {
                            action.accept(t, t2, t3);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given arrays until all elements from the shorter array are processed.
     *
     * @param <A> the type of the elements in the first array
     * @param <B> the type of the elements in the second array
     * @param <E> the type of the exception that the action may throw
     * @param a the first array whose elements are to be processed
     * @param b the second array whose elements are to be processed
     * @param action the action to be performed for each pair of elements from the arrays
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final A[] a, final B[] b, final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (isEmpty(a) || isEmpty(b)) {
            return;
        }

        for (int i = 0, minLen = min(a.length, b.length); i < minLen; i++) {
            action.accept(a[i], b[i]);
        }
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given iterables until all elements from the shorter iterable are processed.
     *
     * @param <A> the type of the elements in the first iterable
     * @param <B> the type of the elements in the second iterable
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterable whose elements are to be processed
     * @param b the second iterable whose elements are to be processed
     * @param action the action to be performed for each pair of elements from the iterables
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (isEmptyCollection(a) || isEmptyCollection(b)) {
            return;
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();

        forEach(iterA, iterB, action);
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given iterators until all elements from the shorter iterator are processed.
     *
     * @param <A> the type of the elements in the first iterator
     * @param <B> the type of the elements in the second iterator
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterator whose elements are to be processed
     * @param b the second iterator whose elements are to be processed
     * @param action the action to be performed for each pair of elements from the iterators
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        if (a == null || b == null) {
            return;
        }

        while (a.hasNext() && b.hasNext()) {
            action.accept(a.next(), b.next());
        }
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given arrays until all elements from the shortest array are processed.
     *
     * @param <A> the type of the elements in the first array
     * @param <B> the type of the elements in the second array
     * @param <C> the type of the elements in the third array
     * @param <E> the type of the exception that the action may throw
     * @param a the first array whose elements are to be processed
     * @param b the second array whose elements are to be processed
     * @param c the third array whose elements are to be processed
     * @param action the action to be performed for each triple of elements from the arrays
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final A[] a, final B[] b, final C[] c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (isEmpty(a) || isEmpty(b) || isEmpty(c)) {
            return;
        }

        for (int i = 0, minLen = min(a.length, b.length, c.length); i < minLen; i++) {
            action.accept(a[i], b[i], c[i]);
        }
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given iterables until all elements from the shortest iterable are processed.
     *
     * @param <A> the type of the elements in the first iterable
     * @param <B> the type of the elements in the second iterable
     * @param <C> the type of the elements in the third iterable
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterable whose elements are to be processed
     * @param b the second iterable whose elements are to be processed
     * @param c the third iterable whose elements are to be processed
     * @param action the action to be performed for each triple of elements from the iterables
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (isEmptyCollection(a) || isEmptyCollection(b) || isEmptyCollection(c)) {
            return;
        }

        final Iterator<A> iterA = a.iterator();
        final Iterator<B> iterB = b.iterator();
        final Iterator<C> iterC = c.iterator();

        forEach(iterA, iterB, iterC, action);
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given iterators until all elements from the shortest iterator are processed.
     *
     * @param <A> the type of the elements in the first iterator
     * @param <B> the type of the elements in the second iterator
     * @param <C> the type of the elements in the third iterator
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterator whose elements are to be processed
     * @param b the second iterator whose elements are to be processed
     * @param c the third iterator whose elements are to be processed
     * @param action the action to be performed for each triple of elements from the iterators
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c,
            final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        if (a == null || b == null || c == null) {
            return;
        }

        while (a.hasNext() && b.hasNext() && c.hasNext()) {
            action.accept(a.next(), b.next(), c.next());
        }
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given arrays until all elements from the longer array are processed.
     *
     * @param <A> the type of the elements in the first array
     * @param <B> the type of the elements in the second array
     * @param <E> the type of the exception that the action may throw
     * @param a the first array whose elements are to be processed
     * @param b the second array whose elements are to be processed
     * @param valueForNoneA the value to be used if the first array is shorter than the second array
     * @param valueForNoneB the value to be used if the second array is shorter than the first array
     * @param action the action to be performed for each pair of elements from the arrays
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final A[] a, final B[] b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final int lenA = len(a);
        final int lenB = len(b);

        for (int i = 0, maxLen = max(lenA, lenB); i < maxLen; i++) {
            action.accept(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB);
        }
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given iterables until all elements from the longer iterable are processed.
     *
     * @param <A> the type of the elements in the first iterable
     * @param <B> the type of the elements in the second iterable
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterable whose elements are to be processed
     * @param b the second iterable whose elements are to be processed
     * @param valueForNoneA the value to be used if the first iterable is shorter than the second iterable
     * @param valueForNoneB the value to be used if the second iterable is shorter than the first iterable
     * @param action the action to be performed for each pair of elements from the iterables
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final Iterator<A> iterA = isEmptyCollection(a) ? ObjIterator.empty() : a.iterator();
        final Iterator<B> iterB = isEmptyCollection(b) ? ObjIterator.empty() : b.iterator();

        forEach(iterA, iterB, valueForNoneA, valueForNoneB, action);
    }

    /**
     * Executes the provided {@code action} for each pair of elements from the given iterators until all elements from the longer iterator are processed.
     *
     * @param <A> the type of the elements in the first iterator
     * @param <B> the type of the elements in the second iterator
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterator whose elements are to be processed
     * @param b the second iterator whose elements are to be processed
     * @param valueForNoneA the value to be used if the first iterator is shorter than the second iterator
     * @param valueForNoneB the value to be used if the second iterator is shorter than the first iterator
     * @param action the action to be performed for each pair of elements from the iterators
     * @throws E if the action throws an exception
     */
    public static <A, B, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final A valueForNoneA, final B valueForNoneB,
            final Throwables.BiConsumer<? super A, ? super B, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.empty() : a;
        final Iterator<B> iterB = b == null ? ObjIterator.empty() : b;

        A nextA = null;
        B nextB = null;

        while (iterA.hasNext() || iterB.hasNext()) {
            nextA = iterA.hasNext() ? iterA.next() : valueForNoneA;
            nextB = iterB.hasNext() ? iterB.next() : valueForNoneB;

            action.accept(nextA, nextB);
        }
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given arrays until all elements from the longest array are processed.
     *
     * @param <A> the type of the elements in the first array
     * @param <B> the type of the elements in the second array
     * @param <C> the type of the elements in the third array
     * @param <E> the type of the exception that the action may throw
     * @param a the first array whose elements are to be processed
     * @param b the second array whose elements are to be processed
     * @param c the third array whose elements are to be processed
     * @param valueForNoneA the value to be used if the first array is shorter than the second and third arrays
     * @param valueForNoneB the value to be used if the second array is shorter than the first and third arrays
     * @param valueForNoneC the value to be used if the third array is shorter than the first and second arrays
     * @param action the action to be performed for each triple of elements from the arrays
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final A[] a, final B[] b, final C[] c, final A valueForNoneA, final B valueForNoneB,
            final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final int lenA = len(a);
        final int lenB = len(b);
        final int lenC = len(c);

        for (int i = 0, maxLen = max(lenA, lenB, lenC); i < maxLen; i++) {
            action.accept(i < lenA ? a[i] : valueForNoneA, i < lenB ? b[i] : valueForNoneB, i < lenC ? c[i] : valueForNoneC);
        }
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given iterables until all elements from the longest iterable are processed.
     *
     * @param <A> the type of the elements in the first iterable
     * @param <B> the type of the elements in the second iterable
     * @param <C> the type of the elements in the third iterable
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterable whose elements are to be processed
     * @param b the second iterable whose elements are to be processed
     * @param c the third iterable whose elements are to be processed
     * @param valueForNoneA the value to be used if the first iterable is shorter than the second and third iterables
     * @param valueForNoneB the value to be used if the second iterable is shorter than the first and third iterables
     * @param valueForNoneC the value to be used if the third iterable is shorter than the first and second iterables
     * @param action the action to be performed for each triple of elements from the iterables
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterable<A> a, final Iterable<B> b, final Iterable<C> c, final A valueForNoneA,
            final B valueForNoneB, final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final Iterator<A> iterA = isEmptyCollection(a) ? ObjIterator.empty() : a.iterator();
        final Iterator<B> iterB = isEmptyCollection(b) ? ObjIterator.empty() : b.iterator();
        final Iterator<C> iterC = isEmptyCollection(c) ? ObjIterator.empty() : c.iterator();

        forEach(iterA, iterB, iterC, valueForNoneA, valueForNoneB, valueForNoneC, action);
    }

    /**
     * Executes the provided {@code action} for each triple of elements from the given iterators until all elements from the longest iterator are processed.
     *
     * @param <A> the type of the elements in the first iterator
     * @param <B> the type of the elements in the second iterator
     * @param <C> the type of the elements in the third iterator
     * @param <E> the type of the exception that the action may throw
     * @param a the first iterator whose elements are to be processed
     * @param b the second iterator whose elements are to be processed
     * @param c the third iterator whose elements are to be processed
     * @param valueForNoneA the value to be used if the first iterator is shorter than the second and third iterators
     * @param valueForNoneB the value to be used if the second iterator is shorter than the first and third iterators
     * @param valueForNoneC the value to be used if the third iterator is shorter than the first and second iterators
     * @param action the action to be performed for each triple of elements from the iterators
     * @throws E if the action throws an exception
     */
    public static <A, B, C, E extends Exception> void forEach(final Iterator<A> a, final Iterator<B> b, final Iterator<C> c, final A valueForNoneA,
            final B valueForNoneB, final C valueForNoneC, final Throwables.TriConsumer<? super A, ? super B, ? super C, E> action) throws E {
        final Iterator<A> iterA = a == null ? ObjIterator.empty() : a;
        final Iterator<B> iterB = b == null ? ObjIterator.empty() : b;
        final Iterator<C> iterC = b == null ? ObjIterator.empty() : c;

        A nextA = null;
        B nextB = null;
        C nextC = null;

        while (iterA.hasNext() || iterB.hasNext() || iterC.hasNext()) {
            nextA = iterA.hasNext() ? iterA.next() : valueForNoneA;
            nextB = iterB.hasNext() ? iterB.next() : valueForNoneB;
            nextC = iterC.hasNext() ? iterC.next() : valueForNoneC;

            action.accept(nextA, nextB, nextC);
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", null, "Bob", null, "Charlie"};
     * N.forEachNonNull(names, name -> System.out.println(name));
     * // Prints: Alice, Bob, Charlie (skips nulls)
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param action the action to execute for each {@code non-null} element
     * @throws E if the action throws an exception
     * @see #forEach(Object[], Throwables.Consumer)
     * @see #forEachNonNull(Iterable, Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEachNonNull(final T[] a, final Throwables.Consumer<? super T, E> action) throws E {
        if (isEmpty(a)) {
            return;
        }

        for (final T e : a) {
            if (e != null) {
                action.accept(e);
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", null, "Bob");
     * N.forEachNonNull(names, name -> System.out.println(name));
     * // Prints: Alice, Bob (skips null)
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute for each {@code non-null} element
     * @throws E if the action throws an exception
     * @see #forEach(Iterable, Throwables.Consumer)
     * @see #forEachNonNull(Object[], Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEachNonNull(final Iterable<? extends T> c, final Throwables.Consumer<? super T, E> action) throws E {
        if (isEmptyCollection(c)) {
            return;
        }

        for (final T e : c) {
            if (e != null) {
                action.accept(e);
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", null, "Bob").iterator();
     * N.forEachNonNull(iter, name -> System.out.println(name));
     * // Prints: Alice, Bob (skips null)
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param action the action to execute for each {@code non-null} element
     * @throws E if the action throws an exception
     * @see #forEach(Iterator, Throwables.Consumer)
     * @see #forEachNonNull(Iterable, Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEachNonNull(final Iterator<? extends T> iter, final Throwables.Consumer<? super T, E> action) throws E {
        if (iter == null) {
            return;
        }

        T e = null;

        while (iter.hasNext()) {
            if ((e = iter.next()) != null) {
                action.accept(e);
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the array paired with {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] users = {"Alice", null, "Bob"};
     * N.forEachNonNull(users,
     *     user -> getOrders(user),  // returns List<Order>, may contain nulls
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each non-null user with each non-null order
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param a the array to iterate
     * @param flatMapper the function producing an iterable for each {@code non-null} element (skips {@code null} results and {@code null} elements)
     * @param action the action to execute for each {@code non-null} (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Object[], Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterable paired with {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> users = Arrays.asList("Alice", null, "Bob");
     * N.forEachNonNull(users,
     *     user -> getOrders(user),  // returns List<Order>, may contain nulls
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each non-null user with each non-null order
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param c the iterable to iterate
     * @param flatMapper the function producing an iterable for each {@code non-null} element (skips {@code null} results and {@code null} elements)
     * @param action the action to execute for each {@code non-null} (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Iterable, Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (isEmptyCollection(c)) {
            return;
        }

        for (final T t : c) {
            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterator paired with {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> users = Arrays.asList("Alice", null, "Bob").iterator();
     * N.forEachNonNull(users,
     *     user -> getOrders(user),  // returns List<Order>, may contain nulls
     *     (user, order) -> System.out.println(user + ": " + order));
     * // Processes each non-null user with each non-null order
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <U> the type of elements produced by flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that action may throw
     * @param iter the iterator to iterate
     * @param flatMapper the function producing an iterable for each {@code non-null} element (skips {@code null} results and {@code null} elements)
     * @param action the action to execute for each {@code non-null} (element, mapped) pair
     * @throws E if flatMapper throws an exception
     * @throws E2 if action throws an exception
     * @see #forEach(Iterator, Throwables.Function, Throwables.BiConsumer)
     */
    public static <T, U, E extends Exception, E2 extends Exception> void forEachNonNull(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<U>, E> flatMapper, final Throwables.BiConsumer<? super T, ? super U, E2> action)
            throws E, E2 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            if (t != null) {
                final Iterable<U> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final U u : c2) {
                        if (u != null) {
                            action.accept(t, u);
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the array with two levels of {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] categories = {"Electronics", null};
     * N.forEachNonNull(categories,
     *     cat -> getProducts(cat),      // Category -> List<Product>
     *     prod -> getReviews(prod),     // Product -> List<Review>
     *     (cat, prod, review) -> process(cat, prod, review));
     * // Processes each non-null (category, product, review) triple
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <T2> the type of elements from first flatMapper
     * @param <T3> the type of elements from second flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that flatMapper2 may throw
     * @param <E3> the type of exception that action may throw
     * @param a the array to iterate
     * @param flatMapper the first mapping function (T -&gt; Iterable&lt;T2&gt;, skips {@code null} at all levels)
     * @param flatMapper2 the second mapping function (T2 -&gt; Iterable&lt;T3&gt;, skips {@code null} at all levels)
     * @param action the action to execute for each {@code non-null} triple
     * @throws E if flatMapper throws an exception
     * @throws E2 if flatMapper2 throws an exception
     * @throws E3 if action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final T[] a,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmpty(a)) {
            return;
        }

        for (final T t : a) {
            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterable with two levels of {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> categories = Arrays.asList("Electronics", null);
     * N.forEachNonNull(categories,
     *     cat -> getProducts(cat),      // Category -> List<Product>
     *     prod -> getReviews(prod),     // Product -> List<Review>
     *     (cat, prod, review) -> process(cat, prod, review));
     * // Processes each non-null (category, product, review) triple
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <T2> the type of elements from first flatMapper
     * @param <T3> the type of elements from second flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that flatMapper2 may throw
     * @param <E3> the type of exception that action may throw
     * @param c the iterable to iterate
     * @param flatMapper the first mapping function (T -&gt; Iterable&lt;T2&gt;, skips {@code null} at all levels)
     * @param flatMapper2 the second mapping function (T2 -&gt; Iterable&lt;T3&gt;, skips {@code null} at all levels)
     * @param action the action to execute for each {@code non-null} triple
     * @throws E if flatMapper throws an exception
     * @throws E2 if flatMapper2 throws an exception
     * @throws E3 if action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final Iterable<? extends T> c,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (isEmptyCollection(c)) {
            return;
        }

        for (final T t : c) {
            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each {@code non-null} element in the iterator with two levels of {@code non-null} mapped elements.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> categories = categoryList.iterator();
     * N.forEachNonNull(categories,
     *     cat -> getProducts(cat),      // Category -> List<Product>
     *     prod -> getReviews(prod),     // Product -> List<Review>
     *     (cat, prod, review) -> process(cat, prod, review));
     * // Processes each non-null (category, product, review) triple
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <T2> the type of elements from first flatMapper
     * @param <T3> the type of elements from second flatMapper
     * @param <E> the type of exception that flatMapper may throw
     * @param <E2> the type of exception that flatMapper2 may throw
     * @param <E3> the type of exception that action may throw
     * @param iter the iterator to iterate
     * @param flatMapper the first mapping function (T -&gt; Iterable&lt;T2&gt;, skips {@code null} at all levels)
     * @param flatMapper2 the second mapping function (T2 -&gt; Iterable&lt;T3&gt;, skips {@code null} at all levels)
     * @param action the action to execute for each {@code non-null} triple
     * @throws E if flatMapper throws an exception
     * @throws E2 if flatMapper2 throws an exception
     * @throws E3 if action throws an exception
     */
    public static <T, T2, T3, E extends Exception, E2 extends Exception, E3 extends Exception> void forEachNonNull(final Iterator<? extends T> iter,
            final Throwables.Function<? super T, ? extends Iterable<T2>, E> flatMapper,
            final Throwables.Function<? super T2, ? extends Iterable<T3>, E2> flatMapper2,
            final Throwables.TriConsumer<? super T, ? super T2, ? super T3, E3> action) throws E, E2, E3 {
        if (iter == null) {
            return;
        }

        T t = null;

        while (iter.hasNext()) {
            t = iter.next();

            if (t != null) {
                final Iterable<T2> c2 = flatMapper.apply(t);

                if (c2 != null) {
                    for (final T2 t2 : c2) {
                        if (t2 != null) {
                            final Iterable<T3> c3 = flatMapper2.apply(t2);

                            if (c3 != null) {
                                for (final T3 t3 : c3) {
                                    if (t3 != null) {
                                        action.accept(t, t2, t3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each element in the array with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie"};
     * N.forEachIndexed(names, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 0: Alice, 1: Bob, 2: Charlie
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param action the action to execute, receiving index and element
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Object[], int, int, Throwables.IntObjConsumer)
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer)
     * @see #forEach(Object[], Throwables.Consumer)
     */
    public static <T, E extends Exception> void forEachIndexed(final T[] a, final Throwables.IntObjConsumer<? super T, E> action) throws E {
        if (isEmpty(a)) {
            return;
        }

        forEachIndexed(a, 0, a.length, action);
    }

    /**
     * Executes the action for each element in the specified range of the array with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * N.forEachIndexed(names, 1, 3, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 1: Bob, 2: Charlie
     *
     * // Reverse iteration
     * N.forEachIndexed(names, 2, 0, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 2: Charlie, 1: Bob
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range (if fromIndex &gt; toIndex, iterates in reverse)
     * @param action the action to execute, receiving index and element
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Object[], Throwables.IntObjConsumer)
     * @see #forEachIndexed(Collection, int, int, Throwables.IntObjConsumer)
     */
    public static <T, E extends Exception> void forEachIndexed(final T[] a, final int fromIndex, final int toIndex,
            final Throwables.IntObjConsumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), len(a)); // NOSONAR

        if (isEmpty(a) || fromIndex == toIndex) {
            return;
        }

        if (fromIndex <= toIndex) {
            for (int i = fromIndex; i < toIndex; i++) {
                action.accept(i, a[i]);
            }
        } else {
            for (int i = min(a.length - 1, fromIndex); i > toIndex; i--) {
                action.accept(i, a[i]);
            }
        }
    }

    /**
     * Executes the action for each element in the specified range of the collection with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
     * N.forEachIndexed(names, 1, 3, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 1: Bob, 2: Charlie
     *
     * // Reverse iteration
     * N.forEachIndexed(names, 2, 0, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 2: Charlie, 1: Bob
     * }</pre>
     *
     * <p>Note: For {@link java.util.List} with {@link java.util.RandomAccess}, uses optimized access; otherwise uses iterator-based access.
     *
     * @param <T> the type of elements in the collection
     * @param <E> the type of exception that the action may throw
     * @param c the collection to iterate
     * @param fromIndex the starting index (inclusive) of the range
     * @param toIndex the ending index (exclusive) of the range (if fromIndex &gt; toIndex, iterates in reverse)
     * @param action the action to execute, receiving index and element
     * @throws IndexOutOfBoundsException if the range is out of bounds
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Object[], int, int, Throwables.IntObjConsumer)
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer)
     */
    public static <T, E extends Exception> void forEachIndexed(final Collection<? extends T> c, int fromIndex, final int toIndex,
            final Throwables.IntObjConsumer<? super T, E> action) throws IndexOutOfBoundsException, E {
        checkFromToIndex(fromIndex < toIndex ? fromIndex : (toIndex == -1 ? 0 : toIndex), Math.max(fromIndex, toIndex), size(c));
        if ((isEmpty(c) && fromIndex == 0 && toIndex == 0) || fromIndex == toIndex) {
            return;
        }

        fromIndex = min(c.size() - 1, fromIndex);

        if (c instanceof List && c instanceof RandomAccess) {
            final List<T> list = (List<T>) c;

            if (fromIndex <= toIndex) {
                for (int i = fromIndex; i < toIndex; i++) {
                    action.accept(i, list.get(i));
                }
            } else {
                for (int i = fromIndex; i > toIndex; i--) {
                    action.accept(i, list.get(i));
                }
            }
        } else {
            if (fromIndex < toIndex) {
                final Iterator<? extends T> iter = c.iterator();
                int idx = 0;

                while (idx < fromIndex && iter.hasNext()) {
                    iter.next();
                    idx++;
                }

                while (iter.hasNext()) {
                    action.accept(idx, iter.next());

                    if (++idx >= toIndex) {
                        break;
                    }
                }
            } else {
                final Iterator<T> descendingIterator = getDescendingIteratorIfPossible(c);

                if (descendingIterator != null) {
                    int idx = c.size() - 1;

                    while (idx > fromIndex && descendingIterator.hasNext()) {
                        descendingIterator.next();
                        idx--;
                    }

                    while (descendingIterator.hasNext()) {
                        action.accept(idx, descendingIterator.next());

                        if (--idx <= toIndex) {
                            break;
                        }
                    }
                } else {
                    final Iterator<? extends T> iter = c.iterator();
                    int idx = 0;

                    while (idx <= toIndex && iter.hasNext()) {
                        iter.next();
                        idx++;
                    }

                    final T[] a = (T[]) new Object[fromIndex - toIndex];

                    while (iter.hasNext()) {
                        a[idx - 1 - toIndex] = iter.next();

                        if (idx++ >= fromIndex) {
                            break;
                        }
                    }

                    for (int i = a.length - 1; i >= 0; i--) {
                        action.accept(i + toIndex + 1, a[i]);
                    }
                }
            }
        }
    }

    /**
     * Executes the action for each element in the iterable with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
     * N.forEachIndexed(names, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 0: Alice, 1: Bob, 2: Charlie
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute, receiving index and element
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Object[], Throwables.IntObjConsumer)
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer)
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer, int)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> action) throws E {
        if (c == null) {
            return;
        }

        int idx = 0;

        for (final T e : c) {
            action.accept(idx++, e);
        }
    }

    /**
     * Executes the action for each element in the iterator with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", "Bob", "Charlie").iterator();
     * N.forEachIndexed(iter, (idx, name) ->
     *     System.out.println(idx + ": " + name));
     * // Prints: 0: Alice, 1: Bob, 2: Charlie
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param action the action to execute, receiving index and element
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer)
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer, int)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> action)
            throws E {
        if (iter == null) {
            return;
        }

        int idx = 0;

        while (iter.hasNext()) {
            action.accept(idx++, iter.next());
        }
    }

    /**
     * Executes the action for each entry in the map with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
     * N.forEachIndexed(ages, (idx, entry) ->
     *     System.out.println(idx + ": " + entry.getKey() + "=" + entry.getValue()));
     * // Prints entries with their indices
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param <E> the type of exception that the action may throw
     * @param map the map to iterate
     * @param action the action to execute, receiving index and entry
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Map, Throwables.IntBiObjConsumer)
     * @see #forEach(Map, Throwables.Consumer)
     */
    public static <K, V, E extends Exception> void forEachIndexed(final Map<K, V> map, final Throwables.IntObjConsumer<? super Map.Entry<K, V>, E> action)
            throws E {
        if (isEmpty(map)) {
            return;
        }

        forEachIndexed(map.entrySet(), action);
    }

    /**
     * Executes the action for each entry in the map with its index.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, Integer> ages = Map.of("Alice", 25, "Bob", 30);
     * N.forEachIndexed(ages, (idx, name, age) ->
     *     System.out.println(idx + ": " + name + " is " + age));
     * // Prints: 0: Alice is 25, 1: Bob is 30
     * }</pre>
     *
     * @param <K> the type of map keys
     * @param <V> the type of map values
     * @param <E> the type of exception that the action may throw
     * @param map the map to iterate
     * @param action the action to execute, receiving index, key, and value
     * @throws E if the action throws an exception
     * @see #forEachIndexed(Map, Throwables.IntObjConsumer)
     * @see #forEach(Map, Throwables.BiConsumer)
     */
    public static <K, V, E extends Exception> void forEachIndexed(final Map<K, V> map, final Throwables.IntBiObjConsumer<? super K, ? super V, E> action)
            throws E {
        if (isEmpty(map)) {
            return;
        }

        int idx = 0;

        for (final Map.Entry<K, V> entry : map.entrySet()) {
            action.accept(idx++, entry.getKey(), entry.getValue());
        }
    }

    /**
     * Executes the action for each element in the iterable with its index using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> urls = Arrays.asList("http://a.com", "http://b.com", "http://c.com");
     * N.forEachIndexed(urls, (idx, url) ->
     *     System.out.println(idx + ": " + fetchData(url)), 2);
     * // Processes URLs in parallel using 2 threads with indices
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute, receiving index and element
     * @param processThreadNum the number of threads for parallel processing
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer, int, Executor)
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer)
     * @see #forEach(Iterable, Throwables.Consumer, int)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> action,
            final int processThreadNum) {
        forEachIndexed(c, action, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the action for each element in the iterable with its index using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> urls = Arrays.asList("http://a.com", "http://b.com", "http://c.com");
     * ExecutorService executor = Executors.newFixedThreadPool(2);
     * N.forEachIndexed(urls, (idx, url) ->
     *     System.out.println(idx + ": " + fetchData(url)), 2, executor);
     * // Processes URLs in parallel using custom executor with indices
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute, receiving index and element
     * @param processThreadNum the number of threads for parallel processing
     * @param executor the executor to use for parallel processing
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer, int)
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer, int, Executor)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterable<? extends T> c, final Throwables.IntObjConsumer<? super T, E> action,
            final int processThreadNum, final Executor executor) {
        final int size = c instanceof Collection ? ((Collection<T>) c).size() : Integer.MAX_VALUE;

        forEachIndexed(c == null ? ObjIterator.<T> empty() : c.iterator(), action, N.min(size, processThreadNum), executor);
    }

    /**
     * Executes the action for each element in the iterator with its index using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = getUrlIterator();
     * N.forEachIndexed(iter, (idx, url) ->
     *     System.out.println(idx + ": " + fetchData(url)), 2);
     * // Processes iterator elements in parallel using 2 threads with indices
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param elementConsumer the action to execute, receiving index and element
     * @param processThreadNum the number of threads for parallel processing
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer, int, Executor)
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum) {
        forEachIndexed(iter, elementConsumer, processThreadNum, N.ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes the action for each element in the iterator with its index using parallel processing.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = getUrlIterator();
     * ExecutorService executor = Executors.newFixedThreadPool(2);
     * N.forEachIndexed(iter, (idx, url) ->
     *     System.out.println(idx + ": " + fetchData(url)), 2, executor);
     * // Processes iterator elements in parallel using custom executor with indices
     * }</pre>
     *
     * <p>Note: Indices are assigned atomically in the order elements are retrieved from the iterator.
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param elementConsumer the action to execute, receiving index and element
     * @param processThreadNum the number of threads for parallel processing
     * @param executor the executor to use for parallel processing
     * @throws IllegalArgumentException if processThreadNum is invalid
     * @see #forEachIndexed(Iterator, Throwables.IntObjConsumer, int)
     * @see #forEachIndexed(Iterable, Throwables.IntObjConsumer, int, Executor)
     */
    public static <T, E extends Exception> void forEachIndexed(final Iterator<? extends T> iter, final Throwables.IntObjConsumer<? super T, E> elementConsumer,
            final int processThreadNum, final Executor executor) throws IllegalArgumentException {
        final Iterator<? extends T> iteratorII = iter == null ? ObjIterator.empty() : iter;
        final CountDownLatch countDownLatch = new CountDownLatch(processThreadNum);
        final AtomicInteger index = new AtomicInteger(0);
        final Holder<Exception> errorHolder = new Holder<>();

        for (int i = 0; i < processThreadNum; i++) {
            executor.execute(() -> {
                int idx = 0;
                T element = null;

                try {
                    while (errorHolder.value() == null) {
                        synchronized (iteratorII) {
                            if (iteratorII.hasNext()) {
                                idx = index.getAndIncrement();
                                element = iteratorII.next();
                            } else {
                                break;
                            }
                        }

                        elementConsumer.accept(idx, element);
                    }
                } catch (final Exception e) {
                    synchronized (errorHolder) {
                        if (errorHolder.value() == null) {
                            errorHolder.setValue(e);
                        } else {
                            errorHolder.value().addSuppressed(e);
                        }
                    }
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (final InterruptedException e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }

        if (errorHolder.value() != null) {
            throw ExceptionUtil.toRuntimeException(errorHolder.value(), true);
        }
    }

    /**
     * Executes the action for each pair of consecutive elements in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"Alice", "Bob", "Charlie", "David"};
     * N.forEachPair(names, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: Alice -> Bob, Bob -> Charlie, Charlie -> David
     *
     * // With odd length
     * String[] values = {"A", "B", "C"};
     * N.forEachPair(values, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: A -> B, B -> C, C -> null
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param action the action to execute, receiving consecutive element pairs (last element paired with {@code null} if odd length)
     * @throws E if the action throws an exception
     * @see #forEachPair(Object[], int, Throwables.BiConsumer)
     * @see #forEachPair(Iterable, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final T[] a, final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        forEachPair(a, 1, action);
    }

    /**
     * Executes the action for each pair of elements in the array with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"A", "B", "C", "D", "E", "F"};
     * N.forEachPair(names, 2, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: A -> B, C -> D, E -> F (non-overlapping pairs)
     *
     * String[] values = {"A", "B", "C", "D", "E"};
     * N.forEachPair(values, 3, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: A -> B, D -> E (pairs with stride 3)
     * }</pre>
     *
     * <p>Note: With increment=1, pairs are consecutive. With increment=2, pairs are non-overlapping. Last unpaired element is paired with {@code null}.
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param increment the increment between starting points of consecutive pairs (must be positive)
     * @param action the action to execute, receiving element pairs
     * @throws E if the action throws an exception
     * @see #forEachPair(Object[], Throwables.BiConsumer)
     * @see #forEachPair(Iterable, int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final T[] a, final int increment, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        checkArgPositive(increment, cs.increment);

        if (isEmpty(a)) {
            return;
        }

        final Iterator<? extends T> iter = ObjIterator.of(a);
        forEachPair(iter, increment, action);
    }

    /**
     * Executes the action for each pair of consecutive elements in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
     * N.forEachPair(names, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: Alice -> Bob, Bob -> Charlie, Charlie -> David
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute, receiving consecutive element pairs (last element paired with {@code null} if odd length)
     * @throws E if the action throws an exception
     * @see #forEachPair(Iterable, int, Throwables.BiConsumer)
     * @see #forEachPair(Object[], Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final Iterable<? extends T> c, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        forEachPair(c, 1, action);
    }

    /**
     * Executes the action for each pair of elements in the iterable with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("A", "B", "C", "D", "E", "F");
     * N.forEachPair(names, 2, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: A -> B, C -> D, E -> F (non-overlapping pairs)
     * }</pre>
     *
     * <p>Note: With increment=1, pairs are consecutive. With increment=2, pairs are non-overlapping. Last unpaired element is paired with {@code null}.
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param increment the increment between starting points of consecutive pairs (must be positive)
     * @param action the action to execute, receiving element pairs
     * @throws E if the action throws an exception
     * @see #forEachPair(Iterable, Throwables.BiConsumer)
     * @see #forEachPair(Iterator, int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final Iterable<? extends T> c, final int increment,
            final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        checkArgPositive(increment, cs.increment);

        if (isEmptyCollection(c)) {
            return;
        }

        final Iterator<? extends T> iter = c.iterator();
        forEachPair(iter, increment, action);
    }

    /**
     * Executes the action for each pair of consecutive elements in the iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("Alice", "Bob", "Charlie", "David").iterator();
     * N.forEachPair(iter, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: Alice -> Bob, Bob -> Charlie, Charlie -> David
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param action the action to execute, receiving consecutive element pairs (last element paired with {@code null} if odd length)
     * @throws E if the action throws an exception
     * @see #forEachPair(Iterator, int, Throwables.BiConsumer)
     * @see #forEachPair(Iterable, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final Iterator<? extends T> iter, final Throwables.BiConsumer<? super T, ? super T, E> action)
            throws E {
        forEachPair(iter, 1, action);
    }

    /**
     * Executes the action for each pair of elements in the iterator with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("A", "B", "C", "D", "E", "F").iterator();
     * N.forEachPair(iter, 2, (first, second) ->
     *     System.out.println(first + " -> " + second));
     * // Prints: A -> B, C -> D, E -> F (non-overlapping pairs)
     * }</pre>
     *
     * <p>Note: With increment=1, pairs are consecutive. With increment=2, pairs are non-overlapping. Last unpaired element is paired with {@code null}.
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param increment the increment between starting points of consecutive pairs (must be positive)
     * @param action the action to execute, receiving element pairs
     * @throws E if the action throws an exception
     * @see #forEachPair(Iterator, Throwables.BiConsumer)
     * @see #forEachPair(Iterable, int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachPair(final Iterator<? extends T> iter, final int increment,
            final Throwables.BiConsumer<? super T, ? super T, E> action) throws E {
        final int windowSize = 2;
        checkArgPositive(increment, cs.increment);

        if (iter == null) {
            return;
        }

        boolean isFirst = true;
        T prev = null;

        while (iter.hasNext()) {
            if (increment > windowSize && !isFirst) {
                int skipNum = increment - windowSize;

                while (skipNum-- > 0 && iter.hasNext()) {
                    iter.next();
                }

                if (!iter.hasNext()) {
                    break;
                }
            }

            if (increment == 1) {
                action.accept(isFirst ? iter.next() : prev, (prev = (iter.hasNext() ? iter.next() : null)));
            } else {
                action.accept(iter.next(), iter.hasNext() ? iter.next() : null);
            }

            isFirst = false;
        }
    }

    /**
     * Executes the action for each triple of consecutive elements in the array.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"A", "B", "C", "D", "E"};
     * N.forEachTriple(names, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, B-C-D, C-D-E, D-E-null, E-null-null
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param action the action to execute, receiving consecutive element triples (missing elements replaced with {@code null})
     * @throws E if the action throws an exception
     * @see #forEachTriple(Object[], int, Throwables.TriConsumer)
     * @see #forEachPair(Object[], Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final T[] a, final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(a, 1, action);
    }

    /**
     * Executes the action for each triple of elements in the array with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] names = {"A", "B", "C", "D", "E", "F"};
     * N.forEachTriple(names, 3, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, D-E-F (non-overlapping triples)
     * }</pre>
     *
     * <p>Note: With increment=1, triples are consecutive (overlap by 2). With increment=3, triples are non-overlapping. Missing elements replaced with {@code null}.
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to iterate
     * @param increment the increment between starting points of consecutive triples (must be positive)
     * @param action the action to execute, receiving element triples
     * @throws E if the action throws an exception
     * @see #forEachTriple(Object[], Throwables.TriConsumer)
     * @see #forEachPair(Object[], int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final T[] a, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        checkArgPositive(increment, cs.increment);

        if (isEmpty(a)) {
            return;
        }

        final Iterator<? extends T> iter = ObjIterator.of(a);
        forEachTriple(iter, increment, action);
    }

    /**
     * Executes the action for each triple of consecutive elements in the iterable.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("A", "B", "C", "D", "E");
     * N.forEachTriple(names, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, B-C-D, C-D-E, D-E-null, E-null-null
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param action the action to execute, receiving consecutive element triples (missing elements replaced with {@code null})
     * @throws E if the action throws an exception
     * @see #forEachTriple(Iterable, int, Throwables.TriConsumer)
     * @see #forEachPair(Iterable, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final Iterable<? extends T> c,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(c, 1, action);
    }

    /**
     * Executes the action for each triple of elements in the iterable with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> names = Arrays.asList("A", "B", "C", "D", "E", "F");
     * N.forEachTriple(names, 3, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, D-E-F (non-overlapping triples)
     * }</pre>
     *
     * <p>Note: With increment=1, triples are consecutive (overlap by 2). With increment=3, triples are non-overlapping. Missing elements replaced with {@code null}.
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param c the iterable to iterate
     * @param increment the increment between starting points of consecutive triples (must be positive)
     * @param action the action to execute, receiving element triples
     * @throws E if the action throws an exception
     * @see #forEachTriple(Iterable, Throwables.TriConsumer)
     * @see #forEachPair(Iterable, int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final Iterable<? extends T> c, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        checkArgPositive(increment, cs.increment);

        if (c == null) {
            return;
        }

        final Iterator<? extends T> iter = c.iterator();
        forEachTriple(iter, increment, action);
    }

    /**
     * Executes the action for each triple of consecutive elements in the iterator.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("A", "B", "C", "D", "E").iterator();
     * N.forEachTriple(iter, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, B-C-D, C-D-E, D-E-null, E-null-null
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param action the action to execute, receiving consecutive element triples (missing elements replaced with {@code null})
     * @throws E if the action throws an exception
     * @see #forEachTriple(Iterator, int, Throwables.TriConsumer)
     * @see #forEachPair(Iterator, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final Iterator<? extends T> iter,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        forEachTriple(iter, 1, action);
    }

    /**
     * Executes the action for each triple of elements in the iterator with the specified increment.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("A", "B", "C", "D", "E", "F").iterator();
     * N.forEachTriple(iter, 3, (first, second, third) ->
     *     System.out.println(first + "-" + second + "-" + third));
     * // Prints: A-B-C, D-E-F (non-overlapping triples)
     * }</pre>
     *
     * <p>Note: With increment=1, triples are consecutive (overlap by 2). With increment=3, triples are non-overlapping. Missing elements replaced with {@code null}.
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to iterate
     * @param increment the increment between starting points of consecutive triples (must be positive)
     * @param action the action to execute, receiving element triples
     * @throws E if the action throws an exception
     * @see #forEachTriple(Iterator, Throwables.TriConsumer)
     * @see #forEachPair(Iterator, int, Throwables.BiConsumer)
     */
    public static <T, E extends Exception> void forEachTriple(final Iterator<? extends T> iter, final int increment,
            final Throwables.TriConsumer<? super T, ? super T, ? super T, E> action) throws E {
        final int windowSize = 3;
        checkArgPositive(increment, cs.increment);

        if (iter == null) {
            return;
        }

        boolean isFirst = true;
        T prev = null;
        T prev2 = null;

        while (iter.hasNext()) {
            if (increment > windowSize && !isFirst) {
                int skipNum = increment - windowSize;

                while (skipNum-- > 0 && iter.hasNext()) {
                    iter.next();
                }

                if (!iter.hasNext()) {
                    break;
                }
            }

            if (increment == 1) {
                action.accept(isFirst ? iter.next() : prev2, (prev2 = (isFirst ? (iter.hasNext() ? iter.next() : null) : prev)),
                        (prev = (iter.hasNext() ? iter.next() : null)));
            } else if (increment == 2) {
                action.accept(isFirst ? iter.next() : prev, iter.hasNext() ? iter.next() : null, (prev = (iter.hasNext() ? iter.next() : null)));
            } else {
                action.accept(iter.next(), iter.hasNext() ? iter.next() : null, iter.hasNext() ? iter.next() : null);
            }

            isFirst = false;
        }
    }

    /**
     * Executes the command with retry logic on failure.
     * Retries up to the specified number of times with the given interval between attempts.
     * The retry condition determines whether to retry based on the caught exception.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.execute(() -> sendRequest(),
     *     3,
     *     1000,
     *     e -> e instanceof IOException);
     * // Retries up to 3 times with 1 second interval if IOException occurs
     * }</pre>
     *
     * @param cmd the command to execute
     * @param retryTimes the number of retry attempts if execution fails
     * @param retryIntervalInMillis the interval in milliseconds between retries
     * @param retryCondition the condition checked after failure to decide whether to retry
     * @throws RuntimeException if execution fails and no more retries are allowed
     * @see #execute(Callable, int, long, BiPredicate)
     * @see #asyncExecute(Throwables.Runnable, int, long, Predicate)
     * @see Retry#of(int, long, Predicate)
     */
    public static void execute(final Throwables.Runnable<? extends Exception> cmd, final int retryTimes, final long retryIntervalInMillis,
            final Predicate<? super Exception> retryCondition) {
        try {
            Retry.of(retryTimes, retryIntervalInMillis, retryCondition).run(cmd);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }
    }

    /**
     * Executes the command with retry logic on failure and returns the result.
     * Retries up to the specified number of times with the given interval between attempts.
     * The retry condition determines whether to retry based on the result and/or caught exception.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.execute(() -> fetchData(),
     *     3,
     *     1000,
     *     (r, e) -> r == null || e instanceof IOException);
     * // Retries up to 3 times with 1 second interval if result is null or IOException occurs
     * }</pre>
     *
     * @param <R> the type of result returned by the command
     * @param cmd the command to execute
     * @param retryTimes the number of retry attempts if execution fails
     * @param retryIntervalInMillis the interval in milliseconds between retries
     * @param retryCondition the condition checked after each attempt to decide whether to retry
     * @return the result returned by the callable task
     * @throws RuntimeException if execution fails and no more retries are allowed
     * @see #execute(Throwables.Runnable, int, long, Predicate)
     * @see #asyncExecute(Callable, int, long, BiPredicate)
     * @see Retry#of(int, long, BiPredicate)
     */
    public static <R> R execute(final Callable<R> cmd, final int retryTimes, final long retryIntervalInMillis,
            final BiPredicate<? super R, ? super Exception> retryCondition) {
        try {
            final Retry<R> retry = Retry.of(retryTimes, retryIntervalInMillis, retryCondition);
            return retry.call(cmd);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }
    }

    /**
     * Executes the command asynchronously using the default executor.
     * Returns immediately with a future that completes when the command finishes.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<Void> future = N.asyncExecute(() -> processData());
     * // Command runs asynchronously, can continue with other work
     * future.get(); // Wait for completion if needed
     * }</pre>
     *
     * @param command the command to execute asynchronously
     * @return a future representing the pending completion of the task
     * @see #asyncExecute(Throwables.Runnable, Executor)
     * @see #asyncExecute(Callable)
     * @see #execute(Throwables.Runnable, int, long, Predicate)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command) {
        return ASYNC_EXECUTOR.execute(command);
    }

    /**
     * Executes the command asynchronously using the specified executor.
     * Returns immediately with a future that completes when the command finishes.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(2);
     * ContinuableFuture<Void> future = N.asyncExecute(() -> processData(), executor);
     * // Command runs asynchronously on the specified executor
     * }</pre>
     *
     * @param command the command to execute asynchronously
     * @param executor the executor to use for execution
     * @return a future representing the pending completion of the task
     * @see #asyncExecute(Throwables.Runnable)
     * @see #asyncExecute(Callable, Executor)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command, final Executor executor) {
        return ContinuableFuture.run(command, executor);
    }

    /**
     * Executes the command asynchronously after the specified delay.
     * Returns immediately with a future that completes when the command finishes.
     * Uses a scheduled executor to introduce the delay before execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<Void> future = N.asyncExecute(() -> sendEmail(), 5000);
     * // Command runs after 5 seconds
     * }</pre>
     *
     * @param command the command to execute asynchronously
     * @param delayInMillis the delay in milliseconds before execution
     * @return a future representing the pending completion of the task
     * @see #asyncExecute(Throwables.Runnable)
     * @see #asyncExecute(Callable, long)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> command, final long delayInMillis) {
        return new ContinuableFuture<>(SCHEDULED_EXECUTOR.schedule(() -> {
            command.run();
            return null;
        }, delayInMillis, TimeUnit.MILLISECONDS));
    }

    /**
     * Executes the command asynchronously using the default executor and returns the result.
     * Returns immediately with a future that completes with the command's result.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<String> future = N.asyncExecute(() -> fetchData());
     * // Command runs asynchronously, can continue with other work
     * String result = future.get(); // Wait for and retrieve the result
     * }</pre>
     *
     * @param <R> the type of result returned by the command
     * @param command the command to execute asynchronously
     * @return a future representing the pending result
     * @see #asyncExecute(Callable, Executor)
     * @see #asyncExecute(Throwables.Runnable)
     * @see #execute(Callable, int, long, BiPredicate)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command) {
        return ASYNC_EXECUTOR.execute(command);
    }

    /**
     * Executes the command asynchronously using the specified executor and returns the result.
     * Returns immediately with a future that completes with the command's result.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(2);
     * ContinuableFuture<String> future = N.asyncExecute(() -> fetchData(), executor);
     * // Command runs asynchronously on the specified executor
     * String result = future.get();
     * }</pre>
     *
     * @param <R> the type of result returned by the command
     * @param command the command to execute asynchronously
     * @param executor the executor to use for execution
     * @return a future representing the pending result
     * @see #asyncExecute(Callable)
     * @see #asyncExecute(Throwables.Runnable, Executor)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command, final Executor executor) {
        return ContinuableFuture.call(command, executor);
    }

    /**
     * Executes the command asynchronously after the specified delay and returns the result.
     * Returns immediately with a future that completes with the command's result.
     * Uses a scheduled executor to introduce the delay before execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<String> future = N.asyncExecute(() -> fetchData(), 5000);
     * // Command runs after 5 seconds
     * String result = future.get();
     * }</pre>
     *
     * @param <R> the type of result returned by the command
     * @param command the command to execute asynchronously
     * @param delayInMillis the delay in milliseconds before execution
     * @return a future representing the pending result
     * @see #asyncExecute(Callable)
     * @see #asyncExecute(Throwables.Runnable, long)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> command, final long delayInMillis) {
        return new ContinuableFuture<>(SCHEDULED_EXECUTOR.schedule(command, delayInMillis, TimeUnit.MILLISECONDS));
    }

    /**
     * Executes the command asynchronously with retry logic on failure.
     * Returns immediately with a future that completes when the command succeeds or retries are exhausted.
     * Retries up to the specified number of times with the given interval between attempts.
     * The retry condition determines whether to retry based on the caught exception.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<Void> future = N.asyncExecute(
     *     () -> sendRequest(),
     *     3,
     *     1000,
     *     e -> e instanceof IOException);
     * // Asynchronously retries up to 3 times with 1 second interval if IOException occurs
     * }</pre>
     *
     * @param cmd the command to execute asynchronously
     * @param retryTimes the number of retry attempts if execution fails
     * @param retryIntervalInMillisInMillis the interval in milliseconds between retries
     * @param retryCondition the condition checked after failure to decide whether to retry
     * @return a future representing the pending completion of the task
     * @see #asyncExecute(Throwables.Runnable)
     * @see #execute(Throwables.Runnable, int, long, Predicate)
     * @see #asyncExecute(Callable, int, long, BiPredicate)
     */
    public static ContinuableFuture<Void> asyncExecute(final Throwables.Runnable<? extends Exception> cmd, final int retryTimes,
            final long retryIntervalInMillisInMillis, final Predicate<? super Exception> retryCondition) {
        return ASYNC_EXECUTOR.execute(() -> {
            Retry.of(retryTimes, retryIntervalInMillisInMillis, retryCondition).run(cmd);
            return null;
        });
    }

    /**
     * Executes the command asynchronously with retry logic on failure and returns the result.
     * Returns immediately with a future that completes with the command's result or when retries are exhausted.
     * Retries up to the specified number of times with the given interval between attempts.
     * The retry condition determines whether to retry based on the result and/or caught exception.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ContinuableFuture<String> future = N.asyncExecute(
     *     () -> fetchData(),
     *     3,
     *     1000,
     *     (r, e) -> r == null || e instanceof IOException);
     * // Asynchronously retries up to 3 times with 1 second interval
     * String result = future.get();
     * }</pre>
     *
     * @param <R> the type of result returned by the command
     * @param cmd the command to execute asynchronously
     * @param retryTimes the number of retry attempts if execution fails
     * @param retryIntervalInMillisInMillis the interval in milliseconds between retries
     * @param retryCondition the condition checked after each attempt to decide whether to retry
     * @return a future representing the pending result
     * @see #asyncExecute(Callable)
     * @see #execute(Callable, int, long, BiPredicate)
     * @see #asyncExecute(Throwables.Runnable, int, long, Predicate)
     */
    public static <R> ContinuableFuture<R> asyncExecute(final Callable<R> cmd, final int retryTimes, final long retryIntervalInMillisInMillis,
            final BiPredicate<? super R, ? super Exception> retryCondition) {
        return ASYNC_EXECUTOR.execute(() -> {
            final Retry<R> retry = Retry.of(retryTimes, retryIntervalInMillisInMillis, retryCondition);
            return retry.call(cmd);
        });
    }

    /**
     * Executes a list of commands asynchronously using the default executor.
     * Returns immediately with a list of futures that complete as each command finishes.
     * Each command runs independently and can complete at different times.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * List<ContinuableFuture<Void>> futures = N.asyncExecute(tasks);
     * // All tasks run asynchronously in parallel
     * }</pre>
     *
     * @param commands the list of commands to execute asynchronously
     * @return a list of futures representing the pending completion of each command
     * @see #asyncExecute(List, Executor)
     * @see #asyncExecute(Throwables.Runnable)
     */
    public static List<ContinuableFuture<Void>> asyncExecute(final List<? extends Throwables.Runnable<? extends Exception>> commands) {
        return ASYNC_EXECUTOR.execute(commands);
    }

    /**
     * Executes a list of commands asynchronously using the specified executor.
     * Returns immediately with a list of futures that complete as each command finishes.
     * Each command runs independently and can complete at different times.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * List<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * List<ContinuableFuture<Void>> futures = N.asyncExecute(tasks, executor);
     * // All tasks run asynchronously using the specified executor
     * }</pre>
     *
     * @param commands the list of commands to execute asynchronously
     * @param executor the executor to use for execution
     * @return a list of futures representing the pending completion of each command
     * @see #asyncExecute(List)
     * @see #asyncExecute(Throwables.Runnable, Executor)
     */
    public static List<ContinuableFuture<Void>> asyncExecute(final List<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final List<ContinuableFuture<Void>> results = new ArrayList<>(commands.size());

        for (final Throwables.Runnable<? extends Exception> cmd : commands) {
            results.add(ContinuableFuture.run(cmd, executor));
        }

        return results;
    }

    /**
     * Executes a collection of commands asynchronously using the default executor and returns results.
     * Returns immediately with a list of futures that complete with each command's result.
     * Each command runs independently and can complete at different times.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * List<ContinuableFuture<String>> futures = N.asyncExecute(tasks);
     * // All tasks run asynchronously in parallel
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute asynchronously
     * @return a list of futures representing the pending results
     * @see #asyncExecute(Collection, Executor)
     * @see #asyncExecute(Callable)
     */
    public static <R> List<ContinuableFuture<R>> asyncExecute(final Collection<? extends Callable<R>> commands) {
        return ASYNC_EXECUTOR.execute(commands);
    }

    /**
     * Executes a collection of commands asynchronously using the specified executor and returns results.
     * Returns immediately with a list of futures that complete with each command's result.
     * Each command runs independently and can complete at different times.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * List<ContinuableFuture<String>> futures = N.asyncExecute(tasks, executor);
     * // All tasks run asynchronously using the specified executor
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute asynchronously
     * @param executor the executor to use for execution
     * @return a list of futures representing the pending results
     * @see #asyncExecute(Collection)
     * @see #asyncExecute(Callable, Executor)
     */
    public static <R> List<ContinuableFuture<R>> asyncExecute(final Collection<? extends Callable<R>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final List<ContinuableFuture<R>> results = new ArrayList<>(commands.size());

        for (final Callable<R> cmd : commands) {
            results.add(ContinuableFuture.call(cmd, executor));
        }

        return results;
    }

    /**
     * Executes commands asynchronously using the default executor and returns an iterator for lazy result iteration.
     * Returns immediately with an iterator that yields results in completion order (fastest command first).
     * If an error occurs in a command, iteration is interrupted and the error is thrown.
     * Other commands continue running and are not canceled.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * ObjIterator<Void> results = N.asynRun(tasks);
     * // Iterate results as they complete (fastest first)
     * while (results.hasNext()) {
     *     results.next();
     * }
     * }</pre>
     *
     * @param commands the collection of commands to execute asynchronously
     * @return an iterator yielding results in completion order
     * @see #asynRun(Collection, Executor)
     * @see #asynCall(Collection)
     * @see #asyncExecute(List)
     */
    public static ObjIterator<Void> asynRun(final Collection<? extends Throwables.Runnable<? extends Exception>> commands) {
        return asynRun(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes commands asynchronously using the specified executor and returns an iterator for lazy result iteration.
     * Returns immediately with an iterator that yields results in completion order (fastest command first).
     * If an error occurs in a command, iteration is interrupted and the error is thrown.
     * Other commands continue running and are not canceled.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * Collection<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * ObjIterator<Void> results = N.asynRun(tasks, executor);
     * // Iterate results as they complete (fastest first)
     * while (results.hasNext()) {
     *     results.next();
     * }
     * }</pre>
     *
     * @param commands the collection of commands to execute asynchronously
     * @param executor the executor to use for execution
     * @return an iterator yielding results in completion order
     * @see #asynRun(Collection)
     * @see #asynCall(Collection, Executor)
     */
    public static ObjIterator<Void> asynRun(final Collection<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return ObjIterator.empty();
        }

        final int cmdCount = commands.size();
        final List<FutureTask<Object>> futures = new LinkedList<>();
        final ArrayBlockingQueue<Object> queue = new ArrayBlockingQueue<>(cmdCount);

        for (final Throwables.Runnable<? extends Exception> cmd : commands) {
            final FutureTask<Object> futureTask = new FutureTask<>(() -> {
                cmd.run();

                queue.add(NULL_MASK);

                return null;
            });

            executor.execute(futureTask);

            futures.add(futureTask);
        }

        return new ObjIterator<>() {
            @Override
            public boolean hasNext() {
                if (queue.size() > 0) {
                    return true;
                }

                while (true) {
                    final Iterator<FutureTask<Object>> iter = futures.iterator();

                    while (iter.hasNext()) {
                        final FutureTask<Object> future = iter.next();

                        if (future.isDone()) {
                            try {
                                future.get();
                            } catch (InterruptedException | ExecutionException e) {
                                // cause inconsistent if iterate result or not. Secondly, asynchronized execution should not impact each other.
                                //    while (iter.hasNext()) {
                                //        iter.next().cancel(false);
                                //    }

                                throw ExceptionUtil.toRuntimeException(e, true);
                            }

                            iter.remove();

                            if (queue.size() > 0) {
                                return true;
                            }
                        }
                    }

                    if (queue.size() > 0) {
                        return true;
                    }

                    if (futures.size() == 0) {
                        break;
                    }

                    sleepUninterruptibly(1);
                }

                //noinspection ConstantValue
                return queue.size() > 0;
            }

            @Override
            public Void next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                queue.poll();

                return null;
            }
        };
    }

    /**
     * Executes commands asynchronously using the default executor and returns an iterator for lazy result iteration.
     * Returns immediately with an iterator that yields results in completion order (fastest command first).
     * Each result is returned as commands complete.
     * If an error occurs in a command, iteration is interrupted and the error is thrown.
     * Other commands continue running and are not canceled.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * ObjIterator<String> results = N.asynCall(tasks);
     * // Iterate results as they complete (fastest first)
     * while (results.hasNext()) {
     *     String result = results.next();
     *     System.out.println(result);
     * }
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute asynchronously
     * @return an iterator yielding results in completion order
     * @see #asynCall(Collection, Executor)
     * @see #asynRun(Collection)
     * @see #asyncExecute(Collection)
     */
    public static <R> ObjIterator<R> asynCall(final Collection<? extends Callable<? extends R>> commands) {
        return asynCall(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes commands asynchronously using the specified executor and returns an iterator for lazy result iteration.
     * Returns immediately with an iterator that yields results in completion order (fastest command first).
     * Each result is returned as commands complete.
     * If an error occurs in a command, iteration is interrupted and the error is thrown.
     * Other commands continue running and are not canceled.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * ObjIterator<String> results = N.asynCall(tasks, executor);
     * // Iterate results as they complete (fastest first)
     * while (results.hasNext()) {
     *     String result = results.next();
     *     System.out.println(result);
     * }
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute asynchronously
     * @param executor the executor to use for execution
     * @return an iterator yielding results in completion order
     * @throws IllegalArgumentException if the executor is invalid
     * @see #asynCall(Collection)
     * @see #asynRun(Collection, Executor)
     */
    public static <R> ObjIterator<R> asynCall(final Collection<? extends Callable<? extends R>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return ObjIterator.empty();
        }

        final int cmdCount = commands.size();
        final List<FutureTask<R>> futures = new LinkedList<>();
        final ArrayBlockingQueue<R> queue = new ArrayBlockingQueue<>(cmdCount);
        final R none = (R) NULL_MASK;

        for (final Callable<? extends R> cmd : commands) {
            final FutureTask<R> futureTask = new FutureTask<>(() -> {
                final R ret = cmd.call();

                if (ret == null) {
                    queue.add(none);
                } else {
                    queue.add(ret);
                }

                return ret;
            });

            executor.execute(futureTask);

            futures.add(futureTask);
        }

        return new ObjIterator<>() {
            private R next = null;

            @Override
            public boolean hasNext() {
                if (queue.size() > 0) {
                    return true;
                }

                while (true) {
                    final Iterator<FutureTask<R>> iter = futures.iterator();

                    while (iter.hasNext()) {
                        final FutureTask<R> future = iter.next();

                        if (future.isDone()) {
                            try {
                                future.get();
                            } catch (InterruptedException | ExecutionException e) {
                                // Cause inconsistent if iterate result or not. Secondly, asynchronized execution should not impact each other.
                                //    while (iter.hasNext()) {
                                //        iter.next().cancel(false);
                                //    }

                                throw ExceptionUtil.toRuntimeException(e, true);
                            }

                            iter.remove();

                            if (queue.size() > 0) {
                                return true;
                            }
                        }
                    }

                    if (queue.size() > 0) {
                        return true;
                    }

                    if (futures.size() == 0) {
                        break;
                    }

                    sleepUninterruptibly(1);
                }

                //noinspection ConstantValue
                return queue.size() > 0;
            }

            @Override
            public R next() {
                if (!hasNext()) {
                    throw new NoSuchElementException(InternalUtil.ERROR_MSG_FOR_NO_SUCH_EX);
                }

                next = queue.poll();
                return next == none ? null : next;
            }
        };
    }

    /**
     * Executes two commands in parallel and waits for both to complete.
     * The first command runs in the current thread, the second in another thread.
     * If an error occurs in either command, cancels any unfinished commands.
     * Blocks until both commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runInParallel(
     *     () -> processFile1(),
     *     () -> processFile2()
     * );
     * // Both commands execute in parallel, method blocks until both complete
     * }</pre>
     *
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable, Throwables.Runnable)
     * @see #runInParallel(Collection)
     * @see #asyncExecute(List)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        boolean hasException = true;

        try {
            command.run();
            f2.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException && (!f2.isDone())) { // NOSONAR
                f2.cancel(false);
            }
        }
    }

    /**
     * Executes three commands in parallel and waits for all to complete.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runInParallel(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * // All three commands execute in parallel, method blocks until all complete
     * }</pre>
     *
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable)
     * @see #runInParallel(Collection)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }
            }
        }
    }

    /**
     * Executes four commands in parallel and waits for all to complete.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runInParallel(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3(),
     *     () -> processFile4()
     * );
     * // All four commands execute in parallel, method blocks until all complete
     * }</pre>
     *
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @param command4 the fourth command to execute in another thread
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable, Throwables.Runnable)
     * @see #runInParallel(Collection)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3, final Throwables.Runnable<? extends Exception> command4) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        final ContinuableFuture<Void> f4 = asyncExecute(command4);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();
            f4.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }

                if (!f4.isDone()) {
                    f4.cancel(false);
                }
            }
        }
    }

    /**
     * Executes five commands in parallel and waits for all to complete.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runInParallel(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3(),
     *     () -> processFile4(),
     *     () -> processFile5()
     * );
     * // All five commands execute in parallel, method blocks until all complete
     * }</pre>
     *
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @param command4 the fourth command to execute in another thread
     * @param command5 the fifth command to execute in another thread
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable, Throwables.Runnable, Throwables.Runnable)
     * @see #runInParallel(Collection)
     */
    public static void runInParallel(final Throwables.Runnable<? extends Exception> command, final Throwables.Runnable<? extends Exception> command2,
            final Throwables.Runnable<? extends Exception> command3, final Throwables.Runnable<? extends Exception> command4,
            final Throwables.Runnable<? extends Exception> command5) {
        final ContinuableFuture<Void> f2 = asyncExecute(command2);
        final ContinuableFuture<Void> f3 = asyncExecute(command3);
        final ContinuableFuture<Void> f4 = asyncExecute(command4);
        final ContinuableFuture<Void> f5 = asyncExecute(command5);
        boolean hasException = true;

        try {
            command.run();
            f2.get();
            f3.get();
            f4.get();
            f5.get();

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }

                if (!f4.isDone()) {
                    f4.cancel(false);
                }

                if (!f5.isDone()) {
                    f5.cancel(false);
                }
            }
        }
    }

    /**
     * Executes a collection of commands in parallel using the default executor and waits for all to complete.
     * The first command runs in the current thread, the remaining commands in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * N.runInParallel(tasks);
     * // All commands execute in parallel, method blocks until all complete
     * }</pre>
     *
     * @param commands the collection of commands to execute in parallel
     * @see #runInParallel(Collection, Executor)
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable)
     */
    public static void runInParallel(final Collection<? extends Throwables.Runnable<? extends Exception>> commands) {
        runInParallel(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes a collection of commands in parallel using the specified executor and waits for all to complete.
     * The first command runs in the current thread, the remaining commands using the provided executor.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     * Does nothing if the collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * Collection<Throwables.Runnable<Exception>> tasks = Arrays.asList(
     *     () -> processFile1(),
     *     () -> processFile2(),
     *     () -> processFile3()
     * );
     * N.runInParallel(tasks, executor);
     * // All commands execute in parallel using the specified executor
     * }</pre>
     *
     * @param commands the collection of commands to execute in parallel
     * @param executor the executor to use for parallel execution
     * @see #runInParallel(Collection)
     * @see #asyncExecute(List, Executor)
     */
    public static void runInParallel(final Collection<? extends Throwables.Runnable<? extends Exception>> commands, final Executor executor) {
        if (isEmpty(commands)) {
            return;
        }

        final int cmdSize = commands.size();
        final List<ContinuableFuture<Void>> futures = new ArrayList<>(cmdSize - 1);
        boolean hasException = true;

        try {
            final Iterator<? extends Throwables.Runnable<? extends Exception>> iter = commands.iterator();
            final Throwables.Runnable<? extends Exception> firstCommand = iter.next();

            while (iter.hasNext()) {
                futures.add(asyncExecute(iter.next(), executor));
            }

            firstCommand.run();

            for (final ContinuableFuture<Void> f : futures) {
                f.get();
            }

            hasException = false;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                for (final ContinuableFuture<Void> f : futures) {
                    if (!f.isDone()) {
                        f.cancel(false);
                    }
                }
            }
        }
    }

    /**
     * Executes two commands in parallel, waits for both to complete, and returns their results as a tuple.
     * The first command runs in the current thread, the second in another thread.
     * If an error occurs in either command, cancels any unfinished commands.
     * Blocks until both commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Tuple2<String, Integer> results = N.callInParallel(
     *     () -> fetchData(),
     *     () -> calculateTotal()
     * );
     * // Both commands execute in parallel, returns (data, total)
     * String data = results._1;
     * Integer total = results._2;
     * }</pre>
     *
     * @param <R> the type of result from the first command
     * @param <R2> the type of result from the second command
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @return a tuple containing the results of both commands
     * @see #callInParallel(Callable, Callable, Callable)
     * @see #runInParallel(Throwables.Runnable, Throwables.Runnable)
     */
    public static <R, R2> Tuple2<R, R2> callInParallel(final Callable<R> command, final Callable<R2> command2) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();

            hasException = false;

            return Tuple.of(r, r2);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException && (!f2.isDone())) { // NOSONAR
                f2.cancel(false);
            }
        }
    }

    /**
     * Executes three commands in parallel, waits for all to complete, and returns their results as a tuple.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Tuple3<String, Integer, List<User>> results = N.callInParallel(
     *     () -> fetchData(),
     *     () -> calculateTotal(),
     *     () -> loadUsers()
     * );
     * // All three commands execute in parallel, returns (data, total, users)
     * String data = results._1;
     * Integer total = results._2;
     * List<User> users = results._3;
     * }</pre>
     *
     * @param <R> the type of result from the first command
     * @param <R2> the type of result from the second command
     * @param <R3> the type of result from the third command
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @return a tuple containing the results of all three commands
     * @see #callInParallel(Callable, Callable)
     * @see #callInParallel(Callable, Callable, Callable, Callable)
     */
    public static <R, R2, R3> Tuple3<R, R2, R3> callInParallel(final Callable<R> command, final Callable<R2> command2, final Callable<R3> command3) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();

            hasException = false;

            return Tuple.of(r, r2, r3);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }
            }
        }
    }

    /**
     * Executes four commands in parallel, waits for all to complete, and returns their results as a tuple.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Tuple4<String, Integer, List<User>, Boolean> results = N.callInParallel(
     *     () -> fetchData(),
     *     () -> calculateTotal(),
     *     () -> loadUsers(),
     *     () -> checkStatus()
     * );
     * // All four commands execute in parallel
     * String data = results._1;
     * Integer total = results._2;
     * List<User> users = results._3;
     * Boolean status = results._4;
     * }</pre>
     *
     * @param <R> the type of result from the first command
     * @param <R2> the type of result from the second command
     * @param <R3> the type of result from the third command
     * @param <R4> the type of result from the fourth command
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @param command4 the fourth command to execute in another thread
     * @return a tuple containing the results of all four commands
     * @see #callInParallel(Callable, Callable, Callable)
     * @see #callInParallel(Callable, Callable, Callable, Callable, Callable)
     */
    public static <R, R2, R3, R4> Tuple4<R, R2, R3, R4> callInParallel(final Callable<R> command, final Callable<R2> command2, final Callable<R3> command3,
            final Callable<R4> command4) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        final ContinuableFuture<R4> f4 = asyncExecute(command4);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();
            final R4 r4 = f4.get();

            hasException = false;

            return Tuple.of(r, r2, r3, r4);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }

                if (!f4.isDone()) {
                    f4.cancel(false);
                }
            }
        }
    }

    /**
     * Executes five commands in parallel, waits for all to complete, and returns their results as a tuple.
     * The first command runs in the current thread, the others in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Tuple5<String, Integer, List<User>, Boolean, Double> results = N.callInParallel(
     *     () -> fetchData(),
     *     () -> calculateTotal(),
     *     () -> loadUsers(),
     *     () -> checkStatus(),
     *     () -> computeAverage()
     * );
     * // All five commands execute in parallel
     * }</pre>
     *
     * @param <R> the type of result from the first command
     * @param <R2> the type of result from the second command
     * @param <R3> the type of result from the third command
     * @param <R4> the type of result from the fourth command
     * @param <R5> the type of result from the fifth command
     * @param command the first command to execute in the current thread
     * @param command2 the second command to execute in another thread
     * @param command3 the third command to execute in another thread
     * @param command4 the fourth command to execute in another thread
     * @param command5 the fifth command to execute in another thread
     * @return a tuple containing the results of all five commands
     * @see #callInParallel(Callable, Callable, Callable, Callable)
     * @see #callInParallel(Collection)
     */
    public static <R, R2, R3, R4, R5> Tuple5<R, R2, R3, R4, R5> callInParallel(final Callable<R> command, final Callable<R2> command2,
            final Callable<R3> command3, final Callable<R4> command4, final Callable<R5> command5) {
        final ContinuableFuture<R2> f2 = asyncExecute(command2);
        final ContinuableFuture<R3> f3 = asyncExecute(command3);
        final ContinuableFuture<R4> f4 = asyncExecute(command4);
        final ContinuableFuture<R5> f5 = asyncExecute(command5);
        boolean hasException = true;

        try {
            final R r = command.call();
            final R2 r2 = f2.get();
            final R3 r3 = f3.get();
            final R4 r4 = f4.get();
            final R5 r5 = f5.get();

            hasException = false;

            return Tuple.of(r, r2, r3, r4, r5);
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                if (!f2.isDone()) {
                    f2.cancel(false);
                }

                if (!f3.isDone()) {
                    f3.cancel(false);
                }

                if (!f4.isDone()) {
                    f4.cancel(false);
                }

                if (!f5.isDone()) {
                    f5.cancel(false);
                }
            }
        }
    }

    /**
     * Executes a collection of commands in parallel using the default executor and returns all results as a list.
     * The first command runs in the current thread, the remaining commands in separate threads.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     * Returns an empty list if the collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * List<String> results = N.callInParallel(tasks);
     * // All commands execute in parallel, returns list of results in order
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute in parallel
     * @return a list containing the results of all commands in the same order
     * @see #callInParallel(Collection, Executor)
     * @see #callInParallel(Callable, Callable)
     */
    public static <R> List<R> callInParallel(final Collection<? extends Callable<? extends R>> commands) {
        return callInParallel(commands, ASYNC_EXECUTOR.getExecutor());
    }

    /**
     * Executes a collection of commands in parallel using the specified executor and returns all results as a list.
     * The first command runs in the current thread, the remaining commands using the provided executor.
     * If an error occurs in any command, cancels all unfinished commands.
     * Blocks until all commands complete or an error occurs.
     * Returns an empty list if the collection is {@code null} or empty.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * ExecutorService executor = Executors.newFixedThreadPool(3);
     * Collection<Callable<String>> tasks = Arrays.asList(
     *     () -> fetchData1(),
     *     () -> fetchData2(),
     *     () -> fetchData3()
     * );
     * List<String> results = N.callInParallel(tasks, executor);
     * // All commands execute in parallel using the specified executor
     * }</pre>
     *
     * @param <R> the type of result returned by each command
     * @param commands the collection of commands to execute in parallel
     * @param executor the executor to use for parallel execution
     * @return a list containing the results of all commands in the same order
     * @throws IllegalArgumentException if the executor is invalid
     * @see #callInParallel(Collection)
     * @see #runInParallel(Collection, Executor)
     */
    public static <R> List<R> callInParallel(final Collection<? extends Callable<? extends R>> commands, final Executor executor)
            throws IllegalArgumentException {
        if (isEmpty(commands)) {
            return new ArrayList<>();
        }

        final int cmdSize = commands.size();
        final List<ContinuableFuture<? extends R>> futures = new ArrayList<>(cmdSize - 1);
        boolean hasException = true;

        try {
            final Iterator<? extends Callable<? extends R>> iter = commands.iterator();
            final Callable<? extends R> firstCommand = iter.next();

            while (iter.hasNext()) {
                futures.add(asyncExecute(iter.next(), executor));
            }

            final List<R> result = new ArrayList<>(cmdSize);
            result.add(firstCommand.call());

            for (final ContinuableFuture<? extends R> f : futures) {
                result.add(f.get());
            }

            hasException = false;

            return result;
        } catch (final Exception e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        } finally {
            if (hasException) {
                for (final ContinuableFuture<? extends R> f : futures) {
                    if (!f.isDone()) {
                        f.cancel(false);
                    }
                }
            }
        }
    }

    /**
     * Executes the action on batches of elements from the array.
     * Does nothing if the array is {@code null} or empty.
     * The action receives a list containing each batch of elements.
     * The action must not modify or cache the input batch list, as it may be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] items = {"A", "B", "C", "D", "E"};
     * N.runByBatch(items, 2, batch -> {
     *     System.out.println("Processing batch: " + batch);
     * });
     * // Processes: [A, B], [C, D], [E]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the action may throw
     * @param a the array to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the action to execute on each batch (must not modify or cache the batch)
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the action throws an exception
     * @see #runByBatch(Iterable, int, Throwables.Consumer)
     * @see #callByBatch(Object[], int, Throwables.Function)
     */
    public static <T, E extends Exception> void runByBatch(final T[] a, final int batchSize, final Throwables.Consumer<? super List<T>, E> batchAction)
            throws IllegalArgumentException, E {
        if (isEmpty(a)) {
            return;
        }

        runByBatch(Arrays.asList(a), batchSize, batchAction);
    }

    /**
     * Executes the action on batches of elements from the iterable.
     * Does nothing if the iterable is {@code null} or empty.
     * The action receives a list containing each batch of elements.
     * The action must not modify or cache the input batch list, as it may be reused.
     * For {@link java.util.List} inputs, uses optimized indexed access.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> items = Arrays.asList("A", "B", "C", "D", "E");
     * N.runByBatch(items, 2, batch -> {
     *     System.out.println("Processing batch: " + batch);
     * });
     * // Processes: [A, B], [C, D], [E]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the action may throw
     * @param iter the iterable to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the action to execute on each batch (must not modify or cache the batch)
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the action throws an exception
     * @see #runByBatch(Object[], int, Throwables.Consumer)
     * @see #callByBatch(Iterable, int, Throwables.Function)
     */
    public static <T, E extends Exception> void runByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.Consumer<? super List<T>, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (N.isEmpty(iter)) {
            return;
        }

        if (iter instanceof List) {
            final List<T> list = (List<T>) iter;
            final int totalSize = list.size();

            if (totalSize <= batchSize) {
                batchAction.accept(list);
            } else {
                for (int i = 0; i < totalSize; i += batchSize) {
                    batchAction.accept(list.subList(i, min(i + batchSize, totalSize)));
                }
            }
        } else {
            runByBatch(iter.iterator(), batchSize, batchAction);
        }
    }

    /**
     * Executes the action on batches of elements from the iterator.
     * Does nothing if the iterator is {@code null} or has no elements.
     * The action receives a list containing each batch of elements.
     * The action must not modify or cache the input batch list, as it may be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = Arrays.asList("A", "B", "C", "D", "E").iterator();
     * N.runByBatch(iter, 2, batch -> {
     *     System.out.println("Processing batch: " + batch);
     * });
     * // Processes: [A, B], [C, D], [E]
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the action may throw
     * @param iter the iterator to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the action to execute on each batch (must not modify or cache the batch)
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the action throws an exception
     * @see #runByBatch(Iterable, int, Throwables.Consumer)
     * @see #callByBatch(Iterator, int, Throwables.Function)
     */
    public static <T, E extends Exception> void runByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.Consumer<? super List<T>, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || !iter.hasNext()) {
            return;
        }

        final T[] a = (T[]) new Object[batchSize];
        int cnt = 0;

        while (iter.hasNext()) {
            a[cnt++ % batchSize] = iter.next();

            if (cnt % batchSize == 0) {
                batchAction.accept(ImmutableList.of(a));
            }
        }

        if (cnt % batchSize != 0) {
            batchAction.accept(ImmutableList.of(copyOfRange(a, 0, cnt % batchSize)));
        }
    }

    /**
     * Executes the element consumer on each element in the array with its index, then runs the batch action after each batch.
     * Does nothing if the array is {@code null} or empty.
     * Processes elements in batches: applies element consumer to each element, then runs batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] items = {"A", "B", "C", "D", "E"};
     * N.runByBatch(items, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> System.out.println("Batch complete")
     * );
     * // Prepares elements 0-1, runs batch action, prepares 2-3, runs batch action, etc.
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param a the array to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to execute after each batch is prepared
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #runByBatch(Iterable, int, Throwables.IntObjConsumer, Throwables.Runnable)
     * @see #runByBatch(Object[], int, Throwables.Consumer)
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final T[] a, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        if (isEmpty(a)) {
            return;
        }

        runByBatch(Arrays.asList(a), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes the element consumer on each element in the iterable with its index, then runs the batch action after each batch.
     * Does nothing if the iterable is {@code null} or empty.
     * Processes elements in batches: applies element consumer to each element, then runs batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> items = Arrays.asList("A", "B", "C", "D", "E");
     * N.runByBatch(items, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> System.out.println("Batch complete")
     * );
     * // Prepares elements 0-1, runs batch action, prepares 2-3, runs batch action, etc.
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param iter the iterable to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to execute after each batch is prepared
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #runByBatch(Iterator, int, Throwables.IntObjConsumer, Throwables.Runnable)
     * @see #runByBatch(Object[], int, Throwables.IntObjConsumer, Throwables.Runnable)
     * @see #runByBatch(Iterable, int, Throwables.Consumer)
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        if (N.isEmpty(iter)) {
            return;
        }

        runByBatch(iter.iterator(), batchSize, elementConsumer, batchAction);
    }

    /**
     * Executes the element consumer on each element in the iterator with its index, then runs the batch action after each batch.
     * Does nothing if the iterator is {@code null} or has no elements.
     * Processes elements in batches: applies element consumer to each element, then runs batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = getDataIterator();
     * N.runByBatch(iter, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> System.out.println("Batch complete")
     * );
     * // Prepares elements 0-1, runs batch action, prepares 2-3, runs batch action, etc.
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param iter the iterator to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to execute after each batch is prepared
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #runByBatch(Iterable, int, Throwables.IntObjConsumer, Throwables.Runnable)
     * @see #runByBatch(Object[], int, Throwables.IntObjConsumer, Throwables.Runnable)
     * @see #runByBatch(Iterator, int, Throwables.Consumer)
     */
    public static <T, E extends Exception, E2 extends Exception> void runByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Runnable<E2> batchAction) throws IllegalArgumentException, E, E2 {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || !iter.hasNext()) {
            return;
        }

        int cnt = 0;

        while (iter.hasNext()) {
            elementConsumer.accept(cnt, iter.next());
            cnt++;

            if (cnt % batchSize == 0) {
                batchAction.run();
            }
        }

        if (cnt % batchSize != 0) {
            batchAction.run();
        }
    }

    /**
     * Applies the batch function to batches of elements from the array and returns all results as a list.
     * Returns an empty list if the array is {@code null} or empty.
     * The batch function receives a list containing each batch of elements.
     * The function must not modify or cache the input batch list, as it may be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] items = {"A", "B", "C", "D", "E"};
     * List<Integer> batchSums = N.callByBatch(items, 2, batch -> {
     *     return batch.stream().mapToInt(String::length).sum();
     * });
     * // Processes: [A, B], [C, D], [E] and returns [2, 2, 1]
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <R> the type of result returned by the batch function
     * @param <E> the type of exception that the batch function may throw
     * @param a the array to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the function to apply to each batch (must not modify or cache the batch)
     * @return a list containing the results from applying the function to each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the batch function throws an exception
     * @see #callByBatch(Iterable, int, Throwables.Function)
     * @see #runByBatch(Object[], int, Throwables.Consumer)
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final T[] a, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return callByBatch(Arrays.asList(a), batchSize, batchAction);
    }

    /**
     * Applies the batch function to batches of elements from the iterable and returns all results as a list.
     * Returns an empty list if the iterable is {@code null} or empty.
     * The batch function receives a list containing each batch of elements.
     * The function must not modify or cache the input batch list, as it may be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> items = Arrays.asList("A", "B", "C", "D", "E");
     * List<Integer> batchSums = N.callByBatch(items, 2, batch -> {
     *     return batch.stream().mapToInt(String::length).sum();
     * });
     * // Processes: [A, B], [C, D], [E] and returns [2, 2, 1]
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <R> the type of result returned by the batch function
     * @param <E> the type of exception that the batch function may throw
     * @param iter the iterable to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the function to apply to each batch (must not modify or cache the batch)
     * @return a list containing the results from applying the function to each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the batch function throws an exception
     * @see #callByBatch(Iterator, int, Throwables.Function)
     * @see #callByBatch(Object[], int, Throwables.Function)
     * @see #runByBatch(Iterable, int, Throwables.Consumer)
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (N.isEmpty(iter)) {
            return new ArrayList<>();
        }

        if (iter instanceof List) {
            final List<T> list = (List<T>) iter;
            final int totalSize = list.size();
            final List<R> result = new ArrayList<>(totalSize % batchSize == 0 ? totalSize / batchSize : totalSize / batchSize + 1);

            if (totalSize <= batchSize) {
                result.add(batchAction.apply(list));
            } else {
                for (int i = 0; i < totalSize; i += batchSize) {
                    result.add(batchAction.apply(list.subList(i, min(i + batchSize, totalSize))));
                }
            }

            return result;
        } else {
            return callByBatch(iter.iterator(), batchSize, batchAction);
        }
    }

    /**
     * Applies the batch function to batches of elements from the iterator and returns all results as a list.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * The batch function receives a list containing each batch of elements.
     * The function must not modify or cache the input batch list, as it may be reused.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = getDataIterator();
     * List<Integer> batchSums = N.callByBatch(iter, 2, batch -> {
     *     return batch.stream().mapToInt(String::length).sum();
     * });
     * // Processes batches and returns list of batch results
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <R> the type of result returned by the batch function
     * @param <E> the type of exception that the batch function may throw
     * @param iter the iterator to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param batchAction the function to apply to each batch (must not modify or cache the batch)
     * @return a list containing the results from applying the function to each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the batch function throws an exception
     * @see #callByBatch(Iterable, int, Throwables.Function)
     * @see #callByBatch(Object[], int, Throwables.Function)
     * @see #runByBatch(Iterator, int, Throwables.Consumer)
     */
    public static <T, R, E extends Exception> List<R> callByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.Function<? super List<T>, R, E> batchAction) throws IllegalArgumentException, E {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || !iter.hasNext()) {
            return new ArrayList<>();
        }

        final T[] a = (T[]) new Object[batchSize];
        final List<R> result = new ArrayList<>();
        int cnt = 0;

        while (iter.hasNext()) {
            a[cnt++ % batchSize] = iter.next();

            if (cnt % batchSize == 0) {
                result.add(batchAction.apply(ImmutableList.of(a)));
            }
        }

        if (cnt % batchSize != 0) {
            result.add(batchAction.apply(ImmutableList.of(copyOfRange(a, 0, cnt % batchSize))));
        }

        return result;
    }

    /**
     * Applies the element consumer to each element in the array with its index, then calls the batch action after each batch and returns all results as a list.
     * Returns an empty list if the array is {@code null} or empty.
     * Processes elements in batches: applies element consumer to each element, then calls batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String[] items = {"A", "B", "C", "D", "E"};
     * List<Integer> batchCounts = N.callByBatch(items, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> getCurrentBatchSize()
     * );
     * // Prepares elements 0-1, calls batch action, prepares 2-3, calls batch action, etc.
     * // Returns list of results from each batch action
     * }</pre>
     *
     * @param <T> the type of elements in the array
     * @param <R> the type of result returned by the batch action
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param a the array to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to call after each batch is prepared
     * @return a list containing the results from calling the batch action after each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #callByBatch(Iterable, int, Throwables.IntObjConsumer, Throwables.Callable)
     * @see #runByBatch(Object[], int, Throwables.IntObjConsumer, Throwables.Runnable)
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final T[] a, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        if (isEmpty(a)) {
            return new ArrayList<>();
        }

        return callByBatch(Arrays.asList(a), batchSize, elementConsumer, batchAction);
    }

    /**
     * Applies the element consumer to each element in the iterable with its index, then calls the batch action after each batch and returns all results as a list.
     * Returns an empty list if the iterable is {@code null} or empty.
     * Processes elements in batches: applies element consumer to each element, then calls batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<String> items = Arrays.asList("A", "B", "C", "D", "E");
     * List<Integer> batchCounts = N.callByBatch(items, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> getCurrentBatchSize()
     * );
     * // Prepares elements 0-1, calls batch action, prepares 2-3, calls batch action, etc.
     * // Returns list of results from each batch action
     * }</pre>
     *
     * @param <T> the type of elements in the iterable
     * @param <R> the type of result returned by the batch action
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param iter the iterable to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to call after each batch is prepared
     * @return a list containing the results from calling the batch action after each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #callByBatch(Iterator, int, Throwables.IntObjConsumer, Throwables.Callable)
     * @see #callByBatch(Object[], int, Throwables.IntObjConsumer, Throwables.Callable)
     * @see #runByBatch(Iterable, int, Throwables.IntObjConsumer, Throwables.Runnable)
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final Iterable<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        if (N.isEmpty(iter)) {
            return new ArrayList<>();
        }

        return callByBatch(iter.iterator(), batchSize, elementConsumer, batchAction);
    }

    /**
     * Applies the element consumer to each element in the iterator with its index, then calls the batch action after each batch and returns all results as a list.
     * Returns an empty list if the iterator is {@code null} or has no elements.
     * Processes elements in batches: applies element consumer to each element, then calls batch action.
     * Useful for preparing batch operations where each element needs preprocessing before batch execution.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Iterator<String> iter = getDataIterator();
     * List<Integer> batchCounts = N.callByBatch(iter, 2,
     *     (idx, item) -> System.out.println("Preparing " + idx + ": " + item),
     *     () -> getCurrentBatchSize()
     * );
     * // Prepares elements 0-1, calls batch action, prepares 2-3, calls batch action, etc.
     * // Returns list of results from each batch action
     * }</pre>
     *
     * @param <T> the type of elements in the iterator
     * @param <R> the type of result returned by the batch action
     * @param <E> the type of exception that the element consumer may throw
     * @param <E2> the type of exception that the batch action may throw
     * @param iter the iterator to process in batches
     * @param batchSize the number of elements in each batch (must be positive)
     * @param elementConsumer the action to apply to each element with its index
     * @param batchAction the action to call after each batch is prepared
     * @return a list containing the results from calling the batch action after each batch
     * @throws IllegalArgumentException if batchSize is not positive
     * @throws E if the element consumer throws an exception
     * @throws E2 if the batch action throws an exception
     * @see #callByBatch(Iterable, int, Throwables.IntObjConsumer, Throwables.Callable)
     * @see #callByBatch(Object[], int, Throwables.IntObjConsumer, Throwables.Callable)
     * @see #runByBatch(Iterator, int, Throwables.IntObjConsumer, Throwables.Runnable)
     */
    public static <T, R, E extends Exception, E2 extends Exception> List<R> callByBatch(final Iterator<? extends T> iter, final int batchSize,
            final Throwables.IntObjConsumer<? super T, E> elementConsumer, final Throwables.Callable<? extends R, E2> batchAction)
            throws IllegalArgumentException, E, E2 {
        checkArgPositive(batchSize, cs.batchSize);

        if (iter == null || !iter.hasNext()) {
            return new ArrayList<>();
        }

        final List<R> result = new ArrayList<>();
        int cnt = 0;

        while (iter.hasNext()) {
            elementConsumer.accept(cnt++, iter.next());

            if (cnt % batchSize == 0) {
                result.add(batchAction.call());
            }
        }

        if (cnt % batchSize != 0) {
            result.add(batchAction.call());
        }

        return result;
    }

    /**
     * Executes the command uninterruptibly, blocking until completion even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes, then restores the interrupted status.
     * This is useful for operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runUninterruptibly(() -> {
     *     Thread.sleep(1000); // Must complete even if interrupted
     * });
     * // Thread interrupted status is restored after completion
     * }</pre>
     *
     * @param cmd the command to execute uninterruptibly
     * @throws IllegalArgumentException if cmd is {@code null}
     * @see #runUninterruptibly(Throwables.LongConsumer, long)
     */
    public static void runUninterruptibly(final Throwables.Runnable<InterruptedException> cmd) throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            while (true) {
                try {
                    cmd.run();
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Executes the command uninterruptibly with a timeout, blocking until completion or timeout even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes or the timeout elapses, then restores the interrupted status.
     * The command receives the remaining time in milliseconds on each attempt.
     * This is useful for timed operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runUninterruptibly(remainingMillis -> {
     *     lock.tryLock(remainingMillis, TimeUnit.MILLISECONDS);
     * }, 5000);
     * // Attempts lock acquisition with remaining time on each retry
     * }</pre>
     *
     * @param cmd the command to execute with remaining time in milliseconds
     * @param timeoutInMillis the maximum time to wait in milliseconds
     * @throws IllegalArgumentException if cmd is {@code null}
     * @see #runUninterruptibly(Throwables.BiConsumer, long, TimeUnit)
     * @see #runUninterruptibly(Throwables.Runnable)
     */
    public static void runUninterruptibly(final Throwables.LongConsumer<InterruptedException> cmd, final long timeoutInMillis) throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            long remainingMillis = timeoutInMillis;
            final long sysMillis = System.currentTimeMillis();
            final long end = remainingMillis >= Long.MAX_VALUE - sysMillis ? Long.MAX_VALUE : sysMillis + remainingMillis;

            while (true) {
                try {
                    cmd.accept(remainingMillis);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingMillis = end - System.currentTimeMillis();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Executes the command uninterruptibly with a timeout and time unit, blocking until completion or timeout even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes or the timeout elapses, then restores the interrupted status.
     * The command receives the remaining time and time unit (always nanoseconds) on each attempt.
     * This is useful for timed operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.runUninterruptibly((remainingTime, timeUnit) -> {
     *     condition.await(remainingTime, timeUnit);
     * }, 5, TimeUnit.SECONDS);
     * // Attempts condition await with remaining time on each retry
     * }</pre>
     *
     * @param cmd the command to execute with remaining time and unit (nanoseconds)
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @throws IllegalArgumentException if cmd or unit is {@code null}
     * @see #runUninterruptibly(Throwables.LongConsumer, long)
     * @see #runUninterruptibly(Throwables.Runnable)
     */
    public static void runUninterruptibly(@NotNull final Throwables.BiConsumer<Long, TimeUnit, InterruptedException> cmd, final long timeout,
            @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    cmd.accept(remainingNanos, TimeUnit.NANOSECONDS);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Calls the command uninterruptibly and returns the result, blocking until completion even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes, then restores the interrupted status.
     * This is useful for operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.callUninterruptibly(() -> {
     *     Thread.sleep(1000);
     *     return "completed";
     * });
     * // Returns result even if interrupted, interrupted status restored after
     * }</pre>
     *
     * @param <T> the type of result returned by the command
     * @param cmd the command to call uninterruptibly
     * @return the result of the command
     * @throws IllegalArgumentException if cmd is {@code null}
     * @see #callUninterruptibly(Throwables.LongFunction, long)
     * @see #runUninterruptibly(Throwables.Runnable)
     */
    public static <T> T callUninterruptibly(final Throwables.Callable<T, InterruptedException> cmd) throws IllegalArgumentException {
        boolean interrupted = false;
        try {
            while (true) {
                try {
                    return cmd.call();
                } catch (final InterruptedException e) {
                    interrupted = true;
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Calls the command uninterruptibly with a timeout and returns the result, blocking until completion or timeout even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes or the timeout elapses, then restores the interrupted status.
     * The command receives the remaining time in milliseconds on each attempt.
     * This is useful for timed operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.callUninterruptibly(remainingMillis -> {
     *     if (lock.tryLock(remainingMillis, TimeUnit.MILLISECONDS)) {
     *         return "acquired";
     *     }
     *     return "failed";
     * }, 5000);
     * // Attempts operation with remaining time on each retry
     * }</pre>
     *
     * @param <T> the type of result returned by the command
     * @param cmd the command to call with remaining time in milliseconds
     * @param timeoutInMillis the maximum time to wait in milliseconds
     * @return the result of the command
     * @throws IllegalArgumentException if cmd is {@code null}
     * @see #callUninterruptibly(Throwables.BiFunction, long, TimeUnit)
     * @see #callUninterruptibly(Throwables.Callable)
     */
    public static <T> T callUninterruptibly(final Throwables.LongFunction<? extends T, InterruptedException> cmd, final long timeoutInMillis)
            throws IllegalArgumentException {
        boolean interrupted = false;

        try {
            long remainingMillis = timeoutInMillis;
            final long sysMillis = System.currentTimeMillis();
            final long end = remainingMillis >= Long.MAX_VALUE - sysMillis ? Long.MAX_VALUE : sysMillis + remainingMillis;

            while (true) {
                try {
                    return cmd.apply(remainingMillis);
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingMillis = end - System.currentTimeMillis();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Calls the command uninterruptibly with a timeout and time unit and returns the result, blocking until completion or timeout even if the thread is interrupted.
     * If the thread is interrupted during execution, continues to block until the command completes or the timeout elapses, then restores the interrupted status.
     * The command receives the remaining time and time unit (always nanoseconds) on each attempt.
     * This is useful for timed operations that must complete atomically without being interrupted mid-execution.
     *
     * <p>Note: Copied from Google Guava under Apache License 2.0 and may be modified.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.callUninterruptibly((remainingTime, timeUnit) -> {
     *     if (future.get(remainingTime, timeUnit) != null) {
     *         return "success";
     *     }
     *     return "timeout";
     * }, 5, TimeUnit.SECONDS);
     * // Attempts future get with remaining time on each retry
     * }</pre>
     *
     * @param <T> the type of result returned by the command
     * @param cmd the command to call with remaining time and unit (nanoseconds)
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the result of the command
     * @throws IllegalArgumentException if cmd or unit is {@code null}
     * @see #callUninterruptibly(Throwables.LongFunction, long)
     * @see #callUninterruptibly(Throwables.Callable)
     */
    public static <T> T callUninterruptibly(@NotNull final Throwables.BiFunction<Long, TimeUnit, T, InterruptedException> cmd, final long timeout,
            @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    return cmd.apply(remainingNanos, TimeUnit.NANOSECONDS);
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Executes the callable and returns the result wrapped in a {@code Nullable}.
     * Returns an empty {@code Nullable} if an exception occurs during execution.
     * This provides a safe way to execute operations that may throw exceptions without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Nullable<String> result = N.tryOrEmptyIfExceptionOccurred(() -> {
     *     return riskyOperation();
     * });
     * // Returns Nullable.of(result) on success, Nullable.empty() on exception
     * }</pre>
     *
     * @param <R> the type of result returned by the callable
     * @param cmd the callable to execute
     * @return a {@code Nullable} containing the result, or empty if an exception occurs
     * @see #tryOrEmptyIfExceptionOccurred(Object, Throwables.Function)
     * @see #tryOrDefaultIfExceptionOccurred(Callable, Supplier)
     * @see Try#call(Throwables.Function)
     */
    @Beta
    public static <R> Nullable<R> tryOrEmptyIfExceptionOccurred(final Callable<R> cmd) {
        try {
            return Nullable.of(cmd.call());
        } catch (final Exception e) {
            return Nullable.empty();
        }
    }

    /**
     * Applies the function to the initial value and returns the result wrapped in a {@code Nullable}.
     * Returns an empty {@code Nullable} if an exception occurs during execution.
     * This provides a safe way to execute operations that may throw exceptions without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String url = "http://example.com";
     * Nullable<String> content = N.tryOrEmptyIfExceptionOccurred(url, u -> {
     *     return fetchContent(u);
     * });
     * // Returns Nullable.of(content) on success, Nullable.empty() on exception
     * }</pre>
     *
     * @param <T> the type of the initial value
     * @param <R> the type of result returned by the function
     * @param init the initial value to pass to the function
     * @param func the function to apply
     * @return a {@code Nullable} containing the result, or empty if an exception occurs
     * @see #tryOrEmptyIfExceptionOccurred(Callable)
     * @see #tryOrDefaultIfExceptionOccurred(Object, Throwables.Function, Supplier)
     * @see Try#call(Throwables.Function)
     */
    @Beta
    public static <T, R> Nullable<R> tryOrEmptyIfExceptionOccurred(final T init, final Throwables.Function<? super T, ? extends R, ? extends Exception> func) {
        try {
            return Nullable.of(func.apply(init));
        } catch (final Exception e) {
            return Nullable.empty();
        }
    }

    /**
     * Executes the callable and returns the result.
     * Returns the result from the supplier if an exception occurs during execution.
     * This provides a safe way to execute operations with a fallback value without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.tryOrDefaultIfExceptionOccurred(
     *     () -> riskyOperation(),
     *     () -> "default value"
     * );
     * // Returns result on success, "default value" on exception
     * }</pre>
     *
     * @param <R> the type of result returned by the callable
     * @param cmd the callable to execute
     * @param supplierForDefaultIfExceptionOccurred the supplier to provide default value on exception
     * @return the result of the callable, or the result from the supplier on exception
     * @see #tryOrDefaultIfExceptionOccurred(Callable, Comparable)
     * @see #tryOrEmptyIfExceptionOccurred(Callable)
     * @see Try#call(Throwables.Function, Supplier)
     */
    @Beta
    public static <R> R tryOrDefaultIfExceptionOccurred(final Callable<R> cmd, final Supplier<R> supplierForDefaultIfExceptionOccurred) {
        try {
            return cmd.call();
        } catch (final Exception e) {
            return supplierForDefaultIfExceptionOccurred.get();
        }
    }

    /**
     * Executes the callable and returns the result.
     * Returns the provided default value if an exception occurs during execution.
     * This provides a safe way to execute operations with a fallback value without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String result = N.tryOrDefaultIfExceptionOccurred(
     *     () -> riskyOperation(),
     *     "default value"
     * );
     * // Returns result on success, "default value" on exception
     * }</pre>
     *
     * @param <R> the type of result returned by the callable (must extend Comparable to avoid ambiguity)
     * @param cmd the callable to execute
     * @param defaultIfExceptionOccurred the default value to return on exception
     * @return the result of the callable, or the default value on exception
     * @see #tryOrDefaultIfExceptionOccurred(Callable, Supplier)
     * @see #tryOrEmptyIfExceptionOccurred(Callable)
     * @see Try#call(Throwables.Function)
     */
    @Beta
    // <R extends Comparable<? super R>> to avoid ambiguous error with Comparable<R>. Comparable is most common super interface for all types.
    public static <R extends Comparable<? super R>> R tryOrDefaultIfExceptionOccurred(final Callable<R> cmd, final R defaultIfExceptionOccurred) {
        try {
            return cmd.call();
        } catch (final Exception e) {
            return defaultIfExceptionOccurred;
        }
    }

    /**
     * Applies the function to the initial value and returns the result.
     * Returns the result from the supplier if an exception occurs during execution.
     * This provides a safe way to execute operations with a fallback value without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String url = "http://example.com";
     * String content = N.tryOrDefaultIfExceptionOccurred(
     *     url,
     *     u -> fetchContent(u),
     *     () -> "default content"
     * );
     * // Returns content on success, "default content" on exception
     * }</pre>
     *
     * @param <T> the type of the initial value
     * @param <R> the type of result returned by the function
     * @param init the initial value to pass to the function
     * @param func the function to apply
     * @param supplierForDefaultIfExceptionOccurred the supplier to provide default value on exception
     * @return the result of the function, or the result from the supplier on exception
     * @see #tryOrDefaultIfExceptionOccurred(Object, Throwables.Function, Comparable)
     * @see #tryOrEmptyIfExceptionOccurred(Object, Throwables.Function)
     * @see Try#call(Throwables.Function, Supplier)
     */
    @Beta
    public static <T, R> R tryOrDefaultIfExceptionOccurred(final T init, final Throwables.Function<? super T, ? extends R, ? extends Exception> func,
            final Supplier<R> supplierForDefaultIfExceptionOccurred) {
        try {
            return func.apply(init);
        } catch (final Exception e) {
            return supplierForDefaultIfExceptionOccurred.get();
        }
    }

    /**
     * Applies the function to the initial value and returns the result.
     * Returns the provided default value if an exception occurs during execution.
     * This provides a safe way to execute operations with a fallback value without explicit try-catch blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String url = "http://example.com";
     * String content = N.tryOrDefaultIfExceptionOccurred(
     *     url,
     *     u -> fetchContent(u),
     *     "default content"
     * );
     * // Returns content on success, "default content" on exception
     * }</pre>
     *
     * @param <T> the type of the initial value
     * @param <R> the type of result returned by the function (must extend Comparable to avoid ambiguity)
     * @param init the initial value to pass to the function
     * @param func the function to apply
     * @param defaultIfExceptionOccurred the default value to return on exception
     * @return the result of the function, or the default value on exception
     * @see #tryOrDefaultIfExceptionOccurred(Object, Throwables.Function, Supplier)
     * @see #tryOrEmptyIfExceptionOccurred(Object, Throwables.Function)
     * @see Try#call(Throwables.Function)
     */
    @Beta
    // <R extends Comparable<? super R>> to avoid ambiguous error with Comparable<R>. Comparable is most common super interface for all types.
    public static <T, R extends Comparable<? super R>> R tryOrDefaultIfExceptionOccurred(final T init,
            final Throwables.Function<? super T, ? extends R, ? extends Exception> func, final R defaultIfExceptionOccurred) {
        try {
            return func.apply(init);
        } catch (final Exception e) {
            return defaultIfExceptionOccurred;
        }
    }

    /**
     * Returns a {@code Nullable} containing the result of the supplier if the condition is {@code true}.
     * Returns an empty {@code Nullable} if the condition is {@code false}.
     * This provides a concise way to conditionally compute values without explicit if-else blocks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * boolean hasPermission = checkPermission(user);
     * Nullable<String> data = N.ifOrEmpty(hasPermission, () -> fetchSensitiveData());
     * // Returns Nullable.of(data) if hasPermission is true, Nullable.empty() otherwise
     * }</pre>
     *
     * @param <R> the type of result returned by the supplier
     * @param <E> the type of exception that the supplier may throw
     * @param b the condition to evaluate
     * @param supplier the supplier to execute if the condition is true
     * @return a {@code Nullable} containing the result if condition is {@code true}, empty otherwise
     * @throws E if the supplier throws an exception
     * @see #ifNotNull(Object, Throwables.Consumer)
     */
    @Beta
    public static <R, E extends Exception> Nullable<R> ifOrEmpty(final boolean b, final Throwables.Supplier<R, E> supplier) throws E {
        if (b) {
            return Nullable.of(supplier.get());
        } else {
            return Nullable.empty();
        }
    }

    // Maybe misused: N.ifOrElse(user != null, user.getFirstName(), firstName -> N.println(firstName));

    /**
     * Executes one of two actions based on the boolean condition.
     * Executes actionForTrue if the condition is {@code true}, otherwise executes actionForFalse.
     * Skips execution if the corresponding action is {@code null}.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.ifOrElse(user.isAdmin(),
     *     () -> grantAdminAccess(),
     *     () -> grantRegularAccess()
     * );
     * // Executes appropriate action based on condition
     * }</pre>
     *
     * @param <E1> the type of exception that actionForTrue may throw
     * @param <E2> the type of exception that actionForFalse may throw
     * @param b the boolean condition to test
     * @param actionForTrue the action to execute if condition is {@code true} (may be {@code null})
     * @param actionForFalse the action to execute if condition is {@code false} (may be {@code null})
     * @throws E1 if condition is {@code true} and actionForTrue throws an exception
     * @throws E2 if condition is {@code false} and actionForFalse throws an exception
     * @deprecated it's not a good idea? if-else is better?
     */
    @Deprecated
    public static <E1 extends Exception, E2 extends Exception> void ifOrElse(final boolean b, final Throwables.Runnable<E1> actionForTrue,
            final Throwables.Runnable<E2> actionForFalse) throws E1, E2 {
        if (b) {
            if (actionForTrue != null) {
                actionForTrue.run();
            }
        } else {
            if (actionForFalse != null) {
                actionForFalse.run();
            }
        }
    }

    /**
     * Executes the consumer with the object if the object is not {@code null}.
     * Does nothing if the object is {@code null}.
     * This provides a concise way to perform null-safe operations without explicit {@code null} checks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * User user = findUser(userId);
     * N.ifNotNull(user, u -> {
     *     System.out.println("User: " + u.getName());
     * });
     * // Executes consumer only if user is not null
     * }</pre>
     *
     * @param <T> the type of the object
     * @param <E> the type of exception that the consumer may throw
     * @param obj the object to check for null
     * @param cmd the consumer to execute if object is not null
     * @throws E if the consumer throws an exception
     * @see #ifNotEmpty(CharSequence, Throwables.Consumer)
     * @see #ifOrEmpty(boolean, Throwables.Supplier)
     */
    @Beta
    public static <T, E extends Exception> void ifNotNull(final T obj, final Throwables.Consumer<? super T, E> cmd) throws E {
        if (obj != null) {
            cmd.accept(obj);
        }
    }

    /**
     * Executes the consumer with the CharSequence if it is not {@code null} or empty.
     * Does nothing if the CharSequence is {@code null} or empty.
     * This provides a concise way to perform operations on non-empty strings without explicit checks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * String name = getUserInput();
     * N.ifNotEmpty(name, n -> {
     *     System.out.println("Hello, " + n);
     * });
     * // Executes consumer only if name is not null and not empty
     * }</pre>
     *
     * @param <CS> the type of CharSequence
     * @param <E> the type of exception that the consumer may throw
     * @param c the CharSequence to check
     * @param cmd the consumer to execute if CharSequence is not empty
     * @throws E if the consumer throws an exception
     * @see #ifNotEmpty(Collection, Throwables.Consumer)
     * @see #ifNotNull(Object, Throwables.Consumer)
     */
    @Beta
    public static <CS extends CharSequence, E extends Exception> void ifNotEmpty(final CS c, final Throwables.Consumer<? super CS, E> cmd) throws E {
        if (notEmpty(c)) {
            cmd.accept(c);
        }
    }

    /**
     * Executes the consumer with the collection if it is not {@code null} or empty.
     * Does nothing if the collection is {@code null} or empty.
     * This provides a concise way to perform operations on non-empty collections without explicit checks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * List<User> users = findActiveUsers();
     * N.ifNotEmpty(users, list -> {
     *     System.out.println("Found " + list.size() + " active users");
     * });
     * // Executes consumer only if users is not null and not empty
     * }</pre>
     *
     * @param <C> the type of Collection
     * @param <E> the type of exception that the consumer may throw
     * @param c the collection to check
     * @param cmd the consumer to execute if collection is not empty
     * @throws E if the consumer throws an exception
     * @see #ifNotEmpty(Map, Throwables.Consumer)
     * @see #ifNotEmpty(CharSequence, Throwables.Consumer)
     */
    @SuppressWarnings("rawtypes")
    @Beta
    public static <C extends Collection, E extends Exception> void ifNotEmpty(final C c, final Throwables.Consumer<? super C, E> cmd) throws E {
        if (notEmpty(c)) {
            cmd.accept(c);
        }
    }

    /**
     * Executes the consumer with the map if it is not {@code null} or empty.
     * Does nothing if the map is {@code null} or empty.
     * This provides a concise way to perform operations on non-empty maps without explicit checks.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * Map<String, String> config = loadConfig();
     * N.ifNotEmpty(config, map -> {
     *     System.out.println("Loaded " + map.size() + " config entries");
     * });
     * // Executes consumer only if config is not null and not empty
     * }</pre>
     *
     * @param <M> the type of Map
     * @param <E> the type of exception that the consumer may throw
     * @param m the map to check
     * @param cmd the consumer to execute if map is not empty
     * @throws E if the consumer throws an exception
     * @see #ifNotEmpty(Collection, Throwables.Consumer)
     * @see #ifNotNull(Object, Throwables.Consumer)
     */
    @SuppressWarnings("rawtypes")
    @Beta
    public static <M extends Map, E extends Exception> void ifNotEmpty(final M m, final Throwables.Consumer<? super M, E> cmd) throws E {
        if (notEmpty(m)) {
            cmd.accept(m);
        }
    }

    /**
     * Pauses the execution of the current thread for the specified time in milliseconds.
     * Does nothing if the timeout is zero or negative.
     * If the thread is interrupted during sleep, throws RuntimeException with the interrupted status restored.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.sleep(1000); // Sleeps for 1 second
     * // Throws RuntimeException if interrupted
     * }</pre>
     *
     * @param timeoutInMillis the time to sleep in milliseconds
     * @see #sleep(long, TimeUnit)
     * @see #sleepUninterruptibly(long)
     */
    public static void sleep(final long timeoutInMillis) {
        if (timeoutInMillis <= 0) {
            return;
        }

        try {
            TimeUnit.MILLISECONDS.sleep(timeoutInMillis);
        } catch (final InterruptedException e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }
    }

    /**
     * Pauses the execution of the current thread for the specified time with the given time unit.
     * Does nothing if the timeout is zero or negative.
     * If the thread is interrupted during sleep, throws RuntimeException with the interrupted status restored.
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * N.sleep(5, TimeUnit.SECONDS); // Sleeps for 5 seconds
     * N.sleep(500, TimeUnit.MILLISECONDS); // Sleeps for 500 milliseconds
     * // Throws RuntimeException if interrupted
     * }</pre>
     *
     * @param timeout the time to sleep
     * @param unit the time unit for the timeout parameter
     * @throws IllegalArgumentException if unit is {@code null}
     * @see #sleep(long)
     * @see #sleepUninterruptibly(long, TimeUnit)
     */
    public static void sleep(final long timeout, @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        if (timeout <= 0) {
            return;
        }

        try {
            unit.sleep(timeout);
        } catch (final InterruptedException e) {
            throw ExceptionUtil.toRuntimeException(e, true);
        }
    }

    /**
     * Pauses the execution of the current thread for the specified time in an uninterruptible manner.
     * This method will continue to sleep for the full duration even if the thread is interrupted,
     * re-establishing the interrupt status only after the sleep completes.
     *
     * <p><strong>Note:</strong> This implementation is derived from Google Guava under Apache License 2.0 and has been modified.</p>
     *
     * <p>When a thread is interrupted during the sleep call, this method continues to block until the
     * full timeout duration elapses, and only then re-interrupts the thread by calling
     * {@link Thread#interrupt()} to restore the interrupted status.</p>
     *
     * <p>This behavior is useful when you need guaranteed sleep duration regardless of interruptions,
     * such as rate limiting, retry delays, or time-based coordination where partial sleep would
     * break the timing contract.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Rate limiting: ensure minimum delay between operations
     * N.sleepUninterruptibly(1000); // Always sleeps for 1 second
     * 
     * // Retry with fixed delay - won't be shortened by interrupts
     * for (int attempt = 0; attempt < maxRetries; attempt++) {
     *     try {
     *         return performOperation();
     *     } catch (Exception e) {
     *         if (attempt < maxRetries - 1) {
     *             N.sleepUninterruptibly(retryDelayMs);
     *         }
     *     }
     * }
     * }</pre>
     *
     * @param timeoutInMillis the time to sleep in milliseconds. If zero or negative, 
     *                       the method returns immediately without sleeping
     * @see #sleep(long)
     * @see #sleep(long, TimeUnit)
     * @see Thread#interrupt()
     * @see TimeUnit#sleep(long)
     */
    public static void sleepUninterruptibly(final long timeoutInMillis) {
        if (timeoutInMillis <= 0) {
            return;
        }

        boolean interrupted = false;

        try {
            long remainingNanos = TimeUnit.MILLISECONDS.toNanos(timeoutInMillis);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    // TimeUnit.sleep() treats negative timeouts just like zero.
                    TimeUnit.NANOSECONDS.sleep(remainingNanos);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Pauses the execution of the current thread for the specified time with the given time unit in an uninterruptible manner.
     * This method will continue to sleep for the full duration even if the thread is interrupted,
     * re-establishing the interrupt status only after the sleep completes.
     *
     * <p><strong>Note:</strong> This implementation is derived from Google Guava under Apache License 2.0 and has been modified.</p>
     *
     * <p>When a thread is interrupted during the sleep call, this method continues to block until the
     * full timeout duration elapses, and only then re-interrupts the thread by calling
     * {@link Thread#interrupt()} to restore the interrupted status.</p>
     *
     * <p>This behavior is useful when you need guaranteed sleep duration regardless of interruptions,
     * such as rate limiting, retry delays, or time-based coordination where partial sleep would
     * break the timing contract.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Sleep for 5 seconds regardless of interruptions
     * N.sleepUninterruptibly(5, TimeUnit.SECONDS);
     * 
     * // Micro-sleep for precise timing
     * N.sleepUninterruptibly(500, TimeUnit.MICROSECONDS);
     * 
     * // Rate limiting with different time units
     * N.sleepUninterruptibly(2, TimeUnit.MINUTES); // 2 minute delay
     * }</pre>
     *
     * @param timeout the time to sleep. If zero or negative, the method returns immediately without sleeping
     * @param unit the time unit for the timeout parameter. Must not be null
     * @throws IllegalArgumentException if the specified {@code unit} is {@code null}
     * @see #sleepUninterruptibly(long)
     * @see #sleep(long, TimeUnit)
     * @see TimeUnit
     * @see Thread#interrupt()
     */
    public static void sleepUninterruptibly(final long timeout, @NotNull final TimeUnit unit) throws IllegalArgumentException {
        checkArgNotNull(unit, cs.unit);

        if (timeout <= 0) {
            return;
        }

        boolean interrupted = false;

        try {
            long remainingNanos = unit.toNanos(timeout);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    // TimeUnit.sleep() treats negative timeouts just like zero.
                    TimeUnit.NANOSECONDS.sleep(remainingNanos);
                    return;
                } catch (final InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }

    /**
     * Creates a lazy-initialized supplier from the provided supplier that defers computation until first access.
     * The supplier's {@code get()} method will only be called once, on the first invocation, and the result
     * will be cached for all subsequent calls. This provides thread-safe lazy initialization with memoization.
     *
     * <p>This is particularly useful for expensive computations or resource initialization that should only
     * happen if and when the value is actually needed, and should be computed only once.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Expensive computation deferred until needed
     * Supplier<List<String>> expensiveData = N.lazyInit(() -> {
     *     System.out.println("Computing expensive data...");
     *     return loadDataFromDatabase(); // Only called once
     * });
     * 
     * // First call triggers computation
     * List<String> data1 = expensiveData.get(); // Prints "Computing expensive data..."
     * 
     * // Subsequent calls return cached result
     * List<String> data2 = expensiveData.get(); // No computation, returns cached value
     * 
     * // Resource initialization
     * Supplier<DatabaseConnection> connection = N.lazyInit(() -> {
     *     return new DatabaseConnection(config);
     * });
     * }</pre>
     *
     * <p><strong>Thread safety:</strong> The returned supplier is thread-safe. Concurrent calls to {@code get()}
     * will ensure that the underlying supplier is called exactly once, even in multi-threaded environments.</p>
     *
     * <p><strong>Performance:</strong> After the first call, subsequent calls have minimal overhead as they
     * simply return the cached value without any synchronization.</p>
     *
     * @param <T> the type of results supplied by this supplier
     * @param supplier the supplier to be lazily initialized, must not be null
     * @return a thread-safe lazy-initialized supplier that caches the result of the first call
     * @see LazyInitializer#of(Supplier)
     * @see #lazyInitialize(Throwables.Supplier)
     */
    @Beta
    public static <T> com.landawn.abacus.util.function.Supplier<T> lazyInit(final Supplier<T> supplier) {
        return LazyInitializer.of(supplier);
    }

    /**
     * Creates a lazy-initialized supplier from the provided exception-throwing supplier that defers computation until first access.
     * The supplier's {@code get()} method will only be called once, on the first invocation, and the result
     * will be cached for all subsequent calls. This provides thread-safe lazy initialization with memoization for
     * suppliers that may throw checked exceptions.
     *
     * <p>This is particularly useful for expensive computations or resource initialization that may throw
     * checked exceptions and should only happen if and when the value is actually needed.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Database connection with exception handling
     * Throwables.Supplier<Connection, SQLException> lazyConnection = N.lazyInitialize(() -> {
     *     System.out.println("Establishing database connection...");
     *     return DriverManager.getConnection(url, user, password);
     * });
     * 
     * try {
     *     Connection conn1 = lazyConnection.get(); // May throw SQLException on first call
     *     Connection conn2 = lazyConnection.get(); // Returns cached connection, no exception
     * } catch (SQLException e) {
     *     // Handle connection error
     * }
     * 
     * // File reading with lazy initialization
     * Throwables.Supplier<String, IOException> fileContent = N.lazyInitialize(() -> {
     *     return Files.readString(Paths.get("config.txt"));
     * });
     * }</pre>
     *
     * <p><strong>Thread safety:</strong> The returned supplier is thread-safe. Concurrent calls to {@code get()}
     * will ensure that the underlying supplier is called exactly once, even in multi-threaded environments.</p>
     *
     * <p><strong>Exception behavior:</strong> If the underlying supplier throws an exception on the first call,
     * that exception will be propagated and the supplier will remain uninitialized. Subsequent calls will
     * attempt to call the underlying supplier again.</p>
     *
     * @param <T> the type of results supplied by this supplier
     * @param <E> the type of exception that may be thrown by the supplier
     * @param supplier the exception-throwing supplier to be lazily initialized, must not be null
     * @return a thread-safe lazy-initialized supplier that caches the result of the first successful call
     * @see Throwables.LazyInitializer#of(Throwables.Supplier)
     * @see #lazyInit(Supplier)
     */
    @Beta
    public static <T, E extends Exception> Throwables.Supplier<T, E> lazyInitialize(final Throwables.Supplier<T, E> supplier) {
        return Throwables.LazyInitializer.of(supplier);
    }

    /**
     * Converts the specified {@code Exception} to a {@code RuntimeException} if it's a checked {@code exception}, otherwise returns itself.
     *
     * @param e the exception to be converted to a runtime exception.
     * @return a RuntimeException that represents the provided exception.
     * @see ExceptionUtil#toRuntimeException(Exception)
     * @see ExceptionUtil#toRuntimeException(Exception, boolean)
     * @see ExceptionUtil#toRuntimeException(Throwable)
     * @see ExceptionUtil#toRuntimeException(Throwable, boolean)
     * @see ExceptionUtil#toRuntimeException(Throwable, boolean, boolean)
     * @see ExceptionUtil#registerRuntimeExceptionMapper(Class, Function)
     */
    @Beta
    public static RuntimeException toRuntimeException(final Exception e) {
        return ExceptionUtil.toRuntimeException(e);
    }

    /**
     * Converts the specified {@code Throwable} to a {@code RuntimeException} if it's a checked {@code exception} or an {@code Error}, otherwise returns itself.
     *
     * @param e the throwable to be converted to a runtime exception.
     * @return a RuntimeException that represents the provided throwable.
     * @see ExceptionUtil#toRuntimeException(Throwable)
     * @see ExceptionUtil#toRuntimeException(Throwable, boolean)
     * @see ExceptionUtil#toRuntimeException(Throwable, boolean, boolean)
     * @see ExceptionUtil#registerRuntimeExceptionMapper(Class, Function)
     */
    @Beta
    public static RuntimeException toRuntimeException(final Throwable e) {
        return ExceptionUtil.toRuntimeException(e);
    }

    //    /**

    /**
     * Prints the given object's string representation to the standard output stream (System.out) and returns the object.
     * This method provides intelligent formatting for different object types and is particularly useful for debugging
     * and method chaining scenarios where you want to inspect intermediate values without breaking the chain.
     *
     * <p><strong>Formatting behavior:</strong></p>
     * <ul>
     * <li><strong>Collections:</strong> Formatted as [element1, element2, element3] with comma-space separators</li>
     * <li><strong>Object arrays:</strong> Formatted as [element1, element2, element3] with comma-space separators</li>
     * <li><strong>Maps:</strong> Formatted as {key1=value1, key2=value2} with comma-space separators</li>
     * <li><strong>Other objects:</strong> Uses {@code N.toString(Object)} for string representation</li>
     * </ul>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Method chaining with debugging
     * List<String> result = N.println(Arrays.asList("a", "b", "c"))  // Prints: [a, b, c]
     *     .stream()
     *     .map(String::toUpperCase)
     *     .collect(toList());
     * 
     * // Debug intermediate values
     * int value = N.println(calculateSomething())  // Prints the calculated value
     *     * 2;
     * 
     * // Collection debugging
     * Map<String, Integer> map = new HashMap<>();
     * map.put("foo", 1);
     * map.put("bar", 2);
     * N.println(map);  // Prints: {foo=1, bar=2}
     * 
     * // Array debugging
     * String[] array = {"hello", "world"};
     * N.println(array);  // Prints: [hello, world]
     * }</pre>
     *
     * <p><strong>Performance note:</strong> This method uses optimized string builders with cached buffers
     * for formatting collections and arrays, providing good performance for debugging purposes.</p>
     *
     * @param <T> the type of the object to be printed
     * @param obj the object to be printed, may be null
     * @return the same object that was printed, enabling method chaining
     * @see #toString(Object)
     * @see #fprintln(String, Object...)
     * @see System#out
     */
    @SuppressWarnings("rawtypes")
    public static <T> T println(final T obj) {
        if (obj instanceof Collection) {
            //noinspection resource
            System.out.println(Joiner.with(Strings.ELEMENT_SEPARATOR, "[", "]").reuseCachedBuffer().appendAll((Collection) obj).toString()); //NOSONAR
        } else if (obj instanceof Object[]) {
            //noinspection resource
            System.out.println(Joiner.with(Strings.ELEMENT_SEPARATOR, "[", "]").reuseCachedBuffer().appendAll((Object[]) obj).toString()); //NOSONAR
        } else if (obj instanceof Map) {
            //noinspection resource
            System.out.println(Joiner.with(Strings.ELEMENT_SEPARATOR, "=", "{", "}").reuseCachedBuffer().appendEntries((Map) obj).toString()); //NOSONAR
        } else {
            System.out.println(toString(obj)); //NOSONAR
        }

        return obj;
    }

    /**
     * Prints a formatted string to the standard output stream (System.out) followed by a newline.
     * This method provides convenient formatted printing using printf-style format strings,
     * combining the functionality of {@link String#format(String, Object...)} with automatic newline addition.
     *
     * <p>The format string uses the same syntax as {@link String#format(String, Object...)}, supporting
     * various format specifiers such as %s (string), %d (decimal), %f (floating point), %x (hexadecimal), etc.</p>
     *
     * <p><b>Usage Examples:</b></p>
     * <pre>{@code
     * // Simple string formatting
     * N.fprintln("Hello, %s!", "World");  // Prints: Hello, World!
     * 
     * // Multiple arguments with different types
     * N.fprintln("User %s (ID: %d) has %.2f credits", "Alice", 123, 45.67);
     * // Prints: User Alice (ID: 123) has 45.67 credits
     * 
     * // Numeric formatting
     * N.fprintln("Hexadecimal: %x, Binary: %8s", 255, Integer.toBinaryString(255));
     * // Prints: Hexadecimal: ff, Binary: 11111111
     * 
     * // Date/time formatting
     * N.fprintln("Current time: %tF %tT", new Date(), new Date());
     * // Prints: Current time: 2023-12-25 14:30:45
     * 
     * // Debugging with formatted output
     * N.fprintln("Processing item %d of %d: %s", current, total, item.getName());
     * }</pre>
     *
     * <p><strong>Performance note:</strong> This method uses {@link System#out System.out.printf(String, Object...)}
     * internally, which is efficient for formatted output but may be slower than simple string concatenation
     * for very frequent debugging calls.</p>
     *
     * @param format the format string as described in {@link java.util.Formatter}. Must not be null
     * @param args the arguments referenced by the format specifiers in the format string.
     *             If there are more arguments than format specifiers, the extra arguments are ignored.
     *             The number of arguments is variable and may be zero
     * @throws IllegalFormatException if the format string is invalid or contains illegal format specifiers
     * @see String#format(String, Object...)
     * @see System#out System.out.printf(String, Object...)
     * @see #println(Object)
     * @see java.util.Formatter
     */
    public static void fprintln(final String format, final Object... args) {
        System.out.printf(format, args); //NOSONAR
        System.out.println(); //NOSONAR
    }
}
